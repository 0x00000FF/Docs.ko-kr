---
title: 기본 XAML 스키마 컨텍스트 및 WPF XAML 스키마 컨텍스트
ms.date: 03/30/2017
ms.assetid: 04e06a15-09b3-4210-9bdf-9a64c2eccb83
ms.openlocfilehash: 2e92372de61230a98a02282cc28fc3f479cd94eb
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/12/2020
ms.locfileid: "81433081"
---
# <a name="default-xaml-schema-context-and-wpf-xaml-schema-context"></a><span data-ttu-id="eed19-102">기본 XAML 스키마 컨텍스트 및 WPF XAML 스키마 컨텍스트</span><span class="sxs-lookup"><span data-stu-id="eed19-102">Default XAML Schema Context and WPF XAML Schema Context</span></span>
<span data-ttu-id="eed19-103">XAML 스키마 컨텍스트는 특정 XAML 어휘를 사용하는 XAML 프로덕션이 형식 매핑 해결 방법, 어셈블리로드 방법, 특정 판독기 및 기록기 설정을 해석하는 방법을 포함하여 개체 쓰기 동작과 상호 작용하는 방법을 갖춘 개념적 엔터티입니다.</span><span class="sxs-lookup"><span data-stu-id="eed19-103">A XAML schema context is a conceptual entity that qualifies how a XAML production that uses a particular XAML vocabulary interacts with the object writing behavior, including how type mapping resolves, how assemblies are loaded, how certain reader and writer settings are interpreted.</span></span> <span data-ttu-id="eed19-104">이 항목에서는 CLR 형식 시스템을 기반으로 하는 .NET XAML 서비스의 기능 및 관련 기본 XAML 스키마 컨텍스트에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="eed19-104">This topic describes the features of .NET XAML Services and the associated default XAML schema context, which is based on the CLR type system.</span></span> <span data-ttu-id="eed19-105">이 항목에서는 WPF에 사용되는 XAML 스키마 컨텍스트에 대해서도 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="eed19-105">This topic also describes the XAML schema context that is used for WPF.</span></span>

## <a name="default-xaml-schema-context"></a><span data-ttu-id="eed19-106">기본 XAML 스키마 컨텍스트</span><span class="sxs-lookup"><span data-stu-id="eed19-106">Default XAML Schema Context</span></span>

<span data-ttu-id="eed19-107">.NET XAML 서비스는 기본 XAML 스키마 컨텍스트를 구현하고 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="eed19-107">.NET XAML Services both implements and uses a default XAML schema context.</span></span> <span data-ttu-id="eed19-108">기본 XAML 스키마 컨텍스트 동작이 <xref:System.Xaml.XamlSchemaContext> 클래스의 API에 항상 완전히 표시되는 것은 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="eed19-108">The default XAML schema context behavior is not always fully visible in the API of the <xref:System.Xaml.XamlSchemaContext> class.</span></span> <span data-ttu-id="eed19-109">그러나 대부분의 경우 기본 XAML 스키마 컨텍스트가 영향을 주는 동작은 XAML 형식 시스템의 공통 API(예: 멤버 <xref:System.Xaml.XamlMember> 또는 <xref:System.Xaml.XamlType>또는 기본 XAML 스키마 컨텍스트를 사용하는 XAML 판독기 및 XAML 작성기에 노출된 API를 통해)를 통해 관찰할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eed19-109">However, in many cases the behavior that the default XAML schema context influences is observable through common API of the XAML type system, such as members of <xref:System.Xaml.XamlMember> or <xref:System.Xaml.XamlType>, or through APIs exposed on XAML readers and XAML writers that are using the default XAML schema context.</span></span>

<span data-ttu-id="eed19-110">생성자를 호출하여 기본 동작을 캡슐화하는 a를 <xref:System.Xaml.XamlSchemaContext> <xref:System.Xaml.XamlSchemaContext> 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eed19-110">You can create a <xref:System.Xaml.XamlSchemaContext> that encapsulates the default behavior by calling the <xref:System.Xaml.XamlSchemaContext> constructor.</span></span> <span data-ttu-id="eed19-111">이렇게 하면 기본 XAML 스키마 컨텍스트가 명시적으로 만들어집니다.</span><span class="sxs-lookup"><span data-stu-id="eed19-111">This explicitly creates the default XAML schema context.</span></span> <span data-ttu-id="eed19-112"><xref:System.Xaml.XamlSchemaContext> 입력 매개 변수를 명시적으로 사용하지 않는 API를 사용하여 XAML 리더 또는 XAML 라이터를 초기화하면 동일한 기본 XAML 스키마 컨텍스트가 암시적으로 만들어집니다.</span><span class="sxs-lookup"><span data-stu-id="eed19-112">The same default XAML schema context is created implicitly, if you initialize a XAML reader or XAML writer using APIs that do not explicitly take a <xref:System.Xaml.XamlSchemaContext> input parameter.</span></span>

<span data-ttu-id="eed19-113">기본 XAML 스키마 컨텍스트는 형식 매핑 동작에 대한 CLR 리플렉션을 기반으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="eed19-113">The default XAML schema context relies on CLR reflection for its type mapping behavior.</span></span> <span data-ttu-id="eed19-114">여기에는 정의 CLR <xref:System.Type>및 <xref:System.Reflection.PropertyInfo> 관련 <xref:System.Reflection.MethodInfo>또는 에 대한 검사가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="eed19-114">This includes examining the defining CLR <xref:System.Type>, and related <xref:System.Reflection.PropertyInfo> or <xref:System.Reflection.MethodInfo>.</span></span> <span data-ttu-id="eed19-115">또한 형식 또는 멤버에 대한 CLR 기여는 CLR 백업 유형을 사용하는 XAML 형식 또는 XAML 멤버 정보에 대한 세부 정보를 채우기 위해 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="eed19-115">Also, CLR attribution on types or members is used in order to fill in the specifics for XAML type or XAML member information that uses the CLR backing type.</span></span> <span data-ttu-id="eed19-116">기본 XAML 스키마 컨텍스트에는 CLR 형식 시스템에서 `Invoker` 필요한 정보를 사용할 수 있으므로 패턴과 같은 형식 시스템 확장 기술이 필요하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="eed19-116">The default XAML schema context does not require type system extension techniques such as the `Invoker` pattern, because the necessary information is available from the CLR type system.</span></span>

<span data-ttu-id="eed19-117">어셈블리 로드 논리의 경우 기본 XAML 스키마 컨텍스트는 주로 XAML 네임스페이스 매핑에 제공된 모든 어셈블리 값에 의존합니다.</span><span class="sxs-lookup"><span data-stu-id="eed19-117">For assembly loading logic, the default XAML schema context relies mainly on any assembly values provided in XAML namespace mappings.</span></span> <span data-ttu-id="eed19-118">또한 <xref:System.Xaml.XamlReaderSettings.LocalAssembly%2A> 내부 형식 로드와 같은 시나리오의 경우 어셈블리를 로드하도록 암시할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eed19-118">Also, <xref:System.Xaml.XamlReaderSettings.LocalAssembly%2A> can hint an assembly to load, for scenarios such as loading internal types.</span></span>

## <a name="wpf-xaml-schema-context"></a><span data-ttu-id="eed19-119">WPF XAML 스키마 컨텍스트</span><span class="sxs-lookup"><span data-stu-id="eed19-119">WPF XAML Schema Context</span></span>

<span data-ttu-id="eed19-120">WPF 구현은 기본이 아닌 XAML 스키마 컨텍스트를 구현하여 도입할 수 있는 기능의 종류에 대한 흥미로운 그림을 제공하기 때문에 WPF XAML 스키마 컨텍스트는 이 항목에서 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="eed19-120">The WPF XAML schema context is described in this topic because the WPF implementation provides an interesting illustration of the kinds of features that can be introduced by implementing a non-default XAML schema context.</span></span> <span data-ttu-id="eed19-121">또한 XAML 스키마 컨텍스트 개념은 WPF XAML을 다루는 WPF 설명서에서 별로 설명되지 않습니다. XAML 스키마 컨텍스트에서 사용할 수 있는 동작은 기본 XAML 스키마 컨텍스트가 작동하는 방식에 대한 설명과 통합된 경우에만 완전히 이해할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eed19-121">Also, the XAML schema context concept is not discussed very much in the WPF documentation that addresses WPF XAML; the behavior that the XAML schema context enables might only be fully understandable if integrated with a discussion of how the default XAML schema context works.</span></span> <span data-ttu-id="eed19-122">WPF XAML 스키마 컨텍스트는 다음 동작을 구현합니다.</span><span class="sxs-lookup"><span data-stu-id="eed19-122">The WPF XAML schema context implements the following behavior.</span></span>

<span data-ttu-id="eed19-123">**조회 재정의:** WPF에는 <xref:System.Windows.Markup.ContentPropertyAttribute> 어트리뷰션되지 않고 작동하는 XAML 콘텐츠 속성이 있는 XAML에 대한 몇 가지 콘텐츠 모델이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eed19-123">**Lookup overrides:** WPF has a few content models for XAML where there are XAML content properties that function without being <xref:System.Windows.Markup.ContentPropertyAttribute> attributed.</span></span> <span data-ttu-id="eed19-124"><xref:System.Xaml.XamlType.LookupContentProperty%2A>WPF에 대한 재정의는 이 동작을 구현합니다.</span><span class="sxs-lookup"><span data-stu-id="eed19-124"><xref:System.Xaml.XamlType.LookupContentProperty%2A> overrides for WPF implement this behavior.</span></span>

<span data-ttu-id="eed19-125">**WPF 식에 대한 지연:** WPF에는 런타임 컨텍스트를 사용할 수 있게 될 때까지 값을 연기하는 여러 식 클래스가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eed19-125">**Deferral for WPF expressions:** WPF features several expression classes that defer a value until a runtime context is available.</span></span> <span data-ttu-id="eed19-126">또한 템플릿 확장은 지연 기술에 의존하는 런타임 동작입니다.</span><span class="sxs-lookup"><span data-stu-id="eed19-126">Also, template expansion is a runtime behavior that relies on deferral techniques.</span></span>

<span data-ttu-id="eed19-127">**시스템 조회 최적화 유형:** WPF에는 말 그대로 수백 개의 WPF 정의 클래스에 상속되는 기본 클래스 멤버 정의를 포함하여 광범위한 XAML 어휘 및 개체 모델이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eed19-127">**Type system lookup optimizations:** WPF has an extensive XAML vocabulary and object model, including base class member definitions that inherit to literally hundreds of WPF-defined classes.</span></span> <span data-ttu-id="eed19-128">또한 WPF 자체는 여러 어셈블리에 분산되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eed19-128">Also, WPF itself is spread across several assemblies.</span></span> <span data-ttu-id="eed19-129">WPF는 조회 테이블 및 기타 기술을 사용하여 형식 조회를 최적화합니다.</span><span class="sxs-lookup"><span data-stu-id="eed19-129">WPF optimizes its type lookup using lookup tables and other techniques.</span></span> <span data-ttu-id="eed19-130">이렇게 하면 기본 XAML 스키마 컨텍스트 및 CLR 기반 형식 조회에 대한 성능이 향상됩니다.</span><span class="sxs-lookup"><span data-stu-id="eed19-130">This provides performance improvements over the default XAML schema context and its CLR-based type lookup.</span></span> <span data-ttu-id="eed19-131">형식이 조회 테이블에 없는 경우 동작은 기본 XAML 스키마 컨텍스트와 유사한 XAML 스키마 컨텍스트 기술을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="eed19-131">In cases where types do not exist in a lookup table, the behavior uses XAML schema context techniques that are similar to the default XAML schema context.</span></span>

<span data-ttu-id="eed19-132">**XamlType 및 XamlMember 확장:** WPF는 종속성 속성을 사용하여 속성 개념을 확장하고 라우트된 이벤트를 사용하여 이벤트 개념을 확장합니다.</span><span class="sxs-lookup"><span data-stu-id="eed19-132">**XamlType and XamlMember extension:** WPF extends property concepts with dependency properties, and event concepts with routed events.</span></span> <span data-ttu-id="eed19-133">이러한 개념에 XAML 처리 작업에 대한 가시성을 높이기 <xref:System.Xaml.XamlType> <xref:System.Xaml.XamlMember>위해 WPF는 종속성 속성 및 라우팅된 이벤트 특성을 보고하는 내부 속성을 확장하고 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="eed19-133">To give these concepts greater visibility for XAML processing operations, WPF extends <xref:System.Xaml.XamlType> and <xref:System.Xaml.XamlMember>, and adds internal properties that report dependency property and routed event characteristics.</span></span>

### <a name="accessing-the-wpf-xaml-schema-context"></a><span data-ttu-id="eed19-134">WPF XAML 스키마 컨텍스트 액세스</span><span class="sxs-lookup"><span data-stu-id="eed19-134">Accessing the WPF XAML Schema Context</span></span>

<span data-ttu-id="eed19-135">WPF <xref:System.Windows.Markup.XamlReader?displayProperty=nameWithType> 또는 <xref:System.Windows.Markup.XamlWriter?displayProperty=nameWithType>WPF를 기반으로 하는 XAML 기술을 사용하는 경우 해당 XAML 판독기 및 XAML 기록기 구현에서 WPF XAML 스키마 컨텍스트가 이미 사용 중입니다.</span><span class="sxs-lookup"><span data-stu-id="eed19-135">If you are using XAML techniques that are based on the WPF <xref:System.Windows.Markup.XamlReader?displayProperty=nameWithType> or <xref:System.Windows.Markup.XamlWriter?displayProperty=nameWithType>, the WPF XAML schema context is already in use on those XAML reader and XAML writer implementations.</span></span>

<span data-ttu-id="eed19-136">WPF XAML 스키마 컨텍스트로 초기화하지 않는 다른 XAML 판독기 또는 XAML 기록기 구현을 사용하는 경우 에서 <xref:System.Windows.Markup.XamlReader.GetWpfSchemaContext%2A?displayProperty=nameWithType>작업 중인 WPF XAML 스키마 컨텍스트를 얻을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eed19-136">If you are using other XAML reader or XAML writer implementations that do not initialize with the WPF XAML schema context, you may be able to get a working WPF XAML schema context from <xref:System.Windows.Markup.XamlReader.GetWpfSchemaContext%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="eed19-137">그런 다음 이 값을 <xref:System.Xaml.XamlSchemaContext>을 사용하는 다른 API의 초기화로 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eed19-137">You can then use this value as initialization for other API that use a <xref:System.Xaml.XamlSchemaContext>.</span></span> <span data-ttu-id="eed19-138">예를 들어 초기화를 <xref:System.Xaml.XamlXmlReader.%23ctor%2A> 호출하고 WPF XAML 스키마 컨텍스트를 전달할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eed19-138">For example, you could call <xref:System.Xaml.XamlXmlReader.%23ctor%2A> for initialization and pass the WPF XAML schema context.</span></span> <span data-ttu-id="eed19-139">또는 XAML 형식 시스템 작업에 WPF XAML 스키마 컨텍스트를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eed19-139">Or you could use the WPF XAML schema context for XAML type system operations.</span></span> <span data-ttu-id="eed19-140">여기에는 <xref:System.Xaml.XamlType> 또는 <xref:System.Xaml.XamlMember>의 시공 초기화가 <xref:System.Xaml.XamlSchemaContext.GetXamlType%2A?displayProperty=nameWithType>포함될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eed19-140">This might include construction initialization of a <xref:System.Xaml.XamlType> or <xref:System.Xaml.XamlMember>, or calling <xref:System.Xaml.XamlSchemaContext.GetXamlType%2A?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="eed19-141">순수한 XAML 노드 스트림 관점에서 WPF XAML의 특정 측면에 액세스하는 경우 일부 WPF 프레임워크 기능이 아직 작동하지 않았을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eed19-141">Note that if you access certain aspects of WPF XAML from a pure XAML node stream perspectives, some of the WPF framework capabilities may not have acted yet.</span></span> <span data-ttu-id="eed19-142">예를 들어 컨트롤에 대한 WPF 템플릿은 아직 적용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="eed19-142">For example, WPF templates for controls are not yet applied.</span></span> <span data-ttu-id="eed19-143">따라서 런타임에 전체 시각적 트리로 채워질 수 있는 속성에 액세스하는 경우 템플릿을 참조하는 속성 값만 표시될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eed19-143">Thus if you access a property that at run time might be populated with a full visual tree, you might only see a property value that references a template.</span></span> <span data-ttu-id="eed19-144">WPF 태그 확장에 대해 제공된 서비스 컨텍스트는 런타임이 아닌 상황에서 제공된 경우 정확하지 않을 수 있으며 개체 그래프를 작성하려고 할 때 예외가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eed19-144">The service context provided for WPF markup extensions might also not be accurate if provided from a non-runtime situation, and can result in exceptions when attempting to write an object graph.</span></span>

## <a name="xaml-and-assembly-loading"></a><span data-ttu-id="eed19-145">XAML 및 어셈블리 로딩</span><span class="sxs-lookup"><span data-stu-id="eed19-145">XAML and Assembly Loading</span></span>

<span data-ttu-id="eed19-146">XAML 및 .NET XAML 서비스에 대한 어셈블리 로드는 <xref:System.AppDomain>CLR 정의 개념과 통합됩니다.</span><span class="sxs-lookup"><span data-stu-id="eed19-146">Assembly loading for XAML and .NET XAML Services integrates with the CLR-defined concept of <xref:System.AppDomain>.</span></span> <span data-ttu-id="eed19-147">XAML 스키마 컨텍스트는 사용 <xref:System.AppDomain> 및 기타 요인에 따라 어셈블리를 로드하거나 런타임 또는 디자인 시간에 형식을 찾는 방법을 해석합니다.</span><span class="sxs-lookup"><span data-stu-id="eed19-147">A XAML schema context interprets how to either load assemblies or find types at run time or design time, based on the use of <xref:System.AppDomain> and other factors.</span></span> <span data-ttu-id="eed19-148">논리는 XAML이 XAML 판독기의 느슨한 XAML인지, XAML이 DLL로 `XamlBuildTask`컴파일되었는지 또는 WPF에 의해 생성된 `PresentationBuildTask`BAML인지에 따라 약간 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="eed19-148">The logic is slightly different depending on whether the XAML is loose XAML for a XAML reader, is XAML compiled into a DLL by `XamlBuildTask`, or is BAML generated by WPF's `PresentationBuildTask`.</span></span>

<span data-ttu-id="eed19-149">WPF에 대한 XAML 스키마 컨텍스트는 WPF 응용 프로그램 모델과 통합되며, WPF 구현 세부 정보인 다른 요소도 사용합니다. <xref:System.AppDomain></span><span class="sxs-lookup"><span data-stu-id="eed19-149">The XAML schema context for WPF integrates with the WPF application model, which in turn uses <xref:System.AppDomain> as well as other factors that are WPF implementation details.</span></span>

#### <a name="xaml-reader-input-loose-xaml"></a><span data-ttu-id="eed19-150">XAML 리더 입력(느슨한 XAML)</span><span class="sxs-lookup"><span data-stu-id="eed19-150">XAML reader input (loose XAML)</span></span>

01. <span data-ttu-id="eed19-151">XAML 스키마 컨텍스트는 응용 프로그램을 <xref:System.AppDomain> 통해 가장 최근에 로드된 어셈블리부터 시작하여 이름의 모든 측면과 일치하는 이미 로드된 어셈블리를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="eed19-151">The XAML schema context iterates through the <xref:System.AppDomain> of the application, looking for an already-loaded assembly that matches all aspects of the name, starting from the most recently loaded assembly.</span></span> <span data-ttu-id="eed19-152">일치하는 검색어가 발견되면 해당 어셈블리가 해상도에 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="eed19-152">If a match is found, that assembly is used for resolution.</span></span>

02. <span data-ttu-id="eed19-153">그렇지 않으면 CLR <xref:System.Reflection.Assembly> API를 기반으로 하는 다음 기술 중 하나가 어셈블리를 로드하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="eed19-153">Otherwise, one of the following techniques based on CLR <xref:System.Reflection.Assembly> API are used to load an assembly:</span></span>

    - <span data-ttu-id="eed19-154">이름이 매핑에서 한정된 경우 <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType> 정규화된 이름을 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="eed19-154">If the name is qualified in the mapping, call <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType> on the qualified name.</span></span>

    - <span data-ttu-id="eed19-155">이전 단계가 실패하면 짧은 이름(및 공개 키 토큰이 <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>있는 경우)을 사용하여 을 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="eed19-155">If the previous step fails, use the short name (and public key token if present) to call <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>.</span></span>

    - <span data-ttu-id="eed19-156">이름이 매핑에서 정규화되지 않은 <xref:System.Reflection.Assembly.LoadWithPartialName%2A?displayProperty=nameWithType>경우 를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="eed19-156">If the name is unqualified in the mapping, call <xref:System.Reflection.Assembly.LoadWithPartialName%2A?displayProperty=nameWithType>.</span></span>

#### <a name="xamlbuildtask"></a><span data-ttu-id="eed19-157">XamlBuildTask</span><span class="sxs-lookup"><span data-stu-id="eed19-157">XamlBuildTask</span></span>

<span data-ttu-id="eed19-158">`XamlBuildTask`는 WCF(Windows 통신 재단) 및 Windows 워크플로 파운데이션에 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="eed19-158">`XamlBuildTask` is used for Windows Communication Foundation (WCF) and Windows Workflow Foundation.</span></span>

<span data-ttu-id="eed19-159">어셈블리 `XamlBuildTask` 참조는 항상 정규화됩니다.</span><span class="sxs-lookup"><span data-stu-id="eed19-159">Note that assembly references through `XamlBuildTask` are always fully qualified.</span></span>

1. <span data-ttu-id="eed19-160">정규화된 이름을 호출합니다. <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="eed19-160">Call <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType> on the qualified name.</span></span>

2. <span data-ttu-id="eed19-161">이전 단계가 실패하면 짧은 이름(및 공개 키 토큰이 <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>있는 경우)을 사용하여 을 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="eed19-161">If the previous step fails, use the short name (and public key token if present) to call <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>.</span></span>

#### <a name="baml-presentationbuildtask"></a><span data-ttu-id="eed19-162">BAML (프레젠테이션 빌드 태스크)</span><span class="sxs-lookup"><span data-stu-id="eed19-162">BAML (PresentationBuildTask)</span></span>

<span data-ttu-id="eed19-163">BAML에 대한 어셈블리 로드에는 BAML이 포함된 초기 어셈블리를 구성 요소로 로드하고 BAML 프로덕션에서 참조하는 모든 형식에 대해 형식 백업 어셈블리를 로드하는 두 가지 측면이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eed19-163">There are two aspects to assembly-loading for BAML: loading the initial assembly that contains the BAML as a component, and loading the type-backing assemblies for any types referenced by the BAML production.</span></span>

##### <a name="assembly-load-for-initial-markup"></a><span data-ttu-id="eed19-164">초기 태그에 대한 어셈블리 로드:</span><span class="sxs-lookup"><span data-stu-id="eed19-164">Assembly load for initial markup:</span></span>

<span data-ttu-id="eed19-165">태그에서 태그를 로드하는 어셈블리에 대한 참조는 항상 정규화되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="eed19-165">The reference to the assembly to load the markup from is always unqualified.</span></span>

1. <span data-ttu-id="eed19-166">WPF XAML 스키마 컨텍스트는 WPF <xref:System.AppDomain> 응용 프로그램을 통해 변경되어 가장 최근에 로드된 어셈블리부터 시작하여 이름의 모든 측면과 일치하는 이미 로드된 어셈블리를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="eed19-166">The WPF XAML schema context iterates through the <xref:System.AppDomain> of the WPF application, looking for an already-loaded assembly that matches all aspects of the name, starting from the most recently loaded assembly.</span></span> <span data-ttu-id="eed19-167">일치하는 검색어가 발견되면 해당 어셈블리가 해상도에 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="eed19-167">If a match is found, that assembly is used for resolution.</span></span>

2. <span data-ttu-id="eed19-168">이전 단계가 실패하면 짧은 이름(및 공개 키 토큰이 <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>있는 경우)을 사용하여 을 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="eed19-168">If the previous step fails, use the short name (and public key token if present) to call <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>.</span></span>

##### <a name="assembly-references-by-baml-types"></a><span data-ttu-id="eed19-169">BAML 형식별 어셈블리 참조:</span><span class="sxs-lookup"><span data-stu-id="eed19-169">Assembly references by BAML types:</span></span>

<span data-ttu-id="eed19-170">BAML 프로덕션에 사용되는 형식에 대한 어셈블리 참조는 빌드 작업의 출력으로 항상 정규화됩니다.</span><span class="sxs-lookup"><span data-stu-id="eed19-170">Assembly references for types used in the BAML production are always fully qualified, as an output of the build task.</span></span>

01. <span data-ttu-id="eed19-171">WPF XAML 스키마 컨텍스트는 WPF <xref:System.AppDomain> 응용 프로그램을 통해 변경되어 가장 최근에 로드된 어셈블리부터 시작하여 이름의 모든 측면과 일치하는 이미 로드된 어셈블리를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="eed19-171">The WPF XAML schema context iterates through the <xref:System.AppDomain> of the WPF application, looking for an already-loaded assembly that matches all aspects of the name, starting from the most recently loaded assembly.</span></span> <span data-ttu-id="eed19-172">일치하는 검색어가 발견되면 해당 어셈블리가 해상도에 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="eed19-172">If a match is found, that assembly is used for resolution.</span></span>

02. <span data-ttu-id="eed19-173">그렇지 않으면 다음 기술 중 하나가 어셈블리를 로드하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="eed19-173">Otherwise, one of the following techniques is used to load an assembly:</span></span>

    - <span data-ttu-id="eed19-174">정규화된 이름을 호출합니다. <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="eed19-174">Call <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType> on the qualified name.</span></span>
  
    - <span data-ttu-id="eed19-175">짧은 이름 + 공개 키 토큰 조합이 BAML에서 로드된 어셈블리와 일치하는 경우 해당 어셈블리를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="eed19-175">If a short name + public key token combination match the assembly that the BAML was loaded from, use that assembly.</span></span>

    - <span data-ttu-id="eed19-176">짧은 이름 + 공개 키 <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>토큰을 사용하여 을 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="eed19-176">Use short name + public key token to call <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>.</span></span>

## <a name="see-also"></a><span data-ttu-id="eed19-177">참조</span><span class="sxs-lookup"><span data-stu-id="eed19-177">See also</span></span>

- [<span data-ttu-id="eed19-178">XAML 노드 스트림 구조 및 개념 이해</span><span class="sxs-lookup"><span data-stu-id="eed19-178">Understanding XAML Node Stream Structures and Concepts</span></span>](understanding-xaml-node-stream-structures-and-concepts.md)

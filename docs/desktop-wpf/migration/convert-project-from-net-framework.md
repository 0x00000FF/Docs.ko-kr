---
title: WPF 앱을 .NET 코어 3.0으로 마이그레이션
description: Windows 프레젠테이션 기반(WPF) 앱을 .NET Core 3.0으로 마이그레이션하는 방법을 알아봅니다.
author: mjrousos
ms.date: 09/12/2019
ms.author: mikerou
ms.openlocfilehash: f52005e7c8a6312b8c4e09a950f1f635af1894e4
ms.sourcegitcommit: cdf5084648bf5e77970cbfeaa23f1cab3e6e234e
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 02/01/2020
ms.locfileid: "81432595"
---
# <a name="migrating-wpf-apps-to-net-core"></a><span data-ttu-id="9da70-103">WPF 앱에서 .NET 코어로 마이그레이션</span><span class="sxs-lookup"><span data-stu-id="9da70-103">Migrating WPF apps to .NET Core</span></span>

<span data-ttu-id="9da70-104">이 문서에서는 .NET Framework에서 .NET Core 3.0으로 Windows 프레젠테이션 기반(WPF) 앱을 마이그레이션하는 데 필요한 단계를 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-104">This article covers the steps necessary to migrate a Windows Presentation Foundation (WPF) app from .NET Framework to .NET Core 3.0.</span></span> <span data-ttu-id="9da70-105">포트에 손에 WPF 응용 프로그램이 없는 경우, 하지만 프로세스를 시도 하 고 **Bean Trader** 싶습니다. [GitHub](https://github.com/dotnet/windows-desktop/tree/master/Samples/BeanTrader)</span><span class="sxs-lookup"><span data-stu-id="9da70-105">If you don't have a WPF app on hand to port, but would like to try out the process, you can use the **Bean Trader** sample app available on [GitHub](https://github.com/dotnet/windows-desktop/tree/master/Samples/BeanTrader).</span></span> <span data-ttu-id="9da70-106">원래 응용 프로그램 (대상 .NET 프레임 워크 4.7.2) NetFx\BeanTraderClient 폴더에서 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-106">The original app (targeting .NET Framework 4.7.2) is available in the NetFx\BeanTraderClient folder.</span></span> <span data-ttu-id="9da70-107">먼저 일반적으로 앱을 포팅하는 데 필요한 단계를 설명한 다음 **Bean Trader** 샘플에 적용되는 특정 변경 사항을 살펴보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-107">First we'll explain the steps necessary to port apps in general, and then we'll walk through the specific changes that apply to the **Bean Trader** sample.</span></span>

[!INCLUDE [desktop guide under construction](../../../includes/desktop-guide-preview-note.md)]

<span data-ttu-id="9da70-108">.NET Core로 마이그레이션하려면 먼저 다음을 수행해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-108">To migrate to .NET Core, you must first:</span></span>

01. <span data-ttu-id="9da70-109">NuGet 종속성을 이해하고 업데이트합니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-109">Understand and update NuGet dependencies:</span></span>

    01. <span data-ttu-id="9da70-110">NuGet 종속성을 업그레이드하여 `<PackageReference>` 형식을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-110">Upgrade NuGet dependencies to use the `<PackageReference>` format.</span></span>
    01. <span data-ttu-id="9da70-111">.NET 코어 또는 .NET 표준 호환성에 대한 최상위 NuGet 종속성을 검토합니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-111">Review top-level NuGet dependencies for .NET Core or .NET Standard compatibility.</span></span>
    01. <span data-ttu-id="9da70-112">NuGet 패키지를 최신 버전으로 업그레이드합니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-112">Upgrade NuGet packages to newer versions.</span></span>
    01. <span data-ttu-id="9da70-113">[.NET 이식성 분석기를](../../standard/analyzers/portability-analyzer.md) 사용하여 .NET 종속성을 이해합니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-113">Use the [.NET Portability Analyzer](../../standard/analyzers/portability-analyzer.md) to understand .NET dependencies.</span></span>

01. <span data-ttu-id="9da70-114">프로젝트 파일을 새 SDK 스타일 형식으로 마이그레이션합니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-114">Migrate the project file to the new SDK-style format:</span></span>

    01. <span data-ttu-id="9da70-115">.NET 코어와 .NET 프레임워크를 모두 대상으로 할지 또는 .NET 코어만 대상으로 할지 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-115">Choose whether to target both .NET Core and .NET Framework, or only .NET Core.</span></span>
    01. <span data-ttu-id="9da70-116">관련 프로젝트 파일 속성 및 항목을 새 프로젝트 파일에 복사합니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-116">Copy relevant project file properties and items to the new project file.</span></span>

01. <span data-ttu-id="9da70-117">빌드 문제 해결:</span><span class="sxs-lookup"><span data-stu-id="9da70-117">Fix build issues:</span></span>

    01. <span data-ttu-id="9da70-118">[Microsoft.Windows.호환성](https://www.nuget.org/packages/Microsoft.Windows.Compatibility/) 패키지에 대한 참조를 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-118">Add a reference to the [Microsoft.Windows.Compatibility](https://www.nuget.org/packages/Microsoft.Windows.Compatibility/) package.</span></span>
    01. <span data-ttu-id="9da70-119">API 수준 차이를 찾아 수정합니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-119">Find and fix API-level differences.</span></span>
    01. <span data-ttu-id="9da70-120">또는 이외의 *app.config* `connectionStrings`섹션을 제거합니다. `appSettings`</span><span class="sxs-lookup"><span data-stu-id="9da70-120">Remove *app.config* sections other than `appSettings` or `connectionStrings`.</span></span>
    01. <span data-ttu-id="9da70-121">필요한 경우 생성된 코드를 다시 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-121">Regenerate generated code, if necessary.</span></span>

01. <span data-ttu-id="9da70-122">런타임 테스트:</span><span class="sxs-lookup"><span data-stu-id="9da70-122">Runtime testing:</span></span>

    01. <span data-ttu-id="9da70-123">포팅된 앱이 예상대로 작동하는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-123">Confirm the ported app works as expected.</span></span>
    01. <span data-ttu-id="9da70-124"><xref:System.NotSupportedException> 예외를 주의하십시오.</span><span class="sxs-lookup"><span data-stu-id="9da70-124">Beware of <xref:System.NotSupportedException> exceptions.</span></span>

## <a name="about-the-sample"></a><span data-ttu-id="9da70-125">샘플 정보</span><span class="sxs-lookup"><span data-stu-id="9da70-125">About the sample</span></span>

<span data-ttu-id="9da70-126">이 문서에서는 실제 WPF 앱과 유사한 다양한 종속성을 사용하기 때문에 [Bean Trader 샘플](https://github.com/dotnet/windows-desktop/tree/master/Samples/BeanTrader) 앱을 참조합니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-126">This article references the [Bean Trader sample app](https://github.com/dotnet/windows-desktop/tree/master/Samples/BeanTrader) because it uses a variety of dependencies similar to those that real-world WPF apps might have.</span></span> <span data-ttu-id="9da70-127">이 앱은 크지는 않지만 복잡성 측면에서 'Hello World'에서 한 단계 더 올라가기 위한 것입니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-127">The app isn't large, but is meant to be a step up from 'Hello World' in terms of complexity.</span></span> <span data-ttu-id="9da70-128">이 앱은 실제 앱을 이식하는 동안 사용자가 발생할 수 있는 몇 가지 문제를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-128">The app demonstrates some issues users may encounter while porting real apps.</span></span> <span data-ttu-id="9da70-129">응용 프로그램은 WCF 서비스와 통신, 그래서 제대로 실행하려면, 당신은 또한 BeanTraderServer 프로젝트를 실행해야합니다 (동일한 GitHub 리포지토리에서 사용 가능) BeanTraderClient 구성이 올바른 끝점을 가리키는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-129">The app communicates with a WCF service, so for it to run properly, you'll also need to run the BeanTraderServer project (available in the same GitHub repository) and make sure the BeanTraderClient configuration points to the correct endpoint.</span></span> <span data-ttu-id="9da70-130">(기본적으로 샘플은 서버가 동일한 컴퓨터에서 *http://localhost:8090*실행되고 있다고 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-130">(By default, the sample assumes the server is running on the same machine at *http://localhost:8090*, which will be true if you launch BeanTraderServer locally.)</span></span>

<span data-ttu-id="9da70-131">이 샘플 앱은 .NET Core 포팅 과제및 솔루션을 시연하기 위한 것입니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-131">Keep in mind that this sample app is meant to demonstrate .NET Core porting challenges and solutions.</span></span> <span data-ttu-id="9da70-132">WPF 모범 사례를 설명하기 위한 것이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-132">It's not meant to demonstrate WPF best practices.</span></span> <span data-ttu-id="9da70-133">사실, 그것은 의도적으로 포팅 하는 동안 흥미로운 도전의 적어도 몇 건너 있는지 확인 하는 몇 가지 안티 패턴을 포함.</span><span class="sxs-lookup"><span data-stu-id="9da70-133">In fact, it deliberately includes some anti-patterns to make sure you come across at least a couple of interesting challenges while porting.</span></span>

## <a name="getting-ready"></a><span data-ttu-id="9da70-134">준비</span><span class="sxs-lookup"><span data-stu-id="9da70-134">Getting ready</span></span>

<span data-ttu-id="9da70-135">.NET Framework 앱을 .NET Core로 마이그레이션하는 주요 과제는 종속성이 다르게 작동하거나 전혀 작동하지 않을 수 있다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-135">The primary challenge of migrating a .NET Framework app to .NET Core is that its dependencies may work differently or not at all.</span></span> <span data-ttu-id="9da70-136">마이그레이션은 이전보다 훨씬 쉽습니다. 이제 많은 NuGet 패키지가 .NET 표준을 대상으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-136">Migration is much easier than it used to be; many NuGet packages now target .NET Standard.</span></span> <span data-ttu-id="9da70-137">.NET Core 2.0부터 .NET 프레임워크와 .NET 코어 표면 영역이 비슷해졌습니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-137">Starting with .NET Core 2.0, the .NET Framework and .NET Core surface areas have become similar.</span></span> <span data-ttu-id="9da70-138">그럼에도 불구하고 NuGet 패키지와 사용 가능한 .NET API모두에서 몇 가지 차이점이 남아 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-138">Even so, some differences (both in support from NuGet packages and in available .NET APIs) remain.</span></span> <span data-ttu-id="9da70-139">마이그레이션의 첫 번째 단계는 앱의 종속성을 검토하고 참조가 .NET Core로 쉽게 마이그레이션할 수 있는 형식으로 되어 있는지 확인하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-139">The first step in migrating is to review the app's dependencies and make sure references are in a format that's easily migrated to .NET Core.</span></span>

### <a name="upgrade-to-packagereference-nuget-references"></a><span data-ttu-id="9da70-140">NuGet `<PackageReference>` 참조로 업그레이드</span><span class="sxs-lookup"><span data-stu-id="9da70-140">Upgrade to `<PackageReference>` NuGet references</span></span>

<span data-ttu-id="9da70-141">이전 .NET Framework 프로젝트는 일반적으로 *Packages.config* 파일에 NuGet 종속성을 나열합니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-141">Older .NET Framework projects typically list their NuGet dependencies in a *packages.config* file.</span></span> <span data-ttu-id="9da70-142">새로운 SDK 스타일 프로젝트 파일 형식은 NuGet 패키지를 별도의 구성 파일이 아닌 csproj 파일 자체의 요소로 [`<PackageReference>`](/nuget/consume-packages/package-references-in-project-files) 참조합니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-142">The new SDK-style project file format references NuGet packages as [`<PackageReference>`](/nuget/consume-packages/package-references-in-project-files) elements in the csproj file itself rather than in a separate config file.</span></span>

<span data-ttu-id="9da70-143">마이그레이션할 때 -style 참조를 `<PackageReference>`사용하면 두 가지 장점이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-143">When migrating, there are two advantages to using `<PackageReference>`-style references:</span></span>

- <span data-ttu-id="9da70-144">새 .NET Core 프로젝트 파일에 필요한 NuGet 참조 스타일입니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-144">This is the style of NuGet reference that is required for the new .NET Core project file.</span></span> <span data-ttu-id="9da70-145">이미 사용 `<PackageReference>`중인 경우 해당 프로젝트 파일 요소를 복사하여 새 프로젝트에 직접 붙여넣을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-145">If you're already using `<PackageReference>`, those project file elements can be copied and pasted directly into the new project.</span></span>
- <span data-ttu-id="9da70-146">packages.config 파일과 `<PackageReference>` 달리 요소는 프로젝트가 직접 종속되는 최상위 종속성만 참조합니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-146">Unlike a packages.config file, `<PackageReference>` elements only refer to the top-level dependencies that your project depends on directly.</span></span> <span data-ttu-id="9da70-147">다른 모든 전이적 NuGet 패키지는 복원 시점에 결정되며 자동 생성된 obj\project.assets.json 파일에 기록됩니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-147">All other transitive NuGet packages will be determined at restore time and recorded in the autogenerated obj\project.assets.json file.</span></span> <span data-ttu-id="9da70-148">이렇게 하면 프로젝트에 어떤 종속성이 있는지 쉽게 확인할 수 있으므로 .NET Core에서 필요한 종속성이 작동하는지 여부를 결정할 때 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-148">This makes it much easier to determine what dependencies your project has, which is useful when determining whether the necessary dependencies will work on .NET Core or not.</span></span>

<span data-ttu-id="9da70-149">.NET Framework 앱을 .NET Core로 마이그레이션하는 첫 번째 단계는 NuGet 참조를 사용하도록 `<PackageReference>` 업데이트하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-149">The first step to migrating a .NET Framework app to .NET Core is to update it to use `<PackageReference>` NuGet references.</span></span> <span data-ttu-id="9da70-150">비주얼 스튜디오는 이 것을 간단하게 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-150">Visual Studio makes this simple.</span></span> <span data-ttu-id="9da70-151">Visual Studio의 **솔루션 탐색기에서**프로젝트의 *packages.config* 파일을 마우스 오른쪽 단추로 클릭한 다음 **packages.config를 패키지참조로 마이그레이션합니다.**</span><span class="sxs-lookup"><span data-stu-id="9da70-151">Just right-click the project's *packages.config* file in Visual Studio's **Solution Explorer**, and then select **Migrate packages.config to PackageReference**.</span></span>

![패키지참조로 업그레이드](./media/convert-project-from-net-framework/package-reference-migration.png)

<span data-ttu-id="9da70-153">계산된 최상위 NuGet 종속성을 표시하고 최상위 수준으로 승격해야 하는 다른 NuGet 패키지를 묻는 대화 상자가 나타납니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-153">A dialog appears showing calculated top-level NuGet dependencies and asking which other NuGet packages should be promoted to top-level.</span></span> <span data-ttu-id="9da70-154">이러한 다른 패키지 중 어느 것도 콩 상인 샘플에 대한 최상위 가 될 필요가 없습니다, 그래서 당신은 그 상자의 모든 선택을 취소 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-154">None of these other packages need to be top-level for the Bean Trader sample, so you can uncheck all of those boxes.</span></span> <span data-ttu-id="9da70-155">그런 다음 **확인을** 클릭하면 *packages.config* `<PackageReference>` 파일이 제거되고 요소가 프로젝트 파일에 추가됩니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-155">Then, click **Ok** and the *packages.config* file is removed and `<PackageReference>` elements are added to the project file.</span></span>

<span data-ttu-id="9da70-156">`<PackageReference>`-스타일 참조는 NuGet 패키지를 패키지 폴더에 로컬로 저장하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-156">`<PackageReference>`-style references don't store NuGet packages locally in a packages folder.</span></span> <span data-ttu-id="9da70-157">대신 최적화로 전역적으로 저장됩니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-157">Instead, they're stored globally as an optimization.</span></span> <span data-ttu-id="9da70-158">마이그레이션이 완료되면 csproj 파일을 편집하고 .에서 `<Analyzer>` 이전에 보낸 분석기를 참조하는 요소를 제거합니다. \* \패키지\* 디렉토리.</span><span class="sxs-lookup"><span data-stu-id="9da70-158">After the migration completes, edit the csproj file and remove any `<Analyzer>` elements referring to the analyzers that previously came from the *..\packages* directory.</span></span> <span data-ttu-id="9da70-159">걱정하지 마세요. NuGet 패키지 참조가 남아 있으므로 분석기는 프로젝트에 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-159">Don't worry; since you still have the NuGet package references, the analyzers will be included in the project.</span></span> <span data-ttu-id="9da70-160">이전 패키지를 정리하기만 하면 됩니다.config `<Analyzer>` 스타일 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-160">You just need to clean up the old packages.config-style `<Analyzer>` elements.</span></span>

### <a name="review-nuget-packages"></a><span data-ttu-id="9da70-161">NuGet 패키지 검토</span><span class="sxs-lookup"><span data-stu-id="9da70-161">Review NuGet packages</span></span>

<span data-ttu-id="9da70-162">이제 프로젝트에 종속된 최상위 NuGet 패키지를 볼 수 있으므로 .NET Core에서 해당 패키지를 사용할 수 있는지 여부를 검토할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-162">Now that you can see the top-level NuGet packages that the project depends on, you can review whether those packages are available on .NET Core.</span></span> <span data-ttu-id="9da70-163">nuget.org 종속성을 확인하여 패키지가 .NET [Core를](https://www.nuget.org/)지원하는지 여부를 확인할 수 있습니다. 커뮤니티에서 만든 [fuget.org](https://www.fuget.org/) 사이트는 패키지 정보 페이지 상단에 이 정보를 눈에 띄게 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-163">You can determine whether a package supports .NET Core by looking at its dependencies on [nuget.org](https://www.nuget.org/). The community-created [fuget.org](https://www.fuget.org/) site shows this information prominently at the top of the package information page.</span></span>

<span data-ttu-id="9da70-164">.NET Core 3.0을 대상으로 하는 경우 .NET Core 또는 .NET 표준을 대상으로 하는 모든 패키지가 작동해야 합니다(.NET Core는 .NET 표준 표면 영역을 구현하기 때문에).</span><span class="sxs-lookup"><span data-stu-id="9da70-164">When targeting .NET Core 3.0, any packages targeting .NET Core or .NET Standard should work (since .NET Core implements the .NET Standard surface area).</span></span> <span data-ttu-id="9da70-165">경우에 따라 사용 되는 패키지의 특정 버전 .NET 코어 또는 .NET 표준을 대상으로 하지 않습니다 하지만 최신 버전 것입니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-165">In some cases, the specific version of a package that's used won't target .NET Core or .NET Standard, but newer versions will.</span></span> <span data-ttu-id="9da70-166">이 경우 패키지의 최신 버전으로 업그레이드하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-166">In this case, you should consider upgrading to the latest version of the package.</span></span>

<span data-ttu-id="9da70-167">.NET Framework를 대상으로 하는 패키지도 사용할 수 있지만 몇 가지 위험이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-167">You can use packages targeting .NET Framework, as well, but that introduces some risk.</span></span> <span data-ttu-id="9da70-168">.NET Core에서 .NET 프레임워크에 종속되는 것은 .NET Core 및 .NET Framework 영역이 이러한 종속성이 *자주* 작동할 정도로 유사하기 때문에 허용됩니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-168">.NET Core to .NET Framework dependencies are allowed because .NET Core and .NET Framework surface areas are similar enough that such dependencies *often* work.</span></span> <span data-ttu-id="9da70-169">그러나 패키지가 .NET Core에 없는 .NET API를 사용하려고 하면 런타임 예외가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-169">However, if the package tries to use a .NET API that isn't present in .NET Core, you'll encounter a runtime exception.</span></span> <span data-ttu-id="9da70-170">따라서 다른 옵션을 사용할 수 없는 경우에만 .NET Framework 패키지를 참조해야 하며 이렇게 하면 테스트 부담이 가중된다는 것을 이해해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-170">Because of that, you should only reference .NET Framework packages when no other options are available and understand that doing so imposes a test burden.</span></span>

<span data-ttu-id="9da70-171">.NET Core 또는 .NET Standard를 대상으로 하지 않는 참조된 패키지가 있는 경우 다른 대안을 고려해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-171">If there are packages referenced that don't target .NET Core or .NET Standard, you'll have to think about other alternatives:</span></span>

- <span data-ttu-id="9da70-172">대신 사용할 수있는 다른 유사한 패키지가 있습니까?</span><span class="sxs-lookup"><span data-stu-id="9da70-172">Are there other similar packages that can be used instead?</span></span> <span data-ttu-id="9da70-173">때때로 NuGet 저자는 별도의 '를 게시합니다. 특히 .NET 코어를 대상으로 하는 라이브러리의 코어 버전입니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-173">Sometimes NuGet authors publish separate '.Core' versions of their libraries specifically targeting .NET Core.</span></span> <span data-ttu-id="9da70-174">엔터프라이즈 라이브러리 패키지는 커뮤니티 게시 "의 예입니다. 넷 코어"대안.</span><span class="sxs-lookup"><span data-stu-id="9da70-174">Enterprise Library packages are an example of the community publishing ".NetCore" alternatives.</span></span> <span data-ttu-id="9da70-175">다른 경우에는 .NET Standard에서 특정 서비스에 대한 최신 SDK(때로는 다른 패키지 이름)를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-175">In other cases, newer SDKs for a particular service (sometimes with different package names) are available for .NET Standard.</span></span> <span data-ttu-id="9da70-176">사용할 수 있는 대안이 없는 경우 .NET Core에서 실행한 후 철저히 테스트해야 한다는 점을 염두에 두고 .NET Framework 대상 패키지를 사용하여 진행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-176">If no alternatives are available, you can proceed using the .NET Framework-targeted packages, bearing in mind that you'll need to test them thoroughly once running on .NET Core.</span></span>

<span data-ttu-id="9da70-177">빈 트레이더 샘플에는 다음과 같은 최상위 NuGet 종속성이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-177">The Bean Trader sample has the following top-level NuGet dependencies:</span></span>

- [<span data-ttu-id="9da70-178">**캐슬.윈저, 버전 4.1.1**</span><span class="sxs-lookup"><span data-stu-id="9da70-178">**Castle.Windsor, version 4.1.1**</span></span>](https://www.castleproject.org/projects/windsor/)  

  <span data-ttu-id="9da70-179">이 패키지는 .NET 표준 1.6을 대상으로 하므로 .NET Core에서 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-179">This package targets .NET Standard 1.6, so it works on .NET Core.</span></span>

- [<span data-ttu-id="9da70-180">**마이크로소프트.코드분석.FxCop분석기, 버전 2.6.3**</span><span class="sxs-lookup"><span data-stu-id="9da70-180">**Microsoft.CodeAnalysis.FxCopAnalyzers, version 2.6.3**</span></span>](https://www.nuget.org/packages/Microsoft.CodeAnalysis.FxCopAnalyzers/2.6.3)  
  <span data-ttu-id="9da70-181">이 패키지는 메타 패키지이므로 지원하는 플랫폼을 즉시 알 수는 없지만 [문서에 따르면](https://github.com/dotnet/roslyn-analyzers#microsoftcodeanalysisfxcopanalyzers) 최신 버전(2.9.2)이 .NET Framework 및 .NET Core 모두에서 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-181">This is a meta-package, so it's not immediately obvious which platforms it supports, but [documentation](https://github.com/dotnet/roslyn-analyzers#microsoftcodeanalysisfxcopanalyzers) indicates that its newest version (2.9.2) will work for both .NET Framework and .NET Core.</span></span>

- [<span data-ttu-id="9da70-182">**니토.애싱크, 버전 4.0.1**</span><span class="sxs-lookup"><span data-stu-id="9da70-182">**Nito.AsyncEx, version 4.0.1**</span></span>](https://www.nuget.org/packages/Nito.AsyncEx/4.0.1)  

  <span data-ttu-id="9da70-183">이 패키지는 .NET Core를 대상으로 하지 않지만 최신 5.0 버전은 해당 합니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-183">This package doesn't target .NET Core, but the newer 5.0 version does.</span></span> <span data-ttu-id="9da70-184">많은 NuGet 패키지가 최근에 .NET 표준 지원을 추가했지만 이전 프로젝트 버전은 .NET Framework만 대상으로 하므로 마이그레이션할 때 일반적입니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-184">This is common when migrating because many NuGet packages have added .NET Standard support recently, but older project versions will only target .NET Framework.</span></span> <span data-ttu-id="9da70-185">버전 차이가 사소한 버전 차이인 경우 최신 버전으로 쉽게 업그레이드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-185">If the version difference is only a minor version difference, it's often easy to upgrade to the newer version.</span></span> <span data-ttu-id="9da70-186">이는 주요 버전 변경이므로 패키지에 주요 변경 사항이 있을 수 있으므로 신중하게 업그레이드해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-186">Because this is a major version change, you need to be cautious upgrading since there could be breaking changes in the package.</span></span> <span data-ttu-id="9da70-187">하지만 앞으로 나아갈 길이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-187">There is a path forward, though, which is good.</span></span>

- [<span data-ttu-id="9da70-188">**MahApps.Metro, 버전 1.6.5**</span><span class="sxs-lookup"><span data-stu-id="9da70-188">**MahApps.Metro, version 1.6.5**</span></span>](https://www.nuget.org/packages/MahApps.Metro/1.6.5)  

  <span data-ttu-id="9da70-189">이 패키지는 .NET Core를 대상으로 하지 않지만 최신 시험판(2.0-알파)을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-189">This package also doesn't target .NET Core, but has a newer pre-release (2.0-alpha) that does.</span></span> <span data-ttu-id="9da70-190">다시 말하지만, 당신은 변화를 깨는 조심해야하지만, 새로운 패키지는 고무적이다.</span><span class="sxs-lookup"><span data-stu-id="9da70-190">Again, you have to look out for breaking changes, but the newer package is encouraging.</span></span>

<span data-ttu-id="9da70-191">빈 트레이더 샘플의 NuGet 종속성은 모두 .NET 표준/.NET 코어를 대상으로 하거나 최신 버전을 가지고 있으므로 여기에서 차단 문제가 발생하지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-191">The Bean Trader sample's NuGet dependencies all either target .NET Standard/.NET Core or have newer versions that do, so there are unlikely to be any blocking issues here.</span></span>

### <a name="upgrade-nuget-packages"></a><span data-ttu-id="9da70-192">NuGet 패키지 업그레이드</span><span class="sxs-lookup"><span data-stu-id="9da70-192">Upgrade NuGet packages</span></span>

<span data-ttu-id="9da70-193">가능하면 이 시점에서 최신 버전(프로젝트가 여전히 .NET Framework을 대상으로 하는)으로 .NET Core 또는 .NET 표준만을 대상으로 하는 모든 패키지의 버전을 업그레이드하여 주요 변경 사항을 조기에 발견하고 해결하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-193">If possible, it would be good to upgrade the versions of any packages that only target .NET Core or .NET Standard with more recent versions at this point (with the project still targeting .NET Framework) to discover and address any breaking changes early.</span></span>

<span data-ttu-id="9da70-194">앱의 기존 .NET Framework 버전을 변경하지 않으려면 .NET Core를 대상으로 하는 새 프로젝트 파일이 있을 때까지 기다릴 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-194">If you would rather not make any material changes to the existing .NET Framework version of the app, this can wait until you have a new project file targeting .NET Core.</span></span> <span data-ttu-id="9da70-195">그러나 NuGet 패키지를 미리 .NET Core 호환 버전으로 업그레이드하면 새 프로젝트 파일을 만들면 마이그레이션 프로세스가 더욱 쉬워지고 .NET Framework와 .NET Core 버전 간의 차이점이 줄어듭니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-195">However, upgrading the NuGet packages to .NET Core-compatible versions ahead of time makes the migration process even easier once you create the new project file and reduces the number of differences between the .NET Framework and .NET Core versions of the app.</span></span>

<span data-ttu-id="9da70-196">Bean Trader 샘플을 사용하면 한 가지 예외를 제외하고 필요한 모든 업그레이드를 쉽게 수행할 수 있습니다(Visual Studio의 NuGet 패키지 관리자 사용) **MahApps.Metro 1.6.5에서** **2.0으로** 업그레이드하면 테마 및 악센트 관리 API와 관련된 주요 변경 사항이 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-196">With the Bean Trader sample, all of the necessary upgrades can be made easily (using Visual Studio's NuGet package manager) with one exception: upgrading from **MahApps.Metro 1.6.5** to **2.0** reveals breaking changes related to theme and accent management APIs.</span></span>

<span data-ttu-id="9da70-197">이상적으로는 .NET Core에서 작동할 가능성이 높기 때문에 최신 버전의 패키지를 사용하도록 앱이 업데이트되는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-197">Ideally, the app would be updated to use the newer version of the package (since that is more likely to work on .NET Core).</span></span> <span data-ttu-id="9da70-198">그러나 경우에 따라 실현 가능하지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-198">In some cases, however, that may not be feasible.</span></span> <span data-ttu-id="9da70-199">이러한 경우 필요한 변경 사항이 간단하지 않고 이 자습서에서는 **MahApps.Metro 2가** 아닌 .NET Core 3로 마이그레이션하는 데 중점을 두므로 **MahApps.Metro를** 업그레이드하지 마십시오.</span><span class="sxs-lookup"><span data-stu-id="9da70-199">In these cases, don't upgrade **MahApps.Metro** because the necessary changes are non-trivial and this tutorial focuses on migrating to .NET Core 3, not to **MahApps.Metro 2.**</span></span> <span data-ttu-id="9da70-200">또한, 이것은 낮은 위험 .NET 프레임 워크 종속성 때문에 콩 상인 응용 프로그램 **MahApps.Metro의**작은 부분만 실행 .</span><span class="sxs-lookup"><span data-stu-id="9da70-200">Also, this is a low-risk .NET Framework dependency because the Bean Trader app only exercises a small part of **MahApps.Metro**.</span></span> <span data-ttu-id="9da70-201">물론 마이그레이션이 완료되면 모든 것이 작동하는지 확인하기 위한 테스트가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-201">It will, of course, require testing to make sure everything's working once the migration is complete.</span></span> <span data-ttu-id="9da70-202">이것이 실제 시나리오라면 마이그레이션을 수행하지 않기 때문에 **MahApps.Metro** 버전 2.0으로 이동하는 작업을 추적하는 문제를 제기하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-202">If this were a real-world scenario, it would be good to file an issue to track the work to move to **MahApps.Metro** version 2.0 since not doing the migration now leaves behind some technical debt.</span></span>

<span data-ttu-id="9da70-203">NuGet 패키지가 최신 버전으로 업데이트되면 Bean Trader 샘플의 프로젝트 파일의 `<PackageReference>` 항목 그룹이 다음과 같아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-203">Once the NuGet packages are updated to recent versions, the `<PackageReference>` item group in the Bean Trader sample's project file should look like this.</span></span>

```xml
<ItemGroup>
  <PackageReference Include="Castle.Windsor">
    <Version>4.1.1</Version>
  </PackageReference>
  <PackageReference Include="MahApps.Metro">
    <Version>1.6.5</Version>
  </PackageReference>
  <PackageReference Include="Microsoft.CodeAnalysis.FxCopAnalyzers">
    <Version>2.9.2</Version>
  </PackageReference>
  <PackageReference Include="Nito.AsyncEx">
    <Version>5.0.0</Version>
  </PackageReference>
</ItemGroup>
```

### <a name="net-framework-portability-analysis"></a><span data-ttu-id="9da70-204">.NET 프레임워크 이식성 분석</span><span class="sxs-lookup"><span data-stu-id="9da70-204">.NET Framework portability analysis</span></span>

<span data-ttu-id="9da70-205">프로젝트의 NuGet 종속성 상태를 이해한 후 고려해야 할 다음 은 .NET Framework API 종속성입니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-205">Once you understand the state of your project's NuGet dependencies, the next thing to consider is .NET Framework API dependencies.</span></span> <span data-ttu-id="9da70-206">[.NET 이식성 분석기](../../standard/analyzers/portability-analyzer.md) 도구는 프로젝트가 사용하는 .NET API 중 다른 .NET 플랫폼에서 사용할 수 있는 .NET API를 이해하는 데 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-206">The [.NET Portability Analyzer](../../standard/analyzers/portability-analyzer.md) tool is useful for understanding which of the .NET APIs your project uses are available on other .NET platforms.</span></span>

<span data-ttu-id="9da70-207">이 도구는 [Visual Studio 플러그인,](https://marketplace.visualstudio.com/items?itemName=ConnieYau.NETPortabilityAnalyzer) [명령줄 도구](https://github.com/Microsoft/dotnet-apiport/releases)또는 [간단한 GUI로](https://github.com/Microsoft/dotnet-apiport-ui)감싸서 옵션을 단순화합니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-207">The tool comes as a [Visual Studio plugin](https://marketplace.visualstudio.com/items?itemName=ConnieYau.NETPortabilityAnalyzer), a [command-line tool](https://github.com/Microsoft/dotnet-apiport/releases), or wrapped in a [simple GUI](https://github.com/Microsoft/dotnet-apiport-ui), which simplifies its options.</span></span> <span data-ttu-id="9da70-208">포팅 데스크톱 앱의 GUI를 사용하여 .NET Core 블로그 게시물에 [.NET 이식성](https://devblogs.microsoft.com/dotnet/porting-desktop-apps-to-net-core/) 분석기(API 포트)를 사용하는 것에 대해 자세히 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-208">You can read more about using the .NET Portability Analyzer (API Port) using the GUI in the [Porting desktop apps to .NET Core](https://devblogs.microsoft.com/dotnet/porting-desktop-apps-to-net-core/) blog post.</span></span> <span data-ttu-id="9da70-209">명령줄을 사용하려는 경우 필요한 단계는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-209">If you prefer to use the command line, the necessary steps are:</span></span>

1. <span data-ttu-id="9da70-210">[.NET 이식성 분석기를](https://github.com/Microsoft/dotnet-apiport/releases) 아직 가지고 있지 않은 경우 다운로드하십시오.</span><span class="sxs-lookup"><span data-stu-id="9da70-210">Download the [.NET Portability Analyzer](https://github.com/Microsoft/dotnet-apiport/releases) if you don't already have it.</span></span>
1. <span data-ttu-id="9da70-211">.NET Framework 앱을 성공적으로 포팅할 수 있는지 확인합니다(마이그레이션 전에 는 이 방법을 사용할 수 있습니다).</span><span class="sxs-lookup"><span data-stu-id="9da70-211">Make sure the .NET Framework app to be ported builds successfully (this is a good idea prior to migration regardless).</span></span>
1. <span data-ttu-id="9da70-212">이와 같은 명령줄로 API 포트를 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-212">Run API Port with a command line like this.</span></span>

    ```console
    ApiPort.exe analyze -f <PathToBeanTraderBinaries> -r html -r excel -t ".NET Core"
    ```

    <span data-ttu-id="9da70-213">인수는 `-f` 분석할 바이너리를 포함하는 경로를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-213">The `-f` argument specifies the path containing the binaries to analyze.</span></span> <span data-ttu-id="9da70-214">인수는 `-r` 원하는 출력 파일 형식을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-214">The `-r` argument specifies which output file format you want.</span></span> <span data-ttu-id="9da70-215">인수는 `-t` API 사용량을 분석할 .NET 플랫폼을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-215">The `-t` argument specifies which .NET platform to analyze API usage against.</span></span> <span data-ttu-id="9da70-216">이 경우 .NET 코어를 원합니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-216">In this case, you want .NET Core.</span></span>

<span data-ttu-id="9da70-217">HTML 보고서를 열면 첫 번째 섹션에서는 분석된 모든 바이너리와 대상 플랫폼에서 사용할 수 있는 .NET API의 백분율을 나열합니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-217">When you open the HTML report, the first section will list all of the analyzed binaries and what percentage of the .NET APIs they use are available on the targeted platform.</span></span> <span data-ttu-id="9da70-218">백분율 자체는 의미가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-218">The percentage is not meaningful by itself.</span></span> <span data-ttu-id="9da70-219">더 유용한 것은 누락된 특정 API를 확인하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-219">What's more useful is to see the specific APIs that are missing.</span></span> <span data-ttu-id="9da70-220">이렇게 하려면 어셈블리 이름을 선택하거나 개별 어셈블리에 대한 보고서로 아래로 스크롤합니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-220">To do that, either select an assembly name or scroll down to the reports for individual assemblies.</span></span>

<span data-ttu-id="9da70-221">소스 코드를 소유하는 어셈블리에 초점을 맞춥니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-221">Focus on the assemblies that you own the source code for.</span></span> <span data-ttu-id="9da70-222">예를 들어 Bean Trader ApiPort 보고서에는 나열된 바이너리가 많지만 대부분은 NuGet 패키지에 속합니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-222">In the Bean Trader ApiPort report, for example, there are many binaries listed, but most of them belong to NuGet packages.</span></span> <span data-ttu-id="9da70-223">`Castle.Windsor`에서는 .NET Core에 없는 일부 System.Web API에 따라 달라지다는 것을 보여 주며 이 API는</span><span class="sxs-lookup"><span data-stu-id="9da70-223">`Castle.Windsor` shows that it depends on some System.Web APIs that are missing in .NET Core.</span></span> <span data-ttu-id="9da70-224">이전에 .NET Core를 지원하는 것으로 `Castle.Windsor` 확인했기 때문에 이 문제는 문제가 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-224">This isn't a concern because you previously verified that `Castle.Windsor` supports .NET Core.</span></span> <span data-ttu-id="9da70-225">NuGet 패키지는 다른 .NET 플랫폼에서 사용하기 위해 다른 바이너리를 가지는 것이 일반적이므로.NET Framework 버전의 `Castle.Windsor` System.Web API를 사용하는지 여부는 패키지가 .NET 표준 또는 .NET Core(수행하는 항목)를 대상으로 하는 한 관련이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-225">It is common for NuGet packages to have different binaries for use with different .NET platforms, so whether the .NET Framework version of `Castle.Windsor` uses System.Web APIs or not is irrelevant as long as the package also targets .NET Standard or .NET Core (which it does).</span></span>

<span data-ttu-id="9da70-226">빈 트레이더 샘플을 사용하면 고려해야 할 유일한 바이너리만 **BeanTraderClient이며** 보고서에는 두 개의 .NET API만 누락된 `System.ServiceModel.ClientBase<T>.Close` 것으로 `System.ServiceModel.ClientBase<T>.Open`표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-226">With the Bean Trader sample, the only binary that you need to consider is **BeanTraderClient** and the report shows that only two .NET APIs are missing: `System.ServiceModel.ClientBase<T>.Close` and `System.ServiceModel.ClientBase<T>.Open`.</span></span>

![빈트레이어클라이언트 이식성 보고서](./media/convert-project-from-net-framework/portability-report.png)

<span data-ttu-id="9da70-228">WCF 클라이언트 API는 주로 .NET Core에서 지원되므로 이러한 중앙 API에 사용할 수 있는 대안이 있어야 하므로 이러한 문제가 차단될 가능성은 거의 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-228">These are unlikely to be blocking issues because WCF Client APIs are (mostly) supported on .NET Core, so there must be alternatives available for these central APIs.</span></span> <span data-ttu-id="9da70-229">실제로 `System.ServiceModel`.NET Core 표면 영역(사용)을 <https://apisof.net>살펴보면 .NET Core대신 비동기 대안이 있음을 알 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-229">In fact, looking at `System.ServiceModel`'s .NET Core surface area (using <https://apisof.net>), you see that there are async alternatives in .NET Core instead.</span></span>

<span data-ttu-id="9da70-230">이 보고서와 이전 NuGet 종속성 분석을 기반으로 Bean Trader 샘플을 .NET Core로 마이그레이션하는 주요 문제가 없어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-230">Based on this report and the previous NuGet dependency analysis, it looks like there should be no major issues migrating the Bean Trader sample to .NET Core.</span></span> <span data-ttu-id="9da70-231">실제로 마이그레이션을 시작할 다음 단계에 대한 준비가 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-231">You're ready for the next step in which you'll actually start the migration.</span></span>

## <a name="migrating-the-project-file"></a><span data-ttu-id="9da70-232">프로젝트 파일 마이그레이션</span><span class="sxs-lookup"><span data-stu-id="9da70-232">Migrating the project file</span></span>

<span data-ttu-id="9da70-233">앱에서 새 [SDK 스타일 프로젝트 파일 형식을](../../core/tools/csproj.md)사용하지 않는 경우 .NET Core를 대상으로 하는 새 프로젝트 파일이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-233">If your app isn't using the new [SDK-style project file format](../../core/tools/csproj.md), you'll need a new project file to target .NET Core.</span></span> <span data-ttu-id="9da70-234">기존 csproj 파일을 바꾸거나 기존 프로젝트를 현재 상태로 유지하려는 경우 .NET Core를 대상으로 하는 새 csproj 파일을 추가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-234">You can replace the existing csproj file or, if you prefer to keep the existing project untouched in its current state, you can add a new csproj file targeting .NET Core.</span></span> <span data-ttu-id="9da70-235">여러 대상을 지정하는 [다중 대상을](../../standard/library-guidance/cross-platform-targeting.md) 가진 단일 SDK 스타일 프로젝트 파일로 .NET Framework `<TargetFrameworks>` 및 .NET Core용 앱 버전을 빌드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-235">You can build versions of the app for .NET Framework and .NET Core with a single SDK-style project file with [multi-targeting](../../standard/library-guidance/cross-platform-targeting.md) (specifying multiple `<TargetFrameworks>` targets).</span></span>

<span data-ttu-id="9da70-236">새 프로젝트 파일을 만들려면 Visual Studio에서 새 WPF 프로젝트를 `dotnet new wpf` 만들거나 임시 디렉터리의 명령을 사용하여 프로젝트 파일을 생성한 다음 올바른 위치로 복사/이름을 바꿀 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-236">To create the new project file, you can create a new WPF project in Visual Studio or use the `dotnet new wpf` command in a temporary directory to generate the project file and then copy/rename it to the correct location.</span></span> <span data-ttu-id="9da70-237">프로젝트 파일 마이그레이션의 일부를 자동화할 수 있는 커뮤니티에서 만든 도구인 [CsprojToVs2017도](https://github.com/hvanbakel/CsprojToVs2017)있습니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-237">There is also a community-created tool, [CsprojToVs2017](https://github.com/hvanbakel/CsprojToVs2017), that can automate some of the project file migration.</span></span> <span data-ttu-id="9da70-238">이 도구는 유용하지만 마이그레이션의 모든 세부 사항이 올바른지 확인하기 위해 결과를 검토할 사람이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-238">The tool is helpful but still needs a human to review the results to make sure all the details of the migration are correct.</span></span> <span data-ttu-id="9da70-239">도구가 최적으로 처리하지 않는 한 가지 특정 영역은 *packages.config* 파일에서 NuGet 패키지를 마이그레이션하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-239">One particular area that the tool doesn't handle optimally is migrating NuGet packages from *packages.config* files.</span></span> <span data-ttu-id="9da70-240">도구가 여전히 *Packages.config* 파일을 사용하여 NuGet 패키지를 참조하는 프로젝트 파일에서 실행되는 경우 `<PackageReference>` 자동으로 요소로 마이그레이션되지만 최상위 패키지 대신 `<PackageReference>` *모든* 패키지에 대한 요소를 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-240">If the tool runs on a project file that still uses a *packages.config* file to reference NuGet packages, it will migrate to `<PackageReference>` elements automatically, but will add `<PackageReference>` elements for *all* of the packages instead of just top-level ones.</span></span> <span data-ttu-id="9da70-241">이 샘플에서 수행한`<PackageReference>` 것처럼 Visual Studio가 있는 요소로 이미 마이그레이션한 경우 이 도구를 사용하여 변환의 나머지 부분을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-241">If you have already migrated to`<PackageReference>` elements with Visual Studio (as you've done in this sample), then the tool can help with the rest of the conversion.</span></span> <span data-ttu-id="9da70-242">Scott Hanselman이 [csproj 파일 마이그레이션에 대한 블로그 게시물에서](https://www.hanselman.com/blog/UpgradingAnExistingNETProjectFilesToTheLeanNewCSPROJFormatFromNETCore.aspx)권장하는 것처럼 손으로 이식하는 것은 교육적이며 포트에 몇 가지 프로젝트만 있는 경우 더 나은 결과를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-242">Like Scott Hanselman recommends in [his blog post on migrating csproj files](https://www.hanselman.com/blog/UpgradingAnExistingNETProjectFilesToTheLeanNewCSPROJFormatFromNETCore.aspx), porting by hand is educational and will give better results if you only have a few projects to port.</span></span> <span data-ttu-id="9da70-243">그러나 수십 또는 수백 개의 프로젝트 파일을 이식하는 경우 [CsprojToVs2017]과 같은 도구가 도움이 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-243">But if you are porting dozens or hundreds of project files, then a tool like [CsprojToVs2017] can be a help.</span></span>

<span data-ttu-id="9da70-244">빈 트레이더 샘플에 대한 새 프로젝트 `dotnet new wpf` 파일을 만들려면 임시 디렉토리에서 실행하고 생성된 *.csproj* 파일을 *BeanTraderClient* 폴더로 이동하고 **BeanTraderClient.Core.csproj의**이름을 바꿉니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-244">To create a new project file for the Bean Trader sample, run `dotnet new wpf` in a temporary directory and move the generated *.csproj* file into the *BeanTraderClient* folder and rename it **BeanTraderClient.Core.csproj**.</span></span>

<span data-ttu-id="9da70-245">새 프로젝트 파일 형식에는 C# 파일, *resx* 파일 및 디렉터리 에서 찾은 XAML 파일이 자동으로 포함되어 있으므로 프로젝트 파일은 이미 거의 완료되었습니다!</span><span class="sxs-lookup"><span data-stu-id="9da70-245">Because the new project file format automatically includes C# files, *resx* files, and XAML files that it finds in or under its directory, the project file is already almost complete!</span></span> <span data-ttu-id="9da70-246">마이그레이션을 완료하려면 이전 프로젝트 파일과 새 프로젝트 파일을 나란히 열고 이전 프로젝트 파일을 살펴보고 이전 프로젝트 파일을 살펴보고 마이그레이션해야 하는 정보가 있는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-246">To finish the migration, open the old and new project files side-by-side and look through the old one to see if any information it contains needs to be migrated.</span></span> <span data-ttu-id="9da70-247">빈 트레이더 샘플 의 경우 다음 항목을 새 프로젝트에 복사해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-247">In the Bean Trader sample case, the following items should be copied to the new project:</span></span>

- <span data-ttu-id="9da70-248">의 `<RootNamespace>` `<AssemblyName>`에서 `<ApplicationIcon>` 및 속성은 모두 복사해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-248">The `<RootNamespace>`, `<AssemblyName>`, and `<ApplicationIcon>` properties should all be copied.</span></span>

- <span data-ttu-id="9da70-249">또한 Bean Trader `<GenerateAssemblyInfo>false</GenerateAssemblyInfo>` 샘플에 AssemblyInfo.cs 파일에 어셈블리 수준 특성(예: `[AssemblyTitle]`)이 포함되어 있으므로 새 프로젝트 파일에 속성을 추가해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-249">You also need to add a `<GenerateAssemblyInfo>false</GenerateAssemblyInfo>` property to the new project file since the Bean Trader sample includes assembly-level attributes (like `[AssemblyTitle]`) in an AssemblyInfo.cs file.</span></span> <span data-ttu-id="9da70-250">기본적으로 새 SDK 스타일 프로젝트는 csproj 파일의 속성을 기반으로 이러한 특성을 자동으로 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-250">By default, new SDK-style projects will autogenerate these attributes based on properties in the csproj file.</span></span> <span data-ttu-id="9da70-251">이 경우 이러한 일이 발생하지 않도록 하려면(자동 생성된 특성이 AssemblyInfo.cs 특성과 충돌함) `<GenerateAssemblyInfo>`에서 자동 생성된 특성을 사용하지 않도록 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-251">Because you don't want that to happen in this case (the autogenerated attributes would conflict with those from AssemblyInfo.cs), you disable the autogenerated attributes with `<GenerateAssemblyInfo>`.</span></span>

- <span data-ttu-id="9da70-252">*resx* 파일은 포함된 리소스로 자동으로 `<Resource>` 포함되지만 이미지와 같은 다른 항목은 포함되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-252">Although *resx* files are automatically included as embedded resources, other `<Resource>` items like images are not.</span></span> <span data-ttu-id="9da70-253">따라서 이미지 `<Resource>` 및 아이콘 파일을 포함하기 위한 요소를 복사합니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-253">So, copy the `<Resource>` elements for embedding image and icon files.</span></span> <span data-ttu-id="9da70-254">새 프로젝트 파일 형식의 송부 패턴 지원을 사용하여 png 참조를 한 `<Resource Include="**\*.png" />`줄로 단순화할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-254">You can simplify the png references to a single line by using the new project file format's support for globbing patterns: `<Resource Include="**\*.png" />`.</span></span>

- <span data-ttu-id="9da70-255">마찬가지로 `<None>` 항목은 자동으로 포함되지만 기본적으로 출력 디렉토리에 복사되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-255">Similarly, `<None>` items are included automatically, but they aren't copied to the output directory, by default.</span></span> <span data-ttu-id="9da70-256">Bean Trader *프로젝트에는* 비헤이비어 를 사용하여 `PreserveNewest` 출력 디렉토리에 복사된 `<None>` `<None>` 항목이 포함되어 있으므로 이와 같이 해당 파일에 대해 자동으로 채워진 항목을 업데이트해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-256">Because the Bean Trader project includes a `<None>` item that *is* copied to the output directory (using `PreserveNewest` behaviors), you need to update the automatically populated `<None>` item for that file, like this.</span></span>

  ```xml
  <None Update="BeanTrader.pfx">
    <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
  </None>
  ```

- <span data-ttu-id="9da70-257">Bean Trader 샘플에는 이 파일에 정의된 테마와 악센트가 앱 `Content` 자체에 포함되지 `Page`않고 런타임에 파일의 XAML에서 로드되기 때문에 XAML 파일(Default.Accent.xaml)이 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-257">The Bean Trader sample includes a XAML file (Default.Accent.xaml) as `Content` (rather than as a `Page`) because themes and accents defined in this file are loaded from the file's XAML at runtime, rather than being embedded in the app itself.</span></span> <span data-ttu-id="9da70-258">그러나 새 프로젝트 시스템에는 XAML 파일이므로 이 파일을 `<Page>`자동으로 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-258">The new project system automatically includes this file as a `<Page>`, however, since it's a XAML file.</span></span> <span data-ttu-id="9da70-259">따라서 XAML 파일을 페이지()로`<Page Remove="**\Default.Accent.xaml" />`제거하고 콘텐츠로 추가해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-259">So, you need to both remove the XAML file as a page (`<Page Remove="**\Default.Accent.xaml" />`) and add it as content.</span></span>

  ```xml
  <Content Include="Resources\Themes\Default.Accent.xaml">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
  </Content>
  ```

- <span data-ttu-id="9da70-260">마지막으로 모든 요소를 복사하여 `<ItemGroup>` NuGet 참조를 추가합니다. `<PackageReference>`</span><span class="sxs-lookup"><span data-stu-id="9da70-260">Finally, add NuGet references by copying the `<ItemGroup>` with all the `<PackageReference>` elements.</span></span> <span data-ttu-id="9da70-261">이전에 NuGet 패키지를 .NET 코어 호환 버전으로 업그레이드하지 않은 경우 이제 패키지 참조가 .NET Core 관련 프로젝트에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-261">If you hadn't previously upgraded the NuGet packages to .NET Core-compatible versions, you could do that now that the package references are in a .NET Core-specific project.</span></span>

<span data-ttu-id="9da70-262">이 시점에서 BeanTrader 솔루션에 새 프로젝트를 추가하고 Visual Studio에서 열 수 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-262">At this point, it should be possible to add the new project to the BeanTrader solution and open it in Visual Studio.</span></span> <span data-ttu-id="9da70-263">이 프로젝트는 솔루션 **탐색기에서** `dotnet restore BeanTraderClient.Core.csproj` 올바르게 보이며 패키지를 성공적으로 복원해야 합니다(.NET Framework를 대상으로 사용하는 MahApps.Metro 버전과 관련된 두 가지 경고가 있음).</span><span class="sxs-lookup"><span data-stu-id="9da70-263">The project should look correct in **Solution Explorer**, and `dotnet restore BeanTraderClient.Core.csproj` should successfully restore packages (with two expected warnings related to the MahApps.Metro version you're using targeting .NET Framework).</span></span>

<span data-ttu-id="9da70-264">두 프로젝트 파일을 나란히 유지할 수 있지만(이전 프로젝트를 그대로 빌드하려는 경우 바람직할 수도 있음) 마이그레이션 프로세스가 복잡해집니다(두 프로젝트는 동일한 bin 및 obj 폴더를 사용하려고 합니다).</span><span class="sxs-lookup"><span data-stu-id="9da70-264">Although it's possible to keep both project files side-by-side (and may even be desirable if you want to keep building the old project exactly as it was), it complicates the migration process (the two projects will try to use the same bin and obj folders) and usually isn't necessary.</span></span> <span data-ttu-id="9da70-265">.NET Core 및 .NET Framework 대상모두에 대해 빌드하려는 `<TargetFramework>netcoreapp3.0</TargetFramework>` 경우 새 프로젝트 파일의 속성을 `<TargetFrameworks>netcoreapp3.0;net472</TargetFrameworks>` 대신 바꿀 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-265">If you want to build for both .NET Core and .NET Framework targets, you can replace the `<TargetFramework>netcoreapp3.0</TargetFramework>` property in the new project file with `<TargetFrameworks>netcoreapp3.0;net472</TargetFrameworks>` instead.</span></span> <span data-ttu-id="9da70-266">빈 트레이더 샘플의 경우 더 이상 필요하지 않으므로 이전 프로젝트 파일(BeanTraderClient.csproj)을 삭제합니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-266">For the Bean Trader sample, delete the old project file (BeanTraderClient.csproj) since it's no longer needed.</span></span> <span data-ttu-id="9da70-267">두 프로젝트 파일을 모두 유지하려는 경우 다른 출력 및 중간 출력 경로로 빌드하도록 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-267">If you prefer to keep both project files, be sure to have them build to different output and intermediate output paths.</span></span>

## <a name="fix-build-issues"></a><span data-ttu-id="9da70-268">빌드 문제 해결</span><span class="sxs-lookup"><span data-stu-id="9da70-268">Fix build issues</span></span>

<span data-ttu-id="9da70-269">포팅 프로세스의 세 번째 단계는 프로젝트를 빌드하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-269">The third step of the porting process is getting the project to build.</span></span> <span data-ttu-id="9da70-270">일부 앱은 프로젝트 파일이 SDK 스타일 프로젝트로 변환되면 이미 성공적으로 빌드됩니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-270">Some apps will already build successfully once the project file is converted to an SDK-style project.</span></span> <span data-ttu-id="9da70-271">앱의 경우, 축하합니다!</span><span class="sxs-lookup"><span data-stu-id="9da70-271">If that's the case for your app, congratulations!</span></span> <span data-ttu-id="9da70-272">4단계로 진행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-272">You can go on to Step 4.</span></span> <span data-ttu-id="9da70-273">다른 앱은 .NET Core를 빌드하기 위해 몇 가지 업데이트가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-273">Other apps will need some updates to get them building for .NET Core.</span></span> <span data-ttu-id="9da70-274">예를 들어, `dotnet build` 빈 트레이더 샘플 프로젝트에서 실행하려고 하면(또는 Visual Studio에서 빌드) 많은 오류가 있지만 신속하게 수정됩니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-274">If you try to run `dotnet build` on the Bean Trader sample project now, for example, (or build it in Visual Studio), there will be many errors, but you'll get them fixed quickly.</span></span>

### <a name="systemservicemodel-references-and-microsoftwindowscompatibility"></a><span data-ttu-id="9da70-275">System.ServiceModel 참조 및 Microsoft.Windows.호환성</span><span class="sxs-lookup"><span data-stu-id="9da70-275">System.ServiceModel references and Microsoft.Windows.Compatibility</span></span>

<span data-ttu-id="9da70-276">.NET Core에서 사용할 수 있지만 .NET Core 앱 메타패키지에 자동으로 포함되지 않는 API에 대한 일반적인 오류 소스는 누락되었습니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-276">A common source of errors is missing references for APIs that are available for .NET Core but not automatically included in the .NET Core app metapackage.</span></span> <span data-ttu-id="9da70-277">이 문제를 해결하려면 `Microsoft.Windows.Compatibility` 패키지를 참조해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-277">To address this, you should reference the `Microsoft.Windows.Compatibility` package.</span></span> <span data-ttu-id="9da70-278">호환성 패키지에는 WCF 클라이언트, 디렉터리 서비스, 레지스트리, 구성, ACL API 등과 같은 Windows 데스크톱 앱에서 공통되는 광범위한 API 집합이 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-278">The compatibility package includes a broad set of APIs that are common in Windows desktop apps, such as WCF client, directory services, registry, configuration, ACLs APIs, and more.</span></span>

<span data-ttu-id="9da70-279">Bean Trader 샘플을 사용하면 대부분의 빌드 오류는 누락된 <xref:System.ServiceModel> 유형으로 인한 것입니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-279">With the Bean Trader sample, the majority of the build errors are due to missing <xref:System.ServiceModel> types.</span></span> <span data-ttu-id="9da70-280">이러한 문제는 필요한 WCF NuGet 패키지를 참조하여 해결할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-280">These could be addressed by referencing the necessary WCF NuGet packages.</span></span> <span data-ttu-id="9da70-281">WCF 클라이언트 API는 `Microsoft.Windows.Compatibility` 패키지에 있는 API 중 하나이므로 호환성 패키지를 참조하는 것이 더 나은 솔루션입니다(API와 관련된 모든 문제와 호환성 패키지가 사용할 수 있는 WCF 문제에 대한 해결 방법도 해결하기 때문에).</span><span class="sxs-lookup"><span data-stu-id="9da70-281">WCF client APIs are among those present in the `Microsoft.Windows.Compatibility` package, though, so referencing the compatibility package is an even better solution (since it also addresses any issues related to APIs as well as solutions to the WCF issues that the compatibility package makes available).</span></span> <span data-ttu-id="9da70-282">이 `Microsoft.Windows.Compatibility` 패키지는 대부분의 .NET 코어 3.0 WPF 및 WinForms 포팅 시나리오에서 도움이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-282">The `Microsoft.Windows.Compatibility` package helps in most .NET Core 3.0 WPF and WinForms porting scenarios.</span></span> <span data-ttu-id="9da70-283">NuGet 참조를 추가한 `Microsoft.Windows.Compatibility`후 , 하나의 빌드 오류만 남아 있습니다!</span><span class="sxs-lookup"><span data-stu-id="9da70-283">After adding the NuGet reference to `Microsoft.Windows.Compatibility`, only one build error remains!</span></span>

### <a name="cleaning-up-unused-files"></a><span data-ttu-id="9da70-284">사용하지 않는 파일 정리</span><span class="sxs-lookup"><span data-stu-id="9da70-284">Cleaning up unused files</span></span>

<span data-ttu-id="9da70-285">자주 발생하는 마이그레이션 문제의 한 가지 유형은 *모든* 소스를 자동으로 포함하는 새 SDK 스타일 프로젝트에서 빌드에 이전에 포함되지 않았던 C# 및 XAML 파일과 관련이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-285">One type of migration issue that comes up often relates to C# and XAML files that weren't previously included in the build getting picked up by the new SDK-style projects that include *all* source automatically.</span></span>

<span data-ttu-id="9da70-286">Bean Trader 샘플에 표시되는 다음 빌드 오류는 *OldUnusedViewModel.cs*에서 잘못된 인터페이스 구현을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-286">The next build error you see in the Bean Trader sample refers to a bad interface implementation in *OldUnusedViewModel.cs*.</span></span> <span data-ttu-id="9da70-287">파일 이름은 힌트이지만 검사 시 이 소스 파일이 올바르지 않다는 것을 알 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-287">The file name is a hint, but on inspection, you'll find that this source file is incorrect.</span></span> <span data-ttu-id="9da70-288">원래 .NET Framework 프로젝트에 포함되지 않았기 때문에 이전에는 문제가 발생하지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-288">It didn't cause issues previously because it wasn't included in the original .NET Framework project.</span></span> <span data-ttu-id="9da70-289">디스크에 있었지만 이전 *csproj에* 포함되지 않은 소스 파일은 이제 자동으로 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-289">Source files that were present on disk but not included in the old *csproj* are included automatically now.</span></span>

<span data-ttu-id="9da70-290">이와 같은 일회성 문제의 경우 이전 *csproj와* 비교하여 파일이 필요하지 않은지 확인한 다음 `<Compile Remove="" />` 소스 파일이 더 이상 필요하지 않은 경우 삭제합니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-290">For one-off issues like this, it's easy to compare to the previous *csproj* to confirm that the file isn't needed, and then either `<Compile Remove="" />` it or, if the source file isn't needed anywhere anymore, delete it.</span></span> <span data-ttu-id="9da70-291">이 경우 *OldUnusedViewModel.cs*삭제하는 것이 안전합니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-291">In this case, it's safe to just delete *OldUnusedViewModel.cs*.</span></span>

<span data-ttu-id="9da70-292">이러한 방식으로 제외해야 하는 원본 파일이 많은 경우 프로젝트 파일에서 `<EnableDefaultCompileItems>` 속성을 false로 설정하여 C# 파일의 자동 포함을 비활성화할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-292">If you have many source files that would need to be excluded this way, you can disable auto-inclusion of C# files by setting the `<EnableDefaultCompileItems>` property to false in the project file.</span></span> <span data-ttu-id="9da70-293">그런 다음 포함하려는 소스만 빌드하기 위해 이전 프로젝트 파일에서 새 프로젝트 파일로 항목을 복사할 `<Compile Include>` 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-293">Then, you can copy `<Compile Include>` items from the old project file to the new one in order to only build sources you intended to include.</span></span> <span data-ttu-id="9da70-294">마찬가지로 `<EnableDefaultPageItems>` XAML 페이지의 자동 포함을 해제하는 데 `<EnableDefaultItems>` 사용할 수 있으며 단일 속성으로 둘 다 제어할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-294">Similarly, `<EnableDefaultPageItems>` can be used to turn off auto-inclusion of XAML pages and `<EnableDefaultItems>` can control both with a single property.</span></span>

### <a name="a-brief-aside-on-multi-pass-compilers"></a><span data-ttu-id="9da70-295">멀티 패스 컴파일러에 대한 간략한 설명</span><span class="sxs-lookup"><span data-stu-id="9da70-295">A brief aside on multi-pass compilers</span></span>

<span data-ttu-id="9da70-296">빈 트레이더 샘플에서 잘못된 파일을 제거한 후 다시 빌드할 수 있으며 네 가지 오류가 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-296">After removing the offending file from the Bean Trader sample, you can re-build and will get four errors.</span></span> <span data-ttu-id="9da70-297">전에 는 없었나요?</span><span class="sxs-lookup"><span data-stu-id="9da70-297">Didn't you have one before?</span></span> <span data-ttu-id="9da70-298">오류 수가 증가하는 이유는 무엇입니까?</span><span class="sxs-lookup"><span data-stu-id="9da70-298">Why did the number of errors go up?</span></span> <span data-ttu-id="9da70-299">C# 컴파일러는 [다중 패스 컴파일러입니다.](https://docs.microsoft.com/archive/blogs/ericlippert/how-many-passes)</span><span class="sxs-lookup"><span data-stu-id="9da70-299">The C# compiler is a [multi-pass compiler](https://docs.microsoft.com/archive/blogs/ericlippert/how-many-passes).</span></span> <span data-ttu-id="9da70-300">즉, 각 소스 파일을 두 번 거칩니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-300">This means that it goes through each source file twice.</span></span> <span data-ttu-id="9da70-301">먼저 컴파일러는 각 소스 파일의 메타데이터와 선언만 살펴보고 선언 수준 문제를 식별합니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-301">First, the compiler just looks at metadata and declarations in each source file and identifies any declaration-level problems.</span></span> <span data-ttu-id="9da70-302">수정한 오류입니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-302">Those are the errors you've fixed.</span></span> <span data-ttu-id="9da70-303">그런 다음 코드를 다시 통과하여 C# 소스를 IL로 빌드합니다. 이는 현재 보고 있는 두 번째 오류 집합입니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-303">Then it goes through the code again to build the C# source into IL; those are the second set of errors that you're seeing now.</span></span>

> [!NOTE]
> <span data-ttu-id="9da70-304">C# 컴파일러는 [두 번 이상의 패스를](https://docs.microsoft.com/archive/blogs/ericlippert/how-many-passes)수행하지만, 최종 결과는 이와 같은 큰 코드 변경에 대한 컴파일러 오류가 두 가지 파로 오는 경향이 있다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-304">The C# compiler does [more than just two passes](https://docs.microsoft.com/archive/blogs/ericlippert/how-many-passes), but the end result is that compiler errors for large code changes like this tend to come in two waves.</span></span>

### <a name="third-party-dependency-fixes-castlewindsor"></a><span data-ttu-id="9da70-305">타사 종속 성 수정 (성.윈저)</span><span class="sxs-lookup"><span data-stu-id="9da70-305">Third-party dependency fixes (Castle.Windsor)</span></span>

<span data-ttu-id="9da70-306">일부 마이그레이션 시나리오에서 제기되는 또 다른 종류의 문제는 .NET Framework와 .NET Core 버전의 종속성 간의 API 차이입니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-306">Another class of issue that comes up in some migration scenarios is API differences between .NET Framework and .NET Core versions of dependencies.</span></span> <span data-ttu-id="9da70-307">NuGet 패키지가 .NET Framework 및 .NET 표준 또는 .NET Core를 모두 대상으로 하는 경우에도 다른 .NET 대상에서 사용할 라이브러리가 다를 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-307">Even if a NuGet package targets both .NET Framework and .NET Standard or .NET Core, there may be different libraries for use with different .NET targets.</span></span> <span data-ttu-id="9da70-308">이렇게 하면 패키지가 다양한 .NET 플랫폼을 지원할 수 있으며, 이 경우 다른 구현이 필요할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-308">This allows the packages to support many different .NET platforms, which may require different implementations.</span></span> <span data-ttu-id="9da70-309">또한 다른 .NET 플랫폼을 대상으로 할 때 라이브러리에 작은 API 차이가 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-309">It also means that there may be small API differences in the libraries when targeting different .NET platforms.</span></span>

<span data-ttu-id="9da70-310">빈 트레이더 샘플에 표시되는 다음 오류 집합은 API와 `Castle.Windsor` 관련이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-310">The next set of errors you'll see in the Bean Trader sample are related to `Castle.Windsor` APIs.</span></span> <span data-ttu-id="9da70-311">.NET 코어 빈 트레이더 프로젝트는 .NET Framework 대상 프로젝트(4.1.1)와 동일한 버전을 `Castle.Windsor` 사용하지만 이 두 플랫폼에 대한 구현은 약간 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-311">The .NET Core Bean Trader project uses the same version of `Castle.Windsor` as the .NET Framework-targeted project (4.1.1), but the implementations for those two platforms are slightly different.</span></span>

<span data-ttu-id="9da70-312">이 경우 해결해야 할 다음과 같은 문제가 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-312">In this case, you see the following issues that need to be fixed:</span></span>

1. <span data-ttu-id="9da70-313">`Castle.MicroKernel.Registration.Classes.FromThisAssembly`.NET 코어에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-313">`Castle.MicroKernel.Registration.Classes.FromThisAssembly` isn't available on .NET Core.</span></span> <span data-ttu-id="9da70-314">그러나 비슷한 `Classes.FromAssemblyContaining` API를 사용할 수 있으므로 호출을 하는 `Classes.FromThisAssembly()` 형식이 `Classes.FromAssemblyContaining(t)`있는 `t` 위치에 대한 호출로 두 용도를 모두 바꿀 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-314">There is, however, the similar API `Classes.FromAssemblyContaining` available, so we can replace both uses of `Classes.FromThisAssembly()` with calls to `Classes.FromAssemblyContaining(t)`, where `t` is the type making the call.</span></span>
1. <span data-ttu-id="9da70-315">마찬가지로, *Bootstrapper.cs* `Castle.Windsor.Installer.FromAssembly`. .NET Core에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-315">Similarly, in *Bootstrapper.cs*, `Castle.Windsor.Installer.FromAssembly`.This is unavailable on .NET Core.</span></span> <span data-ttu-id="9da70-316">대신 해당 호출을 로 `FromAssembly.Containing(typeof(Bootstrapper))`대체할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-316">Instead, that call can be replaced with `FromAssembly.Containing(typeof(Bootstrapper))`.</span></span>

### <a name="updating-wcf-client-usage"></a><span data-ttu-id="9da70-317">WCF 클라이언트 사용 업데이트</span><span class="sxs-lookup"><span data-stu-id="9da70-317">Updating WCF client usage</span></span>

<span data-ttu-id="9da70-318">차이점을 `Castle.Windsor` 수정하면 .NET Core Bean Trader 프로젝트의 마지막 남은 `BeanTraderServiceClient` 빌드 오류는 `DuplexClientBase`메서드가 없다는 `Open` 것입니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-318">Having fixed the `Castle.Windsor` differences, the last remaining build error in the .NET Core Bean Trader project is that `BeanTraderServiceClient` (which derives from `DuplexClientBase`) doesn't have an `Open` method.</span></span> <span data-ttu-id="9da70-319">이 마이그레이션 프로세스의 시작 부분에서 .NET 이식성 분석기에서 강조 표시 한 API이기 때문에 이것은 놀라운 일이 아니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-319">This isn't surprising since this is an API that was highlighted by the .NET Portability Analyzer at the beginning of this migration process.</span></span> <span data-ttu-id="9da70-320">하지만 `BeanTraderServiceClient` 더 큰 이슈에 관심을 불러일으킵니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-320">Looking at `BeanTraderServiceClient` draws our attention to a larger issue, though.</span></span> <span data-ttu-id="9da70-321">이 WCF 클라이언트는 [Svcutil.exe](../../framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md) 도구에 의해 자동 생성되었습니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-321">This WCF client was autogenerated by the [Svcutil.exe](../../framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md) tool.</span></span>

<span data-ttu-id="9da70-322">**Svcutil에서 생성된 WCF 클라이언트는 .NET 프레임워크에서 사용하기 위한 것입니다.**</span><span class="sxs-lookup"><span data-stu-id="9da70-322">**WCF clients generated by Svcutil are meant for use on .NET Framework.**</span></span>

<span data-ttu-id="9da70-323">svcutil에서 생성된 WCF 클라이언트를 사용하는 솔루션은 .NET Core와 함께 사용하기 위해 .NET 표준 호환 클라이언트를 다시 생성해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-323">Solutions that use svcutil-generated WCF clients will need to regenerate .NET Standard-compatible clients for use with .NET Core.</span></span> <span data-ttu-id="9da70-324">이전 클라이언트가 작동하지 않는 주된 이유 중 하나는 WCF 바인딩 및 끝점을 정의하기 위해 앱 구성에 의존하기 때문에 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-324">One of the main reasons the old clients won't work is that they depend on app configuration for defining WCF bindings and endpoints.</span></span> <span data-ttu-id="9da70-325">.NET 표준 WCF API는 플랫폼 간(System.Configuration API를 사용할 수 없는 경우)에서 작동할 수 있으므로 .NET Core 및 .NET 표준 시나리오의 WCF 클라이언트는 구성 대신 프로그래밍 방식으로 바인딩 및 끝점을 정의해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-325">Because .NET Standard WCF APIs can work cross-platform (where System.Configuration APIs aren't available), WCF clients for .NET Core and .NET Standard scenarios must define bindings and endpoints programmatically instead of in configuration.</span></span>

<span data-ttu-id="9da70-326">실제로 `<system.serviceModel>` app.config 섹션에 종속된 모든 WCF 클라이언트 사용량(Svcutil으로 만든 지 수동으로 만들든 수동으로)을 변경하여 .NET Core에서 작동하려면 변경해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-326">In fact, any WCF client usage that depends on the `<system.serviceModel>` app.config section (whether created with Svcutil or manually) will need to be changed to work on .NET Core.</span></span>

<span data-ttu-id="9da70-327">.NET 표준 호환 WCF 클라이언트를 자동으로 생성하는 방법에는 두 가지가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-327">There are two ways to automatically generate .NET Standard-compatible WCF clients:</span></span>

- <span data-ttu-id="9da70-328">이 `dotnet-svcutil` 도구는 Svcutil이 이전에 작업한 방식과 유사한 방식으로 WCF 클라이언트를 생성하는 .NET 도구입니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-328">The `dotnet-svcutil` tool is a .NET tool that generates WCF clients in a way that is similar to how Svcutil worked previously.</span></span>
- <span data-ttu-id="9da70-329">Visual Studio는 연결된 서비스 기능의 [WCF 웹 서비스 참조](../../core/additional-tools/wcf-web-service-reference-guide.md) 옵션을 사용하여 WCF 클라이언트를 생성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-329">Visual Studio can generate WCF clients using the [WCF Web Service Reference](../../core/additional-tools/wcf-web-service-reference-guide.md) option of its Connected Services feature.</span></span>

<span data-ttu-id="9da70-330">어느 쪽이든 잘 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-330">Either approach works well.</span></span> <span data-ttu-id="9da70-331">물론 WCF 클라이언트 코드를 직접 작성할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-331">Alternatively, of course, you could write the WCF client code yourself.</span></span> <span data-ttu-id="9da70-332">이 샘플에서는 Visual Studio 커넥티드 서비스 기능을 사용하기로 결정했습니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-332">For this sample, I chose to use the Visual Studio Connected Service feature.</span></span> <span data-ttu-id="9da70-333">이렇게 하려면 Visual Studio의 솔루션 탐색기에서 *BeanTraderClient.Core* 프로젝트를 마우스 오른쪽 단추로 클릭하고**연결된 서비스** **추가를** > 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-333">To do that, right-click on the *BeanTraderClient.Core* project in Visual Studio's solution explorer and select **Add** > **Connected Service**.</span></span> <span data-ttu-id="9da70-334">다음으로 WCF 웹 서비스 참조 공급자를 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-334">Next, choose the WCF Web Service Reference Provider.</span></span> <span data-ttu-id="9da70-335">이렇게 하면 백엔드 Bean Trader 웹 서비스의 주소(로컬로`localhost:8080` 서버를 실행하는 경우)와 생성된 형식이 사용해야 하는 네임스페이스(BeanTrader.Service, 예:)를 지정할 수 있는 대화 상자가 나타납니다.**BeanTrader.Service**</span><span class="sxs-lookup"><span data-stu-id="9da70-335">This will bring up a dialog where you can specify the address of the backend Bean Trader web service (`localhost:8080` if you are running the server locally) and the namespace that generated types should use (**BeanTrader.Service**, for example).</span></span>

![WCF 웹 서비스 참조 연결된 서비스 대화 상자](./media/convert-project-from-net-framework/connected-service-dialog.png)

<span data-ttu-id="9da70-337">**완료** 단추를 선택하면 프로젝트에 새 연결된 서비스 노드가 추가되고 Bean Trader 서비스에 액세스하기 위한 새 .NET 표준 WCF 클라이언트가 포함된 해당 노드 아래에 Reference.cs 파일이 추가됩니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-337">After you select the **Finish** button, a new Connected Services node is added to the project and a Reference.cs file is added under that node containing the new .NET Standard WCF client for accessing the Bean Trader service.</span></span> <span data-ttu-id="9da70-338">해당 파일의 `GetEndpointAddress` 메서드 `GetBindingForEndpoint` 또는 메서드를 보면 이제 바인딩 및 끝점이 앱 구성을 통해서가 아니라 프로그래밍 방식으로 생성되는 것을 볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-338">If you look at the `GetEndpointAddress` or `GetBindingForEndpoint` methods in that file, you'll see that bindings and endpoints are now generated programmatically (instead of via app config).</span></span> <span data-ttu-id="9da70-339">'연결된 서비스 추가' 기능은 프로젝트 파일의 일부 System.ServiceModel 패키지에 대한 참조를 추가할 수 있으며, 필요한 모든 WCF 패키지는 Microsoft.Windows.Compatibility을 통해 포함되어 있기 때문에 필요하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-339">The 'Add Connected Services' feature may also add references to some System.ServiceModel packages in the project file, which aren't needed since all necessary WCF packages are included via Microsoft.Windows.Compatibility.</span></span> <span data-ttu-id="9da70-340">csproj를 확인하여 추가 System.ServiceModel `<PackageReference>` 항목이 추가되었는지 확인하고, 그렇다면 제거합니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-340">Check the csproj to see if any extra System.ServiceModel `<PackageReference>` items have been added, and if so, remove them.</span></span>

<span data-ttu-id="9da70-341">우리의 프로젝트에는 현재 새로운 WCF 클라이언트 클래스가 있습니다 *(Reference.cs)* 이전 클래스 (BeanTrader.cs)도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-341">Our project has new WCF client classes now (in *Reference.cs*), but it also still has the old ones (in BeanTrader.cs).</span></span> <span data-ttu-id="9da70-342">이 시점에서 두 가지 옵션이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-342">There are two options at this point:</span></span>

- <span data-ttu-id="9da70-343">원래 .NET Framework 프로젝트를 빌드할 수 있도록 하려면 (새 .NET Core 대상 프로젝트와 함께) .NET Core 프로젝트의 csproj 파일에 `<Compile Remove="BeanTrader.cs" />` 항목을 사용 하 여 앱의 .NET 프레임 워크 및 .NET Core 버전 이 다른 WCF 클라이언트를 사용 하도록 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-343">If you want to be able to build the original .NET Framework project (alongside the new .NET Core-targeted one), you can use a `<Compile Remove="BeanTrader.cs" />` item in the .NET Core project's csproj file so that the .NET Framework and .NET Core versions of the app use different WCF clients.</span></span> <span data-ttu-id="9da70-344">이렇게 하면 기존 .NET Framework 프로젝트를 변경하지 않고 두는 이점이 있지만 생성된 WCF 클라이언트를 사용하는 코드가 .NET Framework 프로젝트보다 .NET Core 사례에서 약간 달라야 `#if` 할 수 있으므로 .NET Core를 위해 빌드될 때 일부 WCF 클라이언트 사용량(예: 클라이언트 만들기)을 조건부로 컴파일하기 위해 지시문을 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-344">This has the advantage of leaving the existing .NET Framework project unchanged, but has the disadvantage that code using the generated WCF clients may need to be slightly different in the .NET Core case than it was in the .NET Framework project, so you'll likely need to use `#if` directives to conditionally compile some WCF client usage (creating clients, for example) to work one way when built for .NET Core and another way when built for .NET Framework.</span></span>

- <span data-ttu-id="9da70-345">반면에 기존 .NET Framework 프로젝트의 일부 코드 변동이 허용되는 경우 *모두 BeanTrader.cs* 제거할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-345">If, on the other hand, some code churn in the existing .NET Framework project is acceptable, you can remove *BeanTrader.cs* all together.</span></span> <span data-ttu-id="9da70-346">새 WCF 클라이언트는 .NET 표준용으로 빌드되므로 .NET Core 및 .NET Framework 시나리오모두에서 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-346">Because the new WCF client is built for .NET Standard, it will work in both .NET Core and .NET Framework scenarios.</span></span> <span data-ttu-id="9da70-347">.NET Core 외에 .NET Framework를 빌드하는 경우(다중 타겟팅 또는 두 개의 csproj 파일을 사용하여) 두 대상 모두에 대해 이 새 *Reference.cs* 파일을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-347">If you are building for .NET Framework in addition to .NET Core (either by multi-targeting or by having two csproj files), you can use this new *Reference.cs* file for both targets.</span></span> <span data-ttu-id="9da70-348">이 방법은 두 개의 서로 다른 WCF 클라이언트를 지원하기 위해 코드를 분기할 필요가 없다는 장점이 있습니다. 동일한 코드가 모든 곳에서 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-348">This approach has the advantage that the code won't need to bifurcate to support two different WCF clients; the same code will be used everywhere.</span></span> <span data-ttu-id="9da70-349">단점은 (아마도 안정) .NET Framework 프로젝트를 변경해야 한다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-349">The drawback is that it involves changing the (presumably stable) .NET Framework project.</span></span>

<span data-ttu-id="9da70-350">Bean Trader 샘플의 경우 마이그레이션이 더 쉬워지면 원래 프로젝트를 작게 변경할 수 있으므로 다음 단계를 수행하여 WCF 클라이언트 사용량을 조정합니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-350">In the case of the Bean Trader sample, you can make small changes to the original project if it makes migration easier, so follow these steps to reconcile WCF client usage:</span></span>

01. <span data-ttu-id="9da70-351">솔루션 탐색기의 '기존 항목 추가' 컨텍스트 메뉴를 사용하여 .NET 프레임워크 *BeanTraderClient.csproj* 프로젝트에 새 Reference.cs 파일을 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-351">Add the new Reference.cs file to the .NET Framework *BeanTraderClient.csproj* project using the 'Add existing item' context menu from the solution explorer.</span></span> <span data-ttu-id="9da70-352">C# 파일을 복사하는 것이 아니라 두 프로젝트에서 동일한 파일을 사용할 수 있도록 '링크'를 추가해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-352">Be sure to add 'as link' so that the same file is used by both projects (as opposed to copying the C# file).</span></span> <span data-ttu-id="9da70-353">단일 csproj(다중 타겟팅 사용)를 사용하여 .NET Core 및 .NET Framework를 모두 빌드하는 경우 이 단계가 필요하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-353">If you are building for both .NET Core and .NET Framework with a single csproj (using multi-targeting) then this step isn't necessary.</span></span>

01. <span data-ttu-id="9da70-354">*BeanTrader.cs*삭제합니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-354">Delete *BeanTrader.cs*.</span></span>

01. <span data-ttu-id="9da70-355">새 WCF 클라이언트는 이전 클라이언트와 비슷하지만 생성된 코드의 여러 네임스페이스는 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-355">The new WCF client is similar to the old one, but a number of namespaces in the generated code are different.</span></span> <span data-ttu-id="9da70-356">따라서 WCF 클라이언트 형식이 BeanTrader.Model 대신 BeanTrader.Model 또는 네임스페이스 없이 BeanTrader.Service(또는 선택한 네임스페이스 이름)에서 사용되도록 프로젝트를 업데이트해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-356">Because of this, it is necessary to update the project so that WCF client types are used from BeanTrader.Service (or whatever namespace name you chose) instead of BeanTrader.Model or without a namespace.</span></span> <span data-ttu-id="9da70-357">*BeanTraderClient.Core.csproj를* 구축하면 이러한 변경이 필요한 위치를 식별하는 데 도움이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-357">Building *BeanTraderClient.Core.csproj* will help to identify where these changes need to be made.</span></span> <span data-ttu-id="9da70-358">C# 및 XAML 소스 파일모두에서 수정이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-358">Fixes will be needed both in C# and in XAML source files.</span></span>

01. <span data-ttu-id="9da70-359">마지막으로 `BeanTraderServiceClient` 형식에 사용할 수 있는 생성자가 변경되어 *BeanTraderServiceClientFactory.cs* 오류가 있음을 알 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-359">Finally, you'll discover that there is an error in *BeanTraderServiceClientFactory.cs* because the available constructors for the `BeanTraderServiceClient` type have changed.</span></span> <span data-ttu-id="9da70-360">예전에는 `InstanceContext` `CallbackHandler` `Castle.Windsor` 인수를 제공할 수 있었습니다(IoC 컨테이너에서 를 사용하여 만든).</span><span class="sxs-lookup"><span data-stu-id="9da70-360">It used to be possible to supply an `InstanceContext` argument (which was created using a `CallbackHandler` from the `Castle.Windsor` IoC container).</span></span> <span data-ttu-id="9da70-361">새 생성자는 새 `CallbackHandler`생성자 입니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-361">The new constructors create new `CallbackHandler`s.</span></span> <span data-ttu-id="9da70-362">그러나 기본 형식에는 원하는 `BeanTraderServiceClient`것과 일치하는 생성자가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-362">There are, however, constructors in `BeanTraderServiceClient`'s base type that match what you want.</span></span> <span data-ttu-id="9da70-363">자동 생성된 WCF 클라이언트 코드는 모두 부분 클래스에 존재하므로 쉽게 확장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-363">Since the autogenerated WCF client code all exists in partial classes, you can easily extend it.</span></span> <span data-ttu-id="9da70-364">이렇게 하려면 *BeanTraderServiceClient.cs라는* 새 파일을 만든 다음 BeanTrader.Service 네임스페이스를 사용하여 같은 이름의 부분 클래스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-364">To do this, create a new file called *BeanTraderServiceClient.cs* and then create a partial class with that same name (using the BeanTrader.Service namespace).</span></span> <span data-ttu-id="9da70-365">그런 다음 여기에 표시된 대로 부분 형식에 하나의 생성기를 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-365">Then, add one constructor to the partial type as shown here.</span></span>

    ```csharp
    public BeanTraderServiceClient(System.ServiceModel.InstanceContext callbackInstance) :
        base(callbackInstance, EndpointConfiguration.NetTcpBinding_BeanTraderService)
            { }
    ```

<span data-ttu-id="9da70-366">이러한 변경 사항을 통해 Bean Trader 샘플은 이제 새로운 .NET 표준 호환 WCF 클라이언트를 사용하고 `Open` *대신* 사용할 `await OpenAsync` TradingService.cs 통화를 변경하는 최종 수정을 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-366">With those changes made, the Bean Trader sample will now be using a new .NET Standard-compatible WCF client and you can make the final fix of changing the `Open` call in *TradingService.cs* to use `await OpenAsync` instead.</span></span>

<span data-ttu-id="9da70-367">WCF 문제가 해결되면 빈 트레이더 샘플의 .NET 코어 버전이 깔끔하게 구축됩니다!</span><span class="sxs-lookup"><span data-stu-id="9da70-367">With the WCF issues addressed, the .NET Core version of the Bean Trader sample now builds cleanly!</span></span>

## <a name="runtime-testing"></a><span data-ttu-id="9da70-368">런타임 테스트</span><span class="sxs-lookup"><span data-stu-id="9da70-368">Runtime testing</span></span>

<span data-ttu-id="9da70-369">프로젝트가 .NET Core에 대해 깔끔하게 빌드되는 즉시 마이그레이션 작업이 수행되지 않는다는 사실을 잊기 쉽습니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-369">It's easy to forget that migration work isn't done as soon as the project builds cleanly against .NET Core.</span></span> <span data-ttu-id="9da70-370">이식된 앱을 테스트할 시간도 두는 것이 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-370">It's important to leave time for testing the ported app, too.</span></span> <span data-ttu-id="9da70-371">빌드가 성공적으로 완료되면 특히 .NET Framework를 대상으로 하는 패키지를 사용하는 경우 앱이 예상대로 실행되고 작동하는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-371">Once things build successfully, make sure the app runs and works as expected, especially if you are using any packages targeting .NET Framework.</span></span>

<span data-ttu-id="9da70-372">의 포팅 콩 상인 응용 프로그램을 시작하고 무슨 일이 일어나는지 보자.</span><span class="sxs-lookup"><span data-stu-id="9da70-372">Let's try launching the ported Bean Trader app and see what happens.</span></span> <span data-ttu-id="9da70-373">응용 프로그램은 다음과 같은 예외로 실패하기 전에 멀리 얻을하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-373">The app doesn't get far before failing with the following exception.</span></span>

```output
System.Configuration.ConfigurationErrorsException: 'Configuration system failed to initialize'

Inner Exception
ConfigurationErrorsException: Unrecognized configuration section system.serviceModel.
```

<span data-ttu-id="9da70-374">물론 이것은 의미가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-374">This makes sense, of course.</span></span> <span data-ttu-id="9da70-375">WCF는 더 이상 앱 구성을 사용하지 않으므로 app.config 파일의 이전 system.serviceModel 섹션을 제거해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-375">Remember that WCF no longer uses app configuration, so the old system.serviceModel section of the app.config file needs to be removed.</span></span> <span data-ttu-id="9da70-376">업데이트된 WCF 클라이언트에는 코드에 동일한 정보가 모두 포함되어 있으므로 구성 섹션이 더 이상 필요하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-376">The updated WCF client includes all of the same information in its code, so the config section isn't needed anymore.</span></span> <span data-ttu-id="9da70-377">app.config에서 WCF 끝점을 구성할 수 있도록 하려면 앱 설정으로 추가하고 WCF 클라이언트 코드를 업데이트하여 구성에서 WCF 서비스 끝점을 검색할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-377">If you wanted the WCF endpoint to be configurable in app.config, you could add it as an app setting and update the WCF client code to retrieve the WCF service endpoint from configuration.</span></span>

<span data-ttu-id="9da70-378">*app.config의*system.serviceModel 섹션을 제거한 후 앱이 시작되지만 사용자가 로그인할 때 다른 예외를 제외하고 실패합니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-378">After removing the system.serviceModel section of *app.config*, the app launches but fails with another exception when a user signs in.</span></span>

```output
System.PlatformNotSupportedException: 'Operation is not supported on this platform.'
```

<span data-ttu-id="9da70-379">지원되지 않는 `Func<T>.BeginInvoke`API는 .</span><span class="sxs-lookup"><span data-stu-id="9da70-379">The unsupported API is `Func<T>.BeginInvoke`.</span></span> <span data-ttu-id="9da70-380">[dotnet/corefx#5940에서](https://github.com/dotnet/corefx/issues/5940)설명한 대로 .NET Core는 `BeginInvoke` `EndInvoke` 기본 원격 종속성으로 인해 대리자 형식에 대한 메서드와 메서드를 지원하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-380">As explained in [dotnet/corefx#5940](https://github.com/dotnet/corefx/issues/5940), .NET Core doesn't support the `BeginInvoke` and `EndInvoke` methods on delegate types due to underlying remoting dependencies.</span></span> <span data-ttu-id="9da70-381">이 문제와 수정 사항은 [마이그레이션 Delegate.BeginInvoke .NET Core](https://devblogs.microsoft.com/dotnet/migrating-delegate-begininvoke-calls-for-net-core/) 블로그 게시물에 대한 호출에 대해 자세히 `BeginInvoke` `EndInvoke` 설명하지만 요점은 `Task.Run` 호출을 대체해야 한다는 것입니다(또는 가능한 경우 비동기 대안).</span><span class="sxs-lookup"><span data-stu-id="9da70-381">This issue and its fix are explained in more detail in the [Migrating Delegate.BeginInvoke Calls for .NET Core](https://devblogs.microsoft.com/dotnet/migrating-delegate-begininvoke-calls-for-net-core/) blog post, but the gist is that `BeginInvoke` and `EndInvoke` calls should be replaced with `Task.Run` (or async alternatives, if possible).</span></span> <span data-ttu-id="9da70-382">여기에 일반적인 솔루션을 적용하면 `BeginInvoke` 호출을 `Task.Run`에서 `Invoke` 시작된 호출로 대체할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-382">Applying the general solution here, the `BeginInvoke` call can be replaced with an `Invoke` call launched by `Task.Run`.</span></span>

```csharp
Task.Run(() =>
{
    return userInfoRetriever.Invoke();
}).ContinueWith(result =>
{
    // BeginInvoke's callback is replaced with ContinueWith
    var task = result.ConfigureAwait(false);
    CurrentTrader = task.GetAwaiter().GetResult();
}, TaskScheduler.Default);
```

<span data-ttu-id="9da70-383">사용량을 `BeginInvoke` 제거한 후 .NET Core에서 Bean Trader 앱이 성공적으로 실행됩니다!</span><span class="sxs-lookup"><span data-stu-id="9da70-383">After removing the `BeginInvoke` usage, the Bean Trader app runs successfully on .NET Core!</span></span>

![.NET 코어에서 실행되는 빈 트레이더](./media/convert-project-from-net-framework/running-on-core.png)

<span data-ttu-id="9da70-385">모든 앱은 서로 다르므로 사용자 고유의 앱을 .NET Core로 마이그레이션하는 데 필요한 특정 단계는 다양합니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-385">All apps are different, so the specific steps needed to migrate your own apps to .NET Core will vary.</span></span> <span data-ttu-id="9da70-386">그러나 바라건대 콩 상인 샘플은 일반적인 워크 플로우와 예상 할 수있는 문제의 유형을 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-386">But hopefully the Bean Trader sample demonstrates the general workflow and the types of issues that can be expected.</span></span> <span data-ttu-id="9da70-387">또한 이 문서의 길이에도 불구하고 .NET Core에서 작동하도록 하기 위해 Bean Trader 샘플에 필요한 실제 변경 사항은 상당히 제한적이었습니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-387">And, despite this article's length, the actual changes needed in the Bean Trader sample to make it work on .NET Core were fairly limited.</span></span> <span data-ttu-id="9da70-388">많은 앱이 이와 같은 방식으로 .NET Core로 마이그레이션됩니다. 코드 변경이 필요 없거나 제한되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9da70-388">Many apps migrate to .NET Core in this same way; with limited or even no code changes needed.</span></span>

---
title: ".NET Core로 이식 - 라이브러리"
description: ".NET Framework에서 .NET Core로 라이브러리 프로젝트를 이식하는 방법에 관해 알아봅니다."
keywords: .NET, .NET Core
author: cartermp
ms.author: mairaw
ms.date: 07/14/2017
ms.topic: article
ms.prod: .net-core
ms.devlang: dotnet
ms.assetid: a0fd860d-d6b6-4659-b325-8a6e6f5fa4a1
ms.workload:
- dotnetcore
ms.openlocfilehash: 24c74f0396dd7bfdf19fc0e11a29110fdbf27173
ms.sourcegitcommit: cf22b29db780e532e1090c6e755aa52d28273fa6
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 02/01/2018
---
# <a name="porting-to-net-core---libraries"></a><span data-ttu-id="41687-104">.NET Core로 이식 - 라이브러리</span><span class="sxs-lookup"><span data-stu-id="41687-104">Porting to .NET Core - Libraries</span></span>

<span data-ttu-id="41687-105">이 문서에서는 플랫폼 간에 실행되도록 .NET Core에 라이브러리 코드를 이식하는 방법에 관해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="41687-105">This article discusses porting library code to .NET Core so that it runs cross-platform.</span></span>

## <a name="prerequisites"></a><span data-ttu-id="41687-106">필수 구성 요소</span><span class="sxs-lookup"><span data-stu-id="41687-106">Prerequisites</span></span>

<span data-ttu-id="41687-107">이 문서에서는 다음을 전제로 합니다.</span><span class="sxs-lookup"><span data-stu-id="41687-107">This article assumes that you:</span></span>

- <span data-ttu-id="41687-108">사용자가 Visual Studio 2017 이상을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="41687-108">Are using Visual Studio 2017 or later.</span></span>
  - <span data-ttu-id="41687-109">.NET Core는 이전 버전의 Visual Studio에서 지원되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="41687-109">.NET Core isn't supported on earlier versions of Visual Studio</span></span>
- <span data-ttu-id="41687-110">사용자가 [권장 이식 프로세스](index.md)를 이해합니다.</span><span class="sxs-lookup"><span data-stu-id="41687-110">Understand the [recommended porting process](index.md).</span></span>
- <span data-ttu-id="41687-111">사용자가 [타사 종속성](third-party-deps.md)과 관련된 문제를 모두 해결했습니다.</span><span class="sxs-lookup"><span data-stu-id="41687-111">Have resolved any issues with [third-party dependencies](third-party-deps.md).</span></span>

<span data-ttu-id="41687-112">또한 다음 항목의 내용을 숙지해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="41687-112">You should also become familiar with the content of the following topics:</span></span>

<span data-ttu-id="41687-113">[.NET 표준](~/docs/standard/net-standard.md) </span><span class="sxs-lookup"><span data-stu-id="41687-113">[.NET Standard](~/docs/standard/net-standard.md) </span></span>  
<span data-ttu-id="41687-114">이 항목에서는 모든 .NET 구현에서 사용할 수 있는 .NET API의 공식 사양에 관해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="41687-114">This topic describes the formal specification of .NET APIs that are intended to be available on all .NET implementations.</span></span>

<span data-ttu-id="41687-115">[패키지, 메타패키지 및 프레임워크](~/docs/core/packages.md) </span><span class="sxs-lookup"><span data-stu-id="41687-115">[Packages, Metapackages and Frameworks](~/docs/core/packages.md) </span></span>  
<span data-ttu-id="41687-116">이 문서에서는 .NET Core가 패키지를 정의하고 사용하는 방법과 패키지가 여러 .NET 구현에서 실행되는 코드를 지원하는 방법에 관해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="41687-116">This article discusses how .NET Core defines and uses packages and how packages support code running on multiple .NET implementations.</span></span>

<span data-ttu-id="41687-117">[플랫폼 간 도구로 라이브러리 개발](~/docs/core/tutorials/libraries.md) </span><span class="sxs-lookup"><span data-stu-id="41687-117">[Developing Libraries with Cross Platform Tools](~/docs/core/tutorials/libraries.md) </span></span>  
<span data-ttu-id="41687-118">이 항목에서는 플랫폼 간 CLI 도구를 사용하여 .NET용 라이브러리를 작성하는 방법에 관해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="41687-118">This topic explains how to write libraries for .NET using cross-platform CLI tools.</span></span>

<span data-ttu-id="41687-119">[.NET Core용 *csproj* 형식에 대한 추가 사항](~/docs/core/tools/csproj.md) </span><span class="sxs-lookup"><span data-stu-id="41687-119">[Additions to the *csproj* format for .NET Core](~/docs/core/tools/csproj.md) </span></span>  
<span data-ttu-id="41687-120">이 문서에서는 *csproj* 및 MSBuild로 프로젝트 시스템을 전환함에 따라 프로젝트 파일에 추가된 변경 내용을 간략하게 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="41687-120">This article outlines the changes that were added to the project file as part of the move to *csproj* and MSBuild.</span></span>

<span data-ttu-id="41687-121">[.NET Core로 이식 - 타사 종속성 분석](~/docs/core/porting/third-party-deps.md) </span><span class="sxs-lookup"><span data-stu-id="41687-121">[Porting to .NET Core - Analyzing your Third-Party Party Dependencies](~/docs/core/porting/third-party-deps.md) </span></span>  
<span data-ttu-id="41687-122">이 항목에서는 타사 종속성의 이식성 및 .NET Core에서 NuGet 패키지 종속성이 실행되지 않는 경우 해야 할 작업에 관해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="41687-122">This topic discusses the portability of third-party dependencies and what to do when a NuGet package dependency doesn't run on .NET Core.</span></span>

## <a name="net-framework-technologies-unavailable-on-net-core"></a><span data-ttu-id="41687-123">.NET Core에서 사용할 수 없는 .NET Framework 기술</span><span class="sxs-lookup"><span data-stu-id="41687-123">.NET Framework technologies unavailable on .NET Core</span></span>

<span data-ttu-id="41687-124">.NET Framework 라이브러리에서 사용할 수 있는 AppDomain, 원격 통신, CAS(코드 액세스 보안), 보안 투명도와 같은 몇몇 기술은 .NET Core에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="41687-124">Several technologies available to .NET Framework libraries aren't available for use with .NET Core, such as AppDomains, Remoting, Code Access Security (CAS), and Security Transparency.</span></span> <span data-ttu-id="41687-125">라이브러리가 이러한 기술 중 하나 이상에 의존하는 경우 아래에 설명된 대체 방법을 고려하세요.</span><span class="sxs-lookup"><span data-stu-id="41687-125">If your libraries rely on one or more of these technologies, consider the alternative approaches outlined below.</span></span> <span data-ttu-id="41687-126">API 호환성에 대한 자세한 정보를 위해 CoreFX 팀이 GitHub에서 [행동 변경/호환 중단 및 사용 중단/레거시 API 목록](https://github.com/dotnet/corefx/wiki/ApiCompat)을 유지 관리합니다.</span><span class="sxs-lookup"><span data-stu-id="41687-126">For more information on API compatibility, the CoreFX team maintains a [List of behavioral changes/compat breaks and deprecated/legacy APIs](https://github.com/dotnet/corefx/wiki/ApiCompat) at GitHub.</span></span>

<span data-ttu-id="41687-127">API 또는 기술이 현재 구현되지 않았기 때문에 이들을 고의로 지원하지 않는 것은 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="41687-127">Just because an API or technology isn't currently implemented doesn't imply it's intentionally unsupported.</span></span> <span data-ttu-id="41687-128">특정 API 및 기술을 요청하려면 GitHub의 [dotnet/corefx 리포지토리 문제](https://github.com/dotnet/corefx/issues)에서 문제를 제기하세요.</span><span class="sxs-lookup"><span data-stu-id="41687-128">File an issue in the [dotnet/corefx repository issues](https://github.com/dotnet/corefx/issues) at GitHub to ask for specific APIs and technologies.</span></span> <span data-ttu-id="41687-129">[문제의 이식 요청](https://github.com/dotnet/corefx/labels/port-to-core)은 `port-to-core` 레이블로 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="41687-129">[Porting requests in the issues](https://github.com/dotnet/corefx/labels/port-to-core) are marked with the `port-to-core` label.</span></span>

### <a name="appdomains"></a><span data-ttu-id="41687-130">AppDomain</span><span class="sxs-lookup"><span data-stu-id="41687-130">AppDomains</span></span>

<span data-ttu-id="41687-131">AppDomain은 앱을 서로 분리합니다.</span><span class="sxs-lookup"><span data-stu-id="41687-131">AppDomains isolate apps from one another.</span></span> <span data-ttu-id="41687-132">AppDomain에는 런타임 지원이 필요하고, 일반적으로 상당히 비싸므로</span><span class="sxs-lookup"><span data-stu-id="41687-132">AppDomains require runtime support and are generally quite expensive.</span></span> <span data-ttu-id="41687-133">.NET Core에서 구현되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="41687-133">They're not implemented in .NET Core.</span></span> <span data-ttu-id="41687-134">앞으로 이 기능을 추가할 계획이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="41687-134">We don't plan on adding this capability in future.</span></span> <span data-ttu-id="41687-135">코드 격리의 경우 별도의 프로세스 또는 컨테이너를 대신 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="41687-135">For code isolation, we recommend separate processes or using containers as an alternative.</span></span> <span data-ttu-id="41687-136">어셈블리를 동적으로 로드하기 위해 새 <xref:System.Runtime.Loader.AssemblyLoadContext> 클래스를 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="41687-136">For the dynamic loading of assemblies, we recommend the new <xref:System.Runtime.Loader.AssemblyLoadContext> class.</span></span>

<span data-ttu-id="41687-137">.NET Framework에서 코드를 쉽게 마이그레이션할 수 있도록 .NET Core에서 <xref:System.AppDomain> API 표면의 일부를 공개했습니다.</span><span class="sxs-lookup"><span data-stu-id="41687-137">To make code migration from .NET Framework easier, we've exposed some of the <xref:System.AppDomain> API surface in .NET Core.</span></span> <span data-ttu-id="41687-138">API 중 일부는 정상적으로 작동하고(예: <xref:System.AppDomain.UnhandledException?displayProperty=nameWithType>), 일부 멤버는 아무것도 하지 않고(예: <xref:System.AppDomain.SetCachePath%2A>), 일부는 <xref:System.PlatformNotSupportedException>을 throw합니다(예: <xref:System.AppDomain.CreateDomain%2A>).</span><span class="sxs-lookup"><span data-stu-id="41687-138">Some of the API functions normally (for example, <xref:System.AppDomain.UnhandledException?displayProperty=nameWithType>), some members do nothing (for example, <xref:System.AppDomain.SetCachePath%2A>), and some of them throw <xref:System.PlatformNotSupportedException> (for example, <xref:System.AppDomain.CreateDomain%2A>).</span></span> <span data-ttu-id="41687-139">[dotnet/corefx GitHub 리포지토리](https://github.com/dotnet/corefx)의 [`System.AppDomain` 참조 소스](https://github.com/dotnet/corefx/blob/master/src/System.Runtime.Extensions/src/System/AppDomain.cs)에 대해 사용하는 형식을 확인하여 구현된 버전과 일치하는 분기를 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="41687-139">Check the types you use against the [`System.AppDomain` reference source](https://github.com/dotnet/corefx/blob/master/src/System.Runtime.Extensions/src/System/AppDomain.cs) in the [dotnet/corefx GitHub repository](https://github.com/dotnet/corefx) making sure to select the branch that matches your implemented version.</span></span>

### <a name="remoting"></a><span data-ttu-id="41687-140">원격 통신</span><span class="sxs-lookup"><span data-stu-id="41687-140">Remoting</span></span>

<span data-ttu-id="41687-141">.NET Remoting은 문제가 있는 아키텍처로 확인되었으며</span><span class="sxs-lookup"><span data-stu-id="41687-141">.NET Remoting was identified as a problematic architecture.</span></span> <span data-ttu-id="41687-142">더 이상 지원되지 않는 AppDomain 간 통신에 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="41687-142">It's used for cross-AppDomain communication, which is no longer supported.</span></span> <span data-ttu-id="41687-143">또한 원격 통신에는 유지 관리 비용이 많이 드는 런타임 지원이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="41687-143">Also, Remoting requires runtime support, which is expensive to maintain.</span></span> <span data-ttu-id="41687-144">이러한 이유로 .NET Remoting은 .NET Core에서 지원되지 않으며 향후 지원을 추가할 계획이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="41687-144">For these reasons, .NET Remoting isn't supported on .NET Core, and we don't plan on adding support for it in the future.</span></span>

<span data-ttu-id="41687-145">프로세스 간 통신을 위해 <xref:System.IO.Pipes> 또는 <xref:System.IO.MemoryMappedFiles.MemoryMappedFile> 클래스 같은 IPC(Inter-process communication) 메커니즘을 원격 통신 대신 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="41687-145">For communication across processes, consider inter-process communication (IPC) mechanisms as an alternative to Remoting, such as the <xref:System.IO.Pipes> or the <xref:System.IO.MemoryMappedFiles.MemoryMappedFile> class.</span></span>

<span data-ttu-id="41687-146">여러 컴퓨터에서 네트워크 기반 솔루션을 대신 사용하세요.</span><span class="sxs-lookup"><span data-stu-id="41687-146">Across machines, use a network-based solution as an alternative.</span></span> <span data-ttu-id="41687-147">HTTP와 같이 오버헤드가 낮은 일반 텍스트 프로토콜을 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="41687-147">Preferably, use a low-overhead plain text protocol, such as HTTP.</span></span> <span data-ttu-id="41687-148">ASP.NET Core에서 사용하는 웹 서버인 [Kestrel 웹 서버](https://docs.microsoft.com/aspnet/core/fundamentals/servers/kestrel)도 옵션이 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="41687-148">The [Kestrel web server](https://docs.microsoft.com/aspnet/core/fundamentals/servers/kestrel), the web server used by ASP.NET Core, is an option here.</span></span> <span data-ttu-id="41687-149">또한 네트워크 기반, 컴퓨터 간 시나리오에서 <xref:System.Net.Sockets>의 사용을 고려하세요.</span><span class="sxs-lookup"><span data-stu-id="41687-149">Also consider using <xref:System.Net.Sockets> for network-based, cross-machine scenarios.</span></span> <span data-ttu-id="41687-150">추가 옵션은 [.NET 오픈 소스 개발자 프로젝트: 메시징](https://github.com/Microsoft/dotnet/blob/master/dotnet-developer-projects.md#messaging)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="41687-150">For more options, see [.NET Open Source Developer Projects: Messaging](https://github.com/Microsoft/dotnet/blob/master/dotnet-developer-projects.md#messaging).</span></span>

### <a name="code-access-security-cas"></a><span data-ttu-id="41687-151">CAS(코드 액세스 보안)</span><span class="sxs-lookup"><span data-stu-id="41687-151">Code Access Security (CAS)</span></span>

<span data-ttu-id="41687-152">관리되는 응용 프로그램 또는 라이브러리에서 사용하거나 실행하는 리소스를 제한하기 위해 런타임 또는 프레임워크에 의존하는 샌드박싱은 [.NET Framework에서 지원되지 않으므로](~/docs/framework/misc/code-access-security.md) .NET Core에서도 지원되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="41687-152">Sandboxing, which is relying on the runtime or the framework to constrain which resources a managed application or library uses or runs, [isn't supported on .NET Framework](~/docs/framework/misc/code-access-security.md) and therefore is also not supported on .NET Core.</span></span> <span data-ttu-id="41687-153">CAS를 보안 경계로 계속 처리하기 위해 권한 상승이 발생하는 .NET Framework 및 런타임에는 사례가 너무 많이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="41687-153">We believe that there are too many cases in the .NET Framework and runtime where an elevation of privileges occurs to continue treating CAS as a security boundary.</span></span> <span data-ttu-id="41687-154">또한 CAS는 구현을 더욱 복잡하게 만들고 이를 사용하지 않을 응용 프로그램의 정확성-성능에 종종 영향을 미칩니다.</span><span class="sxs-lookup"><span data-stu-id="41687-154">In addition, CAS makes the implementation more complicated and often has correctness-performance implications for applications that don't intend to use it.</span></span>

<span data-ttu-id="41687-155">최소한의 권한으로 프로세스를 실행하려면 가상화, 컨테이너 또는 사용자 계정과 같은 운영 체제에서 제공하는 보안 경계를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="41687-155">Use security boundaries provided by the operating system, such as virtualization, containers, or user accounts for running processes with the least set of privileges.</span></span>

### <a name="security-transparency"></a><span data-ttu-id="41687-156">보안 투명도</span><span class="sxs-lookup"><span data-stu-id="41687-156">Security Transparency</span></span>

<span data-ttu-id="41687-157">CAS와 마찬가지로 보안 투명도는 샌드박스 코드를 보안상 중요한 코드와 선언적인 방식으로 분리할 수 있지만 [더 이상 보안 경계로서 지원되지는 않습니다](~/docs/framework/misc/security-transparent-code.md).</span><span class="sxs-lookup"><span data-stu-id="41687-157">Similar to CAS, Security Transparency allows separating sandboxed code from security critical code in a declarative fashion but is [no longer supported as a security boundary](~/docs/framework/misc/security-transparent-code.md).</span></span> <span data-ttu-id="41687-158">이 기능은 Silverlight에서 많이 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="41687-158">This feature is heavily used by Silverlight.</span></span> 

<span data-ttu-id="41687-159">최소한의 권한으로 프로세스를 실행하려면 가상화, 컨테이너 또는 사용자 계정과 같은 운영 체제에서 제공하는 보안 경계를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="41687-159">Use security boundaries provided by the operating system, such as virtualization, containers, or user accounts for running processes with the least set of privileges.</span></span>

### <a name="globaljson"></a><span data-ttu-id="41687-160">global.json</span><span class="sxs-lookup"><span data-stu-id="41687-160">global.json</span></span>

<span data-ttu-id="41687-161">*global.json* 파일은 .NET Core 도구 버전의 프로젝트를 설정할 수 있는 선택적 파일입니다.</span><span class="sxs-lookup"><span data-stu-id="41687-161">The *global.json* file is an optional file that allows you to set the .NET Core tools version of a project.</span></span> <span data-ttu-id="41687-162">.NET Core의 야간 빌드를 사용 중이고 특정 버전의 SDK를 지정하려면 *global.json* 파일로 버전을 지정하세요.</span><span class="sxs-lookup"><span data-stu-id="41687-162">If you're using nightly builds of .NET Core and wish to specify a specific version of the SDK, specify the version with a *global.json* file.</span></span> <span data-ttu-id="41687-163">이 파일은 일반적으로 현재 작업 디렉터리 또는 부모 디렉터리 중 하나에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="41687-163">It typically resides in the current working directory or one of its parent directories.</span></span> 

```json
{
  "sdk": {
    "version": "2.1.0-preview1-006491"
  }
}
```

## <a name="converting-a-pcl-project"></a><span data-ttu-id="41687-164">PCL 프로젝트 변환</span><span class="sxs-lookup"><span data-stu-id="41687-164">Converting a PCL project</span></span>

<span data-ttu-id="41687-165">Visual Studio 2017에서 라이브러리를 로드하고 다음 단계를 수행하여 PCL 프로젝트의 대상을 .NET 표준으로 변환할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="41687-165">You can convert the targets of a PCL project to .NET Standard by loading the library in Visual Studio 2017 and performing the following steps:</span></span>

1. <span data-ttu-id="41687-166">프로젝트 파일을 마우스 오른쪽 단추로 클릭하고 **속성**을 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="41687-166">Right-click on the project file and select **Properties**.</span></span>
1. <span data-ttu-id="41687-167">**라이브러리** 아래에서 **.NET 플랫폼 표준을 대상으로 지정**을 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="41687-167">Under **Library**, select **Target .NET Platform Standard**.</span></span>

<span data-ttu-id="41687-168">패키지가 NuGet 3.0을 지원하면 프로젝트의 대상이 .NET 표준으로 다시 지정됩니다.</span><span class="sxs-lookup"><span data-stu-id="41687-168">If your packages support NuGet 3.0, the project retargets to .NET Standard.</span></span>

<span data-ttu-id="41687-169">패키지가 NuGet 3.0을 지원하지 않으면 Visual Studio에서 현재 패키지를 제거하라는 대화 상자가 나타납니다.</span><span class="sxs-lookup"><span data-stu-id="41687-169">If your packages don't support NuGet 3.0, you receive a dialog from Visual Studio telling you to uninstall your current packages.</span></span> <span data-ttu-id="41687-170">이 알림을 받으면 다음 단계를 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="41687-170">If you receive this notice, perform the following steps:</span></span>

1. <span data-ttu-id="41687-171">프로젝트를 마우스 오른쪽 단추로 클릭하고 **NuGet 패키지 관리**를 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="41687-171">Right-click the project, select **Manage NuGet Packages**.</span></span>
1. <span data-ttu-id="41687-172">프로젝트의 패키지를 기록해 둡니다.</span><span class="sxs-lookup"><span data-stu-id="41687-172">Make a note of the project's packages.</span></span>
1. <span data-ttu-id="41687-173">하나씩 패키지를 제거합니다.</span><span class="sxs-lookup"><span data-stu-id="41687-173">Uninstall the packages one-by-one.</span></span>
1. <span data-ttu-id="41687-174">제거 프로세스를 완료하려면 Visual Studio를 다시 시작해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="41687-174">You might need to restart Visual Studio to complete the uninstall process.</span></span> <span data-ttu-id="41687-175">이 경우 **NuGet 패키지 관리자** 창에 **다시 시작** 단추가 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="41687-175">If so, a **Restart** button is presented to you in the **NuGet Package Manager** window.</span></span>
1. <span data-ttu-id="41687-176">프로젝트를 다시 로드하면 .NET 표준이 대상이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="41687-176">When the project reloads, it targets .NET Standard.</span></span> <span data-ttu-id="41687-177">제거해야 하는 패키지를 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="41687-177">Add the packages you were required to uninstall.</span></span>

## <a name="retargeting-your-net-framework-code-to-net-framework-462"></a><span data-ttu-id="41687-178">.NET Framework 4.6.2로 .NET Framework 코드 대상 다시 지정</span><span class="sxs-lookup"><span data-stu-id="41687-178">Retargeting your .NET Framework code to .NET Framework 4.6.2</span></span>

<span data-ttu-id="41687-179">코드가 .NET Framework 4.6.2를 대상으로 하지 않는 경우 .NET Framework 4.6.2로 대상을 다시 지정하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="41687-179">If your code isn't targeting .NET Framework 4.6.2, we recommended that you retarget to .NET Framework 4.6.2.</span></span> <span data-ttu-id="41687-180">그러면 .NET 표준에서 기존 API를 지원할 수 없는 경우 최신 API를 대신 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="41687-180">This ensures the availability of the latest API alternatives for cases where the .NET Standard doesn't support existing APIs.</span></span>

<span data-ttu-id="41687-181">Visual Studio에서 이식하려는 각 프로젝트에 대해 다음을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="41687-181">For each of your projects in Visual Studio you wish to port, do the following:</span></span>

1. <span data-ttu-id="41687-182">프로젝트를 마우스 오른쪽 단추로 클릭하고 속성을 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="41687-182">Right-click on the project and select Properties.</span></span>
1. <span data-ttu-id="41687-183">**대상 프레임워크** 드롭다운에서 **.NET Framework 4.6.2**를 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="41687-183">In the **Target Framework** dropdown, select **.NET Framework 4.6.2**.</span></span>
1. <span data-ttu-id="41687-184">프로젝트를 다시 컴파일합니다.</span><span class="sxs-lookup"><span data-stu-id="41687-184">Recompile your projects.</span></span>

<span data-ttu-id="41687-185">프로젝트가 .NET Framework 4.6.2를 대상으로 하기 때문에 해당 버전의 .NET Framework를 코드 이식의 기반으로 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="41687-185">Because your projects now target .NET Framework 4.6.2, use that version of the .NET Framework as your base for porting code.</span></span>

## <a name="determining-the-portability-of-your-code"></a><span data-ttu-id="41687-186">코드의 이식성 확인</span><span class="sxs-lookup"><span data-stu-id="41687-186">Determining the portability of your code</span></span>

<span data-ttu-id="41687-187">다음 단계에서는 API Portability Analyzer(ApiPort)를 실행하여 분석을 위한 이식성 보고서를 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="41687-187">The next step is to run the API Portability Analyzer (ApiPort) to generate a portability report for analysis.</span></span>

<span data-ttu-id="41687-188">[API 이식성 도구(ApiPort)](../../standard/analyzers/portability-analyzer.md)를 이해하고 .NET Core를 대상으로 하는 이식성 보고서를 생성할 수 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="41687-188">Make sure you understand the [API Portability Analyzer (ApiPort)](../../standard/analyzers/portability-analyzer.md) and how to generate portability reports for targeting .NET Core.</span></span> <span data-ttu-id="41687-189">이 작업을 수행하는 방법은 요구 사항 및 개인적 취향에 따라 달라질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="41687-189">How you do this likely varies based on your needs and personal tastes.</span></span> <span data-ttu-id="41687-190">다음은 몇 가지 서로 다른 접근 방식입니다.</span><span class="sxs-lookup"><span data-stu-id="41687-190">What follows are a few different approaches.</span></span> <span data-ttu-id="41687-191">코드가 어떻게 구성되어 있는가에 따라 이러한 접근 방식의 단계를 혼합하여 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="41687-191">You may find yourself mixing steps of these approaches depending on how your code is structured.</span></span>

### <a name="dealing-primarily-with-the-compiler"></a><span data-ttu-id="41687-192">주로 컴파일러 처리</span><span class="sxs-lookup"><span data-stu-id="41687-192">Dealing primarily with the compiler</span></span>

<span data-ttu-id="41687-193">이 접근 방식은 작은 프로젝트 또는 많은 .NET Framework API를 사용하지 않는 프로젝트에 가장 적합할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="41687-193">This approach may be the best for small projects or projects which don't use many .NET Framework APIs.</span></span> <span data-ttu-id="41687-194">접근 방식은 간단합니다.</span><span class="sxs-lookup"><span data-stu-id="41687-194">The approach is simple:</span></span>

1. <span data-ttu-id="41687-195">필요에 따라 프로젝트에서 ApiPort를 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="41687-195">Optionally, run ApiPort on your project.</span></span> <span data-ttu-id="41687-196">ApiPort를 실행하는 경우 해결해야 할 문제에 대한 보고서에서 정보를 가져오세요.</span><span class="sxs-lookup"><span data-stu-id="41687-196">If you run ApiPort, gain knowledge from the report on issues you'll need to address.</span></span>
1. <span data-ttu-id="41687-197">모든 코드를 새 .NET Core 프로젝트에 복사합니다.</span><span class="sxs-lookup"><span data-stu-id="41687-197">Copy all of your code over into a new .NET Core project.</span></span>
1. <span data-ttu-id="41687-198">이식성 보고서(생성된 경우)를 참조하면서 프로젝트가 완전히 컴파일될 때까지 컴파일러 오류를 해결합니다.</span><span class="sxs-lookup"><span data-stu-id="41687-198">While referring to the portability report (if generated), solve compiler errors until the project fully compiles.</span></span>

<span data-ttu-id="41687-199">이 접근 방식은 구조적이지는 않지만 코드 중심 접근 방식을 사용하면 종종 문제를 신속하게 해결할 수 있으므로 더 작은 프로젝트나 라이브러리에 가장 적합한 방법이 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="41687-199">Although this approach is unstructured, the code-focused approach often leads to resolving issues quickly and might be the best approach for smaller projects or libraries.</span></span> <span data-ttu-id="41687-200">데이터 모델만 포함하는 프로젝트가 이 접근 방식에 적합한 후보가 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="41687-200">A project that contains only data models might be an ideal candidate for this approach.</span></span>

### <a name="staying-on-the-net-framework-until-portability-issues-are-resolved"></a><span data-ttu-id="41687-201">이식성 문제가 해결될 때까지 .NET Framework 유지</span><span class="sxs-lookup"><span data-stu-id="41687-201">Staying on the .NET Framework until portability issues are resolved</span></span>

<span data-ttu-id="41687-202">이 접근 방식은 전체 프로세스 중에 컴파일되는 코드를 선호하는 경우 적합할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="41687-202">This approach might be the best if you prefer to have code that compiles during the entire process.</span></span> <span data-ttu-id="41687-203">이 접근 방식은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="41687-203">The approach is as follows:</span></span>

1. <span data-ttu-id="41687-204">프로젝트에서 ApiPort를 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="41687-204">Run ApiPort on a project.</span></span>
1. <span data-ttu-id="41687-205">이식 가능한 다른 API를 사용하여 문제를 해결합니다.</span><span class="sxs-lookup"><span data-stu-id="41687-205">Address issues by using different APIs that are portable.</span></span>
1. <span data-ttu-id="41687-206">직접적인 대안을 사용할 수 없는 영역을 기록해 둡니다.</span><span class="sxs-lookup"><span data-stu-id="41687-206">Take note of any areas where you're prevented from using a direct alternative.</span></span>
1. <span data-ttu-id="41687-207">각 프로젝트를 새 .NET Core 프로젝트에 복사할 준비가 되었다고 확신할 때까지 이식하려는 모든 프로젝트에 대해 이전 단계를 반복합니다.</span><span class="sxs-lookup"><span data-stu-id="41687-207">Repeat the prior steps for all projects you're porting until you're confident each is ready to be copied over into a new .NET Core project.</span></span>
1. <span data-ttu-id="41687-208">새 .NET Core 프로젝트에 코드를 복사합니다.</span><span class="sxs-lookup"><span data-stu-id="41687-208">Copy the code into a new .NET Core project.</span></span>
1. <span data-ttu-id="41687-209">직접적인 대안이 없는 것으로 기록해 둔 문제를 해결합니다.</span><span class="sxs-lookup"><span data-stu-id="41687-209">Work out any issues where you noted that a direct alternative doesn't exist.</span></span>

<span data-ttu-id="41687-210">이 신중한 접근 방식은 단순히 컴파일러 오류를 해결하는 것보다는 구조적이지만 비교적 코드 중심적이며 컴파일되는 코드가 항상 있다는 장점이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="41687-210">This careful approach is more structured than simply working out compiler errors, but it's still relatively code-focused and has the benefit of always having code that compiles.</span></span> <span data-ttu-id="41687-211">다른 API를 사용하여 해결할 수 없는 특정 문제를 해결하는 방법은 현저하게 달라집니다.</span><span class="sxs-lookup"><span data-stu-id="41687-211">The way you resolve certain issues that couldn't be addressed by just using another API varies greatly.</span></span> <span data-ttu-id="41687-212">특정 프로젝트에 대해 보다 포괄적인 계획을 개발해야 할 수 있으며, 이는 다음 접근 방식에서 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="41687-212">You may find that you need to develop a more comprehensive plan for certain projects, which is covered as the next approach.</span></span>

### <a name="developing-a-comprehensive-plan-of-attack"></a><span data-ttu-id="41687-213">포괄적인 공격 계획 개발</span><span class="sxs-lookup"><span data-stu-id="41687-213">Developing a comprehensive plan of attack</span></span>

<span data-ttu-id="41687-214">이 접근 방식은 .NET Core를 지원하기 위해 코드를 재구성하거나 코드의 특정 영역을 완전히 다시 작성해야 할 수 있는 더 크고 더 복잡한 프로젝트에 가장 적합할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="41687-214">This approach might be best for larger and more complex projects, where restructuring code or completely rewriting certain areas of code might be necessary to support .NET Core.</span></span> <span data-ttu-id="41687-215">이 접근 방식은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="41687-215">The approach is as follows:</span></span>

1. <span data-ttu-id="41687-216">프로젝트에서 ApiPort를 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="41687-216">Run ApiPort on a project.</span></span>
1. <span data-ttu-id="41687-217">이식 불가능한 각 형식이 사용되고 있는 위치 및 해당 형식이 전체 이식성에 어떻게 영향을 주는지를 파악합니다.</span><span class="sxs-lookup"><span data-stu-id="41687-217">Understand where each non-portable type is used and how that affects overall portability.</span></span>
   - <span data-ttu-id="41687-218">해당 형식의 특성을 이해합니다.</span><span class="sxs-lookup"><span data-stu-id="41687-218">Understand the nature of those types.</span></span> <span data-ttu-id="41687-219">수는 적은데 자주 사용되나요?</span><span class="sxs-lookup"><span data-stu-id="41687-219">Are they small in number but used frequently?</span></span> <span data-ttu-id="41687-220">아니면 수는 많지만 자주 사용되지 않나요?</span><span class="sxs-lookup"><span data-stu-id="41687-220">Are they large in number but used infrequently?</span></span> <span data-ttu-id="41687-221">집중적으로 사용되나요? 아니면 코드 전체에 분산되어 있나요?</span><span class="sxs-lookup"><span data-stu-id="41687-221">Is their use concentrated, or is it spread throughout your code?</span></span>
   - <span data-ttu-id="41687-222">이식할 수 없는 코드는 격리가 쉬우므로 더 효과적으로 처리할 수 있나요?</span><span class="sxs-lookup"><span data-stu-id="41687-222">Is it easy to isolate code that isn't portable so that you can deal with it more effectively?</span></span>
   - <span data-ttu-id="41687-223">코드를 리팩터링해야 하나요?</span><span class="sxs-lookup"><span data-stu-id="41687-223">Do you need to refactor your code?</span></span>
   - <span data-ttu-id="41687-224">이식할 수 없는 해당 형식에 대해 동일한 작업을 수행하는 다른 API가 있나요?</span><span class="sxs-lookup"><span data-stu-id="41687-224">For those types which aren't portable, are there alternative APIs that accomplish the same task?</span></span> <span data-ttu-id="41687-225">예를 들어 <xref:System.Net.WebClient> 클래스를 사용하고 있는 경우 <xref:System.Net.Http.HttpClient> 클래스를 대신 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="41687-225">For example if you're using the <xref:System.Net.WebClient> class, you might be able to use the <xref:System.Net.Http.HttpClient> class instead.</span></span>
   - <span data-ttu-id="41687-226">드롭인 대체가 아닌 경우에도 작업을 수행하는 데 사용할 수 있는 이식 가능한 다른 API가 있나요?</span><span class="sxs-lookup"><span data-stu-id="41687-226">Are there different portable APIs available to accomplish a task, even if it's not a drop-in replacement?</span></span> <span data-ttu-id="41687-227">예를 들어 <xref:System.Xml.Schema.XmlSchema>를 사용하여 XML을 구문 분석하지만 XML 스키마 검색이 필요하지 않은 경우, API를 사용하는 대신 <xref:System.Xml.Linq> API를 사용하고 직접 구문 분석을 구현할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="41687-227">For example if you're using <xref:System.Xml.Schema.XmlSchema> to parse XML but don't require XML schema discovery, you could use <xref:System.Xml.Linq> APIs and implement parsing yourself as opposed to relying on an API.</span></span>
1. <span data-ttu-id="41687-228">이식하기 어려운 어셈블리가 있는 경우 지금은 .NET Framework에 유지하는 것이 나을까요?</span><span class="sxs-lookup"><span data-stu-id="41687-228">If you have assemblies that are difficult to port, is it worth leaving them on .NET Framework for now?</span></span> <span data-ttu-id="41687-229">다음과 같은 몇 가지 사항을 고려해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="41687-229">Here are some things to consider:</span></span>
   - <span data-ttu-id="41687-230">.NET Framework 또는 Windows 관련 기능을 너무 많이 사용하기 때문에 .NET Core와 호환되지 않는 일부 기능이 라이브러리에 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="41687-230">You may have some functionality in your library that's incompatible with .NET Core because it relies too heavily on .NET Framework or Windows-specific functionality.</span></span> <span data-ttu-id="41687-231">기능 이식을 위해 리소스를 사용할 수 있을 때까지 임시로 해당 기능을 유지하고 당분간은 기능이 더 적은 라이브러리의 .NET Core 버전을 릴리스하는 것이 더 나을까요?</span><span class="sxs-lookup"><span data-stu-id="41687-231">Is it worth leaving that functionality behind for now and releasing a .NET Core version of your library with less features on a temporary basis until resources are available to port the features?</span></span>
   - <span data-ttu-id="41687-232">리팩터링이 도움이 될까요?</span><span class="sxs-lookup"><span data-stu-id="41687-232">Would a refactor help?</span></span>
1. <span data-ttu-id="41687-233">사용할 수 없는 .NET Framework API의 고유한 구현을 작성하는 것이 합리적일까요?</span><span class="sxs-lookup"><span data-stu-id="41687-233">Is it reasonable to write your own implementation of an unavailable .NET Framework API?</span></span>
   <span data-ttu-id="41687-234">[.NET Framework 참조 소스](https://github.com/Microsoft/referencesource)에서 코드를 복사, 수정 및 사용하는 것이 좋을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="41687-234">You could consider copying, modifying, and using code from the [.NET Framework Reference Source](https://github.com/Microsoft/referencesource).</span></span> <span data-ttu-id="41687-235">참조 소스 코드는 [MIT 라이선스](https://github.com/Microsoft/referencesource/blob/master/LICENSE.txt)에 따라 라이선스가 부여되므로, 소스를 자신의 코드에 대한 기초로 매우 자유롭게 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="41687-235">The reference source code is licensed under the [MIT License](https://github.com/Microsoft/referencesource/blob/master/LICENSE.txt), so you have significant freedom to use the source as a basis for your own code.</span></span> <span data-ttu-id="41687-236">코드에서 Microsoft 특성을 제대로 지정하기만 하면 됩니다.</span><span class="sxs-lookup"><span data-stu-id="41687-236">Just be sure to properly attribute Microsoft in your code.</span></span>
1. <span data-ttu-id="41687-237">필요에 따라 다른 프로젝트에 대해 이 프로세스를 반복합니다.</span><span class="sxs-lookup"><span data-stu-id="41687-237">Repeat this process as needed for different projects.</span></span>
 
<span data-ttu-id="41687-238">분석 단계는 코드베이스의 크기에 따라 다소 시간이 걸릴 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="41687-238">The analysis phase could take some time depending on the size of your codebase.</span></span> <span data-ttu-id="41687-239">이 단계에서 시간을 할애하여 필요한 변경의 범위를 철저하게 이해하고 계획을 개발하면 장기 실행, 특히 복잡한 코드베이스가 있는 경우 일반적으로 시간이 절약됩니다.</span><span class="sxs-lookup"><span data-stu-id="41687-239">Spending time in this phase to thoroughly understand the scope of changes needed and to develop a plan usually saves you time in the long run, particularly if you have a complex codebase.</span></span>

<span data-ttu-id="41687-240">계획에 코드베이스의 중요한 변경 작업을 포함하는 동시에 .NET Framework 4.6.2를 계속 대상으로 지정할 수 있으므로 이전 접근 방식보다 더 구조화된 버전으로 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="41687-240">Your plan could involve making significant changes to your codebase while still targeting .NET Framework 4.6.2, making this a more structured version of the previous approach.</span></span> <span data-ttu-id="41687-241">계획 실행을 시작하는 방법은 코드베이스에 따라 달라집니다.</span><span class="sxs-lookup"><span data-stu-id="41687-241">How you go about executing your plan is dependent on your codebase.</span></span>

### <a name="mixing-approaches"></a><span data-ttu-id="41687-242">접근 방식 혼합</span><span class="sxs-lookup"><span data-stu-id="41687-242">Mixing approaches</span></span>

<span data-ttu-id="41687-243">위의 접근 방식을 프로젝트 단위로 혼합하여 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="41687-243">It's likely that you'll mix the above approaches on a per-project basis.</span></span> <span data-ttu-id="41687-244">사용자 및 코드베이스에 가장 적합한 방법을 수행해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="41687-244">You should do what makes the most sense to you and for your codebase.</span></span>

## <a name="porting-your-tests"></a><span data-ttu-id="41687-245">테스트 이식</span><span class="sxs-lookup"><span data-stu-id="41687-245">Porting your tests</span></span>

<span data-ttu-id="41687-246">코드를 이식한 경우 모든 항목이 제대로 작동하는지 확인하는 가장 좋은 방법은 .NET Core에 이식할 때 코드를 테스트하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="41687-246">The best way to make sure everything works when you've ported your code is to test your code as you port it to .NET Core.</span></span> <span data-ttu-id="41687-247">이렇게 하려면 .NET Core에 대한 테스트를 빌드하고 실행하는 테스트 프레임워크를 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="41687-247">To do this, you'll need to use a testing framework that builds and runs tests for .NET Core.</span></span> <span data-ttu-id="41687-248">현재는 다음과 같은 세 가지 옵션이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="41687-248">Currently, you have three options:</span></span>

- [<span data-ttu-id="41687-249">xUnit</span><span class="sxs-lookup"><span data-stu-id="41687-249">xUnit</span></span>](https://xunit.github.io/)
  * [<span data-ttu-id="41687-250">시작</span><span class="sxs-lookup"><span data-stu-id="41687-250">Getting Started</span></span>](http://xunit.github.io/docs/getting-started-dotnet-core.html)
  * [<span data-ttu-id="41687-251">MSTest 프로젝트를 xUnit으로 변환하는 도구</span><span class="sxs-lookup"><span data-stu-id="41687-251">Tool to convert an MSTest project to xUnit</span></span>](https://github.com/dotnet/codeformatter/tree/master/src/XUnitConverter)
- [<span data-ttu-id="41687-252">NUnit</span><span class="sxs-lookup"><span data-stu-id="41687-252">NUnit</span></span>](http://www.nunit.org/)
  * [<span data-ttu-id="41687-253">시작</span><span class="sxs-lookup"><span data-stu-id="41687-253">Getting Started</span></span>](https://github.com/nunit/docs/wiki/Installation)
  * [<span data-ttu-id="41687-254">MSTest에서 NUnit으로 마이그레이션에 대한 블로그 게시물</span><span class="sxs-lookup"><span data-stu-id="41687-254">Blog post about migrating from MSTest to NUnit</span></span>](http://www.florian-rappl.de/News/Page/275/convert-mstest-to-nunit)
- [<span data-ttu-id="41687-255">MSTest</span><span class="sxs-lookup"><span data-stu-id="41687-255">MSTest</span></span>](https://docs.microsoft.com/visualstudio/test/unit-test-basics)

## <a name="recommended-approach-to-porting"></a><span data-ttu-id="41687-256">이식에 권장되는 접근 방식</span><span class="sxs-lookup"><span data-stu-id="41687-256">Recommended approach to porting</span></span>

<span data-ttu-id="41687-257">궁극적으로 이식 작업은 .NET Framework 코드가 구성된 방법에 따라 크게 달라집니다.</span><span class="sxs-lookup"><span data-stu-id="41687-257">Ultimately, the porting effort depends heavily on how your .NET Framework code is structured.</span></span> <span data-ttu-id="41687-258">코드를 이식하는 좋은 방법은 코드의 기본 구성 요소인 라이브러리의 *기본*으로 시작하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="41687-258">A good way to port your code is to begin with the *base* of your library, which are the foundational components of your code.</span></span> <span data-ttu-id="41687-259">이는 다른 모든 항목에서 직접적으로나 간접적으로 사용하는 데이터 모델이나 일부 다른 기본 클래스 및 메서드가 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="41687-259">This might be data models or some other foundational classes and methods that everything else uses directly or indirectly.</span></span>

1. <span data-ttu-id="41687-260">현재 이식하고 있는 라이브러리의 계층을 테스트하는 테스트 프로젝트를 이식합니다.</span><span class="sxs-lookup"><span data-stu-id="41687-260">Port the test project that tests the layer of your library that you're currently porting.</span></span>
1. <span data-ttu-id="41687-261">라이브러리의 기본을 새 .NET Core 프로젝트에 복사하고 지원하려는 .NET 표준의 버전을 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="41687-261">Copy over the base of your library into a new .NET Core project and select the version of the .NET Standard you wish to support.</span></span>
1. <span data-ttu-id="41687-262">코드를 컴파일하는 데 필요한 대로 내용을 변경합니다.</span><span class="sxs-lookup"><span data-stu-id="41687-262">Make any changes needed to get the code to compile.</span></span> <span data-ttu-id="41687-263">이 작업의 많은 부분에서 NuGet 패키지 종속성을 *csproj* 파일에 추가해야 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="41687-263">Much of this may require adding NuGet package dependencies to your *csproj* file.</span></span>
1. <span data-ttu-id="41687-264">테스트를 실행하고 필요에 따라 조정합니다.</span><span class="sxs-lookup"><span data-stu-id="41687-264">Run the tests and make any needed adjustments.</span></span>
1. <span data-ttu-id="41687-265">이식할 다음 코드 계층을 선택하고 이전 단계를 반복합니다.</span><span class="sxs-lookup"><span data-stu-id="41687-265">Pick the next layer of code to port over and repeat the prior steps.</span></span>

<span data-ttu-id="41687-266">라이브러리의 기본으로 시작하고 기본에서 바깥쪽으로 이동하면서 필요에 따라 각 계층을 테스트하면, 이식은 한 번에 하나의 코드 계층으로 문제가 격리되는 체계적인 프로세스가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="41687-266">If you start with the base of your library and move outward from the base and test each layer as needed, porting is a systematic process where problems are isolated to one layer of code at a time.</span></span>

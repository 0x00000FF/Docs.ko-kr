---
title: 대리자 및 이벤트를 구별
description: 대리자와 이벤트 간의 차이점 및 .NET Core의 이러한 기능을 사용하는 경우를 각각 알아봅니다.
ms.date: 06/20/2016
ms.assetid: 0fdc8629-2fdb-4a7c-a433-5b9d04eaf911
ms.openlocfilehash: 2f9c26519d93314f4991829191723df5426b23b7
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 05/04/2018
ms.locfileid: "33219140"
---
# <a name="distinguishing-delegates-and-events"></a><span data-ttu-id="18890-103">대리자 및 이벤트를 구별</span><span class="sxs-lookup"><span data-stu-id="18890-103">Distinguishing Delegates and Events</span></span>

[<span data-ttu-id="18890-104">이전</span><span class="sxs-lookup"><span data-stu-id="18890-104">Previous</span></span>](modern-events.md)

<span data-ttu-id="18890-105">.NET Core 플랫폼을 처음 사용하는 개발자는 `delegates` 기반 디자인과 `events` 기반 디자인 중에서 결정할 때 종종 어려움을 겪습니다.</span><span class="sxs-lookup"><span data-stu-id="18890-105">Developers that are new to the .NET Core platform often struggle when deciding between a design based on `delegates` and a design based on `events`.</span></span> <span data-ttu-id="18890-106">두 언어 기능이 매우 유사하기 때문에 어려운 개념입니다.</span><span class="sxs-lookup"><span data-stu-id="18890-106">This is a difficult concept, because the two language features are very similar.</span></span> <span data-ttu-id="18890-107">이벤트는 대리자에 대한 언어 지원을 사용하여 작성되기도 합니다.</span><span class="sxs-lookup"><span data-stu-id="18890-107">Events are even built using the language support for delegates.</span></span> 

<span data-ttu-id="18890-108">둘 다 런타임에 바인딩 시나리오를 제공합니다. 즉, 런타임에만 알려지는 메서드를 호출하여 구성 요소가 통신하는 시나리오가 가능합니다.</span><span class="sxs-lookup"><span data-stu-id="18890-108">They both offer a late binding scenario: they enable scenarios where a component communicates by calling a method that is only known at runtime.</span></span> <span data-ttu-id="18890-109">모두 단일 및 다중 구독자 메서드를 지원하는데,</span><span class="sxs-lookup"><span data-stu-id="18890-109">They both support single and multiple subscriber methods.</span></span> <span data-ttu-id="18890-110">이를 단일 캐스트 및 멀티캐스트 지원이라고 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="18890-110">You may find this referred to as singlecast and multicast support.</span></span> <span data-ttu-id="18890-111">둘 다 처리기 추가 및 제거에 대해 유사한 구문을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="18890-111">They both support similar syntax for adding and removing handlers.</span></span> <span data-ttu-id="18890-112">마지막으로 이벤트를 발생시키고 대리자를 호출하는 작업에서 정확히 동일한 메서드 호출 구문을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="18890-112">Finally, raising an event and calling a delegate use exactly the same method call syntax.</span></span> <span data-ttu-id="18890-113">또한 `?.` 연산자와 함께 사용하도록 동일한 `Invoke()` 메서드 구문을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="18890-113">They even both support the same `Invoke()` method syntax for use with the `?.` operator.</span></span>

<span data-ttu-id="18890-114">이러한 모든 유사성으로 인해 언제 어떤 언어 기능을 사용할지를 결정하기가 어려울 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="18890-114">With all those similarities, it is easy to have trouble determining when to use which.</span></span>

## <a name="listening-to-events-is-optional"></a><span data-ttu-id="18890-115">이벤트 수신은 선택 사항임</span><span class="sxs-lookup"><span data-stu-id="18890-115">Listening to Events is Optional</span></span>

<span data-ttu-id="18890-116">사용할 언어 기능을 결정할 때 가장 중요하게 고려할 사항은 연결된 구독자가 있어야 하는지 여부입니다.</span><span class="sxs-lookup"><span data-stu-id="18890-116">The most important consideration in determining which language feature to use is whether or not there must be an attached subscriber.</span></span> <span data-ttu-id="18890-117">코드에서 구독자가 제공하는 코드를 호출해야 하는 경우에는 대리자 기반 디자인을 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="18890-117">If your code must call the code supplied by the subscriber, you should use a design based on delegates.</span></span> <span data-ttu-id="18890-118">코드에서 구독자를 호출하지 않고 모든 작업을 완료할 수 있는 경우에는 이벤트 기반 디자인을 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="18890-118">If your code can complete all its work without calling any subscribers, you should use a design based on events.</span></span> 

<span data-ttu-id="18890-119">이 섹션 중 작성된 예제를 살펴보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="18890-119">Consider the examples built during this section.</span></span> <span data-ttu-id="18890-120">`List.Sort()`를 사용하여 작성한 코드에서 요소를 제대로 정렬하려면 비교자 함수가 제공되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="18890-120">The code you built using `List.Sort()` must be given a comparer function in order to properly sort the elements.</span></span> <span data-ttu-id="18890-121">반환할 요소를 결정하려면 대리자와 함께 LINQ 쿼리를 제공해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="18890-121">LINQ queries must be supplied with delegates in order to determine what elements to return.</span></span> <span data-ttu-id="18890-122">둘 다 대리자로 작성된 디자인을 사용했습니다.</span><span class="sxs-lookup"><span data-stu-id="18890-122">Both used a design built with delegates.</span></span>

<span data-ttu-id="18890-123">`Progress` 이벤트를 살펴보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="18890-123">Consider the `Progress` event.</span></span> <span data-ttu-id="18890-124">이 이벤트는 작업의 진행률을 보고합니다.</span><span class="sxs-lookup"><span data-stu-id="18890-124">It reports progress on a task.</span></span>
<span data-ttu-id="18890-125">수신기가 있는지 여부에 관계없이 작업이 계속 진행됩니다.</span><span class="sxs-lookup"><span data-stu-id="18890-125">The task continues to proceed whether or not there are any listeners.</span></span>
<span data-ttu-id="18890-126">`FileSearcher`는 또 다른 예제입니다.</span><span class="sxs-lookup"><span data-stu-id="18890-126">The `FileSearcher` is another example.</span></span> <span data-ttu-id="18890-127">연결된 이벤트 구독자가 없는 경우에도 검색된 모든 파일을 계속 검색하고 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="18890-127">It would still search and find all the files that were sought, even with no event subscribers attached.</span></span>
<span data-ttu-id="18890-128">UX 컨트롤은 이벤트를 수신하는 구독자가 없는 경우에도 여전히 올바르게 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="18890-128">UX controls still work correctly, even when there are no subscribers listening to the events.</span></span> <span data-ttu-id="18890-129">둘 다 이벤트 기반 디자인을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="18890-129">They both use designs based on events.</span></span>

## <a name="return-values-require-delegates"></a><span data-ttu-id="18890-130">반환 값에 대리자 필요</span><span class="sxs-lookup"><span data-stu-id="18890-130">Return Values Require Delegates</span></span>

<span data-ttu-id="18890-131">또 다른 고려 사항은 대리자 메서드에 필요한 메서드 프로토타입입니다.</span><span class="sxs-lookup"><span data-stu-id="18890-131">Another consideration is the method prototype you would want for your delegate method.</span></span> <span data-ttu-id="18890-132">지금까지 살펴본 대로 이벤트에 사용된 대리자는 모두 void 반환 형식을 갖습니다.</span><span class="sxs-lookup"><span data-stu-id="18890-132">As you've seen, the delegates used for events all have a void return type.</span></span> <span data-ttu-id="18890-133">또한 이벤트 인수 개체의 속성을 수정하여 이벤트 소스에 다시 정보를 전달하는 이벤트 처리기를 만드는 관용구가 있음을 확인했습니다.</span><span class="sxs-lookup"><span data-stu-id="18890-133">You've also seen that there are idioms to create event handlers that do pass information back to event sources through modifying properties of the event argument object.</span></span> <span data-ttu-id="18890-134">이러한 관용구도 작업을 수행하기는 하지만 메서드에서 값을 반환하는 것만큼 자연스럽지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="18890-134">While these idioms do work, they are not as natural as returning a value from a method.</span></span>

<span data-ttu-id="18890-135">이러한 두 추론은 종종 둘 다 제공될 수 있습니다. 대리자 메서드가 값을 반환하는 경우 어떤 방식으로든 알고리즘에 영향을 줄 가능성이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="18890-135">Notice that these two heuristics may often both be present: If your delegate method returns a value, it will likely impact the algorithm in some way.</span></span>

## <a name="event-listeners-often-have-longer-lifetimes"></a><span data-ttu-id="18890-136">종종 이벤트 수신기의 수명이 길어짐</span><span class="sxs-lookup"><span data-stu-id="18890-136">Event Listeners Often Have Longer Lifetimes</span></span> 

<span data-ttu-id="18890-137">약간 더 약한 양쪽 맞춤입니다.</span><span class="sxs-lookup"><span data-stu-id="18890-137">This is a slightly weaker justification.</span></span> <span data-ttu-id="18890-138">그러나 이벤트 소스가 오랜 시간 동안 이벤트를 발생시킬 경우에는 이벤트 기반 디자인이 더 자연스러울 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="18890-138">However, you may find that event-based designs are more natural when the event source will be raising events over a long period of time.</span></span> <span data-ttu-id="18890-139">많은 시스템의 UX 컨트롤에서 이러한 예를 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="18890-139">You can see examples of this for UX controls on many systems.</span></span> <span data-ttu-id="18890-140">이벤트를 구독하면 이벤트 소스가 프로그램의 수명 주기 전체에 걸쳐 이벤트를 발생시킬 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="18890-140">Once you subscribe to an event, the event source may raise events throughout the lifetime of the program.</span></span>
<span data-ttu-id="18890-141">이벤트가 더 이상 필요하지 않은 경우 이벤트 구독을 취소할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="18890-141">(You can unsubscribe from events when you no longer need them.)</span></span>

<span data-ttu-id="18890-142">대리자가 메서드의 인수로 사용되고 해당 메서드가 반환된 후에는 대리자가 사용되지 않는 많은 대리자 기반 디자인과 비교해 보세요.</span><span class="sxs-lookup"><span data-stu-id="18890-142">Contrast that with many delegate-based designs, where a delegate is used as an argument to a method, and the delegate is not used after that method returns.</span></span>

## <a name="evaluate-carefully"></a><span data-ttu-id="18890-143">신중하게 평가</span><span class="sxs-lookup"><span data-stu-id="18890-143">Evaluate Carefully</span></span>

<span data-ttu-id="18890-144">위의 고려 사항은 엄격한 규칙이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="18890-144">The above considerations are not hard and fast rules.</span></span> <span data-ttu-id="18890-145">대신 특정 용도에 가장 적합한 선택 항목을 결정하는 데 도움이 되는 지침을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="18890-145">Instead, they represent guidance that can help you decide which choice is best for your particular usage.</span></span> <span data-ttu-id="18890-146">유사하기 때문에 둘 다를 프로토타입화할 수도 있고 작업에 더 자연스러운 항목을 고려할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="18890-146">Because they are similar, you can even prototype both, and consider which would be more natural to work with.</span></span> <span data-ttu-id="18890-147">둘 다 런타임에 바인딩 시나리오도 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="18890-147">They both handle late binding scenarios well.</span></span> <span data-ttu-id="18890-148">최상의 디자인을 전달하는 기능을 사용하세요.</span><span class="sxs-lookup"><span data-stu-id="18890-148">Use the one that communicates your design the best.</span></span>

---
title: 컴파일러 경고(수준 1) CS4014
ms.date: 07/20/2015
f1_keywords:
- CS4014
helpviewer_keywords:
- CS4014
ms.assetid: b9e7c029-eaa9-48d7-8b3c-9823772c9acb
ms.openlocfilehash: 244328d40c1ab0d7499db2e319460eaf8a0f0812
ms.sourcegitcommit: 6b308cf6d627d78ee36dbbae8972a310ac7fd6c8
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 01/23/2019
ms.locfileid: "54711605"
---
# <a name="compiler-warning-level-1-cs4014"></a><span data-ttu-id="9793d-102">컴파일러 경고(수준 1) CS4014</span><span class="sxs-lookup"><span data-stu-id="9793d-102">Compiler Warning (level 1) CS4014</span></span>

<span data-ttu-id="9793d-103">이 호출이 대기되지 않으므로 호출이 완료되기 전에 현재 메서드가 계속 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="9793d-103">Because this call is not awaited, execution of the current method continues before the call is completed.</span></span> <span data-ttu-id="9793d-104">'await' 연산자는 호출 결과에 적용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="9793d-104">Consider applying the 'await' operator to the result of the call.</span></span>  
  
<span data-ttu-id="9793d-105">현재 메서드는 <xref:System.Threading.Tasks.Task> 또는 <xref:System.Threading.Tasks.Task%601>를 반환하는 비동기 메서드를 호출하고 결과에 [await](../../../csharp/language-reference/keywords/await.md) 연산자를 적용하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9793d-105">The current method calls an async method that returns a <xref:System.Threading.Tasks.Task> or a <xref:System.Threading.Tasks.Task%601> and doesn’t apply the [await](../../../csharp/language-reference/keywords/await.md) operator to the result.</span></span> <span data-ttu-id="9793d-106">비동기 메서드 호출이 비동기 작업을 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="9793d-106">The call to the async method starts an asynchronous task.</span></span> <span data-ttu-id="9793d-107">그러나 `await` 연산자가 적용되지 않기 때문에 프로그램이 작업이 완료될 때까지 기다리지 않고 계속됩니다.</span><span class="sxs-lookup"><span data-stu-id="9793d-107">However, because no `await` operator is applied, the program continues without waiting for the task to complete.</span></span> <span data-ttu-id="9793d-108">대부분의 경우 예상대로 동작하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9793d-108">In most cases, that behavior isn't what you expect.</span></span> <span data-ttu-id="9793d-109">대개 호출 메서드의 다른 부분은 호출의 결과에 따라 다르거나, 최소한 호출을 포함하는 메서드에서 돌아오기 전에 호출된 메서드가 완료되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9793d-109">Usually other aspects of the calling method depend on the results of the call or, minimally, the called method is expected to complete before you return from the method that contains the call.</span></span>  
  
<span data-ttu-id="9793d-110">호출된 비동기 메서드에서 발생하는 예외가 어떻게 되는지도 중요한 문제입니다.</span><span class="sxs-lookup"><span data-stu-id="9793d-110">An equally important issue is what happens to exceptions that are raised in the called async method.</span></span> <span data-ttu-id="9793d-111"><xref:System.Threading.Tasks.Task> 또는 <xref:System.Threading.Tasks.Task%601>를 반환하는 메서드에서 발생하는 예외는 반환된 작업에 저장됩니다.</span><span class="sxs-lookup"><span data-stu-id="9793d-111">An exception that's raised in a method that returns a <xref:System.Threading.Tasks.Task> or  <xref:System.Threading.Tasks.Task%601> is stored in the returned task.</span></span> <span data-ttu-id="9793d-112">작업을 기다리지 않거나 예외를 명시적으로 확인하지 않는 경우 예외가 손실됩니다.</span><span class="sxs-lookup"><span data-stu-id="9793d-112">If you don't await the task or explicitly check for exceptions, the exception is lost.</span></span> <span data-ttu-id="9793d-113">작업을 기다리는 경우 예외가 다시 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="9793d-113">If you await the task, its exception is rethrown.</span></span>  

<span data-ttu-id="9793d-114">가장 좋은 방법은 항상 호출을 기다리는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="9793d-114">As a best practice, you should always await the call.</span></span>

<span data-ttu-id="9793d-115">비동기 호출이 완료될 때까지 기다리지 않으려고 하거나 호출된 메서드가 예외를 발생시키지 않는 경우에만 경고가 표시되지 않게 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9793d-115">You should consider suppressing the warning only if you're sure that you don't want to wait for the asynchronous call to complete and that the called method won't raise any exceptions.</span></span> <span data-ttu-id="9793d-116">이 경우 변수에 호출의 작업 결과를 할당하여 경고가 표시되지 않게 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9793d-116">In that case, you can suppress the warning by assigning the task result of the call to a variable.</span></span>  

<span data-ttu-id="9793d-117">다음 예제는 경고를 발생시키는 방법, 경고가 표시되지 않게 하는 방법 및 호출을 대기하는 방법을 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="9793d-117">The following example shows how to cause the warning, how to suppress it, and how to await the call.</span></span>  

```csharp
async Task CallingMethodAsync()  
{  
    resultsTextBox.Text += "\r\n  Entering calling method.";  
    // Variable delay is used to slow down the called method so that you can  
    // distinguish between awaiting and not awaiting in the program's output.  
    // You can adjust the value to produce the output that this topic shows  
    // after the code.  
    var delay = 5000;  
  
    // Call #1.  
    // Call an async method. Because you don't await it, its completion
    // isn't coordinated with the current method, CallingMethodAsync.  
    // The following line causes warning CS4014.  
    CalledMethodAsync(delay);  
  
    // Call #2.  
    // To suppress the warning without awaiting, you can assign the
    // returned task to a variable. The assignment doesn't change how  
    // the program runs. However, recommended practice is always to  
    // await a call to an async method.  
  
    // Replace Call #1 with the following line.  
    //Task delayTask = CalledMethodAsync(delay);  
  
    // Call #3  
    // To contrast with an awaited call, replace the unawaited call
    // (Call #1 or Call #2) with the following awaited call. Best
    // practice is to await the call.  
  
    //await CalledMethodAsync(delay);  
  
    // If the call to CalledMethodAsync isn't awaited, CallingMethodAsync  
    // continues to run and, in this example, finishes its work and returns  
    // to its caller.  
    resultsTextBox.Text += "\r\n  Returning from calling method.";  
}  
  
async Task CalledMethodAsync(int howLong)  
{  
    resultsTextBox.Text +=
        "\r\n    Entering called method, starting and awaiting Task.Delay.";  
  
    // Slow the process down a little so that you can distinguish between  
    // awaiting and not awaiting in the program's output. Adjust the value  
    // for howLong if necessary.  
    await Task.Delay(howLong);  
    resultsTextBox.Text +=
        "\r\n    Task.Delay is finished--returning from called method.";  
}  
```

<span data-ttu-id="9793d-118">이 예제에서는 Call #1 또는 Call #2를 선택할 경우 해당 호출자(`CalledMethodAsync`)와 호출자의 호출자(`CallingMethodAsync`)가 모두 완료된 후 기다리지 않는 비동기 메서드(`startButton_Click`)가 끝납니다.</span><span class="sxs-lookup"><span data-stu-id="9793d-118">In the example, if you choose Call #1 or Call #2, the unawaited async method (`CalledMethodAsync`) finishes after both its caller (`CallingMethodAsync`) and the caller's caller (`startButton_Click`) are complete.</span></span> <span data-ttu-id="9793d-119">다음 출력의 마지막 줄은 호출된 메서드가 끝나는 시기를 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="9793d-119">The last line in the following output shows you when the called method finishes.</span></span> <span data-ttu-id="9793d-120">전체 예제에서 `CallingMethodAsync` 를 호출하는 이벤트 처리기의 시작과 종료가 출력에 표시되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9793d-120">Entry to and exit from the event handler that calls `CallingMethodAsync` in the full example are marked in the output.</span></span>  

```console
Entering the Click event handler.  
  Entering calling method.  
    Entering called method, starting and awaiting Task.Delay.  
  Returning from calling method.  
Exiting the Click event handler.  
    Task.Delay is finished--returning from called method.  
```

<span data-ttu-id="9793d-121">[#pragma warning](../../../csharp/language-reference/preprocessor-directives/preprocessor-pragma-warning.md) 지시문을 사용하여 컴파일러 경고가 표시되지 않게 할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9793d-121">You can also suppress compiler warnings by using [#pragma warning](../../../csharp/language-reference/preprocessor-directives/preprocessor-pragma-warning.md) directives.</span></span>  
  
## <a name="example"></a><span data-ttu-id="9793d-122">예제</span><span class="sxs-lookup"><span data-stu-id="9793d-122">Example</span></span>

<span data-ttu-id="9793d-123">다음 Windows Presentation Foundation(WPF) 애플리케이션은 이전 예제의 메서드를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="9793d-123">The following Windows Presentation Foundation (WPF) application contains the methods from the previous example.</span></span> <span data-ttu-id="9793d-124">다음 단계는 애플리케이션을 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="9793d-124">The following steps set up the application.</span></span>  
  
1. <span data-ttu-id="9793d-125">WPF 애플리케이션을 만들고 이름을 `AsyncWarning`으로 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="9793d-125">Create a WPF application, and name it `AsyncWarning`.</span></span>  

2. <span data-ttu-id="9793d-126">Visual Studio 코드 편집기에서 **MainWindow.xaml** 탭을 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="9793d-126">In the Visual Studio Code Editor, choose the **MainWindow.xaml** tab.</span></span>  
  
    <span data-ttu-id="9793d-127">탭이 표시되지 않는 경우 **솔루션 탐색기**에서 MainWindow.xaml의 바로 가기 메뉴를 열고 **코드 보기**를 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="9793d-127">If the tab isn't visible, open the shortcut menu for MainWindow.xaml in **Solution Explorer**, and then choose **View Code**.</span></span>  
  
3. <span data-ttu-id="9793d-128">MainWindow.xaml의 **XAML** 보기에서 코드를 다음 코드로 바꿉니다.</span><span class="sxs-lookup"><span data-stu-id="9793d-128">Replace the code in the **XAML** view of MainWindow.xaml with the following code.</span></span>  

    ```xaml
    <Window x:Class="AsyncWarning.MainWindow"  
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"  
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"  
        Title="MainWindow" Height="350" Width="525">
        <Grid>  
            <Button x:Name="startButton" Content="Start" HorizontalAlignment="Left" Margin="214,28,0,0" VerticalAlignment="Top" Width="75" HorizontalContentAlignment="Center" FontWeight="Bold" FontFamily="Aharoni" Click="startButton_Click" />  
            <TextBox x:Name="resultsTextBox" Margin="0,80,0,0" TextWrapping="Wrap" FontFamily="Lucida Console"/>  
        </Grid>  
    </Window>  
    ```

    <span data-ttu-id="9793d-129">단추와 텍스트 상자가 포함된 간단한 창이 MainWindow.xaml의 **디자인** 뷰에 나타납니다.</span><span class="sxs-lookup"><span data-stu-id="9793d-129">A simple window that contains a button and a text box appears in the **Design** view of MainWindow.xaml.</span></span>  
  
    <span data-ttu-id="9793d-130">XAML 디자이너에 대한 자세한 내용은 [Visual Studio에서 XAML 디자이너를 사용하여 UI 만들기](/visualstudio/designers/creating-a-ui-by-using-xaml-designer-in-visual-studio)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="9793d-130">For more information about the XAML Designer, see [Creating a UI by using XAML Designer](/visualstudio/designers/creating-a-ui-by-using-xaml-designer-in-visual-studio).</span></span> <span data-ttu-id="9793d-131">간단한 UI를 직접 빌드하는 방법에 대한 자세한 내용은 "WPF 애플리케이션을 만들려면" 섹션과 "간단한 WPF MainWindow를 디자인하려면" 섹션인 [연습: Async 및 Await를 사용하여 웹에 액세스](../../programming-guide/concepts/async/walkthrough-accessing-the-web-by-using-async-and-await.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="9793d-131">For information about how to build your own simple UI, see the "To create a WPF application" and "To design a simple WPF MainWindow" sections of [Walkthrough: Accessing the Web by Using Async and Await](../../programming-guide/concepts/async/walkthrough-accessing-the-web-by-using-async-and-await.md).</span></span>  
  
4. <span data-ttu-id="9793d-132">MainWindow.xaml.cs의 코드를 다음 코드로 바꿉니다.</span><span class="sxs-lookup"><span data-stu-id="9793d-132">Replace the code in MainWindow.xaml.cs with the following code.</span></span>  
  
    ```csharp  
    using System;  
    using System.Collections.Generic;  
    using System.Linq;  
    using System.Text;  
    using System.Threading.Tasks;  
    using System.Windows;  
    using System.Windows.Controls;  
    using System.Windows.Data;  
    using System.Windows.Documents;  
    using System.Windows.Input;  
    using System.Windows.Media;  
    using System.Windows.Media.Imaging;  
    using System.Windows.Navigation;  
    using System.Windows.Shapes;  
  
    namespace AsyncWarning  
    {  
        public partial class MainWindow : Window  
        {  
            public MainWindow()  
            {  
                InitializeComponent();  
            }  
  
            private async void startButton_Click(object sender, RoutedEventArgs e)  
            {  
                resultsTextBox.Text += "\r\nEntering the Click event handler.";  
                await CallingMethodAsync();  
                resultsTextBox.Text += "\r\nExiting the Click event handler.";  
            }  
  
            async Task CallingMethodAsync()  
            {  
                resultsTextBox.Text += "\r\n  Entering calling method.";  
                // Variable delay is used to slow down the called method so that you can  
                // distinguish between awaiting and not awaiting in the program's output.  
                // You can adjust the value to produce the output that this topic shows  
                // after the code.  
                var delay = 5000;  
  
                // Call #1.  
                // Call an async method. Because you don't await it, its completion
                // isn't coordinated with the current method, CallingMethodAsync.  
                // The following line causes warning CS4014.  
                CalledMethodAsync(delay);  
  
                // Call #2.  
                // To suppress the warning without awaiting, you can assign the
                // returned task to a variable. The assignment doesn't change how  
                // the program runs. However, recommended practice is always to  
                // await a call to an async method.  
  
                // Replace Call #1 with the following line.  
                //Task delayTask = CalledMethodAsync(delay);  
  
                // Call #3  
                // To contrast with an awaited call, replace the unawaited call
                // (Call #1 or Call #2) with the following awaited call. Best
                // practice is to await the call.  
  
                //await CalledMethodAsync(delay);  
  
                // If the call to CalledMethodAsync isn't awaited, CallingMethodAsync  
                // continues to run and, in this example, finishes its work and returns  
                // to its caller.  
                resultsTextBox.Text += "\r\n  Returning from calling method.";  
            }  
  
            async Task CalledMethodAsync(int howLong)  
            {  
                resultsTextBox.Text +=
                    "\r\n    Entering called method, starting and awaiting Task.Delay.";  
  
                // Slow the process down a little so that you can distinguish between  
                // awaiting and not awaiting in the program's output. Adjust the value  
                // for howLong if necessary.  
                await Task.Delay(howLong);  
                resultsTextBox.Text +=
                    "\r\n    Task.Delay is finished--returning from called method.";  
            }  
        }  
  
        // Output with Call #1 or Call #2. (Wait for the last line to appear.)  
  
        // Entering the Click event handler.  
        //   Entering calling method.  
        //     Entering called method, starting and awaiting Task.Delay.  
        //   Returning from calling method.  
        // Exiting the Click event handler.  
        //     Task.Delay is finished--returning from called method.  
  
        // Output with Call #3, which awaits the call to CalledMethodAsync.  
  
        // Entering the Click event handler.  
        //   Entering calling method.  
        //     Entering called method, starting and awaiting Task.Delay.  
        //     Task.Delay is finished--returning from called method.  
        //   Returning from calling method.  
        // Exiting the Click event handler.  
    }  
    ```  
  
5. <span data-ttu-id="9793d-133">F5 키를 선택하여 프로그램을 실행한 다음 **시작** 단추를 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="9793d-133">Choose the F5 key to run the program, and then choose the **Start** button.</span></span>  

<span data-ttu-id="9793d-134">예상 출력이 코드의 끝에 나타납니다.</span><span class="sxs-lookup"><span data-stu-id="9793d-134">The expected output appears at the end of the code.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="9793d-135">참고 항목</span><span class="sxs-lookup"><span data-stu-id="9793d-135">See also</span></span>

- [<span data-ttu-id="9793d-136">await</span><span class="sxs-lookup"><span data-stu-id="9793d-136">await</span></span>](../../../csharp/language-reference/keywords/await.md)
- [<span data-ttu-id="9793d-137">Async 및 Await를 사용한 비동기 프로그래밍</span><span class="sxs-lookup"><span data-stu-id="9793d-137">Asynchronous Programming with async and await</span></span>](../../../csharp/programming-guide/concepts/async/index.md)

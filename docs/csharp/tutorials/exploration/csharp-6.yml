### YamlMime:Tutorial
title: <span data-ttu-id="29e2b-101">C# 6 살펴보기 - C# 대화형 C# 자습서</span><span class="sxs-lookup"><span data-stu-id="29e2b-101">Explore C# 6 - C# interactive C# tutorial</span></span>
metadata:
  title: C# 6 살펴보기 - 브라우저를 사용하여 C# 6의 새 기능을 대화형으로 사용해 보기
  description: 이 자습서에서는 브라우저를 사용하여 C# 6를 대화형으로 살펴볼 수 있습니다. 보다 간결하고 가독성이 높은 코드를 구현하는 C# 6에서 사용할 수 있는 새로운 관용구를 살펴볼 수 있습니다.
  audience: Developer
  level: intermediate
  ms.date: 12/11/2018
  displayType: two-column
  interactive: csharp
  ms.openlocfilehash: e1414c17cefd0fb31bb782a311e11dbd4cc056bb
  ms.sourcegitcommit: 093571de904fc7979e85ef3c048547d0accb1d8a
  ms.translationtype: HT
  ms.contentlocale: ko-KR
  ms.lasthandoff: 09/06/2019
  ms.locfileid: "70394096"
items:
- durationInMinutes: 1
  content: >
    <span data-ttu-id="29e2b-105">이 자습서에서는 브라우저를 사용하여 C#을 작성하고 코드를 컴파일하고 실행한 결과를 확인하면서 C# 6를 대화형으로 살펴볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="29e2b-105">This tutorial lets you explore C# 6 interactively, using your browser to write C# and see the results of compiling and running your code.</span></span> <span data-ttu-id="29e2b-106">여기에는 더 간결한 최신 C# 6 기능을 사용하도록 이전 버전의 C# 방식을 수정하는 일련의 단원이 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="29e2b-106">It contains a series of lessons that modify earlier C# practices to use newer, more concise C# 6 features.</span></span> <span data-ttu-id="29e2b-107">이 문서의 나머지 부분에서는 이러한 각 기능을 간략히 설명하고 이러한 기능을 살펴볼 수 있는 링크를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="29e2b-107">The rest of this article provides an overview of each of these features, with a link to explore each feature.</span></span>
- title: <span data-ttu-id="29e2b-108">읽기 전용 auto 속성으로 실제 읽기 전용 형식 구현</span><span class="sxs-lookup"><span data-stu-id="29e2b-108">Read-only auto-properties enable read-only types</span></span>
  durationInMinutes: 2
  content: "<span data-ttu-id=\"29e2b-109\">auto 속성 구문에서 읽기 전용 auto 속성 및 auto 속성 이니셜라이저가 개선되면서 auto 속성을 더 많은 곳에서 쉽게 사용할 수 있게 되었습니다.</span><span class=\"sxs-lookup\"><span data-stu-id=\"29e2b-109\">Two enhancements to auto-property syntax make it easier to use auto-properties in more places: read-only auto-properties and auto-property initializers.</span></span> <span data-ttu-id=\"29e2b-110\">다음과 같은 소규모 프로그램을 살펴보세요.</span><span class=\"sxs-lookup\"><span data-stu-id=\"29e2b-110\">Consider this small program:</span></span>\n\n[!code-csharp[Starter](../../../../samples/csharp/tutorials/exploration/csharp6-starter/Program.cs)]  \n\n    \n <span data-ttu-id=\"29e2b-111\">포커스 모드로 들어가서 이전 코드를 C# 대화형 창에 복사합니다.</span><span class=\"sxs-lookup\"><span data-stu-id=\"29e2b-111\">Enter Focus mode, copy the preceding code into the C# interactive window.</span></span> <span data-ttu-id=\"29e2b-112\">그런 다음, *실행*을 클릭하여 코드가 어떻게 실행되는지 확인합니다.</span><span class=\"sxs-lookup\"><span data-stu-id=\"29e2b-112\">Then, click *Run* to see what the code does.</span></span> <span data-ttu-id=\"29e2b-113\">`AllCaps`는 대문자 문자열을 반환하면서 속성 값을 수정하는, 원치 않는 부작용을 초래합니다.</span><span class=\"sxs-lookup\"><span data-stu-id=\"29e2b-113\">`AllCaps` has the undesirable side effect of modifying the property values along with returning the uppercase string.</span></span> <span data-ttu-id=\"29e2b-114\">`Person` 클래스 작성자는 `FirstName` 및 `LastName`의 문자열을 읽기 전용으로 만들려고 의도했습니다.</span><span class=\"sxs-lookup\"><span data-stu-id=\"29e2b-114\">The author of the `Person` class intended the strings for `FirstName` and `LastName` to be read-only.</span></span> <span data-ttu-id=\"29e2b-115\">C# 6에서는 이러한 의도를 분명히 알 수 있습니다.</span><span class=\"sxs-lookup\"><span data-stu-id=\"29e2b-115\">With C# 6, you can make that intent clear.</span></span> <span data-ttu-id=\"29e2b-116\">읽기 전용 auto 속성을 만들려면 두 속성 모두에서 `private set`를 삭제하세요.</span><span class=\"sxs-lookup\"><span data-stu-id=\"29e2b-116\">Remove the `private set` from both properties to create a read-only auto property.</span></span> <span data-ttu-id=\"29e2b-117\">*실행*을 클릭하면 `FirstName` 및 `LastName` 속성이 변경되지 않아야 하는데 변경된 두 위치를 컴파일러에서 찾아내는 것을 볼 수 있습니다.</span><span class=\"sxs-lookup\"><span data-stu-id=\"29e2b-117\">Click *Run* to see that the compiler spots the two locations where the `FirstName` and `LastName` properties are changed when they should not have been.</span></span> <span data-ttu-id=\"29e2b-118\">`AllCaps` 메서드를 다음 코드로 변경하여 컴파일러 오류를 해결할 수 있습니다.</span><span class=\"sxs-lookup\"><span data-stu-id=\"29e2b-118\">You can change the `AllCaps` method to the following code to fix the compiler error:</span></span>\n\n```csharp\npublic string AllCaps()\n{\n  return ToString().ToUpper();\n}\n```\n\n<span data-ttu-id=\"29e2b-119\">이 새로운 구문을 사용하면 컴파일러가 속성을 변경할 수 없게 만듭니다.</span><span class=\"sxs-lookup\"><span data-stu-id=\"29e2b-119\">Using this new syntax, the compiler ensures that the properties are immutable.</span></span>\n"
- title: <span data-ttu-id="29e2b-120">auto 속성의 지원 필드 초기화</span><span class="sxs-lookup"><span data-stu-id="29e2b-120">Initialize backing fields for auto-properties</span></span>
  durationInMinutes: 1
  content: "<span data-ttu-id=\"29e2b-121\">C# 6의 새로운 구문을 사용하면 auto 속성에 이니셜라이저를 사용할 수 있습니다.</span><span class=\"sxs-lookup\"><span data-stu-id=\"29e2b-121\">New syntax in C# 6 enables you to use initializers for auto-properties.</span></span> <span data-ttu-id=\"29e2b-122\">클래스의 새 기능이 점점 늘어남에 따라 이 기능은 더욱 중요해지고 있습니다.</span><span class=\"sxs-lookup\"><span data-stu-id=\"29e2b-122\">This becomes more important as classes grow new capabilities.</span></span> <span data-ttu-id=\"29e2b-123\">중간 이름 속성과 세 문자열을 사용하는 새 생성자를 `Person` 클래스에 추가합니다.</span><span class=\"sxs-lookup\"><span data-stu-id=\"29e2b-123\">Add a middle name property, and a new constructor that takes three strings to your `Person` class:</span></span>\n\n[!code-csharp[MiddleName](../../../../samples/csharp/tutorials/exploration/csharp6-finished/Program.cs#MiddleName)]  \n\n<span data-ttu-id=\"29e2b-124\">`MiddleName` 속성에 할당된 것이 이니셜라이저입니다.</span><span class=\"sxs-lookup\"><span data-stu-id=\"29e2b-124\">The assignment on the `MiddleName` property is an initializer.</span></span> <span data-ttu-id=\"29e2b-125\">이는 컴파일러가 생성한 중간 이름의 지원 필드를 초기화합니다.</span><span class=\"sxs-lookup\"><span data-stu-id=\"29e2b-125\">It initializes the compiler-generated backing field for the middle name.</span></span>\n"
- title: <span data-ttu-id="29e2b-126">식 본문 멤버</span><span class="sxs-lookup"><span data-stu-id="29e2b-126">Expression-bodied members</span></span>
  durationInMinutes: 2
  content: >
    <span data-ttu-id="29e2b-127">식 본문 멤버는 간단한 메서드에 대한 간단한 구문을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="29e2b-127">Expression-bodied members provide a lightweight syntax for lightweight methods.</span></span> <span data-ttu-id="29e2b-128">`Person` 클래스에는 두 가지 훌륭한 후보가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="29e2b-128">The `Person` class has two great candidates.</span></span> <span data-ttu-id="29e2b-129">`ToString`의 선언을 살펴봅니다.</span><span class="sxs-lookup"><span data-stu-id="29e2b-129">Look at the declaration of `ToString`:</span></span>


    ```csharp

    public override string ToString()

    {
        return FirstName + " " + LastName;
    }

    ```


    <span data-ttu-id="29e2b-130">`ToString` 선언을 다음 코드로 바꾸세요.</span><span class="sxs-lookup"><span data-stu-id="29e2b-130">Replace that declaration of `ToString` with the following code:</span></span>


    ```csharp

    public override string ToString() => FirstName + " " + LastName;

    ```


    <span data-ttu-id="29e2b-131">`AllCaps` 메서드에도 동일한 작업을 시도해 보세요.</span><span class="sxs-lookup"><span data-stu-id="29e2b-131">Try the same with the `AllCaps` method.</span></span> <span data-ttu-id="29e2b-132">사소한 개선 사항이지만 잘 사용한다면 특히 데이터 전송 개체(DTO) 및 최소한의 동작을 지원하는 다른 형식을 위한 더 가독성이 높은 코드를 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="29e2b-132">This is a small improvement, but when used wisely it creates much more readable code, especially for Data Transfer Objects (DTOs) and other types with minimal behavior.</span></span>
- title: <span data-ttu-id="29e2b-133">단일 클래스 가져오기</span><span class="sxs-lookup"><span data-stu-id="29e2b-133">Importing a single class</span></span>
  durationInMinutes: 2
  content: "<span data-ttu-id=\"29e2b-134\">코드 전체에서 한 클래스의 정적 메서드를 반복적으로 사용하는 경우 매번 클래스 이름을 포함하면 코드의 의미가 불분명해집니다.</span><span class=\"sxs-lookup\"><span data-stu-id=\"29e2b-134\">If you repeatedly use one class' static methods throughout your code, including the class name each time obscures the meaning of your code.</span></span> <span data-ttu-id=\"29e2b-135\">`Person` 클래스는 현재 <xref:System.Console?displayProperty=nameWithType>만 사용된 경우에도 `System` 네임스페이스를 가져옵니다.</span><span class=\"sxs-lookup\"><span data-stu-id=\"29e2b-135\">The `Person` class currently imports the `System` namespace, even though only <xref:System.Console?displayProperty=nameWithType> is used.</span></span> <span data-ttu-id=\"29e2b-136\">`using` 문을 다음과 같이 수정하세요.</span><span class=\"sxs-lookup\"><span data-stu-id=\"29e2b-136\">Modify the `using` statement as follows:</span></span>\n\n[!code-csharp[MiddleName](../../../../samples/csharp/tutorials/exploration/csharp6-finished/Program.cs#UsingStatic)]  \n\n<span data-ttu-id=\"29e2b-137\">`static using` 문은 [`string`](xref:System.String) 클래스 또는 <xref:System.Math?displayProperty=nameWithType> 클래스처럼 여러 정적 메서드가 있는 단일 클래스를 광범위하게 사용하는 대규모 프로그램에서 더욱 유용합니다.</span><span class=\"sxs-lookup\"><span data-stu-id=\"29e2b-137\">The `static using` statement becomes more useful in larger programs that make extensive use of a single class with many static methods, like the [`string`](xref:System.String) class or the <xref:System.Math?displayProperty=nameWithType> class.</span></span>\n"
- title: <span data-ttu-id="29e2b-138">더 나은 문자열 형식</span><span class="sxs-lookup"><span data-stu-id="29e2b-138">A better string format</span></span>
  durationInMinutes: 2
  content: "<span data-ttu-id=\"29e2b-139\">C# 6에는 문자열 및 다른 문자열 값을 생성하기 위해 계산되는 포함된 식에서 문자열을 작성하기 위한 새 구문이 포함됩니다.</span><span class=\"sxs-lookup\"><span data-stu-id=\"29e2b-139\">C# 6 contains new syntax for composing strings from a string and embedded expressions that are evaluated to produce other string values.</span></span> <span data-ttu-id=\"29e2b-140\">이러한 구문을 사용하도록 `ToString` 및 `AllCaps` 메서드를 변경할 수 있습니다.</span><span class=\"sxs-lookup\"><span data-stu-id=\"29e2b-140\">You can change the `ToString` and `AllCaps` methods to use this syntax:</span></span>\n\n[!code-csharp[StringInterpolation](../../../../samples/csharp/tutorials/exploration/csharp6-finished/Program.cs#StringInterpolation)]  \n\n<span data-ttu-id=\"29e2b-141\">`{` 및 `}` 사이에 위치 인수를 사용하는 대신 C# 식을 바로 작성하세요.</span><span class=\"sxs-lookup\"><span data-stu-id=\"29e2b-141\">Instead of positional arguments between the `{` and `}`, you write C# expressions directly.</span></span> <span data-ttu-id=\"29e2b-142\">`Main` 메서드에서도 같은 작업을 수행할 수 있습니다.</span><span class=\"sxs-lookup\"><span data-stu-id=\"29e2b-142\">You can do the same in the `Main` method.</span></span> <span data-ttu-id=\"29e2b-143\">기존 코드를 다음으로 바꿉니다.</span><span class=\"sxs-lookup\"><span data-stu-id=\"29e2b-143\">Replace the existing code with the following:</span></span>\n\n[!code-csharp[InterpolationMain](../../../../samples/csharp/tutorials/exploration/csharp6-finished/Program.cs#InterpolationMain)]  \n\n<span data-ttu-id=\"29e2b-144\">이러한 식의 단일 변수로 제한되지 않습니다.</span><span class=\"sxs-lookup\"><span data-stu-id=\"29e2b-144\">You're not limited to a single variable in these expressions.</span></span> <span data-ttu-id=\"29e2b-145\">새 예제를 시작하고 수정하여 문자열 보간과 함께 사용할 수 있는 다른 식을 보여드리도록 하겠습니다.</span><span class=\"sxs-lookup\"><span data-stu-id=\"29e2b-145\">Let's start with a new example and modify it to demonstrate other expressions you can use with string interpolation.</span></span> <span data-ttu-id=\"29e2b-146\">`Main` 메서드에서 대화형 창에 다음 코드를 붙여넣습니다.</span><span class=\"sxs-lookup\"><span data-stu-id=\"29e2b-146\">Paste the following code into the interactive window in the `Main` method:</span></span>\n\n[!code-csharp[Phrases](../../../../samples/csharp/tutorials/exploration/csharp6-finished/Program.cs#Phrases)]  \n<span data-ttu-id=\"29e2b-147\">LINQ를 사용하므로 대화형 창의 맨 위에 다음과 같은 using 문을 추가해야 합니다.</span><span class=\"sxs-lookup\"><span data-stu-id=\"29e2b-147\">That uses LINQ, so you'll need to add the following using statement to the top of the interactive window:</span></span>\n\n```csharp\nusing System.Linq;\n```\n\n<span data-ttu-id=\"29e2b-148\">지역 변수 `average`를 제거하고 보간된 문자열 식의 일부로 계산을 수행할 수 있습니다.</span><span class=\"sxs-lookup\"><span data-stu-id=\"29e2b-148\">You can remove the local variable `average` and perform that calculation as part of the interpolated string expression.</span></span> <span data-ttu-id=\"29e2b-149\">마지막 두 줄을 다음으로 바꿉니다.</span><span class=\"sxs-lookup\"><span data-stu-id=\"29e2b-149\">Replace the last two lines with the following:</span></span>\n\n```csharp\nWriteLine($\"The average word length is: {wordLength.Average()}\");\n```\n\n<span data-ttu-id=\"29e2b-150\">이전 예제를 실행하면 `Average`에 대한 출력에 원하는 것보다 더 많은 소수 자릿수가 포함됨을 알 수 있습니다.</span><span class=\"sxs-lookup\"><span data-stu-id=\"29e2b-150\">Running the preceding example, you would find that the output for `Average` has more decimal places than you would like.</span></span> <span data-ttu-id=\"29e2b-151\">문자열 보간 구문은 이전 서식 메서드를 통해 제공되는 모든 서식 문자열을 지원합니다.</span><span class=\"sxs-lookup\"><span data-stu-id=\"29e2b-151\">The string interpolation syntax supports all the format strings available using earlier formatting methods.</span></span> <span data-ttu-id=\"29e2b-152\">중괄호 안에 형식 문자열을 지정합니다.</span><span class=\"sxs-lookup\"><span data-stu-id=\"29e2b-152\">You specify the format string inside the braces.</span></span> <span data-ttu-id=\"29e2b-153\">서식 지정할 식 다음에 `:`을 추가합니다.</span><span class=\"sxs-lookup\"><span data-stu-id=\"29e2b-153\">Add a `:` following the expression to format:</span></span>\n\n```csharp\nWriteLine($\"The average word length is: {wordLength.Average():F2}\");\n```\n"
- title: <span data-ttu-id="29e2b-154">쉽고 빠른 null 확인</span><span class="sxs-lookup"><span data-stu-id="29e2b-154">Quick and easy null checks</span></span>
  durationInMinutes: 2
  content: "<span data-ttu-id=\"29e2b-155\">`?.`(null 조건부) 연산자는 추가 `if` 확인 없이 `null` 값을 간편하게 고려하는 논리를 더 쉽게 작성할 수 있게 해줍니다.</span><span class=\"sxs-lookup\"><span data-stu-id=\"29e2b-155\">The `?.` (null conditional) operator makes it easier to write logic that takes `null` values into account seamlessly, without extra `if` checks.</span></span> <span data-ttu-id=\"29e2b-156\">이 기능을 살펴보려면 먼저 대화형 창에 다음 코드를 복사하여 사용해 보세요.</span><span class=\"sxs-lookup\"><span data-stu-id=\"29e2b-156\">To explore the feature, start by copying the following code into the interactive window to try it:</span></span>\n\n```csharp\nusing System;\n\npublic class Program\n{\n    public static void Main()\n    {\n      string s = null;\n      Console.WriteLine(s.Length);\n    }\n}\n```\n\n<span data-ttu-id=\"29e2b-157\">샘플을 실행하면 <xref:System.NullReferenceException>이 throw됩니다.</span><span class=\"sxs-lookup\"><span data-stu-id=\"29e2b-157\">It throws a <xref:System.NullReferenceException> when you run the sample.</span></span> <span data-ttu-id=\"29e2b-158\">`.` 멤버 액세스 연산자를 **null 조건부 연산자**로 변경합니다.</span><span class=\"sxs-lookup\"><span data-stu-id=\"29e2b-158\">Change the `.` member access operator to the **null conditional operator**:</span></span>\n\n```csharp\nConsole.WriteLine(s?.Length);\n``` \n\n<span data-ttu-id=\"29e2b-159\">이러한 변경 후에는 출력이 표시되지 않습니다.</span><span class=\"sxs-lookup\"><span data-stu-id=\"29e2b-159\">After this change, there's no output.</span></span> <span data-ttu-id=\"29e2b-160\">`s.Length`의 결과가 `int`일 경우 `s?.Length`의 결과가 `int?`이기 때문입니다.</span><span class=\"sxs-lookup\"><span data-stu-id=\"29e2b-160\">That's because the result of `s?.Length` is an `int?` when the result of `s.Length` is an `int`.</span></span> <span data-ttu-id=\"29e2b-161\">이 예에서는 `s?.Length`가 `null`입니다.</span><span class=\"sxs-lookup\"><span data-stu-id=\"29e2b-161\">In this example, `s?.Length` is `null`.</span></span> <span data-ttu-id=\"29e2b-162\">`?.`는 왼쪽 피연산자가 `null`일 경우 `null`을 반환합니다.</span><span class=\"sxs-lookup\"><span data-stu-id=\"29e2b-162\">The `?.` returns `null` if its left operand is `null`.</span></span> <span data-ttu-id=\"29e2b-163\">오른쪽 피연산자 형식이 값 형식일 경우 `?.` 연산자는 해당 형식에 nullable 형식을 반환합니다.</span><span class=\"sxs-lookup\"><span data-stu-id=\"29e2b-163\">If the type of the right operand is a value type, the `?.` operator returns a nullable type for that type.</span></span> <span data-ttu-id=\"29e2b-164\">`?.` 외에 배열 또는 인덱서 액세스를 위해 `?[]`를 사용할 수 있습니다.</span><span class=\"sxs-lookup\"><span data-stu-id=\"29e2b-164\">In addition to `?.` you can use `?[]` for array or indexer access.</span></span> <span data-ttu-id=\"29e2b-165\">대화형 창에서 다음 코드를 실행합니다.</span><span class=\"sxs-lookup\"><span data-stu-id=\"29e2b-165\">Try the following code in the interactive window:</span></span>\n\n ```csharp\n char? c = s?[0];\n Console.WriteLine(c.HasValue);\n ```\n\n <span data-ttu-id=\"29e2b-166\">여러 조건부 연산자를 단일 식으로 결합할 수 있습니다.</span><span class=\"sxs-lookup\"><span data-stu-id=\"29e2b-166\">Multiple conditional operators can be combined into a single expression.</span></span> <span data-ttu-id=\"29e2b-167\">`null` 왼쪽 피연산자는 `null` 결과를 생성하여 간편하게 중첩된 if 절이 멤버의 멤버에 액세스하지 않도록 방지합니다.</span><span class=\"sxs-lookup\"><span data-stu-id=\"29e2b-167\">A `null` left operand produces a `null` result, making it easy to avoid nested if clauses to access members of members.</span></span> <span data-ttu-id=\"29e2b-168\">예를 들어 대화형 창에서 다음 코드를 실행해 보세요.</span><span class=\"sxs-lookup\"><span data-stu-id=\"29e2b-168\">For example, try the following code in the interactive window:</span></span>\n\n ```csharp\n string s = null;\n bool? hasMore = s?.ToCharArray()?.GetEnumerator()?.MoveNext();\n Console.WriteLine(hasMore.HasValue);\n ```\n\n <span data-ttu-id=\"29e2b-169\">**null 결합 연산자**를 사용하여 기본값을 제공하면 이전 예제를 단순화할 수 있습니다.</span><span class=\"sxs-lookup\"><span data-stu-id=\"29e2b-169\">The preceding example can be simplified by using the **null coalescing operator** to provide a default value:</span></span>\n\n ```csharp\n bool hasMore = s?.ToCharArray()?.GetEnumerator()?.MoveNext() ?? false;\n Console.WriteLine(hasMore);\n ```\n\n <span data-ttu-id=\"29e2b-170\">**null 조건부 연산자**를 사용하면 코어 논리를 간결하게 만들면서 `null` 값을 간편하게 테스트하는 코드를 작성할 수 있습니다.</span><span class=\"sxs-lookup\"><span data-stu-id=\"29e2b-170\">The **null conditional operator** helps you write code that makes your core logic clear while seamlessly testing for `null` values.</span></span>\n"
- title: <span data-ttu-id="29e2b-171">예외 필터</span><span class="sxs-lookup"><span data-stu-id="29e2b-171">Exception filters</span></span>
  durationInMinutes: 2
  content: "<span data-ttu-id=\"29e2b-172\">예외 필터를 사용하면 일부 조건에 따라 예외를 catch할 수 있습니다.</span><span class=\"sxs-lookup\"><span data-stu-id=\"29e2b-172\">Exception filters enable you to catch an exception based on some condition.</span></span> <span data-ttu-id=\"29e2b-173\">일반적인 사용 예로는 예외를 기록하지만 처리하지는 않는 필터 메서드를 만드는 경우가 있습니다.</span><span class=\"sxs-lookup\"><span data-stu-id=\"29e2b-173\">A typical use is to create a filter method that logs exceptions, but never handles those exceptions.</span></span> <span data-ttu-id=\"29e2b-174\">예외 필터는 `catch` 절을 실행해야 하는 경우 `true`이고, `catch` 절로 예외를 catch하지 않아야 하는 경우에는 `false`인 부울 식입니다.</span><span class=\"sxs-lookup\"><span data-stu-id=\"29e2b-174\">An exception filter is a boolean expression that is `true` when the `catch` clause should be executed, and `false` when the exception should not be caught by the `catch` clause.</span></span> <span data-ttu-id=\"29e2b-175\">대화형 창에서 다음 코드를 실행합니다. 예외 형식 및 메시지가 콘솔에 기록됩니다.</span><span class=\"sxs-lookup\"><span data-stu-id=\"29e2b-175\">Try the following code in the interactive window: It logs the exception type and message to the console.</span></span> <span data-ttu-id=\"29e2b-176\">예외를 처리할 수 없음을 나타내는 `false`가 반환됩니다.</span><span class=\"sxs-lookup\"><span data-stu-id=\"29e2b-176\">It returns `false` which indicates that the exception can't be handled.</span></span> <span data-ttu-id=\"29e2b-177\">대화형 창에서 프로그램을 사용해 보세요.</span><span class=\"sxs-lookup\"><span data-stu-id=\"29e2b-177\">Try the program in the interactive window.</span></span>\n\n```csharp\nusing System;\n\npublic class Program\n{\n    public static void Main()\n    {\n        try \n        {\n            string s = null;\n            Console.WriteLine(s.Length);\n\n        } catch (Exception e) when (LogException(e))\n        {\n        }\n        Console.WriteLine(\"Exception must have been handled\");\n    }\n\n    private static bool LogException(Exception e)\n    {\n        Console.WriteLine($\"\\tIn the log routine. Caught {e.GetType()}\");\n        Console.WriteLine($\"\\tMessage: {e.Message}\");\n        return false;\n    }\n}\n```\n\n<span data-ttu-id=\"29e2b-178\">`LogException` 메서드의 메시지가 표시된 후 기본 예외 메시지가 표시되어야 합니다.</span><span class=\"sxs-lookup\"><span data-stu-id=\"29e2b-178\">You should see the message from the `LogException` method, followed by the default exception message.</span></span> <span data-ttu-id=\"29e2b-179\">실험을 위해 `return false` 문을 `return true`로 변경하고 다시 실행하세요.</span><span class=\"sxs-lookup\"><span data-stu-id=\"29e2b-179\">Just to experiment, change the `return false` statement to `return true` and run this again.</span></span> <span data-ttu-id=\"29e2b-180\">이제 예외가 catch되고 프로그램의 실행이 완료됩니다.</span><span class=\"sxs-lookup\"><span data-stu-id=\"29e2b-180\">Now, the exception is caught and the program runs to completion.</span></span>\n\n<span data-ttu-id=\"29e2b-181\">예외 필터는 로깅 시나리오 외에 예외 속성으로 수행할 작업이 결정되는 경우에 가장 유용합니다.</span><span class=\"sxs-lookup\"><span data-stu-id=\"29e2b-181\">Beyond logging scenarios, exception filters can be most useful when a property of the exception determines what action to take.</span></span> <span data-ttu-id=\"29e2b-182\">예를 들어 <xref:System.AggregateException>을 살펴보면 포함된 예외가 무엇인지 확인하여 특정 예외에 따라 적절한 조치를 취할 수 있습니다.</span><span class=\"sxs-lookup\"><span data-stu-id=\"29e2b-182\">For example, you can look inside an <xref:System.AggregateException> to see what the contained exceptions are and take some appropriate action depending on the specific exception.</span></span>\n"
- title: <span data-ttu-id="29e2b-183">nameof 사용</span><span class="sxs-lookup"><span data-stu-id="29e2b-183">Using nameof</span></span>
  durationInMinutes: 2
  content: "<span data-ttu-id=\"29e2b-184\">`nameof` 연산자는 변수, 형식 또는 형식 멤버의 이름을 반환합니다.</span><span class=\"sxs-lookup\"><span data-stu-id=\"29e2b-184\">The `nameof` operator returns the name of any variable, a type, or a type's member.</span></span> <span data-ttu-id=\"29e2b-185\">대화형 창에서 다음 코드를 실행하고 어떻게 작동하는지 확인하세요.</span><span class=\"sxs-lookup\"><span data-stu-id=\"29e2b-185\">Try the following code in the interactive window to see how it works:</span></span>\n\n```csharp\nusing System;\nusing System.Collections.Generic;\n\npublic class Program\n{\n    public static void Main()\n    {\n        Console.WriteLine(nameof(System.String));\n        int j = 5;\n        Console.WriteLine(nameof(j));\n        List<string> names = new List<string>();\n        Console.WriteLine(nameof(names));\n    }\n}\n```\n\n<span data-ttu-id=\"29e2b-186\">출력은 변수 또는 형식의 이름과 일치합니다.</span><span class=\"sxs-lookup\"><span data-stu-id=\"29e2b-186\">The output matches the name of the variable or type.</span></span> <span data-ttu-id=\"29e2b-187\">정규화된 형식 이름(예: `System.String`)을 제공한 경우에도 `nameof` 연산자는 정규화되지 않은 이름을 반환합니다.</span><span class=\"sxs-lookup\"><span data-stu-id=\"29e2b-187\">Even when you provided the fully qualified type name (such as `System.String`) the `nameof` operator returns the unqualified name.</span></span> <span data-ttu-id=\"29e2b-188\">이 기능은 매개 변수 또는 속성 이름을 문자열로 변환해야 할 때 가장 유용합니다.</span><span class=\"sxs-lookup\"><span data-stu-id=\"29e2b-188\">This feature is most useful when you need to convert a parameter or property name to a string.</span></span> <span data-ttu-id=\"29e2b-189\">예를 들어 <xref:System.ComponentModel.INotifyPropertyChanged>를 구현할 때 <xref:System.ArgumentNullException> 또는 <xref:System.ArgumentException>을 throw하거나 변경된 속성의 이름을 capture하는 경우가 있습니다.</span><span class=\"sxs-lookup\"><span data-stu-id=\"29e2b-189\">Examples include capturing the name of an argument for throwing a <xref:System.ArgumentNullException> or <xref:System.ArgumentException>, or capturing the name of a changed property when implementing <xref:System.ComponentModel.INotifyPropertyChanged>.</span></span> \n"
- title: <span data-ttu-id="29e2b-190">새 개체 초기화 구문</span><span class="sxs-lookup"><span data-stu-id="29e2b-190">New object initialization syntax</span></span>
  durationInMinutes: 2
  content: "<span data-ttu-id=\"29e2b-191\">개체 이니셜라이저 구문은 이제 속성 및 필드뿐 아니라 *인덱서* 초기화를 지원합니다.</span><span class=\"sxs-lookup\"><span data-stu-id=\"29e2b-191\">Object initializer syntax now supports initializing *indexers* as well as properties and fields.</span></span> <span data-ttu-id=\"29e2b-192\">이 추가를 통해 사전 및 기타 형식을 더 쉽게 초기화할 수 있습니다.</span><span class=\"sxs-lookup\"><span data-stu-id=\"29e2b-192\">This addition makes it easier to initialize dictionaries and other types.</span></span> <span data-ttu-id=\"29e2b-193\">사전으로 시작하세요.</span><span class=\"sxs-lookup\"><span data-stu-id=\"29e2b-193\">Start with a dictionary.</span></span> <span data-ttu-id=\"29e2b-194\">대화형 창에서 다음 코드를 실행합니다.</span><span class=\"sxs-lookup\"><span data-stu-id=\"29e2b-194\">Run the following code in the interactive window:</span></span>\n\n```csharp\nvar messages = new Dictionary<int, string>\n{\n    [404] = \"Page not Found\",\n    [302] = \"Page moved, but left a forwarding address.\",\n    [500] = \"The web server can't come out to play today.\"\n};\n\nConsole.WriteLine(messages[302]);\n```\n\n<span data-ttu-id=\"29e2b-195\">인덱서에 값을 설정하는 이 구문은 인덱서에 액세스 가능한 집합 접근자가 있는 모든 유형에 사용할 수 있습니다.</span><span class=\"sxs-lookup\"><span data-stu-id=\"29e2b-195\">This syntax, which sets a value in an indexer, can be used for any type that has an accessible set accessor on an indexer.</span></span>\n\n<span data-ttu-id=\"29e2b-196\">두 번째 변경을 통해 시퀀스를 나타내는 유형에 대한 이니셜라이저 구문을 쉽게 사용할 수 있습니다.</span><span class=\"sxs-lookup\"><span data-stu-id=\"29e2b-196\">A second change makes it easier to enable initializer syntax for types that represent sequences.</span></span> <span data-ttu-id=\"29e2b-197\">컬렉션 이니셜라이저는 <xref:System.Collections.IEnumerable>을 구현하며 공개적으로 액세스할 수 있는 `Add` 메서드가 있는 모든 클래스에서 사용할 수 있습니다.</span><span class=\"sxs-lookup\"><span data-stu-id=\"29e2b-197\">Collection initializers can be used on any class that implements <xref:System.Collections.IEnumerable> and has a publicly accessible `Add` method.</span></span> <span data-ttu-id=\"29e2b-198\">해당 `Add` 메서드는 이제 확장 메서드가 될 수 있습니다.</span><span class=\"sxs-lookup\"><span data-stu-id=\"29e2b-198\">That `Add` method can now be an extension method.</span></span> \n\n<span data-ttu-id=\"29e2b-199\">다음 예제에서는 이 구문에 대한 한 가지 시나리오를 보여줍니다.</span><span class=\"sxs-lookup\"><span data-stu-id=\"29e2b-199\">The following example shows one scenario for this syntax.</span></span> <span data-ttu-id=\"29e2b-200\">`IEnumerable<Point3D>`를 구현하고, 세 개의 인수를 허용하는 포인트를 추가하는 메서드가 있는 `Path` 클래스가 생성됩니다.</span><span class=\"sxs-lookup\"><span data-stu-id=\"29e2b-200\">It creates a `Path` class that implements `IEnumerable<Point3D>` and has a method to add points that take three arguments.</span></span> <span data-ttu-id=\"29e2b-201\">`Extensions` 클래스는 세 가지 구성 요소에서 새 점을 추가하는 추가 `Add` 메서드를 만듭니다.</span><span class=\"sxs-lookup\"><span data-stu-id=\"29e2b-201\">The `Extensions` class creates an additional `Add` method to add a new point from its three components.</span></span> <span data-ttu-id=\"29e2b-202\">이 샘플은 현재 환경의 제한으로 인해 대화형으로 실행되지 않습니다.</span><span class=\"sxs-lookup\"><span data-stu-id=\"29e2b-202\">This sample does not currently run interactively due to restrictions in the environment.</span></span>\n\n```csharp\npublic class Path : IEnumerable<Point3D>\n{\n    private List<Point3D> points = new List<Point3D>();\n    public IEnumerator<Point3D> GetEnumerator() => points.GetEnumerator();\n    IEnumerator IEnumerable.GetEnumerator() => points.GetEnumerator();\n\n    public void Add(Point3D pt) => points.Add(pt);\n}\n\npublic static class Extensions\n{\n    public static void Add(this Path path, double x, double y, double z) => path.Add(new Point3D(x, y, z));\n}\n```\n"
- content: <span data-ttu-id="29e2b-203">C# 6의 새 기능 살펴보기를 완료했습니다.</span><span class="sxs-lookup"><span data-stu-id="29e2b-203">You've completed an exploration of the new features in C# 6.</span></span> <span data-ttu-id="29e2b-204">이제 애플리케이션에서 직접 사용해 보세요.</span><span class="sxs-lookup"><span data-stu-id="29e2b-204">Now try them yourself in your applications.</span></span>

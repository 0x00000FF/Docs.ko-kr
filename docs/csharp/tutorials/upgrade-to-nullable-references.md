---
title: nullable 참조 형식을 사용하여 디자인
description: 이 고급 자습서에서는 nullable 참조 형식을 소개합니다. 참조 값이 null일 수 있는 경우에 대한 디자인 의도를 표현하고 컴파일러가 null일 수 없는 경우를 적용하게 하는 방법을 알아봅니다.
ms.date: 02/19/2019
ms.custom: mvc
ms.openlocfilehash: 357ebd13ca4c610f1c65009621ee628a90c70b15
ms.sourcegitcommit: 6f28b709592503d27077b16fff2e2eacca569992
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 08/28/2019
ms.locfileid: "70105770"
---
# <a name="tutorial-migrate-existing-code-with-nullable-reference-types"></a><span data-ttu-id="0b0c2-104">자습서: nullable 참조 형식이 있는 기존 코드 마이그레이션</span><span class="sxs-lookup"><span data-stu-id="0b0c2-104">Tutorial: Migrate existing code with nullable reference types</span></span>

<span data-ttu-id="0b0c2-105">C# 8에서는 nullable 값 형식이 값 형식을 보완하는 것과 동일한 방식으로 참조 형식을 보완하는 **nullable 참조 형식**이 도입되었습니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-105">C# 8 introduces **nullable reference types**, which complement reference types the same way nullable value types complement value types.</span></span> <span data-ttu-id="0b0c2-106">형식에 `?`를 추가하여 변수를 **nullable 참조 형식**으로 선언합니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-106">You declare a variable to be a **nullable reference type** by appending a `?` to the type.</span></span> <span data-ttu-id="0b0c2-107">예를 들어 `string?`는 nullable `string`을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-107">For example, `string?` represents a nullable `string`.</span></span> <span data-ttu-id="0b0c2-108">이러한 새 형식을 사용하여 디자인 의도를 보다 명확하게 표현할 수 있습니다. ‘항상 값이 있어야 하는’ 변수도 있고, ‘값이 누락될 수 있는’ 변수도 있습니다.  </span><span class="sxs-lookup"><span data-stu-id="0b0c2-108">You can use these new types to more clearly express your design intent: some variables *must always have a value*, others *may be missing a value*.</span></span> <span data-ttu-id="0b0c2-109">참조 형식을 갖는 기존 변수는 모두 nullable이 아닌 참조 형식으로 해석됩니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-109">Any existing variables of a reference type would be interpreted as a non-nullable reference type.</span></span> 

<span data-ttu-id="0b0c2-110">이 자습서에서는 다음과 같은 작업을 수행하는 방법을 알아봅니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-110">In this tutorial, you'll learn how to:</span></span>

> [!div class="checklist"]
> - <span data-ttu-id="0b0c2-111">코드를 작업할 때 null 참조 검사를 활성화합니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-111">Enable null reference checks as you work with code.</span></span>
> - <span data-ttu-id="0b0c2-112">null 값과 각종 경고를 진단하고 수정합니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-112">Diagnose and correct different warnings related to null values.</span></span>
> - <span data-ttu-id="0b0c2-113">nullable이 활성화된 컨텍스트와 nullable이 비활성화된 컨텍스트 간의 인터페이스를 관리합니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-113">Manage the interface between nullable enabled and nullable disabled contexts.</span></span>
> - <span data-ttu-id="0b0c2-114">nullable 주석 컨텍스트를 제어합니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-114">Control nullable annotation contexts.</span></span>

## <a name="prerequisites"></a><span data-ttu-id="0b0c2-115">전제 조건</span><span class="sxs-lookup"><span data-stu-id="0b0c2-115">Prerequisites</span></span>

<span data-ttu-id="0b0c2-116">C# 8.0 베타 컴파일러를 포함하여 .NET Core를 실행하도록 머신을 설정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-116">You'll need to set up your machine to run .NET Core, including the C# 8.0 beta compiler.</span></span> <span data-ttu-id="0b0c2-117">C# 8 베타 컴파일러는 [Visual Studio 2019](https://visualstudio.microsoft.com/downloads/?utm_medium=microsoft&utm_source=docs.microsoft.com&utm_campaign=inline+link&utm_content=download+vs2019) 또는 최신 [.NET Core 3.0 미리 보기](https://dotnet.microsoft.com/download/dotnet-core/3.0)에서 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-117">The C# 8 beta compiler is available with [Visual Studio 2019](https://visualstudio.microsoft.com/downloads/?utm_medium=microsoft&utm_source=docs.microsoft.com&utm_campaign=inline+link&utm_content=download+vs2019), or the latest [.NET Core 3.0 preview](https://dotnet.microsoft.com/download/dotnet-core/3.0).</span></span>

<span data-ttu-id="0b0c2-118">이 자습서에서는 Visual Studio 또는 .NET Core CLI를 포함하여 C# 및 .NET에 익숙하다고 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-118">This tutorial assumes you're familiar with C# and .NET, including either Visual Studio or the .NET Core CLI.</span></span>

## <a name="explore-the-sample-application"></a><span data-ttu-id="0b0c2-119">샘플 애플리케이션 살펴보기</span><span class="sxs-lookup"><span data-stu-id="0b0c2-119">Explore the sample application</span></span>

<span data-ttu-id="0b0c2-120">여기서 마이그레이션할 샘플 애플리케이션은 RSS 피드 리더기 웹앱입니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-120">The sample application that you'll migrate is an RSS feed reader web app.</span></span> <span data-ttu-id="0b0c2-121">이 애플리케이션은 하나의 RSS 피드를 읽고 가장 최근 기사의 요약을 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-121">It reads from a single RSS feed and displays summaries for the most recent articles.</span></span> <span data-ttu-id="0b0c2-122">표시되는 기사를 클릭하여 사이트를 방문할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-122">You can click on any of the articles to visit the site.</span></span> <span data-ttu-id="0b0c2-123">이 애플리케이션은 비교적 최근에 작성되었지만, nullable 참조 형식을 사용할 수 있기 전에 작성되었습니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-123">The application is relatively new but was written before nullable reference types were available.</span></span> <span data-ttu-id="0b0c2-124">이 애플리케이션에는 바람직한 설계 원칙이 적용되었지만, 이 중요한 언어 기능을 남용하지는 마시기 바랍니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-124">The design decisions for the application represented sound principles, but don't take advantage of this important language feature.</span></span>

<span data-ttu-id="0b0c2-125">샘플 애플리케이션에는 앱의 주요 기능의 유효성을 검사하는 단위 테스트 라이브러리가 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-125">The sample application includes a unit test library that validates the major functionality of the app.</span></span> <span data-ttu-id="0b0c2-126">생성되는 경고에 따라 구현을 조금이라도 변경하는 경우, 이 프로젝트를 사용하여 안전하게 업그레이드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-126">That project will make it easier to upgrade safely, if you change any of the implementation based on the warnings generated.</span></span> <span data-ttu-id="0b0c2-127">시작 코드는 [dotnet/samples](https://github.com/dotnet/samples/tree/master/csharp/tutorials/nullable-reference-migration/start) GitHub 리포지토리에서 다운로드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-127">You can download the starter code from the [dotnet/samples](https://github.com/dotnet/samples/tree/master/csharp/tutorials/nullable-reference-migration/start) GitHub repository.</span></span>

<span data-ttu-id="0b0c2-128">프로젝트를 마이그레이션할 때 목표는 변수의 nullable 여부를 어떻게 설정할지 명확히 표현할 수 있도록 새로운 언어 기능을 활용하고, nullable 주석 컨텍스트와 nullable 경고 컨텍스트를 `enabled`로 설정할 때 컴파일러에서 경고가 생성되지 않도록 하는 것이 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-128">Your goal migrating a project should be to leverage the new language features so that you clearly express your intent on the nullability of variables, and do so in such a way that the compiler doesn't generate warnings when you have the nullable annotation context and nullable warning context set to `enabled`.</span></span>

## <a name="upgrade-the-projects-to-c-8"></a><span data-ttu-id="0b0c2-129">프로젝트를 C# 8로 업그레이드</span><span class="sxs-lookup"><span data-stu-id="0b0c2-129">Upgrade the projects to C# 8</span></span>

<span data-ttu-id="0b0c2-130">첫 번째 단계로 마이그레이션 작업의 범위를 확인하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-130">A good first step is to determine the scope of the migration task.</span></span> <span data-ttu-id="0b0c2-131">시작하려면 먼저 프로젝트를 C# 8.0(이상)으로 업그레이드합니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-131">Start by upgrading the project to C# 8.0 (or newer).</span></span> <span data-ttu-id="0b0c2-132">웹 프로젝트의 csproj 파일과 단위 테스트 프로젝트의 csproj 파일에 각각 `LangVersion` 요소를 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-132">Add the `LangVersion` element to both csproj files for the web project and the unit test project:</span></span>

```xml
<LangVersion>8.0</LangVersion>
```

<span data-ttu-id="0b0c2-133">언어 버전을 업그레이드하면 C# 8.0이 선택되지만, nullable 주석 컨텍스트와 nullable 경고 컨텍스트가 활성화되지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-133">Upgrading the language version selects C# 8.0, but does not enable the nullable annotation context or the nullable warning context.</span></span> <span data-ttu-id="0b0c2-134">프로젝트를 다시 빌드하여 경고 없이 빌드되는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-134">Rebuild the project to ensure that it builds without warnings.</span></span>

<span data-ttu-id="0b0c2-135">다음 단계로 nullable 주석 컨텍스트를 켜고 경고가 몇 개나 생성되는지 살펴보는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-135">A good next step is to turn on the nullable annotation context and see how many warnings are generated.</span></span> <span data-ttu-id="0b0c2-136">솔루션의 두 csproj 파일에서 `LangVersion` 요소 아래에 각각 다음 요소를 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-136">Add the following element to both csproj files in the solution, directly under the `LangVersion` element:</span></span>

```xml
<Nullable>enable</Nullable>
```

> [!IMPORTANT]
> <span data-ttu-id="0b0c2-137">`Nullable` 요소의 이전 이름은 `NullableContextOptions`였습니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-137">The `Nullable` element was previously named `NullableContextOptions`.</span></span> <span data-ttu-id="0b0c2-138">Visual Studio 2019, 16.2-p1에서는 바뀐 이름이 제공됩니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-138">The rename ships with Visual Studio 2019, 16.2-p1.</span></span> <span data-ttu-id="0b0c2-139">.NET Core SDK 3.0.100-preview5-011568에는 이 변경이 적용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-139">The .NET Core SDK 3.0.100-preview5-011568 does not have this change.</span></span> <span data-ttu-id="0b0c2-140">.NET Core CLI를 사용하는 경우 다음 미리 보기를 사용할 수 있을 때까지 `NullableContextOptions`를 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-140">If you are using the .NET Core CLI, you'll need to use `NullableContextOptions` until the next preview is available.</span></span>

<span data-ttu-id="0b0c2-141">테스트 빌드를 수행하고 경고 목록을 살펴봅니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-141">Do a test build, and notice the warning list.</span></span> <span data-ttu-id="0b0c2-142">이 작은 애플리케이션에서 컴파일러가 경고를 5개 생성하는 것을 볼 수 있습니다. 여기서는 nullable 주석 컨텍스트를 활성화 상태로 두고 프로젝트 전체의 경고를 수정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-142">In this small application, the compiler generates five warnings, so it's likely you'd leave the nullable annotation context enabled and start fixing warnings for the entire project.</span></span>

<span data-ttu-id="0b0c2-143">이 방법은 규모가 작은 프로젝트에서만 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-143">That strategy works only for smaller projects.</span></span> <span data-ttu-id="0b0c2-144">규모가 큰 프로젝트에서는 전체 코드베이스에서 nullable 주석 컨텍스트를 활성화하여 생성되는 경고의 개수가 많기 때문에 경고를 체계적으로 수정하기가 어렵습니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-144">For any larger projects, the number of warnings generated by enabling the nullable annotation context for the entire codebase makes it harder to fix the warnings systematically.</span></span> <span data-ttu-id="0b0c2-145">규모가 큰 엔터프라이즈 프로젝트에서는 한 번에 프로젝트 하나씩 마이그레이션하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-145">For larger enterprise projects, you'll often want to migrate one project at a time.</span></span> <span data-ttu-id="0b0c2-146">각 프로젝트에서 한 번에 하나의 클래스 또는 파일을 마이그레이션합니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-146">In each project, migrate one class or file at a time.</span></span>

## <a name="warnings-help-discover-original-design-intent"></a><span data-ttu-id="0b0c2-147">원래의 설계 의도를 파악하는 데 도움이 되는 경고</span><span class="sxs-lookup"><span data-stu-id="0b0c2-147">Warnings help discover original design intent</span></span>

<span data-ttu-id="0b0c2-148">2개의 클래스에서 여러 개의 경고가 생성되었습니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-148">There are two classes that generate multiple warnings.</span></span> <span data-ttu-id="0b0c2-149">`NewsStoryViewModel` 클래스부터 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-149">Start with the `NewsStoryViewModel` class.</span></span> <span data-ttu-id="0b0c2-150">경고의 범위를 현재 작업 중인 코드 섹션으로 한정할 수 있도록 두 csproj 파일에서 각각 `Nullable` 요소를 제거합니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-150">Remove the `Nullable` element from both csproj files so that you can limit the scope of warnings to the sections of code you're working with.</span></span> <span data-ttu-id="0b0c2-151">*NewsStoryViewModel.cs* 파일을 열고 다음 지시문을 추가하여 `NewsStoryViewModel`에서 nullable 주석 컨텍스트를 활성화하고 클래스 정의 후에 이를 복원합니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-151">Open the *NewsStoryViewModel.cs* file and add the following directives to enable the nullable annotation context for the `NewsStoryViewModel` and restore it following that class definition:</span></span>

```csharp
#nullable enable
public class NewsStoryViewModel
{
    public DateTimeOffset Published { get; set; }
    public string Title { get; set; }
    public string Uri { get; set; }
}
#nullable restore
```

<span data-ttu-id="0b0c2-152">위의 2개의 지시문은 마이그레이션 노력을 집중하는 데 도움이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-152">These two directives help you focus your migration efforts.</span></span> <span data-ttu-id="0b0c2-153">현재 작업 중인 코드 영역에 해당하는 nullable 경고가 생성되었습니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-153">The nullable warnings are generated for the area of code you're actively working on.</span></span> <span data-ttu-id="0b0c2-154">프로젝트 전체에서 경고를 켤 준비가 될 때까지 일단 그대로 둡니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-154">You'll leave them on until you're ready to turn on the warnings for the entire project.</span></span> <span data-ttu-id="0b0c2-155">나중에 프로젝트 전체에서 nullable 주석을 켰을 때 컨텍스트가 실수로 비활성화되지 않도록 `disable` 값 대신 `restore` 값을 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-155">You should use the `restore` rather than `disable` value so that you don't accidentally disable the context later when you've turned on nullable annotations for the entire project.</span></span> <span data-ttu-id="0b0c2-156">프로젝트 전체에서 nullable 주석 컨텍스트를 켠 후에 해당 프로젝트에서 모든 `#nullable` pragma를 제거할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-156">Once you've turned on the nullable annotation context for the entire project, you can remove all the `#nullable` pragmas from that project.</span></span>

<span data-ttu-id="0b0c2-157">`NewsStoryViewModel` 클래스는 DTO(데이터 전송 개체)로, 2개의 속성이 읽기/쓰기 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-157">The `NewsStoryViewModel` class is a data transfer object (DTO) and two of the properties are read/write strings:</span></span>

[!code-csharp[InitialViewModel](~/samples/csharp/tutorials/nullable-reference-migration/start/SimpleFeedReader/ViewModels/NewsStoryViewModel.cs#StarterViewModel)]

<span data-ttu-id="0b0c2-158">이 2개의 속성 때문에 `CS8618`, “Non-nullable property is uninitialized”(nullable이 아닌 속성이 초기화되지 않았습니다.)가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-158">These two properties cause `CS8618`, "Non-nullable property is uninitialized".</span></span> <span data-ttu-id="0b0c2-159">2개의 `string` 속성 모두 `NewsStoryViewModel`이 생성될 때 기본값이 `null`이므로 원인을 쉽게 파악할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-159">That's clear enough: both `string` properties have the default value of `null` when a `NewsStoryViewModel` is constructed.</span></span> <span data-ttu-id="0b0c2-160">이때 중요한 것은 `NewsStoryViewModel` 개체가 어떻게 생성되는지 알아내는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-160">What's important to discover is how `NewsStoryViewModel` objects are constructed.</span></span> <span data-ttu-id="0b0c2-161">클래스를 살펴봐도 `null` 값이 설계의 일부인지 아니면 이러한 개체가 생성될 때마다 해당 개체가 null이 아닌 값으로 설정되는 것인지 파악하기가 어렵습니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-161">Looking at this class, you can't tell if the `null` value is part of the design, or if these objects are set to non-null values whenever one is created.</span></span> <span data-ttu-id="0b0c2-162">뉴스 기사는 `NewsService` 클래스의 `GetNews` 메서드에서 생성됩니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-162">The news stories are created in the `GetNews` method of the `NewsService` class:</span></span>

[!code-csharp[StarterCreateNewsItem](~/samples/csharp/tutorials/nullable-reference-migration/start/SimpleFeedReader/Services/NewsService.cs#CreateNewsItem)]

<span data-ttu-id="0b0c2-163">위 코드 블록에서는 몇 가지 작업이 진행되고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-163">There's quite a bit going on in the preceding block of code.</span></span> <span data-ttu-id="0b0c2-164">이 애플리케이션은 [AutoMapper](https://automapper.org/) NuGet 패키지를 사용하여 `ISyndicationItem`으로부터 뉴스 항목을 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-164">This application uses the [AutoMapper](https://automapper.org/) NuGet package to construct a news item from an `ISyndicationItem`.</span></span> <span data-ttu-id="0b0c2-165">이 하나의 문에서 뉴스 기사 항목이 생성되고 속성이 설정된다는 사실을 파악했습니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-165">You've discovered that the news story items are constructed and the properties are set in that one statement.</span></span> <span data-ttu-id="0b0c2-166">따라서 `NewsStoryViewModel`의 설계 의도는 이러한 속성이 `null` 값을 갖지 않도록 하는 것임을 알 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-166">That means the design for the `NewsStoryViewModel` indicates that these properties should never have the `null` value.</span></span> <span data-ttu-id="0b0c2-167">이러한 속성은 **nullable이 아닌 참조 형식**이 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-167">These properties should be **nonnullable reference types**.</span></span> <span data-ttu-id="0b0c2-168">이렇게 해야 원래 설계 의도가 가장 잘 표현됩니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-168">That best expresses the original design intent.</span></span> <span data-ttu-id="0b0c2-169">실제로 모든 `NewsStoryViewModel`이 null이 아닌 값으로 올바르게 인스턴스화되었습니다. </span><span class="sxs-lookup"><span data-stu-id="0b0c2-169">In fact, any `NewsStoryViewModel` *is* correctly instantiated with non-null values.</span></span> <span data-ttu-id="0b0c2-170">그렇다면 다음과 같은 초기화 코드가 유효한 수정이 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-170">That makes the following initialization code a valid fix:</span></span>

```csharp
public class NewsStoryViewModel
{
    public DateTimeOffset Published { get; set; }
    public string Title { get; set; } = default!;
    public string Uri { get; set; } = default!;
}
```

<span data-ttu-id="0b0c2-171">`Title`과 `Uri`에 `default`(`string` 형식의 경우 `null`)를 할당해도 프로그램의 런타임 동작이 변경되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-171">The assignment of `Title` and `Uri` to `default` which is `null` for the `string` type doesn't change the runtime behavior of the program.</span></span> <span data-ttu-id="0b0c2-172">`NewsStoryViewModel`은 전과 동일하게 null 값으로 생성되지만, 이제 컴파일러가 경고를 보고하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-172">The `NewsStoryViewModel` is still constructed with null values, but now the compiler reports no warnings.</span></span> <span data-ttu-id="0b0c2-173">`default` 식 뒤에 **null 허용 연산자**인 `!` 문자가 오기 때문에 컴파일러는 선행 식이 null이 아님을 알 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-173">The **null-forgiving operator**, the `!` character following the `default` expression tells the compiler that the preceding expression is not null.</span></span> <span data-ttu-id="0b0c2-174">이 방법은 다른 변경 사항을 수행하는 경우 코드 베이스에 훨씬 더 많은 변경이 적용될 때는 유용하게 사용할 수 있지만, 이 애플리케이션에서는 보다 빠르고 효과적인 솔루션이 있습니다. 바로 `NewsStoryViewModel`을 모든 속성이 생성자에서 설정되는, 변경이 불가능한 형식으로 만드는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-174">This technique may be expedient when other changes force much larger changes to a code base, but in this application there is a relatively quick and better solution: Make the `NewsStoryViewModel` an immutable type where all the properties are set in the constructor.</span></span> <span data-ttu-id="0b0c2-175">`NewsStoryViewModel`에 다음 변경 내용을 적용합니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-175">Make the following changes to the `NewsStoryViewModel`:</span></span>

[!code-csharp[FinishedViewModel](~/samples/csharp/tutorials/nullable-reference-migration/finished/SimpleFeedReader/ViewModels/NewsStoryViewModel.cs#FinishedViewModel)]

<span data-ttu-id="0b0c2-176">그런 다음, AutoMapper를 구성하는 코드가 속성을 설정하는 대신 생성자를 사용하도록 수정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-176">Once that's done, you need to update the code that configures the AutoMapper so that it uses the constructor rather than setting properties.</span></span> <span data-ttu-id="0b0c2-177">`NewsService.cs`를 열고 파일 하단에서 다음 코드를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-177">Open `NewsService.cs` and look for the following code at the bottom of the file:</span></span>

[!code-csharp[StarterAutoMapper](~/samples/csharp/tutorials/nullable-reference-migration/start/SimpleFeedReader/Services/NewsService.cs#ConfigureAutoMapper)]

<span data-ttu-id="0b0c2-178">이 코드는 `ISyndicationItem` 개체의 속성을 `NewsStoryViewModel` 속성에 매핑합니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-178">That code maps properties of the `ISyndicationItem` object to the `NewsStoryViewModel` properties.</span></span> <span data-ttu-id="0b0c2-179">AutoMapper가 대신 생성자를 사용하여 매핑을 수행하도록 수정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-179">You want the AutoMapper to provide the mapping using a constructor instead.</span></span> <span data-ttu-id="0b0c2-180">위 코드를 다음 automapper 구성으로 바꿉니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-180">Replace the above code with the following automapper configuration:</span></span>

[!code-csharp[FinishedViewModel](~/samples/csharp/tutorials/nullable-reference-migration/finished/SimpleFeedReader/Services/NewsService.cs#ConfigureAutoMapper)]

<span data-ttu-id="0b0c2-181">이 클래스는 규모가 작고 신중히 검사했기 때문에 이 클래스 선언 위에서 `#nullable enable` 지시문을 켜야 합니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-181">Notice that because this class is small, and you've examined carefully, you should turn on the `#nullable enable` directive above this class declaration.</span></span> <span data-ttu-id="0b0c2-182">생성자를 변경한 결과 무언가 잘못되었을 수 있으므로 계속 진행하기 전에 먼저 모든 테스트를 실행하여 애플리케이션을 테스트하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-182">The change to the constructor could have broken something, so it's worthwhile to run all the tests and test the application before moving on.</span></span>

<span data-ttu-id="0b0c2-183">지금까지의 작업을 통해 원래 설계 의도가 변수를 `null`로 설정하지 않는 것인지 확인하는 방법을 알아보았습니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-183">The first set of changes showed you how to discover when the original design indicated that variables shouldn't be set to `null`.</span></span> <span data-ttu-id="0b0c2-184">이 방법을 **correct by construction**(생성에 의한 올바름)이라고 부릅니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-184">The technique is referred to as **correct by construction**.</span></span> <span data-ttu-id="0b0c2-185">개체와 개체의 속성을 생성할 때 이것이 `null`이 될 수 없다고 선언하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-185">You declare that an object and its properties cannot be `null` when it's constructed.</span></span> <span data-ttu-id="0b0c2-186">컴파일러는 해당 속성이 생성 후에 `null`로 설정되지 않도록 흐름 분석을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-186">The compiler's flow analysis provides assurance that those properties aren't set to `null` after construction.</span></span> <span data-ttu-id="0b0c2-187">이 생성자는 외부 코드에 의해 호출되는 것을 볼 수 있는데, 이 코드는 **nullable 감지 불가**입니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-187">Note that this constructor is called by external code, and that code is **nullable oblivious**.</span></span> <span data-ttu-id="0b0c2-188">새로운 구문에서는 런타임 검사를 제공하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-188">The new syntax doesn't provide runtime checking.</span></span> <span data-ttu-id="0b0c2-189">따라서 외부 코드가 컴파일러의 흐름 분석을 피해갈 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-189">External code might circumvent the compiler's flow analysis.</span></span> 

<span data-ttu-id="0b0c2-190">클래스의 구조가 설계 의도에 대한 또 다른 힌트를 주는 경우도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-190">Other times, the structure of a class provides different clues to the intent.</span></span> <span data-ttu-id="0b0c2-191">*Pages* 폴더에서 *Error.cshtml.cs* 파일을 엽니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-191">Open the *Error.cshtml.cs* file in the *Pages* folder.</span></span> <span data-ttu-id="0b0c2-192">`ErrorViewModel`에 다음 코드가 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-192">The `ErrorViewModel` contains the following code:</span></span>

[!code-csharp[StarterErrorModel](~/samples/csharp/tutorials/nullable-reference-migration/start/SimpleFeedReader/Pages/Error.cshtml.cs#StartErrorModel)]

<span data-ttu-id="0b0c2-193">클래스 선언 앞에 `#nullable enable` 지시문을 추가하고, 클래스 선언 뒤에 `#nullable restore` 지시문을 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-193">Add the `#nullable enable` directive before the class declaration, and a `#nullable restore` directive after it.</span></span> <span data-ttu-id="0b0c2-194">`RequestId`가 초기화되지 않았다는 경고가 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-194">You'll get one warning that `RequestId` is not initialized.</span></span> <span data-ttu-id="0b0c2-195">클래스를 살펴보니 `RequestId` 속성은 경우에 따라 null이 되어야 한다는 사실을 알 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-195">By looking at the class, you should decide that the `RequestId` property should be null in some cases.</span></span> <span data-ttu-id="0b0c2-196">`ShowRequestId` 속성이 존재한다는 사실이 누락된 값이 있을 수 있음을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-196">The existence of the `ShowRequestId` property indicates that missing values are possible.</span></span> <span data-ttu-id="0b0c2-197">`null`이 유효하므로 `string` 형식에 `?`을 추가하여 `RequestId` 속성이 ‘nullable 참조 형식’임을 나타냅니다. </span><span class="sxs-lookup"><span data-stu-id="0b0c2-197">Because `null` is valid, add the `?` on the `string` type to indicate the `RequestId` property is a *nullable reference type*.</span></span> <span data-ttu-id="0b0c2-198">다음은 완성된 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-198">The final class looks like the following example:</span></span>

[!code-csharp[FinishedErrorModel](~/samples/csharp/tutorials/nullable-reference-migration/finished/SimpleFeedReader/Pages/Error.cshtml.cs#ErrorModel)]

<span data-ttu-id="0b0c2-199">속성이 사용되는 방식을 살펴보면 표시에서 속성이 렌더링되기 전에 연결된 페이지에서 속성이 null인지 검사되는 것을 알 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-199">Check for the uses of the property, and you see that in the associated page, the property is checked for null before rendering it in markup.</span></span> <span data-ttu-id="0b0c2-200">이처럼 nullable 참조 형식이 안전하게 사용되고 있으므로 이 클래스는 완성되었습니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-200">That's a safe use of a nullable reference type, so you're done with this class.</span></span>

## <a name="fixing-nulls-causes-change"></a><span data-ttu-id="0b0c2-201">null을 수정하면 변경이 발생하는 경우</span><span class="sxs-lookup"><span data-stu-id="0b0c2-201">Fixing nulls causes change</span></span>

<span data-ttu-id="0b0c2-202">하나의 경고 세트를 수정하면 관련 코드에서 새로운 경고가 생성되는 경우가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-202">Frequently, the fix for one set of warnings creates new warnings in related code.</span></span> <span data-ttu-id="0b0c2-203">`index.cshtml.cs` 클래스를 수정하여 실제로 경고를 살펴보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-203">Let's see the warnings in action by fixing the `index.cshtml.cs` class.</span></span> <span data-ttu-id="0b0c2-204">`index.cshtml.cs` 파일을 열고 코드를 살펴봅니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-204">Open the `index.cshtml.cs` file and examine the code.</span></span> <span data-ttu-id="0b0c2-205">이 파일에는 인덱스 페이지를 구동하는 코드가 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-205">This file contains the code behind for the index page:</span></span>

[!code-csharp[StarterIndexModel](~/samples/csharp/tutorials/nullable-reference-migration/start/SimpleFeedReader/Pages/Index.cshtml.cs#IndexModelStart)]

<span data-ttu-id="0b0c2-206">`#nullable enable` 지시문을 추가하면</span><span class="sxs-lookup"><span data-stu-id="0b0c2-206">Add the `#nullable enable` directive and you'll see two warnings.</span></span> <span data-ttu-id="0b0c2-207">`ErrorText` 속성과 `NewsItems` 속성이 초기화되지 않았다는 2개의 경고를 볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-207">Neither the `ErrorText` property nor the `NewsItems` property is initialized.</span></span> <span data-ttu-id="0b0c2-208">이 클래스를 살펴보면 두 속성 모두 nullable 참조 형식이 되어야 한다는 사실을 알 수 있습니다. 두 속성 모두 private setter를 갖고 있기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-208">An examination of this class would lead you to believe that both properties should be nullable reference types: Both have private setters.</span></span> <span data-ttu-id="0b0c2-209">`OnGet` 메서드에서 정확히 1개가 할당되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-209">Exactly one is assigned in the `OnGet` method.</span></span> <span data-ttu-id="0b0c2-210">변경을 수행하기 전에 두 속성을 사용하는 주체를 찾아보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-210">Before making changes, look at the consumers of both properties.</span></span> <span data-ttu-id="0b0c2-211">페이지에서 오류 표시가 생성되기 전에 `ErrorText`가 null에 대해 검사됩니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-211">In the page itself, the `ErrorText` is checked against null before generating markup for any errors.</span></span> <span data-ttu-id="0b0c2-212">`NewsItems` 컬렉션이 `null`에 대해 검사되고, 컬렉션에 항목이 있는지도 검사됩니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-212">The `NewsItems` collection is checked against `null`, and checked to ensure the collection has items.</span></span> <span data-ttu-id="0b0c2-213">두 속성을 모두 nullable 참조 형식으로 만들어서 빠르게 수정할 수도 있지만,</span><span class="sxs-lookup"><span data-stu-id="0b0c2-213">A quick fix would be to make both properties nullable reference types.</span></span> <span data-ttu-id="0b0c2-214">이보다 나은 방법은 컬렉션을 nullable이 아닌 참조 형식으로 만들고, 뉴스를 가져올 때 기존 컬렉션에 항목을 추가하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-214">A better fix would be to make the collection a nonnullable reference type, and add items to the existing collection when retrieving news.</span></span> <span data-ttu-id="0b0c2-215">먼저 `ErrorText`의 `string` 형식에 `?`를 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-215">The first fix is to add the `?` to the `string` type for the `ErrorText`:</span></span>

[!code-csharp[UpdateErrorText](~/samples/csharp/tutorials/nullable-reference-migration/finished/SimpleFeedReader/Pages/Index.cshtml.cs#UpdateErrorText)]

<span data-ttu-id="0b0c2-216">이 `ErrorText` 속성에 대한 모든 액세스가 이미 null 검사에 의해 보호되었으므로 이 변경 사항은 다른 코드로 전파되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-216">That change won't ripple through other code, because any access to the `ErrorText` property was already guarded by null checks.</span></span> <span data-ttu-id="0b0c2-217">다음으로 `NewsItems` 목록을 초기화하고 속성 setter를 제거하여 읽기 전용 속성으로 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-217">Next, initialize the `NewsItems` list and remove the property setter, making it a readonly property:</span></span>

[!code-csharp[InitializeNewsItems](~/samples/csharp/tutorials/nullable-reference-migration/finished/SimpleFeedReader/Pages/Index.cshtml.cs#InitializeNewsItems)]

<span data-ttu-id="0b0c2-218">이렇게 하면 경고는 해결되지만 오류가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-218">That fixed the warning but introduced an error.</span></span> <span data-ttu-id="0b0c2-219">`NewsItems` 목록은 이제 **correct by construction**(생성에 의한 올바름)이지만, `OnGet`에서 목록을 설정하는 코드가 새 API에 대응되도록 변경해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-219">The `NewsItems` list is now **correct by construction**, but the code that sets the list in `OnGet` must change to match the new API.</span></span> <span data-ttu-id="0b0c2-220">할당을 사용하는 대신 `AddRange`를 호출하여 기존 목록에 뉴스 항목을 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-220">Instead of an assignment, call `AddRange` to add the news items to the existing list:</span></span>

[!code-csharp[AddRange](~/samples/csharp/tutorials/nullable-reference-migration/finished/SimpleFeedReader/Pages/Index.cshtml.cs#AddRange)]

<span data-ttu-id="0b0c2-221">할당 대신 `AddRange`를 사용한다는 것은 `GetNews` 메서드가 `List` 대신 `IEnumerable`을 반환할 수 있음을 의미합니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-221">Using `AddRange` instead of an assignment means that the `GetNews` method can return an `IEnumerable` instead of a `List`.</span></span> <span data-ttu-id="0b0c2-222">이렇게 하면 할당이 하나 절약됩니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-222">That saves one allocation.</span></span> <span data-ttu-id="0b0c2-223">다음 코드 샘플과 같이 메서드의 시그니처를 변경하고 `ToList` 호출을 제거합니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-223">Change the signature of the method, and remove the `ToList` call, as shown in the following code sample:</span></span>

[!code-csharp[GetNews](~/samples/csharp/tutorials/nullable-reference-migration/finished/SimpleFeedReader/Services/NewsService.cs#GetNewsFinished)]

<span data-ttu-id="0b0c2-224">시그니처를 변경하면 테스트 중 하나도 중단됩니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-224">Changing the signature breaks one of tests as well.</span></span> <span data-ttu-id="0b0c2-225">`SimpleFeedReader.Tests` 프로젝트의 `Services` 폴더에서 `NewsServiceTests.cs` 파일을 엽니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-225">Open the `NewsServiceTests.cs` file in the `Services` folder of the `SimpleFeedReader.Tests` project.</span></span> <span data-ttu-id="0b0c2-226">`Returns_News_Stories_Given_Valid_Uri` 테스트로 이동하고 `result` 변수의 형식을 `IEnumerable<NewsItem>`으로 변경합니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-226">Navigate to the `Returns_News_Stories_Given_Valid_Uri` test and change the type of the `result` variable to `IEnumerable<NewsItem>`.</span></span> <span data-ttu-id="0b0c2-227">형식을 변경한다는 것은 `Count` 속성을 더 이상 사용할 수 없음을 의미하므로, `Assert`의 `Count` 속성을 `Any()` 호출로 변경합니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-227">Changing the type means the `Count` property is no longer available, so replace the `Count` property in the `Assert` with a call to `Any()`:</span></span>

[!code-csharp[FixTests](~/samples/csharp/tutorials/nullable-reference-migration/finished/SimpleFeedReader.Tests/Services/NewsServiceTests.cs#FixTestSignature)]

<span data-ttu-id="0b0c2-228">파일의 시작 부분에 `using System.Linq` 문도 추가해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-228">You'll need to add a `using System.Linq` statement to the beginning of the file as well.</span></span>

<span data-ttu-id="0b0c2-229">지금까지 제네릭 인스턴스화를 포함하는 코드를 업데이트할 때 특히 유의해야 하는 고려 사항을 살펴보았습니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-229">This set of changes highlights special consideration when updating code that includes generic instantiations.</span></span> <span data-ttu-id="0b0c2-230">목록과 목록의 요소는 모두 nullable이 아닌 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-230">Both the list and the elements in the list of non-nullable types.</span></span> <span data-ttu-id="0b0c2-231">둘 중 하나 또는 둘 다 nullable 형식이 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-231">Either or both could be nullable types.</span></span> <span data-ttu-id="0b0c2-232">다음 지시문이 모두 허용됩니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-232">All the following declarations are allowed:</span></span>

- <span data-ttu-id="0b0c2-233">`List<NewsStoryViewModel>`: nullable이 아닌 보기 모델의 nullable이 아닌 목록</span><span class="sxs-lookup"><span data-stu-id="0b0c2-233">`List<NewsStoryViewModel>`: nonnullable list of nonullable view models.</span></span>
- <span data-ttu-id="0b0c2-234">`List<NewsStoryViewModel?>`: nullable 보기 모델의 nullable이 아닌 목록</span><span class="sxs-lookup"><span data-stu-id="0b0c2-234">`List<NewsStoryViewModel?>`: nonnullable list of nullable view models.</span></span>
- <span data-ttu-id="0b0c2-235">`List<NewsStoryViewModel>?`: nullable이 아닌 보기 모델의 nullable 목록</span><span class="sxs-lookup"><span data-stu-id="0b0c2-235">`List<NewsStoryViewModel>?`: nullable list of nonnullable view models.</span></span>
- <span data-ttu-id="0b0c2-236">`List<NewsStoryViewModel?>?`: nullable 보기 모델의 nullable 목록</span><span class="sxs-lookup"><span data-stu-id="0b0c2-236">`List<NewsStoryViewModel?>?`: nullable list of nullable view models.</span></span>

## <a name="interfaces-with-external-code"></a><span data-ttu-id="0b0c2-237">외부 코드와의 인터페이스</span><span class="sxs-lookup"><span data-stu-id="0b0c2-237">Interfaces with external code</span></span>

<span data-ttu-id="0b0c2-238">지금까지 `NewsService` 클래스를 변경했습니다. 이번에는 이 클래스에서 `#nullable enable` 주석을 켭니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-238">You've made changes to the `NewsService` class, so turn on the `#nullable enable` annotation for that class.</span></span> <span data-ttu-id="0b0c2-239">이렇게 해도 새로운 경고가 생성되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-239">This won't generate any new warnings.</span></span> <span data-ttu-id="0b0c2-240">그렇지만 클래스를 주의 깊게 살펴보면 컴파일러의 흐름 분석에 어떤 제한이 있는지 알 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-240">However, careful examination of the class helps to illustrate some of the limitations of the compiler's flow analysis.</span></span> <span data-ttu-id="0b0c2-241">생성자를 살펴봅니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-241">Examine the constructor:</span></span>

[!code-csharp[ServiceConstructor](~/samples/csharp/tutorials/nullable-reference-migration/finished/SimpleFeedReader/Services/NewsService.cs#ServiceConstructor)]

<span data-ttu-id="0b0c2-242">`IMapper` 매개 변수는 nullable이 아닌 참조 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-242">The `IMapper` parameter is typed as a nonnullable reference.</span></span> <span data-ttu-id="0b0c2-243">ASP.NET Core 인프라 코드에 의해 호출되므로, 컴파일러는 `IMapper`가 null이 될 수 없다는 것을 알지 못합니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-243">It's called by ASP.NET Core infrastructure code, so the compiler doesn't really know that the `IMapper` will never be null.</span></span> <span data-ttu-id="0b0c2-244">기본적인 ASP.NET Core DI(종속성 주입) 컨테이너는 필수 서비스를 확인할 수 없는 경우 예외를 throw하므로 이 코드는 올바릅니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-244">The default ASP.NET Core dependency injection (DI) container throws an exception if it can't resolve a necessary service, so the code is correct.</span></span> <span data-ttu-id="0b0c2-245">nullable 주석 컨텍스트를 활성화한 상태로 코드를 컴파일하더라도 컴파일러는 모든 공용 API 호출의 유효성을 검사할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-245">The compiler can't validate all calls to your public APIs, even if your code is compiled with nullable annotation contexts enabled.</span></span> <span data-ttu-id="0b0c2-246">또한, nullable 참조 형식을 사용하도록 설정되지 않은 프로젝트에 의해 라이브러리가 과도하게 사용될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-246">Furthermore, your libraries may be consumed by projects that have not yet opted into using nullable reference types.</span></span> <span data-ttu-id="0b0c2-247">nullable이 아닌 형식으로 선언한 경우에도 공용 API의 입력은 유효성을 검사해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-247">Validate inputs to public APIs even though you've declared them as nonnullable types.</span></span>

## <a name="get-the-code"></a><span data-ttu-id="0b0c2-248">코드 가져오기</span><span class="sxs-lookup"><span data-stu-id="0b0c2-248">Get the code</span></span>

<span data-ttu-id="0b0c2-249">초기 테스트 컴파일에서 확인한 경고를 모두 수정했으므로 이제 두 프로젝트에서 모두 nullable 주석 컨텍스트를 켤 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-249">You've fixed the warnings you identified in the initial test compile, so now you can turn on the nullable annotation context for both projects.</span></span> <span data-ttu-id="0b0c2-250">프로젝트를 다시 빌드하면 컴파일러에서 생성하는 경고가 없는 것을 볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-250">Rebuild the projects; the compiler reports no warnings.</span></span> <span data-ttu-id="0b0c2-251">완성된 프로젝트의 코드는 [dotnet/samples](https://github.com/dotnet/samples/tree/master/csharp/tutorials/nullable-reference-migration/finished) GitHub 리포지토리에서 가져올 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-251">You can get the code for the finished project in the [dotnet/samples](https://github.com/dotnet/samples/tree/master/csharp/tutorials/nullable-reference-migration/finished) GitHub repository.</span></span>

<span data-ttu-id="0b0c2-252">nullable 참조 형식을 지원하는 새로운 기능을 사용하면 코드에서 `null` 값을 처리하는 방식의 잠재적인 오류를 찾아서 수정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-252">The new features that support nullable reference types help you find and fix potential errors in how you handle `null` values in your code.</span></span> <span data-ttu-id="0b0c2-253">nullable 주석 컨텍스트를 활성화하면 어떤 변수는 null이 되면 안 되고, 어떤 변수는 null 값을 포함해도 된다는 설계 의도를 원하는 대로 표현할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-253">Enabling the nullable annotation context allows you to express your design intent: some variables should never be null, other variables may contain null values.</span></span> <span data-ttu-id="0b0c2-254">이러한 기능을 사용하여 설계 의도를 보다 쉽게 드러낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-254">These features make it easier for you to declare your design intent.</span></span> <span data-ttu-id="0b0c2-255">마찬가지로, nullable 경고 컨텍스트는 의도가 위반된 경우 경고를 발생하라고 컴파일러에 알립니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-255">Similarly, the nullable warning context instructs the compiler to issue warnings when you have violated that intent.</span></span> <span data-ttu-id="0b0c2-256">이러한 경고를 살펴보고 업데이트하여 코드의 복원력을 높이고 실행 중에 `NullReferenceException`을 throw할 확률을 줄일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-256">Those warnings guide you to make updates that make your code more resilient and less likely to throw a `NullReferenceException` during execution.</span></span> <span data-ttu-id="0b0c2-257">이러한 컨텍스트의 범위를 제어하여 나머지 코드베이스는 그대로 두고 마이그레이션할 로컬 코드 영역에만 집중할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-257">You can control the scope of these contexts so that you can focus on local areas of code to migrate while the remaining codebase is untouched.</span></span> <span data-ttu-id="0b0c2-258">실전에서는 클래스의 정기적인 유지 관리의 일환으로 이러한 마이그레이션 작업을 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-258">In practice, you can make this migration task a part of regular maintenance to your classes.</span></span> <span data-ttu-id="0b0c2-259">이 자습서에서는 nullable 참조 형식을 사용하도록 애플리케이션을 마이그레이션하는 과정을 살펴봤습니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-259">This tutorial demonstrated the process to migrate an application to use nullable reference types.</span></span> <span data-ttu-id="0b0c2-260">[NodaTime](https://github.com/nodatime/nodatime/pull/1240/commits)에 nullable 참조 형식을 통합하도록 구현된 PR [Jon Skeet](https://github.com/jskeet)에서 더 많은 실제 사례를 참조할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0b0c2-260">You can explore a larger real-world example of this process by examining the PR [Jon Skeet](https://github.com/jskeet) made to incorporate nullable reference types into [NodaTime](https://github.com/nodatime/nodatime/pull/1240/commits).</span></span>

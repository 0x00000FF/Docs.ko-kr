---
title: 익명 형식 - C# 프로그래밍 가이드
ms.custom: seodec18
ms.date: 07/20/2015
helpviewer_keywords:
- anonymous types [C#]
- C# Language, anonymous types
ms.assetid: 59c9d7a4-3b0e-475e-b620-0ab86c088e9b
ms.openlocfilehash: 7d8bdc5ceef5d82e4bc7e13ee932985cae6c2c10
ms.sourcegitcommit: bab17fd81bab7886449217356084bf4881d6e7c8
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 06/26/2019
ms.locfileid: "67398554"
---
# <a name="anonymous-types-c-programming-guide"></a><span data-ttu-id="9967d-102">익명 형식(C# 프로그래밍 가이드)</span><span class="sxs-lookup"><span data-stu-id="9967d-102">Anonymous Types (C# Programming Guide)</span></span>

<span data-ttu-id="9967d-103">익명 형식을 사용하면 먼저 명시적으로 형식을 정의할 필요 없이 읽기 전용 속성 집합을 단일 개체로 편리하게 캡슐화할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9967d-103">Anonymous types provide a convenient way to encapsulate a set of read-only properties into a single object without having to explicitly define a type first.</span></span> <span data-ttu-id="9967d-104">형식 이름은 컴파일러에 의해 생성되며 소스 코드 수준에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9967d-104">The type name is generated by the compiler and is not available at the source code level.</span></span> <span data-ttu-id="9967d-105">각 속성의 형식은 컴파일러에서 유추합니다.</span><span class="sxs-lookup"><span data-stu-id="9967d-105">The type of each property is inferred by the compiler.</span></span>  
  
 <span data-ttu-id="9967d-106">[new](../../../csharp/language-reference/operators/new-operator.md) 연산자를 개체 이니셜라이저와 함께 사용하여 무명 형식을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="9967d-106">You create anonymous types by using the [new](../../../csharp/language-reference/operators/new-operator.md) operator together with an object initializer.</span></span> <span data-ttu-id="9967d-107">개체 이니셜라이저에 대한 자세한 내용은 [개체 및 컬렉션 이니셜라이저](../../../csharp/programming-guide/classes-and-structs/object-and-collection-initializers.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="9967d-107">For more information about object initializers, see [Object and Collection Initializers](../../../csharp/programming-guide/classes-and-structs/object-and-collection-initializers.md).</span></span>  
  
 <span data-ttu-id="9967d-108">다음 예제에서는 `Amount` 및 `Message`라는 두 속성으로 초기화된 익명 형식을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="9967d-108">The following example shows an anonymous type that is initialized with two properties named `Amount` and `Message`.</span></span>  
  
```csharp  
var v = new { Amount = 108, Message = "Hello" };  
  
// Rest the mouse pointer over v.Amount and v.Message in the following  
// statement to verify that their inferred types are int and string.  
Console.WriteLine(v.Amount + v.Message);  
```  
  
 <span data-ttu-id="9967d-109">일반적으로 무명 형식은 소스 시퀀스에 있는 각 개체의 속성 하위 집합을 반환하기 위해 쿼리 식의 [select](../../../csharp/language-reference/keywords/select-clause.md) 절에 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="9967d-109">Anonymous types typically are used in the [select](../../../csharp/language-reference/keywords/select-clause.md) clause of a query expression to return a subset of the properties from each object in the source sequence.</span></span> <span data-ttu-id="9967d-110">쿼리에 대한 자세한 내용은 [LINQ 쿼리 식](../../../csharp/programming-guide/linq-query-expressions/index.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="9967d-110">For more information about queries, see [LINQ Query Expressions](../../../csharp/programming-guide/linq-query-expressions/index.md).</span></span>  
  
 <span data-ttu-id="9967d-111">익명 형식은 하나 이상의 public 읽기 전용 속성을 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="9967d-111">Anonymous types contain one or more public read-only properties.</span></span> <span data-ttu-id="9967d-112">메서드 또는 이벤트와 같은 다른 종류의 클래스 멤버는 유효하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9967d-112">No other kinds of class members, such as methods or events, are valid.</span></span> <span data-ttu-id="9967d-113">속성을 초기화하는 데 사용되는 식은 `null`, 익명 함수 또는 포인터 형식일 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9967d-113">The expression that is used to initialize a property cannot be `null`, an anonymous function, or a pointer type.</span></span>  
  
 <span data-ttu-id="9967d-114">가장 일반적인 시나리오는 다른 형식의 속성으로 익명 형식을 초기화하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="9967d-114">The most common scenario is to initialize an anonymous type with properties from another type.</span></span> <span data-ttu-id="9967d-115">다음 예제에서는 `Product`라는 클래스가 있다고 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="9967d-115">In the following example, assume that a class exists that is named `Product`.</span></span> <span data-ttu-id="9967d-116">`Product` 클래스에는 `Color` 및 `Price` 속성뿐만 아니라 관심 없는 다른 속성도 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9967d-116">Class `Product` includes `Color` and `Price` properties, together with other properties that you are not interested in.</span></span> <span data-ttu-id="9967d-117">`products` 변수는 `Product` 개체의 컬렉션입니다.</span><span class="sxs-lookup"><span data-stu-id="9967d-117">Variable `products` is a collection of `Product` objects.</span></span> <span data-ttu-id="9967d-118">익명 형식 선언은 `new` 키워드로 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="9967d-118">The anonymous type declaration starts with the `new` keyword.</span></span> <span data-ttu-id="9967d-119">선언에서는 `Product`의 두 속성만 사용하는 새 형식을 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="9967d-119">The declaration initializes a new type that uses only two properties from `Product`.</span></span> <span data-ttu-id="9967d-120">따라서 쿼리에 작은 양의 데이터가 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="9967d-120">This causes a smaller amount of data to be returned in the query.</span></span>  
  
 <span data-ttu-id="9967d-121">익명 형식에 멤버 이름을 지정하지 않으면 컴파일러가 익명 형식 멤버에 해당 멤버를 초기화하는 데 사용된 속성과 동일한 이름을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="9967d-121">If you do not specify member names in the anonymous type, the compiler gives the anonymous type members the same name as the property being used to initialize them.</span></span> <span data-ttu-id="9967d-122">앞의 예제에 표시된 것처럼, 식으로 초기화되는 속성의 이름을 제공해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9967d-122">You must provide a name for a property that is being initialized with an expression, as shown in the previous example.</span></span> <span data-ttu-id="9967d-123">다음 예제에서 익명 형식의 속성 이름은 `Color` 및 `Price`입니다.</span><span class="sxs-lookup"><span data-stu-id="9967d-123">In the following example, the names of the properties of the anonymous type are `Color` and `Price`.</span></span>  
  
 [!code-csharp[csRef30Features#81](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csRef30Features/CS/csref30.cs#81)]  
  
 <span data-ttu-id="9967d-124">일반적으로 무명 형식을 사용하여 변수를 초기화할 때는 [var](../../../csharp/language-reference/keywords/var.md)을 사용하여 변수를 암시적 형식 지역 변수로 선언합니다.</span><span class="sxs-lookup"><span data-stu-id="9967d-124">Typically, when you use an anonymous type to initialize a variable, you declare the variable as an implicitly typed local variable by using [var](../../../csharp/language-reference/keywords/var.md).</span></span> <span data-ttu-id="9967d-125">컴파일러만 익명 형식의 기본 이름에 액세스할 수 있으므로 변수 선언에는 형식 이름을 지정할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9967d-125">The type name cannot be specified in the variable declaration because only the compiler has access to the underlying name of the anonymous type.</span></span> <span data-ttu-id="9967d-126">`var`에 대한 자세한 내용은 [암시적 형식 지역 변수](../../../csharp/programming-guide/classes-and-structs/implicitly-typed-local-variables.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="9967d-126">For more information about `var`, see [Implicitly Typed Local Variables](../../../csharp/programming-guide/classes-and-structs/implicitly-typed-local-variables.md).</span></span>  
  
 <span data-ttu-id="9967d-127">다음 예제에 표시된 것처럼, 암시적으로 형식화된 지역 변수와 암시적으로 형식화된 배열을 결합하여 익명으로 형식화된 요소의 배열을 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9967d-127">You can create an array of anonymously typed elements by combining an implicitly typed local variable and an implicitly typed array, as shown in the following example.</span></span>  
  
```csharp  
var anonArray = new[] { new { name = "apple", diam = 4 }, new { name = "grape", diam = 1 }};  
```  
  
## <a name="remarks"></a><span data-ttu-id="9967d-128">설명</span><span class="sxs-lookup"><span data-stu-id="9967d-128">Remarks</span></span>  
 <span data-ttu-id="9967d-129">무명 형식은 [object](../../../csharp/language-reference/keywords/object.md)에서 직접 파생되고 [object](../../../csharp/language-reference/keywords/object.md)를 제외한 어떠한 형식으로도 캐스팅될 수 없는 [class](../../../csharp/language-reference/keywords/class.md) 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="9967d-129">Anonymous types are [class](../../../csharp/language-reference/keywords/class.md) types that derive directly from [object](../../../csharp/language-reference/keywords/object.md), and that cannot be cast to any type except [object](../../../csharp/language-reference/keywords/object.md).</span></span> <span data-ttu-id="9967d-130">컴파일러는 애플리케이션에서 해당 익명 형식에 액세스할 수 없더라도 각 익명 형식의 이름을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="9967d-130">The compiler provides a name for each anonymous type, although your application cannot access it.</span></span> <span data-ttu-id="9967d-131">공용 언어 런타임의 관점에서 익명 형식은 다른 참조 형식과 다를 바가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9967d-131">From the perspective of the common language runtime, an anonymous type is no different from any other reference type.</span></span>  
  
 <span data-ttu-id="9967d-132">어셈블리에서 둘 이상의 익명 개체 이니셜라이저가 순서와 이름 및 형식이 동일한 속성의 시퀀스를 지정하는 경우 컴파일러는 개체를 동일한 형식의 인스턴스로 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="9967d-132">If two or more anonymous object initializers in an assembly specify a sequence of properties that are in the same order and that have the same names and types, the compiler treats the objects as instances of the same type.</span></span> <span data-ttu-id="9967d-133">이러한 개체는 컴파일러에서 생성된 동일한 형식 정보를 공유합니다.</span><span class="sxs-lookup"><span data-stu-id="9967d-133">They share the same compiler-generated type information.</span></span>  
  
 <span data-ttu-id="9967d-134">익명 형식을 가지고 있으므로 필드, 속성, 이벤트 또는 메서드의 반환 형식은 선언할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9967d-134">You cannot declare a field, a property, an event, or the return type of a method as having an anonymous type.</span></span> <span data-ttu-id="9967d-135">마찬가지로, 익명 형식을 가지고 있으므로 메서드, 속성, 생성자 또는 인덱서의 정식 매개 변수는 선언할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9967d-135">Similarly, you cannot declare a formal parameter of a method, property, constructor, or indexer as having an anonymous type.</span></span> <span data-ttu-id="9967d-136">익명 형식이나 익명 형식을 포함한 컬렉션을 메서드에 대한 인수로 전달하려면 매개 변수를 형식 개체로 선언하면 됩니다.</span><span class="sxs-lookup"><span data-stu-id="9967d-136">To pass an anonymous type, or a collection that contains anonymous types, as an argument to a method, you can declare the parameter as type object.</span></span> <span data-ttu-id="9967d-137">그러나 이렇게 하면 강력한 형식화를 사용하는 의미가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9967d-137">However, doing this defeats the purpose of strong typing.</span></span> <span data-ttu-id="9967d-138">쿼리 결과를 저장하거나 메서드 경계 외부로 전달해야 하는 경우 익명 형식 대신 일반적인 명명된 구조체 또는 클래스 사용을 고려하세요.</span><span class="sxs-lookup"><span data-stu-id="9967d-138">If you must store query results or pass them outside the method boundary, consider using an ordinary named struct or class instead of an anonymous type.</span></span>  
  
 <span data-ttu-id="9967d-139">익명 형식에 대한 <xref:System.Object.Equals%2A> 및 <xref:System.Object.GetHashCode%2A> 메서드는 속성의 `Equals` 및 `GetHashCode` 메서드 측면에서 정의되므로 동일한 익명 형식의 두 인스턴스는 해당 속성이 모두 동일한 경우에만 동일합니다.</span><span class="sxs-lookup"><span data-stu-id="9967d-139">Because the <xref:System.Object.Equals%2A> and <xref:System.Object.GetHashCode%2A> methods on anonymous types are defined in terms of the `Equals` and `GetHashCode` methods of the properties, two instances of the same anonymous type are equal only if all their properties are equal.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="9967d-140">참고 항목</span><span class="sxs-lookup"><span data-stu-id="9967d-140">See also</span></span>

- [<span data-ttu-id="9967d-141">C# 프로그래밍 가이드</span><span class="sxs-lookup"><span data-stu-id="9967d-141">C# Programming Guide</span></span>](../../../csharp/programming-guide/index.md)
- [<span data-ttu-id="9967d-142">개체 이니셜라이저 및 컬렉션 이니셜라이저</span><span class="sxs-lookup"><span data-stu-id="9967d-142">Object and Collection Initializers</span></span>](../../../csharp/programming-guide/classes-and-structs/object-and-collection-initializers.md)
- [<span data-ttu-id="9967d-143">C#에서 LINQ 시작</span><span class="sxs-lookup"><span data-stu-id="9967d-143">Getting Started with LINQ in C#</span></span>](../../../csharp/programming-guide/concepts/linq/getting-started-with-linq.md)
- [<span data-ttu-id="9967d-144">LINQ 쿼리 식</span><span class="sxs-lookup"><span data-stu-id="9967d-144">LINQ Query Expressions</span></span>](../../../csharp/programming-guide/linq-query-expressions/index.md)

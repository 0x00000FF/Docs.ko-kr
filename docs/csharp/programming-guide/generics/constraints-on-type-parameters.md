---
title: "형식 매개 변수에 대한 제약 조건(C# 프로그래밍 가이드)"
ms.date: 07/20/2015
ms.prod: .net
ms.technology: devlang-csharp
ms.topic: article
helpviewer_keywords:
- generics [C#], type constraints
- type constraints [C#]
- type parameters [C#], constraints
- unbound type parameter [C#]
ms.assetid: 141b003e-1ddb-4e1c-bcb2-e1c3870e6a51
caps.latest.revision: "41"
author: BillWagner
ms.author: wiwagn
ms.openlocfilehash: f5382b0050b81ed3bb1a075a042bdc4034a3975d
ms.sourcegitcommit: 4f3fef493080a43e70e951223894768d36ce430a
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 11/21/2017
---
# <a name="constraints-on-type-parameters-c-programming-guide"></a><span data-ttu-id="ae8ce-102">형식 매개 변수에 대한 제약 조건(C# 프로그래밍 가이드)</span><span class="sxs-lookup"><span data-stu-id="ae8ce-102">Constraints on Type Parameters (C# Programming Guide)</span></span>
<span data-ttu-id="ae8ce-103">제네릭 클래스를 정의하는 경우 클라이언트 코드에서 클래스를 인스턴스화할 때 형식 인수에 사용할 수 있는 형식 종류에 제한을 적용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ae8ce-103">When you define a generic class, you can apply restrictions to the kinds of types that client code can use for type arguments when it instantiates your class.</span></span> <span data-ttu-id="ae8ce-104">클라이언트 코드에서 제약 조건에 의해 허용되지 않는 형식을 사용하여 클래스를 인스턴스화하려고 하면 컴파일 시간 오류가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="ae8ce-104">If client code tries to instantiate your class by using a type that is not allowed by a constraint, the result is a compile-time error.</span></span> <span data-ttu-id="ae8ce-105">이러한 제한을 제약 조건이라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="ae8ce-105">These restrictions are called constraints.</span></span> <span data-ttu-id="ae8ce-106">제약 조건은 `where` 상황별 키워드를 사용하여 지정됩니다.</span><span class="sxs-lookup"><span data-stu-id="ae8ce-106">Constraints are specified by using the `where` contextual keyword.</span></span> <span data-ttu-id="ae8ce-107">다음 표에는 6가지 유형의 제약 조건이 나와 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ae8ce-107">The following table lists the six types of constraints:</span></span>  
  
|<span data-ttu-id="ae8ce-108">제약 조건</span><span class="sxs-lookup"><span data-stu-id="ae8ce-108">Constraint</span></span>|<span data-ttu-id="ae8ce-109">설명</span><span class="sxs-lookup"><span data-stu-id="ae8ce-109">Description</span></span>|  
|----------------|-----------------|  
|<span data-ttu-id="ae8ce-110">where T : struct</span><span class="sxs-lookup"><span data-stu-id="ae8ce-110">where T: struct</span></span>|<span data-ttu-id="ae8ce-111">형식 인수는 값 형식이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ae8ce-111">The type argument must be a value type.</span></span> <span data-ttu-id="ae8ce-112"><xref:System.Nullable>를 제외한 임의의 값 형식을 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ae8ce-112">Any value type except <xref:System.Nullable> can be specified.</span></span> <span data-ttu-id="ae8ce-113">자세한 내용은 [Nullable 형식 사용](../../../csharp/programming-guide/nullable-types/using-nullable-types.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ae8ce-113">See [Using Nullable Types](../../../csharp/programming-guide/nullable-types/using-nullable-types.md) for more information.</span></span>|  
|<span data-ttu-id="ae8ce-114">where T : class</span><span class="sxs-lookup"><span data-stu-id="ae8ce-114">where T : class</span></span>|<span data-ttu-id="ae8ce-115">형식 인수가 참조 형식이어야 합니다. 이 제약 조건은 클래스, 인터페이스, 대리자 또는 배열 형식에도 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="ae8ce-115">The type argument must be a reference type; this applies also to any class, interface, delegate, or array type.</span></span>|  
|<span data-ttu-id="ae8ce-116">where T : new()</span><span class="sxs-lookup"><span data-stu-id="ae8ce-116">where T : new()</span></span>|<span data-ttu-id="ae8ce-117">형식 인수에 매개 변수가 없는 public 생성자가 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ae8ce-117">The type argument must have a public parameterless constructor.</span></span> <span data-ttu-id="ae8ce-118">다른 제약 조건과 함께 사용할 경우 `new()` 제약 조건을 마지막에 지정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ae8ce-118">When used together with other constraints, the `new()` constraint must be specified last.</span></span>|  
|<span data-ttu-id="ae8ce-119">where T : \<기본 클래스 이름></span><span class="sxs-lookup"><span data-stu-id="ae8ce-119">where T : \<base class name></span></span>|<span data-ttu-id="ae8ce-120">형식 인수가 지정된 기본 클래스이거나 지정된 기본 클래스에서 파생되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ae8ce-120">The type argument must be or derive from the specified base class.</span></span>|  
|<span data-ttu-id="ae8ce-121">where T : \<인터페이스 이름></span><span class="sxs-lookup"><span data-stu-id="ae8ce-121">where T : \<interface name></span></span>|<span data-ttu-id="ae8ce-122">형식 인수가 지정된 인터페이스이거나 지정된 인터페이스를 구현해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ae8ce-122">The type argument must be or implement the specified interface.</span></span> <span data-ttu-id="ae8ce-123">여러 인터페이스 제약 조건을 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ae8ce-123">Multiple interface constraints can be specified.</span></span> <span data-ttu-id="ae8ce-124">제약 인터페이스가 제네릭일 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ae8ce-124">The constraining interface can also be generic.</span></span>|  
|<span data-ttu-id="ae8ce-125">where T : U</span><span class="sxs-lookup"><span data-stu-id="ae8ce-125">where T : U</span></span>|<span data-ttu-id="ae8ce-126">T에 대해 제공되는 형식 인수는 U에 대해 제공되는 인수이거나 이 인수에서 파생되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ae8ce-126">The type argument supplied for T must be or derive from the argument supplied for U.</span></span>|  
  
## <a name="why-use-constraints"></a><span data-ttu-id="ae8ce-127">제약 조건을 사용하는 이유</span><span class="sxs-lookup"><span data-stu-id="ae8ce-127">Why Use Constraints</span></span>  
 <span data-ttu-id="ae8ce-128">제네릭 목록의 항목을 검사하여 유효한지 확인하거나 다른 항목과 비교하려는 경우 컴파일러에 호출해야 하는 연산자 또는 메서드가 클라이언트 코드에서 지정될 수 있는 형식 인수에 의해 지원된다는 보장이 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ae8ce-128">If you want to examine an item in a generic list to determine whether it is valid or to compare it to some other item, the compiler must have some guarantee that the operator or method it has to call will be supported by any type argument that might be specified by client code.</span></span> <span data-ttu-id="ae8ce-129">제네릭 클래스 정의에 하나 이상의 제약 조건을 적용하면 이러한 보장을 얻을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ae8ce-129">This guarantee is obtained by applying one or more constraints to your generic class definition.</span></span> <span data-ttu-id="ae8ce-130">예를 들어 기본 클래스 제약 조건은 이 형식의 개체나 이 형식에서 파생된 개체만 형식 인수로 사용된다고 컴파일러에 알립니다.</span><span class="sxs-lookup"><span data-stu-id="ae8ce-130">For example, the base class constraint tells the compiler that only objects of this type or derived from this type will be used as type arguments.</span></span> <span data-ttu-id="ae8ce-131">컴파일러에 이 보장이 있으면 해당 형식의 메서드가 제네릭 클래스에서 호출되도록 허용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ae8ce-131">Once the compiler has this guarantee, it can allow methods of that type to be called in the generic class.</span></span> <span data-ttu-id="ae8ce-132">제약 조건은 상황별 키워드 `where`를 사용하여 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="ae8ce-132">Constraints are applied by using the contextual keyword `where`.</span></span> <span data-ttu-id="ae8ce-133">다음 코드 예제에서는 기본 클래스 제약 조건을 적용하여 `GenericList<T>` 클래스([제네릭 소개](../../../csharp/programming-guide/generics/introduction-to-generics.md))에 추가할 수 있는 기능을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="ae8ce-133">The following code example demonstrates the functionality we can add to the `GenericList<T>` class (in [Introduction to Generics](../../../csharp/programming-guide/generics/introduction-to-generics.md)) by applying a base class constraint.</span></span>  
  
 [!code-csharp[csProgGuideGenerics#11](../../../csharp/programming-guide/generics/codesnippet/CSharp/constraints-on-type-parameters_1.cs)]  
  
 <span data-ttu-id="ae8ce-134">제약 조건을 통해 제네릭 클래스는 `Employee.Name` 속성을 사용할 수 있습니다. T 형식의 모든 항목이 `Employee` 개체이거나 `Employee`에서 상속되는 개체임이 보장되기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="ae8ce-134">The constraint enables the generic class to use the `Employee.Name` property because all items of type T are guaranteed to be either an `Employee` object or an object that inherits from `Employee`.</span></span>  
  
 <span data-ttu-id="ae8ce-135">동일한 형식 매개 변수에 여러 개의 제약 조건을 적용할 수 있으며, 제약 조건 자체가 다음과 같이 제네릭 형식일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ae8ce-135">Multiple constraints can be applied to the same type parameter, and the constraints themselves can be generic types, as follows:</span></span>  
  
 [!code-csharp[csProgGuideGenerics#12](../../../csharp/programming-guide/generics/codesnippet/CSharp/constraints-on-type-parameters_2.cs)]  
  
 <span data-ttu-id="ae8ce-136">형식 매개 변수 제약을 통해 허용되는 작업 및 메서드 호출 수를 제약 형식 및 해당 상속 계층 구조의 모든 형식에서 지원하는 작업 및 메서드 호출로 늘립니다.</span><span class="sxs-lookup"><span data-stu-id="ae8ce-136">By constraining the type parameter, you increase the number of allowable operations and method calls to those supported by the constraining type and all types in its inheritance hierarchy.</span></span> <span data-ttu-id="ae8ce-137">따라서 제네릭 클래스 또는 메서드를 디자인할 때 단순한 할당 이외의 작업을 제네릭 멤버에 대해 수행하거나 `System.Object`에서 지원되지 않는 메서드를 호출하는 경우 형식 매개 변수에 제약 조건을 적용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ae8ce-137">Therefore, when you design generic classes or methods, if you will be performing any operation on the generic members beyond simple assignment or calling any methods not supported by `System.Object`, you will have to apply constraints to the type parameter.</span></span>  
  
 <span data-ttu-id="ae8ce-138">`where T : class` 제약 조건을 적용하는 경우 `==` 및 `!=` 연산자는 참조 ID만 테스트하고 값이 같은지 테스트하지 않으므로 형식 매개 변수에 사용하지 않도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="ae8ce-138">When applying the `where T : class` constraint, avoid the `==` and `!=` operators on the type parameter because these operators will test for reference identity only, not for value equality.</span></span> <span data-ttu-id="ae8ce-139">이러한 연산자가 인수로 사용되는 형식에서 오버로드되는 경우에도 마찬가지입니다.</span><span class="sxs-lookup"><span data-stu-id="ae8ce-139">This is the case even if these operators are overloaded in a type that is used as an argument.</span></span> <span data-ttu-id="ae8ce-140">다음 코드는 이 내용을 보여 줍니다. <xref:System.String> 클래스가 `==` 연산자를 오버로드하지만 출력이 false입니다.</span><span class="sxs-lookup"><span data-stu-id="ae8ce-140">The following code illustrates this point; the output is false even though the <xref:System.String> class overloads the `==` operator.</span></span>  
  
 [!code-csharp[csProgGuideGenerics#13](../../../csharp/programming-guide/generics/codesnippet/CSharp/constraints-on-type-parameters_3.cs)]  
  
 <span data-ttu-id="ae8ce-141">이렇게 동작하는 이유는 컴파일 시간에 컴파일러에서 T가 참조 형식이란 것만 알고 있으므로 모든 참조 형식에 유효한 기본 연산자를 사용해야 하기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="ae8ce-141">The reason for this behavior is that, at compile time, the compiler only knows that T is a reference type, and therefore must use the default operators that are valid for all reference types.</span></span> <span data-ttu-id="ae8ce-142">값이 같은지 테스트해야 하는 경우 권장되는 방법은 `where T : IComparable<T>` 제약 조건도 적용하여 제네릭 클래스를 생성하는 데 사용할 모든 클래스에서 해당 인터페이스를 구현하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="ae8ce-142">If you must test for value equality, the recommended way is to also apply the `where T : IComparable<T>` constraint and implement that interface in any class that will be used to construct the generic class.</span></span>  
  
## <a name="constraining-multiple-parameters"></a><span data-ttu-id="ae8ce-143">여러 매개 변수 제약</span><span class="sxs-lookup"><span data-stu-id="ae8ce-143">Constraining Multiple Parameters</span></span>  
 <span data-ttu-id="ae8ce-144">다음 예제와 같이 여러 매개 변수에 제약 조건을 적용하고, 단일 매개 변수에 여러 제약 조건을 적용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ae8ce-144">You can apply constraints to multiple parameters, and multiple constraints to a single parameter, as shown in the following example:</span></span>  
  
 [!code-csharp[csProgGuideGenerics#64](../../../csharp/programming-guide/generics/codesnippet/CSharp/constraints-on-type-parameters_4.cs)]  
  
## <a name="unbounded-type-parameters"></a><span data-ttu-id="ae8ce-145">바인딩되지 않은 형식 매개 변수</span><span class="sxs-lookup"><span data-stu-id="ae8ce-145">Unbounded Type Parameters</span></span>  
 <span data-ttu-id="ae8ce-146">공용 클래스 `SampleClass<T>{}`의 T와 같이 제약 조건이 없는 형식 매개 변수를 바인딩되지 않은 형식 매개 변수라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="ae8ce-146">Type parameters that have no constraints, such as T in public class `SampleClass<T>{}`, are called unbounded type parameters.</span></span> <span data-ttu-id="ae8ce-147">바인딩되지 않은 형식 매개 변수에는 다음 규칙이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ae8ce-147">Unbounded type parameters have the following rules:</span></span>  
  
-   <span data-ttu-id="ae8ce-148">`!=` 및 `==` 연산자는 구체적인 형식 인수가 이러한 연산자를 지원한다는 보장이 없기 때문에 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ae8ce-148">The `!=` and `==` operators cannot be used because there is no guarantee that the concrete type argument will support these operators.</span></span>  
  
-   <span data-ttu-id="ae8ce-149">`System.Object`로/에서 변환하거나 임의의 인터페이스 형식으로 명시적으로 변환할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ae8ce-149">They can be converted to and from `System.Object` or explicitly converted to any interface type.</span></span>  
  
-   <span data-ttu-id="ae8ce-150">[null](../../../csharp/language-reference/keywords/null.md)과 비교할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ae8ce-150">You can compare to [null](../../../csharp/language-reference/keywords/null.md).</span></span> <span data-ttu-id="ae8ce-151">바인딩되지 않은 매개 변수를 `null`과 비교하는 경우 형식 인수가 값 형식이면 비교에서 항상 false를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="ae8ce-151">If an unbounded parameter is compared to `null`, the comparison will always return false if the type argument is a value type.</span></span>  
  
## <a name="type-parameters-as-constraints"></a><span data-ttu-id="ae8ce-152">제약 조건인 형식 매개 변수</span><span class="sxs-lookup"><span data-stu-id="ae8ce-152">Type Parameters as Constraints</span></span>  
 <span data-ttu-id="ae8ce-153">다음 예제와 같이 고유한 형식 매개 변수가 있는 멤버 함수가 해당 매개 변수를 포함 형식의 형식 매개 변수로 제약해야 하는 경우 제네릭 형식 매개 변수를 제약 조건으로 사용하면 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="ae8ce-153">The use of a generic type parameter as a constraint is useful when a member function with its own type parameter has to constrain that parameter to the type parameter of the containing type, as shown in the following example:</span></span>  
  
 [!code-csharp[csProgGuideGenerics#14](../../../csharp/programming-guide/generics/codesnippet/CSharp/constraints-on-type-parameters_5.cs)]  
  
 <span data-ttu-id="ae8ce-154">앞의 예제에서 `T`는 `Add` 메서드 컨텍스트에서는 형식 제약 조건이고, `List` 클래스 컨텍스트에서는 바인딩되지 않은 형식 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="ae8ce-154">In the previous example, `T` is a type constraint in the context of the `Add` method, and an unbounded type parameter in the context of the `List` class.</span></span>  
  
 <span data-ttu-id="ae8ce-155">제네릭 클래스 정의에서 형식 매개 변수를 제약 조건으로 사용할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ae8ce-155">Type parameters can also be used as constraints in generic class definitions.</span></span> <span data-ttu-id="ae8ce-156">다른 형식 매개 변수와 함께 꺾쇠 괄호 안에 형식 매개 변수를 선언해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ae8ce-156">Note that the type parameter must be declared within the angle brackets together with any other type parameters:</span></span>  
  
 [!code-csharp[csProgGuideGenerics#15](../../../csharp/programming-guide/generics/codesnippet/CSharp/constraints-on-type-parameters_6.cs)]  
  
 <span data-ttu-id="ae8ce-157">제네릭 클래스에서 형식 매개 변수를 제약 조건으로 사용할 경우 컴파일러에서 형식 매개 변수가 `System.Object`에서 파생된다는 점을 제외하고 형식 매개 변수에 대해 어떠한 정보도 알 수 없으므로 유용성이 매우 제한됩니다.</span><span class="sxs-lookup"><span data-stu-id="ae8ce-157">The usefulness of type parameters as constraints with generic classes is very limited because the compiler can assume nothing about the type parameter except that it derives from `System.Object`.</span></span> <span data-ttu-id="ae8ce-158">두 형식 매개 변수 사이의 상속 관계를 적용하려는 시나리오에서 제네릭 클래스에 형식 매개 변수를 제약 조건으로 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="ae8ce-158">Use type parameters as constraints on generic classes in scenarios in which you want to enforce an inheritance relationship between two type parameters.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="ae8ce-159">참고 항목</span><span class="sxs-lookup"><span data-stu-id="ae8ce-159">See Also</span></span>  
 <xref:System.Collections.Generic>  
 [<span data-ttu-id="ae8ce-160">C# 프로그래밍 가이드</span><span class="sxs-lookup"><span data-stu-id="ae8ce-160">C# Programming Guide</span></span>](../../../csharp/programming-guide/index.md)  
 [<span data-ttu-id="ae8ce-161">제네릭 소개</span><span class="sxs-lookup"><span data-stu-id="ae8ce-161">Introduction to Generics</span></span>](../../../csharp/programming-guide/generics/introduction-to-generics.md)  
 [<span data-ttu-id="ae8ce-162">제네릭 클래스</span><span class="sxs-lookup"><span data-stu-id="ae8ce-162">Generic Classes</span></span>](../../../csharp/programming-guide/generics/generic-classes.md)  
 [<span data-ttu-id="ae8ce-163">new 제약 조건</span><span class="sxs-lookup"><span data-stu-id="ae8ce-163">new Constraint</span></span>](../../../csharp/language-reference/keywords/new-constraint.md)

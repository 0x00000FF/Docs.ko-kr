---
title: "값 형식과 참조 의미 체계가"
description: "안전 하 게 복사 구조를 최소화 하는 언어 기능 이해"
author: billwagner
ms.author: wiwagn
ms.date: 11/10/2017
ms.topic: article
ms.prod: .net
ms.technology: devlang-csharp
ms.devlang: csharp
ms.custom: mvc
ms.openlocfilehash: 9eeaf201c1f5a58044db62e356199b609c4c035a
ms.sourcegitcommit: 7e99f66ef09d2903e22c789c67ff5a10aa953b2f
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 11/18/2017
---
# <a name="reference-semantics-with-value-types"></a><span data-ttu-id="dba46-103">값 형식과 참조 의미 체계가</span><span class="sxs-lookup"><span data-stu-id="dba46-103">Reference semantics with value types</span></span>

<span data-ttu-id="dba46-104">값 형식을 사용 하 여 힙 할당을 종종 방지 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="dba46-104">An advantage to using value types is that they often avoid heap allocations.</span></span>
<span data-ttu-id="dba46-105">해당 단점은 값으로 복사 됩니다.</span><span class="sxs-lookup"><span data-stu-id="dba46-105">The corresponding disadvantage is that they are copied by value.</span></span> <span data-ttu-id="dba46-106">이러한 상충 관계를 사용 하면 많은 양의 데이터에서 작동 하는 알고리즘을 최적화 하기 어렵습니다.</span><span class="sxs-lookup"><span data-stu-id="dba46-106">This tradeoff makes it harder to optimize algorithms that operate on large amounts of data.</span></span> <span data-ttu-id="dba46-107">C# 7.2의 새로운 언어 기능 값 형식과 참조로 전달 의미 체계를 사용할 수 있는 메커니즘을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="dba46-107">New language features in C# 7.2 provide mechanisms that enable pass-by-reference semantics with value types.</span></span> <span data-ttu-id="dba46-108">현명 하 게 이러한 기능을 사용 하는 경우에 할당을 모두를 최소화 하 고 복사 작업 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="dba46-108">If you use these features wisely you can minimize both allocations and copy operations.</span></span> <span data-ttu-id="dba46-109">이 문서는 새로운 기능을 탐색합니다.</span><span class="sxs-lookup"><span data-stu-id="dba46-109">This article explores those new features.</span></span>

<span data-ttu-id="dba46-110">이 문서의 예제 코드의 대부분 C# 7.2에 추가 된 기능을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="dba46-110">Much of the sample code in this article demonstrates features added in C# 7.2.</span></span> <span data-ttu-id="dba46-111">이러한 기능을 사용 하려면 프로젝트에 C# 7.2 또는 그 이후 버전을 사용 하도록 프로젝트를 구성 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="dba46-111">In order to use those features, you have to configure your project to use C# 7.2 or later in your project.</span></span> <span data-ttu-id="dba46-112">Visual Studio를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="dba46-112">You can use Visual Studio to select it.</span></span> <span data-ttu-id="dba46-113">각 프로젝트에 대 한 선택 **프로젝트** 다음 메뉴에서 **속성**합니다.</span><span class="sxs-lookup"><span data-stu-id="dba46-113">For each project, select **Project** from the menu, then **Properties**.</span></span> <span data-ttu-id="dba46-114">선택 된 **빌드** 탭을 클릭 **고급**합니다.</span><span class="sxs-lookup"><span data-stu-id="dba46-114">Select the **Build** tab and click **Advanced**.</span></span> <span data-ttu-id="dba46-115">여기에서 언어 버전을 구성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="dba46-115">From there, you can configure the language version.</span></span> <span data-ttu-id="dba46-116">"7.2" 또는 "최신" 중 하나를 선택 합니다.</span><span class="sxs-lookup"><span data-stu-id="dba46-116">Choose either "7.2", or "latest".</span></span>  <span data-ttu-id="dba46-117">편집할 수도 있습니다는 *csproj* 파일을 다음 노드를 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="dba46-117">Or you can edit the *csproj* file and add the following node:</span></span>

```XML
  <PropertyGroup>
    <LangVersion>7.2</LangVersion>
  </PropertyGroup>
```

<span data-ttu-id="dba46-118">값에 대 한 "7.2" 또는 "최신" 중 하나를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="dba46-118">You can use either "7.2" or "latest" for the value.</span></span>

## <a name="specifying-in-parameters"></a><span data-ttu-id="dba46-119">지정 `in` 매개 변수</span><span class="sxs-lookup"><span data-stu-id="dba46-119">Specifying `in` parameters</span></span>

<span data-ttu-id="dba46-120">추가 하는 C# 7.2는 `in` 기존 보완 하기 위해 키워드 `ref` 및 `out` 키워드 참조로 인수를 전달 하는 메서드를 작성 하는 경우.</span><span class="sxs-lookup"><span data-stu-id="dba46-120">C# 7.2 adds the `in` keyword to complement the existing `ref` and `out` keywords when you write a method that passes arguments by reference.</span></span> <span data-ttu-id="dba46-121">`in` 키워드 지정 된 매개 변수를 전달 하는 참조에 의해 호출된 된 메서드에 전달 된 값을 수정 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="dba46-121">The `in` keyword specifies that you are passing the parameter by reference and the called method does not modify the value passed to it.</span></span> 

<span data-ttu-id="dba46-122">이 추가 디자인 의도 표현 하는 전체 어휘를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="dba46-122">This addition provides a full vocabulary to express your design intent.</span></span> <span data-ttu-id="dba46-123">값 형식에는 다음 한정자 중 하나를 지정 하지 않을 경우 호출 메서드에 전달 될 때 복사 됩니다.</span><span class="sxs-lookup"><span data-stu-id="dba46-123">Value types are copied when passed to a called method when you do not specify any of the following modifiers.</span></span> <span data-ttu-id="dba46-124">이러한 한정자의 각 값 형식이 전달 되도록 참조에 의해 복사 방지를 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="dba46-124">Each of these modifiers specify that a value type is passed by reference, avoiding the copy.</span></span> <span data-ttu-id="dba46-125">각 한정자 다른 목적에 따라 표시:</span><span class="sxs-lookup"><span data-stu-id="dba46-125">Each modifier expresses a different intent:</span></span>

- <span data-ttu-id="dba46-126">`out`:이 메서드는이 매개 변수로 사용 되는 인수 값을 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="dba46-126">`out`: This method sets the value of the argument used as this parameter.</span></span>
- <span data-ttu-id="dba46-127">`ref`:이 메서드는이 매개 변수로 사용 되는 인수의 값을 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="dba46-127">`ref`: This method may set the value of the argument used as this parameter.</span></span>
- <span data-ttu-id="dba46-128">`in`:이 메서드는이 매개 변수로 사용 되는 인수 값을 수정 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="dba46-128">`in`: This method does not modify the value of the argument used as this parameter.</span></span>

<span data-ttu-id="dba46-129">추가 하는 경우는 `in` 한정자 참조로 인수를 전달 하려면 디자인 의도 불필요 한 복사를 방지 하기 위해 참조로 인수를 전달 하는 것을 선언 합니다.</span><span class="sxs-lookup"><span data-stu-id="dba46-129">When you add the `in` modifier to pass an argument by reference, you declare your design intent is to pass arguments by reference to avoid unnecessary copying.</span></span> <span data-ttu-id="dba46-130">해당 인수로 사용 되는 개체를 수정 하지 않을 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="dba46-130">You do not intend to modify the object used as that argument.</span></span> <span data-ttu-id="dba46-131">다음 코드에서는 3D 공간에서 두 점 사이의 거리를 계산 하는 방법의 예를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="dba46-131">The following code shows an example of a method that calculates the distance between two points in 3D space.</span></span> 

[!code-csharp[InArgument](../../samples/csharp/reference-semantics/Program.cs#InArgument "Specifying an In argument")]

<span data-ttu-id="dba46-132">인수는 각각 세 개의 double 값을 포함 하는 두 개의 구조.</span><span class="sxs-lookup"><span data-stu-id="dba46-132">The arguments are two structures that each contain three doubles.</span></span> <span data-ttu-id="dba46-133">Double 8 바이트 이므로 각 인수는 24 바이트.</span><span class="sxs-lookup"><span data-stu-id="dba46-133">A double is 8 bytes, so each argument is 24 bytes.</span></span> <span data-ttu-id="dba46-134">지정 하 여는 `in` 컴퓨터의 아키텍처에 따라 이러한 인수에 대 한 4 바이트 또는 8 바이트 참조를 전달 한정자입니다.</span><span class="sxs-lookup"><span data-stu-id="dba46-134">By specifying the `in` modifier, you pass 4-byte or 8-byte reference to those arguments, depending on the architecture of the machine.</span></span> <span data-ttu-id="dba46-135">크기의 차이 크지 있지만 응용 프로그램 여러 다른 값을 사용 하 여 루프에서이 메서드를 호출 하면 신속 하 게 추가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="dba46-135">The difference in size is small, but it can quickly add up when your application calls this method in a tight loop using many different values.</span></span>
 
<span data-ttu-id="dba46-136">`in` 한정자 보완 `out` 및 `ref` 다른 방식에서입니다.</span><span class="sxs-lookup"><span data-stu-id="dba46-136">The `in` modifier complements `out` and `ref` in other ways as well.</span></span> <span data-ttu-id="dba46-137">만 시에도 다른 메서드의 오버 로드를 만들 수 없습니다 `in`, `out` 또는 `ref`합니다.</span><span class="sxs-lookup"><span data-stu-id="dba46-137">You cannot create overloads of a method that differ only in the presence of `in`, `out` or `ref`.</span></span> <span data-ttu-id="dba46-138">이러한 새 규칙에 대해 정의 된 항상 동일한 동작 확장 `out` 및 `ref` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="dba46-138">These new rules extend the same behavior that had always been defined for `out` and `ref` parameters.</span></span>

<span data-ttu-id="dba46-139">`in` 한정자 매개 변수를 사용 하는 멤버에 적용 될 수 있습니다: 메서드, 대리자, 람다 식, 로컬 함수, 인덱서, 연산자입니다.</span><span class="sxs-lookup"><span data-stu-id="dba46-139">The `in` modifier may be applied to any member that takes parameters: methods, delegates, lambdas, local functions, indexers, operators.</span></span>

<span data-ttu-id="dba46-140">와 달리 `ref` 및 `out` 인수에 리터럴 값 또는 상수에 대해 사용할 수에 대 한 인수는 `in` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="dba46-140">Unlike `ref` and `out` arguments, you may use literal values or constants for the argument to an `in` parameter.</span></span> <span data-ttu-id="dba46-141">또한 달리는 `ref` 또는 `out` 매개 변수를 적용할 필요 하지 않습니다는 `in` 호출 사이트에서 한정자입니다.</span><span class="sxs-lookup"><span data-stu-id="dba46-141">Also, unlike a `ref` or `out` parameter, you don't need to apply the `in` modifier at the call site.</span></span> <span data-ttu-id="dba46-142">다음 코드에서는 호출의 두 가지 예는 `CalculateDistance` 메서드.</span><span class="sxs-lookup"><span data-stu-id="dba46-142">The following code shows you two examples of calling the `CalculateDistance` method.</span></span> <span data-ttu-id="dba46-143">첫 번째 참조로 전달 하는 두 개의 지역 변수를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="dba46-143">The first uses two local variables passed by reference.</span></span> <span data-ttu-id="dba46-144">두 번째 메서드 호출의 일부로 만들어진 임시 변수를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="dba46-144">The second includes a temporary variable created as part of the method call.</span></span> 

[!code-csharp[UseInArgument](../../samples/csharp/reference-semantics/Program.cs#UseInArgument "Specifying an In argument")]

<span data-ttu-id="dba46-145">여러 가지 방법으로는 컴파일러 되도록의 읽기 전용 특성은 `in` 인수에 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="dba46-145">There are several ways in which the compiler ensures that the read-only nature of an `in` argument is enforced.</span></span>  <span data-ttu-id="dba46-146">호출된 된 메서드가에 직접 할당할 수 없습니다는 우선,는 `in` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="dba46-146">First of all, the called method can't directly assign to an `in` parameter.</span></span> <span data-ttu-id="dba46-147">모든 필드에 직접 할당할 수 없습니다는 `in` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="dba46-147">It can't directly assign to any field of an `in` parameter.</span></span> <span data-ttu-id="dba46-148">또한 전달할 수 없습니다는 `in` 요구 되는 모든 메서드 매개 변수는 `ref` 또는 `out` 한정자입니다.</span><span class="sxs-lookup"><span data-stu-id="dba46-148">In addition, you cannot pass an `in` parameter to any method demanding the `ref` or `out` modifier.</span></span>
<span data-ttu-id="dba46-149">있는 경우 컴파일러는는 `in` 인수는 읽기 전용 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="dba46-149">The compiler enforces that the `in` argument is a readonly variable.</span></span> <span data-ttu-id="dba46-150">통과-값 의미 체계를 사용 하는 인스턴스 메서드를 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="dba46-150">You can call any instance method that uses pass-by-value semantics.</span></span> <span data-ttu-id="dba46-151">이러한 경우,의 복사본은 `in` 매개 변수가 생성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="dba46-151">In those instances, a copy of the `in` parameter is created.</span></span> <span data-ttu-id="dba46-152">컴파일러에 대 한 임시 변수를 만들 수 있으므로 `in` 매개 변수를 하나에 대 한 기본값을 지정할 수도 있습니다 `in` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="dba46-152">Because the compiler can create a temporary variable for any `in` parameter, you can also specify default values for any `in` parameter.</span></span> <span data-ttu-id="dba46-153">다음 코드는이 사용 하 여 두 번째 요소에 대 한 값을 기본값으로 원점 (0, 0 지점)를 지정 하려면:</span><span class="sxs-lookup"><span data-stu-id="dba46-153">The follow code uses that to specify the origin (point 0,0) as the default value for the second point:</span></span>

[!code-csharp[InArgumentDefault](../../samples/csharp/reference-semantics/Program.cs#InArgumentDefault "Specifying defaults for an in parameter")]

<span data-ttu-id="dba46-154">`in` 매개 변수 지정 또한 참조 형식에 사용 하거나 숫자 값에서 빌드된 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="dba46-154">The `in` parameter designation can also be used with reference types or built in numeric values.</span></span> <span data-ttu-id="dba46-155">그러나 두 경우 모두 이점은 있는 경우에 최소 있습니다.</span><span class="sxs-lookup"><span data-stu-id="dba46-155">However, the benefits in both cases are minimal, if any.</span></span>

## <a name="ref-readonly-returns"></a><span data-ttu-id="dba46-156">`ref readonly`반환</span><span class="sxs-lookup"><span data-stu-id="dba46-156">`ref readonly` returns</span></span>

<span data-ttu-id="dba46-157">값 형식을 참조로 반환 하지만 해당 값을 수정할 수 없도록 호출자를 허용 하지 않습니다 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="dba46-157">You may also want to return a value type by reference, but disallow the caller from modifying that value.</span></span> <span data-ttu-id="dba46-158">사용 된 `ref readonly` 디자인 의도 표현 하는 한정자입니다.</span><span class="sxs-lookup"><span data-stu-id="dba46-158">Use the `ref readonly` modifier to express that design intent.</span></span> <span data-ttu-id="dba46-159">기존 데이터에 대 한 참조를 반환 하지만 수정을 허용 하지 않습니다는 판독기를 알립니다.</span><span class="sxs-lookup"><span data-stu-id="dba46-159">It notifies readers that you are returning a reference to existing data, but not allowing modification.</span></span> 

<span data-ttu-id="dba46-160">경우 컴파일러는 호출자가 참조를 수정할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="dba46-160">The compiler enforces that the caller cannot modify the reference.</span></span> <span data-ttu-id="dba46-161">값에 직접 지정 하 려 컴파일 타임 오류를 생성 합니다.</span><span class="sxs-lookup"><span data-stu-id="dba46-161">Attempts to assign to the value directly generate a compile-time error.</span></span> <span data-ttu-id="dba46-162">그러나 컴파일러는 멤버 메서드 구조체의 상태를 수정 하는 경우 알 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="dba46-162">However, the compiler cannot know if any member method modifies the state of the struct.</span></span>
<span data-ttu-id="dba46-163">개체가 수정 되지 않습니다을 보장 하려면 컴파일러 복사본을 만들고 해당 복사본을 사용 하 여 참조 멤버를 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="dba46-163">To ensure that the object is not modified, the compiler creates a copy and calls member references using that copy.</span></span> <span data-ttu-id="dba46-164">모든 수정 내용은 해당 방어 복사본에 됩니다.</span><span class="sxs-lookup"><span data-stu-id="dba46-164">Any modifications are to that defensive copy.</span></span> 

<span data-ttu-id="dba46-165">가능성이 사용 하 여 라이브러리 `Point3D` 원본 코드를 통해 자주 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="dba46-165">It's likely that the library using `Point3D` would often use the origin throughout the code.</span></span> <span data-ttu-id="dba46-166">모든 인스턴스에 스택에 새 개체를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="dba46-166">Every instance creates a new object on the stack.</span></span> <span data-ttu-id="dba46-167">상수를 만들고 참조로 반환 하는 것이 도움이 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="dba46-167">It may be advantageous to create a constant and return it by reference.</span></span> <span data-ttu-id="dba46-168">그러나 내부 저장소에 대 한 참조를 반환 하는 경우 수 적용 하려는 호출자에 게 참조 된 저장소를 수정할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="dba46-168">But, if you return a reference to internal storage, you may want to enforce that the caller cannot modify the referenced storage.</span></span> <span data-ttu-id="dba46-169">다음 코드를 반환 하는 읽기 전용 속성 정의 `readonly ref` 에 `Point3D` 출처를 지정 하는 합니다.</span><span class="sxs-lookup"><span data-stu-id="dba46-169">The following code defines a read-only property that returns a `readonly ref` to a `Point3D` that specifies the origin.</span></span>

[!code-csharp[OriginReference](../../samples/csharp/reference-semantics/Point3D.cs#OriginReference "Creating a readonly Origin reference")]

<span data-ttu-id="dba46-170">반환 ref 읽기 전용 복사본을 만드는 것은 쉽습니다: 방금로 선언 되지 변수에 할당할는 `ref readonly` 한정자입니다.</span><span class="sxs-lookup"><span data-stu-id="dba46-170">Creating a copy of a ref readonly return is easy: Just assign it to a variable not declared with the `ref readonly` modifier.</span></span> <span data-ttu-id="dba46-171">컴파일러는 할당의 일부로 개체를 복사 하는 코드를 생성 합니다.</span><span class="sxs-lookup"><span data-stu-id="dba46-171">The compiler generates code to copy the object as part of the assignment.</span></span> 

<span data-ttu-id="dba46-172">변수를 할당 하면는 `ref readonly return`를 하나만 지정할 수 있습니다는 `ref readonly` 변수 또는 읽기 전용 참조의 값으로 복사:</span><span class="sxs-lookup"><span data-stu-id="dba46-172">When you assign a variable to a `ref readonly return`, you can specify either a `ref readonly` variable, or a by-value copy of the readonly reference:</span></span>

[!code-csharp[AssignRefReadonly](../../samples/csharp/reference-semantics/Program.cs#AssignRefReadonly "Assigning a ref readonly")]

<span data-ttu-id="dba46-173">위의 코드에서 첫 번째 할당의 복사본을 만듭니다는 `Origin` 상수와 복사 할당 합니다.</span><span class="sxs-lookup"><span data-stu-id="dba46-173">The first assignment in the preceding code makes a copy of the `Origin` constant and assigns that copy.</span></span> <span data-ttu-id="dba46-174">두 번째에 대 한 참조를 할당합니다.</span><span class="sxs-lookup"><span data-stu-id="dba46-174">The second assigns a reference.</span></span> <span data-ttu-id="dba46-175">에 `readonly` 한정자에는 변수 선언의의 일부 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="dba46-175">Notice that the `readonly` modifier must be part of the declaration of the variable.</span></span> <span data-ttu-id="dba46-176">참조 하는 참조를 수정할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="dba46-176">The reference to which it refers cannot be modified.</span></span> <span data-ttu-id="dba46-177">이렇게 하면 컴파일 타임 오류가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="dba46-177">Attempts to do so result in a compile-time error.</span></span>

## <a name="readonly-struct-type"></a><span data-ttu-id="dba46-178">`readonly struct` 형식</span><span class="sxs-lookup"><span data-stu-id="dba46-178">`readonly struct` type</span></span>

<span data-ttu-id="dba46-179">적용 `ref readonly` 를 한 구조체의 트래픽이 높은 사용 충분할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="dba46-179">Applying `ref readonly` to high-traffic uses of a struct may be sufficient.</span></span>
<span data-ttu-id="dba46-180">그 결과 변경할 수 없는 구조체를 만들어야 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="dba46-180">Other times, you may want to create an immutable struct.</span></span> <span data-ttu-id="dba46-181">항상 읽기 전용 참조로 전달할 수 있습니다 그런 다음.</span><span class="sxs-lookup"><span data-stu-id="dba46-181">Then you can always pass by readonly reference.</span></span> <span data-ttu-id="dba46-182">로 사용 되는 구조체의 메서드를 액세스 하는 경우 발생 하는 복사 연습 방어를 제거 하는 `in` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="dba46-182">That practice removes the defensive copies that take place when you access methods of a struct used as an `in` parameter.</span></span>

<span data-ttu-id="dba46-183">만들면 할 수는 `readonly struct` 유형입니다.</span><span class="sxs-lookup"><span data-stu-id="dba46-183">You can do that by creating a `readonly struct` type.</span></span> <span data-ttu-id="dba46-184">추가할 수는 `readonly` 구조체 선언에는 한정자입니다.</span><span class="sxs-lookup"><span data-stu-id="dba46-184">You can add the `readonly` modifier to a struct declaration.</span></span> <span data-ttu-id="dba46-185">구조체의 모든 멤버가 되는 경우 컴파일러는 `readonly`; `struct` 변경 하지 않아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="dba46-185">The compiler enforces that all members of the struct are `readonly`; the `struct` must be immutable.</span></span>

<span data-ttu-id="dba46-186">에 대 한 다른 최적화는는 `readonly struct`합니다.</span><span class="sxs-lookup"><span data-stu-id="dba46-186">There are other optimizations for a `readonly struct`.</span></span> <span data-ttu-id="dba46-187">사용할 수는 `in` 한정자를 모든 위치에서 있는 `readonly struct` 인수입니다.</span><span class="sxs-lookup"><span data-stu-id="dba46-187">You can use the `in` modifier at every location where a `readonly struct` is an argument.</span></span> <span data-ttu-id="dba46-188">또한 반환할 수 있습니다는 `readonly struct` 로 `ref return` 수명이 개체를 반환 하는 메서드 범위에 해당 하는 개체 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="dba46-188">In addition, you can return a `readonly struct` as a `ref return` when you are returning an object whose lifetime extends beyond the scope of the method returning the object.</span></span>

<span data-ttu-id="dba46-189">멤버를 호출 하는 경우 컴파일러에서 보다 효율적인 코드를 생성 하는 마지막으로, 한 `readonly struct`:는 `this` 수신기의 복사본 대신 참조는 항상는 `in` 매개 변수는 멤버 메서드를 참조로 전달 합니다.</span><span class="sxs-lookup"><span data-stu-id="dba46-189">Finally, the compiler generates more efficient code when you call members of a `readonly struct`: The `this` reference, instead of a copy of the receiver, is always an `in` parameter passed by reference to the member method.</span></span> <span data-ttu-id="dba46-190">이 최적화를 사용 하는 경우 더 많은 복사 저장는 `readonly struct`합니다.</span><span class="sxs-lookup"><span data-stu-id="dba46-190">This optimization saves more copying when you use a `readonly struct`.</span></span> <span data-ttu-id="dba46-191">`Point3D` 이 변경에 대 한 훌륭한 후보입니다.</span><span class="sxs-lookup"><span data-stu-id="dba46-191">The `Point3D` is a great candidate for this change.</span></span> <span data-ttu-id="dba46-192">다음 코드에서는 업데이트 된 `ReadonlyPoint3D` 구조:</span><span class="sxs-lookup"><span data-stu-id="dba46-192">The following code shows an updated `ReadonlyPoint3D` structure:</span></span>

[!code-csharp[ReadonlyOnlyPoint3D](../../samples/csharp/reference-semantics/Point3D.cs#ReadonlyOnlyPoint3D "Defining an immutable structure")]

## <a name="ref-struct-type"></a><span data-ttu-id="dba46-193">`ref struct` 형식</span><span class="sxs-lookup"><span data-stu-id="dba46-193">`ref struct` type</span></span>

<span data-ttu-id="dba46-194">다른 관련 된 언어 기능 스택에 할당 해야 하는 값 형식을 선언할 수 있다는 점입니다.</span><span class="sxs-lookup"><span data-stu-id="dba46-194">Another related language feature is the ability to declare a value type that must be stack allocated.</span></span> <span data-ttu-id="dba46-195">즉, 이러한 형식은 되지 만들 수 있습니다 힙에 다른 클래스의 구성원으로.</span><span class="sxs-lookup"><span data-stu-id="dba46-195">In other words, these types can never be created on the heap as a member of another class.</span></span> <span data-ttu-id="dba46-196">이 기능에 대 한 기본 동기를 <xref:System.Span%601> 및 관련 구조입니다.</span><span class="sxs-lookup"><span data-stu-id="dba46-196">The primary motivation for this feature was <xref:System.Span%601> and related structures.</span></span> <span data-ttu-id="dba46-197"><xref:System.Span%601>포함할 수 있습니다 관리 되는 포인터 해당 멤버 중 하나로 다른 되는 범위의 길이입니다.</span><span class="sxs-lookup"><span data-stu-id="dba46-197"><xref:System.Span%601> may contain a managed pointer as one of its members, the other being the length of the span.</span></span> <span data-ttu-id="dba46-198">C# 안전 하지 않은 컨텍스트 외부에서 관리 되는 메모리에 대 한 포인터를 지원 하지 않으므로 약간 다르게 구현 실제로 됩니다.</span><span class="sxs-lookup"><span data-stu-id="dba46-198">It's actually implemented a bit differently because C# doesn't support pointers to managed memory outside of an unsafe context.</span></span> <span data-ttu-id="dba46-199">포인터와 길이 변경 하는 모든 쓰기 원자성있지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="dba46-199">Any write that changes the pointer and the length is not atomic.</span></span> <span data-ttu-id="dba46-200">즉, 한 <xref:System.Span%601> 부족 범위 오류를 일으키는 것 또는 다른 형식 안전성을 위반 하는 단일 스택 프레임으로 제한 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="dba46-200">That means a <xref:System.Span%601> would be subject to out of range errors or other type safety violations were it not constrained to a single stack frame.</span></span> <span data-ttu-id="dba46-201">또한 JIT 시 충돌 GC 힙에 일반적으로 관리 되는 포인터를 배치 합니다.</span><span class="sxs-lookup"><span data-stu-id="dba46-201">In addition, putting a managed pointer on the GC heap typically crashes at JIT time.</span></span>

<span data-ttu-id="dba46-202">이와 비슷한 요구 사항을 사용 하 여 만든 메모리 작업을 할 수 있습니다 [ `stackalloc` ](language-reference/keywords/stackalloc.md) 메모리 interop Api에서 사용 하는 경우.</span><span class="sxs-lookup"><span data-stu-id="dba46-202">You may have similar requirements working with memory created using [`stackalloc`](language-reference/keywords/stackalloc.md) or when using memory from interop APIs.</span></span> <span data-ttu-id="dba46-203">직접 정의할 수 `ref struct` 이러한 요구 사항에 대 한 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="dba46-203">You can define your own `ref struct` types for those needs.</span></span> <span data-ttu-id="dba46-204">이 문서에 사용 하는 예제 표시 `Span<T>` 을 간소화 합니다.</span><span class="sxs-lookup"><span data-stu-id="dba46-204">In this article, you see examples using `Span<T>` for simplicity.</span></span>

<span data-ttu-id="dba46-205">`ref struct` 선언은 스택에이 형식의 구조체를 이어야 함을 선언 합니다.</span><span class="sxs-lookup"><span data-stu-id="dba46-205">The `ref struct` declaration declares that a struct of this type must be on the stack.</span></span> <span data-ttu-id="dba46-206">언어 규칙에는 이러한 형식의 안전 하 게 보장합니다.</span><span class="sxs-lookup"><span data-stu-id="dba46-206">The language rules ensure the safe use of these types.</span></span> <span data-ttu-id="dba46-207">다른 형식으로 선언 `ref struct` 포함 <xref:System.ReadOnlySpan%601>합니다.</span><span class="sxs-lookup"><span data-stu-id="dba46-207">Other types declared as `ref struct` include <xref:System.ReadOnlySpan%601>.</span></span> 

<span data-ttu-id="dba46-208">보관의 목표는 `ref struct` 스택 할당 변수의 경우 컴파일러는 모두에 대 한 여러 가지 규칙을 소개 하는 대로 입력 `ref struct` 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="dba46-208">The goal of keeping a `ref struct` type as a stack-allocated variable introduces several rules that the compiler enforces for all `ref struct` types.</span></span>

- <span data-ttu-id="dba46-209">상자 없습니다는 `ref struct`합니다.</span><span class="sxs-lookup"><span data-stu-id="dba46-209">You can't box a `ref struct`.</span></span> <span data-ttu-id="dba46-210">할당할 수 없습니다는 `ref struct` 형식의 변수에 형식을 `object`, `dynamic`, 또는 임의의 인터페이스 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="dba46-210">You cannot assign a `ref struct` type to a variable of type `object`, `dynamic`, or any interface type.</span></span>
- <span data-ttu-id="dba46-211">선언할 수 없습니다는 `ref struct` 클래스 또는 일반 구조체의 멤버로 합니다.</span><span class="sxs-lookup"><span data-stu-id="dba46-211">You can't declare a `ref struct` as a member of a class or a normal struct.</span></span>
- <span data-ttu-id="dba46-212">지역 변수를 선언할 수 없습니다 `ref struct` 비동기 메서드의 유형입니다.</span><span class="sxs-lookup"><span data-stu-id="dba46-212">You cannot declare local variables that are `ref struct` types in async methods.</span></span> <span data-ttu-id="dba46-213">반환 하는 동기 메서드를 선언할 수 있습니다 `Task`, `Task<T>` 또는 작업와 비슷한 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="dba46-213">You can declare them in synchronous methods that return `Task`, `Task<T>` or Task-like types.</span></span>
- <span data-ttu-id="dba46-214">선언할 수 없습니다 `ref struct` 반복기에서 지역 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="dba46-214">You cannot declare `ref struct` local variables in iterators.</span></span>
- <span data-ttu-id="dba46-215">캡처할 수 없습니다 `ref struct` 람다 식 또는 로컬 함수에는 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="dba46-215">You cannot capture `ref struct` variables in lambda expressions or local functions.</span></span>

<span data-ttu-id="dba46-216">이러한 제한 사항을 확인을 사용 하지 않는 실수로 `ref struct` 한 방식으로 관리 되는 힙에 승격할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="dba46-216">These restrictions ensure that you do not accidentally use a `ref struct` in a manner that could promote it to the managed heap.</span></span>

## <a name="conclusions"></a><span data-ttu-id="dba46-217">결론</span><span class="sxs-lookup"><span data-stu-id="dba46-217">Conclusions</span></span>

<span data-ttu-id="dba46-218">이러한 향상 된 C# 언어에는 메모리 할당을 필요한 성능을 달성 하는 데 중요 한 될 수 있는 중요 한 알고리즘의 성능 설계 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="dba46-218">These enhancements to the C# language are designed for performance critical algorithms where memory allocations can be critical to achieving the necessary performance.</span></span> <span data-ttu-id="dba46-219">작성 하는 코드에서 이러한 기능을 자주 사용 하지 않는 알 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="dba46-219">You may find that you don't often use these features in the code you write.</span></span> <span data-ttu-id="dba46-220">그러나 이러한 향상 된.NET Framework의 여러 위치에서 채택 된 합니다.</span><span class="sxs-lookup"><span data-stu-id="dba46-220">However, these enhancements have been adopted in many locations in the .NET Framework.</span></span> <span data-ttu-id="dba46-221">점점 더 많은 Api로 이러한 기능을 사용 하 여, 응용 프로그램의 성능을 향상 시킬 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="dba46-221">As more and more APIs make use of these features, you'll see the performance of your own applications improve.</span></span>

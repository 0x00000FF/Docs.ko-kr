---
title: "값 형식과 참조 의미 체계"
description: "구조 복사를 안전하게 최소화하는 언어 기능 이해"
author: billwagner
ms.author: wiwagn
ms.date: 11/10/2017
ms.topic: article
ms.prod: .net
ms.technology: devlang-csharp
ms.devlang: csharp
ms.custom: mvc
ms.openlocfilehash: 6e40907cab2aabcf8c8321819c99298314bcfbc5
ms.sourcegitcommit: 83dd5ec003e788ccb3e33f3412a7af39ae347646
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/15/2018
---
# <a name="reference-semantics-with-value-types"></a><span data-ttu-id="ac1cc-103">값 형식과 참조 의미 체계</span><span class="sxs-lookup"><span data-stu-id="ac1cc-103">Reference semantics with value types</span></span>

<span data-ttu-id="ac1cc-104">값 형식을 사용할 경우의 장점은 대개 힙 할당을 할 필요가 없다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="ac1cc-104">An advantage to using value types is that they often avoid heap allocations.</span></span>
<span data-ttu-id="ac1cc-105">상응하는 단점은 값 형식이 값으로 복사된다는 점입니다.</span><span class="sxs-lookup"><span data-stu-id="ac1cc-105">The corresponding disadvantage is that they are copied by value.</span></span> <span data-ttu-id="ac1cc-106">이러한 장단점 간에 균형을 잡으려고 하니 많은 양의 데이터에서 작동하는 알고리즘을 최적화하기가 어렵습니다.</span><span class="sxs-lookup"><span data-stu-id="ac1cc-106">This tradeoff makes it harder to optimize algorithms that operate on large amounts of data.</span></span> <span data-ttu-id="ac1cc-107">C# 7.2의 새로운 언어 기능은 값 형식으로 pass-by-reference 의미 체계를 가능하게 하는 메커니즘을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="ac1cc-107">New language features in C# 7.2 provide mechanisms that enable pass-by-reference semantics with value types.</span></span> <span data-ttu-id="ac1cc-108">이러한 기능을 현명하게 사용하면 할당 및 복사 작업을 최소화할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ac1cc-108">If you use these features wisely you can minimize both allocations and copy operations.</span></span> <span data-ttu-id="ac1cc-109">이 문서에서는 이러한 새로운 기능을 살펴봅니다.</span><span class="sxs-lookup"><span data-stu-id="ac1cc-109">This article explores those new features.</span></span>

<span data-ttu-id="ac1cc-110">이 문서의 샘플 코드 상당수는 C# 7.2에 추가된 기능을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="ac1cc-110">Much of the sample code in this article demonstrates features added in C# 7.2.</span></span> <span data-ttu-id="ac1cc-111">이러한 기능을 사용하려면 프로젝트에서 C# 7.2 이상을 사용하도록 프로젝트를 구성해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ac1cc-111">In order to use those features, you have to configure your project to use C# 7.2 or later in your project.</span></span> <span data-ttu-id="ac1cc-112">Visual Studio를 사용하여 선택할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ac1cc-112">You can use Visual Studio to select it.</span></span> <span data-ttu-id="ac1cc-113">각 프로젝트에 대해 메뉴에서 **프로젝트**를 선택한 다음 **속성**을 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="ac1cc-113">For each project, select **Project** from the menu, then **Properties**.</span></span> <span data-ttu-id="ac1cc-114">**빌드** 탭을 선택하고 **고급**을 클릭합니다.</span><span class="sxs-lookup"><span data-stu-id="ac1cc-114">Select the **Build** tab and click **Advanced**.</span></span> <span data-ttu-id="ac1cc-115">여기서 언어 버전을 구성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ac1cc-115">From there, you can configure the language version.</span></span> <span data-ttu-id="ac1cc-116">“7.2” 또는 “latest”를 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="ac1cc-116">Choose either "7.2", or "latest".</span></span>  <span data-ttu-id="ac1cc-117">또는 *csproj* 파일을 편집하고 다음 노드를 추가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ac1cc-117">Or you can edit the *csproj* file and add the following node:</span></span>

```XML
  <PropertyGroup>
    <LangVersion>7.2</LangVersion>
  </PropertyGroup>
```

<span data-ttu-id="ac1cc-118">값에 “7.2” 또는 “latest”를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ac1cc-118">You can use either "7.2" or "latest" for the value.</span></span>

## <a name="specifying-in-parameters"></a><span data-ttu-id="ac1cc-119">`in` 매개 변수 지정</span><span class="sxs-lookup"><span data-stu-id="ac1cc-119">Specifying `in` parameters</span></span>

<span data-ttu-id="ac1cc-120">C# 7.2에서는 참조로 인수를 전달하는 메서드를 작성할 때 기존 `ref` 및 `out` 키워드를 보완하기 위해 `in` 키워드를 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="ac1cc-120">C# 7.2 adds the `in` keyword to complement the existing `ref` and `out` keywords when you write a method that passes arguments by reference.</span></span> <span data-ttu-id="ac1cc-121">`in` 키워드는 참조로 매개 변수를 전달하고 호출된 메서드가 전달된 값을 수정하지 않도록 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="ac1cc-121">The `in` keyword specifies that you are passing the parameter by reference and the called method does not modify the value passed to it.</span></span> 

<span data-ttu-id="ac1cc-122">이 추가는 설계 의도를 표현하기 위한 완벽한 어휘를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="ac1cc-122">This addition provides a full vocabulary to express your design intent.</span></span> <span data-ttu-id="ac1cc-123">다음 한정자 중 어떤 것도 지정하지 않으면 값 형식이 호출된 메서드에 전달될 때 복사됩니다.</span><span class="sxs-lookup"><span data-stu-id="ac1cc-123">Value types are copied when passed to a called method when you do not specify any of the following modifiers.</span></span> <span data-ttu-id="ac1cc-124">이러한 각 한정자는 값 형식이 참조로 전달되도록 지정하여 복사를 방지합니다.</span><span class="sxs-lookup"><span data-stu-id="ac1cc-124">Each of these modifiers specify that a value type is passed by reference, avoiding the copy.</span></span> <span data-ttu-id="ac1cc-125">각 한정자는 각기 다른 의도를 표현합니다.</span><span class="sxs-lookup"><span data-stu-id="ac1cc-125">Each modifier expresses a different intent:</span></span>

- <span data-ttu-id="ac1cc-126">`out`: 이 메서드는 이 매개 변수로 사용되는 인수의 값을 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="ac1cc-126">`out`: This method sets the value of the argument used as this parameter.</span></span>
- <span data-ttu-id="ac1cc-127">`ref`: 이 메서드는 이 매개 변수로 사용되는 인수의 값을 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ac1cc-127">`ref`: This method may set the value of the argument used as this parameter.</span></span>
- <span data-ttu-id="ac1cc-128">`in`: 이 메서드는 이 매개 변수로 사용되는 인수의 값을 수정하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ac1cc-128">`in`: This method does not modify the value of the argument used as this parameter.</span></span>

<span data-ttu-id="ac1cc-129">참조로 인수를 전달하기 위해 `in` 한정자를 추가할 때 불필요한 복사를 방지하기 위해 참조로 인수를 전달하는 것이 설계 의도임을 선언합니다.</span><span class="sxs-lookup"><span data-stu-id="ac1cc-129">When you add the `in` modifier to pass an argument by reference, you declare your design intent is to pass arguments by reference to avoid unnecessary copying.</span></span> <span data-ttu-id="ac1cc-130">해당 인수로 사용되는 개체를 수정하려는 의도를 갖지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ac1cc-130">You do not intend to modify the object used as that argument.</span></span> <span data-ttu-id="ac1cc-131">다음 코드는 3D 공간에서 두 점 사이의 거리를 계산하는 메서드의 예를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="ac1cc-131">The following code shows an example of a method that calculates the distance between two points in 3D space.</span></span> 

[!code-csharp[InArgument](../../samples/csharp/reference-semantics/Program.cs#InArgument "Specifying an In argument")]

<span data-ttu-id="ac1cc-132">인수는 각각 세 개의 double을 포함하는 두 개의 구조입니다.</span><span class="sxs-lookup"><span data-stu-id="ac1cc-132">The arguments are two structures that each contain three doubles.</span></span> <span data-ttu-id="ac1cc-133">double은 8바이트이므로 각 인수는 24바이트입니다.</span><span class="sxs-lookup"><span data-stu-id="ac1cc-133">A double is 8 bytes, so each argument is 24 bytes.</span></span> <span data-ttu-id="ac1cc-134">`in` 한정자를 지정하여 컴퓨터 아키텍처에 따라 해당 인수에 4바이트 또는 8바이트 참조를 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="ac1cc-134">By specifying the `in` modifier, you pass 4-byte or 8-byte reference to those arguments, depending on the architecture of the machine.</span></span> <span data-ttu-id="ac1cc-135">크기의 차이는 작지만, 응용 프로그램이 다양한 값을 사용하여 연속 루프에서 이 메서드를 호출하면 빠르게 늘어날 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ac1cc-135">The difference in size is small, but it can quickly add up when your application calls this method in a tight loop using many different values.</span></span>
 
<span data-ttu-id="ac1cc-136">`in` 한정자는 `out` 및 `ref`를 다른 방식으로도 보완합니다.</span><span class="sxs-lookup"><span data-stu-id="ac1cc-136">The `in` modifier complements `out` and `ref` in other ways as well.</span></span> <span data-ttu-id="ac1cc-137">`in`, `out` 또는 `ref`가 있는 경우에만 다른 메서드의 오버로드를 만들 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ac1cc-137">You cannot create overloads of a method that differ only in the presence of `in`, `out`, or `ref`.</span></span> <span data-ttu-id="ac1cc-138">이러한 새 규칙은 항상 `out` 및 `ref` 매개 변수에 대해 정의된 같은 동작을 확장합니다.</span><span class="sxs-lookup"><span data-stu-id="ac1cc-138">These new rules extend the same behavior that had always been defined for `out` and `ref` parameters.</span></span>

<span data-ttu-id="ac1cc-139">`in` 한정자는 메서드, 대리자, 람다, 로컬 함수, 인덱서, 연산자 매개 변수를 사용하는 모든 멤버에 적용될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ac1cc-139">The `in` modifier may be applied to any member that takes parameters: methods, delegates, lambdas, local functions, indexers, operators.</span></span>

<span data-ttu-id="ac1cc-140">`ref` 및 `out` 인수와 달리 `in` 매개 변수에 대한 인수에 리터럴 값 또는 상수를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ac1cc-140">Unlike `ref` and `out` arguments, you may use literal values or constants for the argument to an `in` parameter.</span></span> <span data-ttu-id="ac1cc-141">또한 `ref` 또는 `out` 매개 변수와 달리 호출 사이트에서 `in` 한정자를 적용할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ac1cc-141">Also, unlike a `ref` or `out` parameter, you don't need to apply the `in` modifier at the call site.</span></span> <span data-ttu-id="ac1cc-142">다음 코드는 `CalculateDistance` 메서드를 호출하는 두 가지 예를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="ac1cc-142">The following code shows you two examples of calling the `CalculateDistance` method.</span></span> <span data-ttu-id="ac1cc-143">첫 번째 예에서는 참조로 전달된 두 개의 로컬 변수를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="ac1cc-143">The first uses two local variables passed by reference.</span></span> <span data-ttu-id="ac1cc-144">두 번째 예는 메서드 호출의 일부로 만들어진 임시 변수를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="ac1cc-144">The second includes a temporary variable created as part of the method call.</span></span> 

[!code-csharp[UseInArgument](../../samples/csharp/reference-semantics/Program.cs#UseInArgument "Specifying an In argument")]

<span data-ttu-id="ac1cc-145">컴파일러가 `in` 인수의 읽기 전용 특성이 강제 적용되도록 하는 여러 가지 방법이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ac1cc-145">There are several ways in which the compiler ensures that the read-only nature of an `in` argument is enforced.</span></span>  <span data-ttu-id="ac1cc-146">먼저, 호출된 메서드는 `in` 매개 변수에 직접 할당할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ac1cc-146">First of all, the called method can't directly assign to an `in` parameter.</span></span> <span data-ttu-id="ac1cc-147">호출된 메서드는 `in` 매개 변수의 모든 필드에 직접 할당할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ac1cc-147">It can't directly assign to any field of an `in` parameter.</span></span> <span data-ttu-id="ac1cc-148">또한 `ref` 또는 `out` 한정자가 필요한 모든 메서드에 `in` 매개 변수를 전달할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ac1cc-148">In addition, you cannot pass an `in` parameter to any method demanding the `ref` or `out` modifier.</span></span>
<span data-ttu-id="ac1cc-149">컴파일러는 `in` 인수가 읽기 전용 변수임을 강제 적용합니다.</span><span class="sxs-lookup"><span data-stu-id="ac1cc-149">The compiler enforces that the `in` argument is a readonly variable.</span></span> <span data-ttu-id="ac1cc-150">pass-by-value 의미 체계를 사용하는 모든 인스턴스 메서드를 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ac1cc-150">You can call any instance method that uses pass-by-value semantics.</span></span> <span data-ttu-id="ac1cc-151">이러한 경우 `in` 매개 변수의 복사본이 만들어집니다.</span><span class="sxs-lookup"><span data-stu-id="ac1cc-151">In those instances, a copy of the `in` parameter is created.</span></span> <span data-ttu-id="ac1cc-152">컴파일러가 `in` 매개 변수에 대한 임시 변수를 만들 수 있으므로 사용자는 `in` 매개 변수에 대한 기본값을 지정할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ac1cc-152">Because the compiler can create a temporary variable for any `in` parameter, you can also specify default values for any `in` parameter.</span></span> <span data-ttu-id="ac1cc-153">다음 코드에서는 이를 사용하여 두 번째 점의 기본값으로 원점(포인트 0,0)을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="ac1cc-153">The follow code uses that to specify the origin (point 0,0) as the default value for the second point:</span></span>

[!code-csharp[InArgumentDefault](../../samples/csharp/reference-semantics/Program.cs#InArgumentDefault "Specifying defaults for an in parameter")]

<span data-ttu-id="ac1cc-154">`in` 매개 변수 지정은 참조 형식 또는 기본 제공 숫자 값과 함께 사용될 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ac1cc-154">The `in` parameter designation can also be used with reference types or built in numeric values.</span></span> <span data-ttu-id="ac1cc-155">그러나 두 경우 모두의 이점은 있다고 하더라도 아주 적습니다.</span><span class="sxs-lookup"><span data-stu-id="ac1cc-155">However, the benefits in both cases are minimal, if any.</span></span>

## <a name="ref-readonly-returns"></a><span data-ttu-id="ac1cc-156">`ref readonly` return</span><span class="sxs-lookup"><span data-stu-id="ac1cc-156">`ref readonly` returns</span></span>

<span data-ttu-id="ac1cc-157">참조로 값 형식을 반환하되, 호출자가 해당 값을 수정하지 못하게 할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ac1cc-157">You may also want to return a value type by reference, but disallow the caller from modifying that value.</span></span> <span data-ttu-id="ac1cc-158">`ref readonly` 한정자를 사용하여 해당 설계 의도를 표현합니다.</span><span class="sxs-lookup"><span data-stu-id="ac1cc-158">Use the `ref readonly` modifier to express that design intent.</span></span> <span data-ttu-id="ac1cc-159">이 한정자는 기존 데이터에 대한 참조를 반환하지만, 수정을 허용하지 않음을 판독기에 알립니다.</span><span class="sxs-lookup"><span data-stu-id="ac1cc-159">It notifies readers that you are returning a reference to existing data, but not allowing modification.</span></span> 

<span data-ttu-id="ac1cc-160">컴파일러는 호출자가 참조를 수정할 수 없음을 강제 적용합니다.</span><span class="sxs-lookup"><span data-stu-id="ac1cc-160">The compiler enforces that the caller cannot modify the reference.</span></span> <span data-ttu-id="ac1cc-161">직접 값에 할당하려고 하면 컴파일 시간 오류가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="ac1cc-161">Attempts to assign to the value directly generate a compile-time error.</span></span> <span data-ttu-id="ac1cc-162">그러나 컴파일러는 멤버 메서드가 구조체의 상태를 수정하는지를 알 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ac1cc-162">However, the compiler cannot know if any member method modifies the state of the struct.</span></span>
<span data-ttu-id="ac1cc-163">개체가 수정되지 않도록 컴파일러는 복사본을 만들고 해당 복사본을 사용하여 멤버 참조를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="ac1cc-163">To ensure that the object is not modified, the compiler creates a copy and calls member references using that copy.</span></span> <span data-ttu-id="ac1cc-164">모든 수정은 해당 방어 복사본에 대한 것입니다.</span><span class="sxs-lookup"><span data-stu-id="ac1cc-164">Any modifications are to that defensive copy.</span></span> 

<span data-ttu-id="ac1cc-165">`Point3D`를 사용하는 라이브러리에서는 흔히 코드 전체에서 원점을 사용할 가능성이 높습니다.</span><span class="sxs-lookup"><span data-stu-id="ac1cc-165">It's likely that the library using `Point3D` would often use the origin throughout the code.</span></span> <span data-ttu-id="ac1cc-166">모든 인스턴스는 스택에 새 개체를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="ac1cc-166">Every instance creates a new object on the stack.</span></span> <span data-ttu-id="ac1cc-167">상수를 만들고 참조로 반환하는 것이 유용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ac1cc-167">It may be advantageous to create a constant and return it by reference.</span></span> <span data-ttu-id="ac1cc-168">그러나 내부 저장소에 대한 참조를 반환하는 경우 호출자가 참조된 저장소를 수정할 수 없도록 강제 적용하려고 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ac1cc-168">But, if you return a reference to internal storage, you may want to enforce that the caller cannot modify the referenced storage.</span></span> <span data-ttu-id="ac1cc-169">다음 코드는 원점을 지정하는 `Point3D`에 `readonly ref`를 반환하는 읽기 전용 속성을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="ac1cc-169">The following code defines a read-only property that returns a `readonly ref` to a `Point3D` that specifies the origin.</span></span>

[!code-csharp[OriginReference](../../samples/csharp/reference-semantics/Point3D.cs#OriginReference "Creating a readonly Origin reference")]

<span data-ttu-id="ac1cc-170">ref readonly return의 복사본을 만들기는 쉽습니다. `ref readonly` 한정자로 선언되지 않은 변수에 이를 할당하기만 하면 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ac1cc-170">Creating a copy of a ref readonly return is easy: Just assign it to a variable not declared with the `ref readonly` modifier.</span></span> <span data-ttu-id="ac1cc-171">컴파일러는 지정의 일부로 개체를 복사하는 코드를 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="ac1cc-171">The compiler generates code to copy the object as part of the assignment.</span></span> 

<span data-ttu-id="ac1cc-172">`ref readonly return`에 변수를 할당하면 `ref readonly` 변수나 읽기 전용 참조의 값 형식 복사본을 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ac1cc-172">When you assign a variable to a `ref readonly return`, you can specify either a `ref readonly` variable, or a by-value copy of the readonly reference:</span></span>

[!code-csharp[AssignRefReadonly](../../samples/csharp/reference-semantics/Program.cs#AssignRefReadonly "Assigning a ref readonly")]

<span data-ttu-id="ac1cc-173">이전 코드의 첫 번째 할당에서는 `Origin` 상수의 복사본을 만들고 해당 복사본을 할당합니다.</span><span class="sxs-lookup"><span data-stu-id="ac1cc-173">The first assignment in the preceding code makes a copy of the `Origin` constant and assigns that copy.</span></span> <span data-ttu-id="ac1cc-174">두 번째 할당에서는 참조를 할당합니다.</span><span class="sxs-lookup"><span data-stu-id="ac1cc-174">The second assigns a reference.</span></span> <span data-ttu-id="ac1cc-175">`readonly` 한정자는 변수 선언의 일부여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ac1cc-175">Notice that the `readonly` modifier must be part of the declaration of the variable.</span></span> <span data-ttu-id="ac1cc-176">참조하는 항목에 대한 참조는 수정할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ac1cc-176">The reference to which it refers cannot be modified.</span></span> <span data-ttu-id="ac1cc-177">이를 수행하려고 시도하면 컴파일 시간 오류가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="ac1cc-177">Attempts to do so result in a compile-time error.</span></span>

## <a name="readonly-struct-type"></a><span data-ttu-id="ac1cc-178">`readonly struct` 형식</span><span class="sxs-lookup"><span data-stu-id="ac1cc-178">`readonly struct` type</span></span>

<span data-ttu-id="ac1cc-179">구조체의 트래픽이 많은 사용에 `ref readonly`를 적용하는 것으로 충분할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ac1cc-179">Applying `ref readonly` to high-traffic uses of a struct may be sufficient.</span></span>
<span data-ttu-id="ac1cc-180">그렇지 않은 경우에는 변경할 수 없는 구조체를 만들려고 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ac1cc-180">Other times, you may want to create an immutable struct.</span></span> <span data-ttu-id="ac1cc-181">그런 다음 항상 읽기 전용 참조로 전달할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ac1cc-181">Then you can always pass by readonly reference.</span></span> <span data-ttu-id="ac1cc-182">이 방법을 사용하면 `in` 매개 변수로 사용되는 구조체의 메서드에 액세스할 때 발생하는 방어 복사본이 제거됩니다.</span><span class="sxs-lookup"><span data-stu-id="ac1cc-182">That practice removes the defensive copies that take place when you access methods of a struct used as an `in` parameter.</span></span>

<span data-ttu-id="ac1cc-183">`readonly struct` 형식을 만들어 이렇게 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ac1cc-183">You can do that by creating a `readonly struct` type.</span></span> <span data-ttu-id="ac1cc-184">구조체 선언에 `readonly` 한정자를 추가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ac1cc-184">You can add the `readonly` modifier to a struct declaration.</span></span> <span data-ttu-id="ac1cc-185">컴파일러는 구조체의 모든 인스턴스 멤버가 `readonly`임을 강제 적용합니다. `struct`는 변경할 수 없어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ac1cc-185">The compiler enforces that all instance members of the struct are `readonly`; the `struct` must be immutable.</span></span>

<span data-ttu-id="ac1cc-186">`readonly struct`에 대한 다른 최적화가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ac1cc-186">There are other optimizations for a `readonly struct`.</span></span> <span data-ttu-id="ac1cc-187">`readonly struct`가 인수인 모든 위치에 `in` 한정자를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ac1cc-187">You can use the `in` modifier at every location where a `readonly struct` is an argument.</span></span> <span data-ttu-id="ac1cc-188">또한 수명이 개체를 반환하는 메서드의 범위 이상으로 연장되는 개체를 반환할 때 `readonly struct`를 `ref return`으로 반환할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ac1cc-188">In addition, you can return a `readonly struct` as a `ref return` when you are returning an object whose lifetime extends beyond the scope of the method returning the object.</span></span>

<span data-ttu-id="ac1cc-189">마지막으로 컴파일러는 `readonly struct`의 멤버를 호출할 때 더 효율적인 코드를 생성합니다. 수신기의 복사본 대신 `this` 참조는 항상 멤버 메서드에 대한 참조로 전달되는 `in` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="ac1cc-189">Finally, the compiler generates more efficient code when you call members of a `readonly struct`: The `this` reference, instead of a copy of the receiver, is always an `in` parameter passed by reference to the member method.</span></span> <span data-ttu-id="ac1cc-190">이 최적화는 `readonly struct`를 사용할 때 더 많은 복사 작업을 줄여줍니다.</span><span class="sxs-lookup"><span data-stu-id="ac1cc-190">This optimization saves more copying when you use a `readonly struct`.</span></span> <span data-ttu-id="ac1cc-191">`Point3D`는 이 변경에 대한 좋은 후보입니다.</span><span class="sxs-lookup"><span data-stu-id="ac1cc-191">The `Point3D` is a great candidate for this change.</span></span> <span data-ttu-id="ac1cc-192">다음 코드는 업데이트된 `ReadonlyPoint3D` 구조를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="ac1cc-192">The following code shows an updated `ReadonlyPoint3D` structure:</span></span>

[!code-csharp[ReadonlyOnlyPoint3D](../../samples/csharp/reference-semantics/Point3D.cs#ReadonlyOnlyPoint3D "Defining an immutable structure")]

## <a name="ref-struct-type"></a><span data-ttu-id="ac1cc-193">`ref struct` 형식</span><span class="sxs-lookup"><span data-stu-id="ac1cc-193">`ref struct` type</span></span>

<span data-ttu-id="ac1cc-194">또 다른 관련 언어 기능은 스택에 할당되어야 하는 값 형식을 선언하는 기능입니다.</span><span class="sxs-lookup"><span data-stu-id="ac1cc-194">Another related language feature is the ability to declare a value type that must be stack allocated.</span></span> <span data-ttu-id="ac1cc-195">즉, 이러한 형식은 다른 클래스의 멤버로 힙에 만들어질 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ac1cc-195">In other words, these types can never be created on the heap as a member of another class.</span></span> <span data-ttu-id="ac1cc-196">이 기능의 기본 동기 부여는 <xref:System.Span%601> 및 관련 구조였습니다.</span><span class="sxs-lookup"><span data-stu-id="ac1cc-196">The primary motivation for this feature was <xref:System.Span%601> and related structures.</span></span> <span data-ttu-id="ac1cc-197"><xref:System.Span%601>는 해당 멤버 중 하나로 관리되는 포인터를 포함하고 나머지로는 범위 길이를 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ac1cc-197"><xref:System.Span%601> may contain a managed pointer as one of its members, the other being the length of the span.</span></span> <span data-ttu-id="ac1cc-198">C#은 안전하지 않은 컨텍스트 외부에서 관리되는 메모리에 대한 포인터를 지원하지 않으므로 실제로는 약간 다르게 구현됩니다.</span><span class="sxs-lookup"><span data-stu-id="ac1cc-198">It's actually implemented a bit differently because C# doesn't support pointers to managed memory outside of an unsafe context.</span></span> <span data-ttu-id="ac1cc-199">포인터와 길이를 변경하는 모든 쓰기는 원자성이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="ac1cc-199">Any write that changes the pointer and the length is not atomic.</span></span> <span data-ttu-id="ac1cc-200">즉, <xref:System.Span%601>는 단일 스택 프레임으로 제약되지 않으므로 범위를 벗어나는 오류나 다른 형식 안전성 위반이 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ac1cc-200">That means a <xref:System.Span%601> would be subject to out of range errors or other type safety violations were it not constrained to a single stack frame.</span></span> <span data-ttu-id="ac1cc-201">또한 GC 힙에 관리되는 포인터를 넣으면 일반적으로 JIT 시간에 충돌합니다.</span><span class="sxs-lookup"><span data-stu-id="ac1cc-201">In addition, putting a managed pointer on the GC heap typically crashes at JIT time.</span></span>

<span data-ttu-id="ac1cc-202">[`stackalloc`](language-reference/keywords/stackalloc.md)을 사용하여 만들어진 메모리로 작업할 때나 interop API에서 메모리를 사용할 때도 유사한 요구 사항이 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ac1cc-202">You may have similar requirements working with memory created using [`stackalloc`](language-reference/keywords/stackalloc.md) or when using memory from interop APIs.</span></span> <span data-ttu-id="ac1cc-203">해당 요구 사항에 대한 사용자 고유의 `ref struct` 형식을 정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ac1cc-203">You can define your own `ref struct` types for those needs.</span></span> <span data-ttu-id="ac1cc-204">이 문서에서는 편의상 `Span<T>`를 사용하는 예를 살펴봅니다.</span><span class="sxs-lookup"><span data-stu-id="ac1cc-204">In this article, you see examples using `Span<T>` for simplicity.</span></span>

<span data-ttu-id="ac1cc-205">`ref struct` 선언에서는 이 형식의 구조체가 스택에 있어야 함을 선언합니다.</span><span class="sxs-lookup"><span data-stu-id="ac1cc-205">The `ref struct` declaration declares that a struct of this type must be on the stack.</span></span> <span data-ttu-id="ac1cc-206">언어 규칙은 이러한 형식의 안전한 사용을 보장합니다.</span><span class="sxs-lookup"><span data-stu-id="ac1cc-206">The language rules ensure the safe use of these types.</span></span> <span data-ttu-id="ac1cc-207">`ref struct`로 선언된 다른 형식은 <xref:System.ReadOnlySpan%601>를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="ac1cc-207">Other types declared as `ref struct` include <xref:System.ReadOnlySpan%601>.</span></span> 

<span data-ttu-id="ac1cc-208">`ref struct` 형식을 스택에 할당된 변수로 유지하는 목표로 인해 컴파일러가 모든 `ref struct` 형식에 대해 강제 적용하는 여러 규칙이 도입되었습니다.</span><span class="sxs-lookup"><span data-stu-id="ac1cc-208">The goal of keeping a `ref struct` type as a stack-allocated variable introduces several rules that the compiler enforces for all `ref struct` types.</span></span>

- <span data-ttu-id="ac1cc-209">`ref struct`를 boxing할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ac1cc-209">You can't box a `ref struct`.</span></span> <span data-ttu-id="ac1cc-210">`ref struct` 형식을 `object`, `dynamic` 형식 또는 인터페이스 유형의 변수에 할당할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ac1cc-210">You cannot assign a `ref struct` type to a variable of type `object`, `dynamic`, or any interface type.</span></span>
- <span data-ttu-id="ac1cc-211">`ref struct`를 클래스 또는 일반 구조체의 멤버로 선언할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ac1cc-211">You can't declare a `ref struct` as a member of a class or a normal struct.</span></span>
- <span data-ttu-id="ac1cc-212">비동기 메서드에 `ref struct` 형식인 로컬 변수를 선언할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ac1cc-212">You cannot declare local variables that are `ref struct` types in async methods.</span></span> <span data-ttu-id="ac1cc-213">`Task`, `Task<T>` 또는 Task와 유사한 형식을 반환하는 동기 메서드에 선언할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ac1cc-213">You can declare them in synchronous methods that return `Task`, `Task<T>` or Task-like types.</span></span>
- <span data-ttu-id="ac1cc-214">반복기에 `ref struct` 로컬 변수를 선언할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ac1cc-214">You cannot declare `ref struct` local variables in iterators.</span></span>
- <span data-ttu-id="ac1cc-215">람다 식 또는 로컬 함수에서 `ref struct` 변수를 캡처할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ac1cc-215">You cannot capture `ref struct` variables in lambda expressions or local functions.</span></span>

<span data-ttu-id="ac1cc-216">이러한 제한 사항은 실수로 `ref struct`를 관리되는 힙으로 승격할 수 있는 방식으로 이 구조체를 사용하지 않게 해줍니다.</span><span class="sxs-lookup"><span data-stu-id="ac1cc-216">These restrictions ensure that you do not accidentally use a `ref struct` in a manner that could promote it to the managed heap.</span></span>

## <a name="conclusions"></a><span data-ttu-id="ac1cc-217">결론</span><span class="sxs-lookup"><span data-stu-id="ac1cc-217">Conclusions</span></span>

<span data-ttu-id="ac1cc-218">C# 언어에 대한 이러한 향상된 기능은 필요한 성능을 달성하는 데 메모리 할당이 중요할 수 있는, 성능이 중요한 알고리즘을 위해 설계되었습니다.</span><span class="sxs-lookup"><span data-stu-id="ac1cc-218">These enhancements to the C# language are designed for performance critical algorithms where memory allocations can be critical to achieving the necessary performance.</span></span> <span data-ttu-id="ac1cc-219">작성하는 코드에서 이러한 기능을 자주 사용하지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ac1cc-219">You may find that you don't often use these features in the code you write.</span></span> <span data-ttu-id="ac1cc-220">그러나 이러한 향상된 기능은 .NET Framework의 많은 위치에 채택되었습니다.</span><span class="sxs-lookup"><span data-stu-id="ac1cc-220">However, these enhancements have been adopted in many locations in the .NET Framework.</span></span> <span data-ttu-id="ac1cc-221">점점 더 많은 API에서 이러한 기능을 사용하므로 사용자의 응용 프로그램 성능이 개선되는 것을 알 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ac1cc-221">As more and more APIs make use of these features, you'll see the performance of your own applications improve.</span></span>

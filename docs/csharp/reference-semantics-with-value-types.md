---
title: 값 형식과 참조 의미 체계
description: 구조 복사를 안전하게 최소화하는 언어 기능 이해
ms.date: 11/10/2017
ms.custom: mvc
ms.openlocfilehash: f241219994d7a03192a4aea69b912bf1ac5ed29c
ms.sourcegitcommit: efff8f331fd9467f093f8ab8d23a203d6ecb5b60
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 09/03/2018
ms.locfileid: "43422668"
---
# <a name="reference-semantics-with-value-types"></a><span data-ttu-id="dac03-103">값 형식과 참조 의미 체계</span><span class="sxs-lookup"><span data-stu-id="dac03-103">Reference semantics with value types</span></span>

<span data-ttu-id="dac03-104">값 형식을 사용할 경우의 장점은 대개 힙 할당을 할 필요가 없다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-104">An advantage to using value types is that they often avoid heap allocations.</span></span>
<span data-ttu-id="dac03-105">단점은 값 형식이 값으로 복사된다는 점입니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-105">The disadvantage is that they are copied by value.</span></span> <span data-ttu-id="dac03-106">이러한 장단점 간에 균형을 잡으려고 하니 많은 양의 데이터에서 작동하는 알고리즘을 최적화하기가 어렵습니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-106">This tradeoff makes it harder to optimize algorithms that operate on large amounts of data.</span></span> <span data-ttu-id="dac03-107">C# 7.2의 새로운 언어 기능은 값 형식으로 pass-by-reference 의미 체계를 가능하게 하는 메커니즘을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-107">New language features in C# 7.2 provide mechanisms that enable pass-by-reference semantics with value types.</span></span> <span data-ttu-id="dac03-108">이러한 기능을 현명하게 사용하여 할당 및 복사 작업을 최소화하세요.</span><span class="sxs-lookup"><span data-stu-id="dac03-108">Use these features wisely to minimize both allocations and copy operations.</span></span> <span data-ttu-id="dac03-109">이 문서에서는 이러한 새로운 기능을 살펴봅니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-109">This article explores those new features.</span></span>

<span data-ttu-id="dac03-110">이 문서의 샘플 코드 상당수는 C# 7.2에 추가된 기능을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-110">Much of the sample code in this article demonstrates features added in C# 7.2.</span></span> <span data-ttu-id="dac03-111">이러한 기능을 사용하려면 C# 7.2 이상을 사용하도록 프로젝트를 구성해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-111">In order to use those features, you must configure your project to use C# 7.2 or later.</span></span> <span data-ttu-id="dac03-112">언어 버전 설정에 대한 자세한 내용은 [언어 버전 구성](language-reference/configure-language-version.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="dac03-112">For more information on setting the language version see [configure the language version](language-reference/configure-language-version.md).</span></span>

## <a name="passing-arguments-by-readonly-reference"></a><span data-ttu-id="dac03-113">읽기 전용 참조로 인수 전달</span><span class="sxs-lookup"><span data-stu-id="dac03-113">Passing arguments by readonly reference</span></span>

<span data-ttu-id="dac03-114">C# 7.2에서는 기존 `ref` 및 `out` 키워드를 보완하기 위해 `in` 키워드를 추가하여 참조로 인수를 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-114">C# 7.2 adds the `in` keyword to complement the existing `ref` and `out` keywords to pass arguments by reference.</span></span> <span data-ttu-id="dac03-115">`in` 키워드는 인수를 참조로 전달하도록 지정하지만 호출된 메서드는 값을 수정하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-115">The `in` keyword specifies passing the argument by reference, but the called method does not modify the value.</span></span> 

<span data-ttu-id="dac03-116">이 추가는 설계 의도를 표현하기 위한 완벽한 어휘를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-116">This addition provides a full vocabulary to express your design intent.</span></span> <span data-ttu-id="dac03-117">메서드 서명에 다음 한정자 중 어떤 것도 지정하지 않으면 호출된 메서드에 전달될 때 값 형식이 복사됩니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-117">Value types are copied when passed to a called method when you don't specify any of the following modifiers in the method signature.</span></span> <span data-ttu-id="dac03-118">이러한 각 한정자는 값 형식이 참조로 전달되도록 지정하여 복사를 방지합니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-118">Each of these modifiers specifies that a value type is passed by reference, avoiding the copy.</span></span> <span data-ttu-id="dac03-119">각 한정자는 각기 다른 의도를 표현합니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-119">Each modifier expresses a different intent:</span></span>

- <span data-ttu-id="dac03-120">`out`: 이 메서드는 이 매개 변수로 사용되는 인수의 값을 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-120">`out`: This method sets the value of the argument used as this parameter.</span></span>
- <span data-ttu-id="dac03-121">`ref`: 이 메서드는 이 매개 변수로 사용되는 인수의 값을 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-121">`ref`: This method may set the value of the argument used as this parameter.</span></span>
- <span data-ttu-id="dac03-122">`in`: 이 메서드는 이 매개 변수로 사용되는 인수의 값을 수정하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-122">`in`: This method does not modify the value of the argument used as this parameter.</span></span>

<span data-ttu-id="dac03-123">참조로 인수를 전달하기 위해 `in` 한정자를 추가하고 불필요한 복사를 방지하기 위해 참조로 인수를 전달할 디자인 의도를 선언합니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-123">Add the `in` modifier to pass an argument by reference and declare your design intent to pass arguments by reference to avoid unnecessary copying.</span></span> <span data-ttu-id="dac03-124">해당 인수로 사용되는 개체를 수정하려는 의도를 갖지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-124">You do not intend to modify the object used as that argument.</span></span> <span data-ttu-id="dac03-125">다음 코드는 3D 공간에서 두 점 사이의 거리를 계산하는 메서드의 예를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-125">The following code shows an example of a method that calculates the distance between two points in 3D space.</span></span> 

[!code-csharp[InArgument](../../samples/csharp/reference-semantics/Program.cs#InArgument "Specifying an In argument")]

<span data-ttu-id="dac03-126">인수는 각각 세 개의 double을 포함하는 두 개의 구조입니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-126">The arguments are two structures that each contain three doubles.</span></span> <span data-ttu-id="dac03-127">double은 8바이트이므로 각 인수는 24바이트입니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-127">A double is 8 bytes, so each argument is 24 bytes.</span></span> <span data-ttu-id="dac03-128">`in` 한정자를 지정하여 컴퓨터 아키텍처에 따라 해당 인수에 4바이트 또는 8바이트 참조를 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-128">By specifying the `in` modifier, you pass a 4-byte or 8-byte reference to those arguments, depending on the architecture of the machine.</span></span> <span data-ttu-id="dac03-129">크기의 차이는 작지만, 응용 프로그램이 다양한 값을 사용하여 연속 루프에서 이 메서드를 호출하면 빠르게 늘어날 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-129">The difference in size is small, but it can quickly add up when your application calls this method in a tight loop using many different values.</span></span>
 
<span data-ttu-id="dac03-130">`in` 한정자는 `out` 및 `ref`를 다른 방식으로도 보완합니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-130">The `in` modifier complements `out` and `ref` in other ways as well.</span></span> <span data-ttu-id="dac03-131">`in`, `out` 또는 `ref`가 있는 경우에만 다른 메서드의 오버로드를 만들 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-131">You cannot create overloads of a method that differ only in the presence of `in`, `out`, or `ref`.</span></span> <span data-ttu-id="dac03-132">이러한 새 규칙은 항상 `out` 및 `ref` 매개 변수에 대해 정의된 같은 동작을 확장합니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-132">These new rules extend the same behavior that had always been defined for `out` and `ref` parameters.</span></span>

<span data-ttu-id="dac03-133">`in` 한정자는 메서드, 대리자, 람다, 로컬 함수, 인덱서, 연산자 매개 변수를 사용하는 모든 멤버에 적용될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-133">The `in` modifier may be applied to any member that takes parameters: methods, delegates, lambdas, local functions, indexers, operators.</span></span>

<span data-ttu-id="dac03-134">`ref` 및 `out` 인수와 달리 `in` 매개 변수에 대한 인수에 리터럴 값 또는 상수를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-134">Unlike `ref` and `out` arguments, you may use literal values or constants for the argument to an `in` parameter.</span></span> <span data-ttu-id="dac03-135">또한 `ref` 또는 `out` 매개 변수와 달리 호출 사이트에서 `in` 한정자를 적용할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-135">Also, unlike a `ref` or `out` parameter, you don't need to apply the `in` modifier at the call site.</span></span> <span data-ttu-id="dac03-136">다음 코드는 `CalculateDistance` 메서드를 호출하는 두 가지 예를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-136">The following code shows you two examples of calling the `CalculateDistance` method.</span></span> <span data-ttu-id="dac03-137">첫 번째 예에서는 참조로 전달된 두 개의 로컬 변수를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-137">The first uses two local variables passed by reference.</span></span> <span data-ttu-id="dac03-138">두 번째 예는 메서드 호출의 일부로 만들어진 임시 변수를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-138">The second includes a temporary variable created as part of the method call.</span></span> 

[!code-csharp[UseInArgument](../../samples/csharp/reference-semantics/Program.cs#UseInArgument "Specifying an In argument")]

<span data-ttu-id="dac03-139">컴파일러가 `in` 인수의 읽기 전용 특성이 강제 적용되도록 하는 여러 가지 방법이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-139">There are several ways in which the compiler ensures that the read-only nature of an `in` argument is enforced.</span></span>  <span data-ttu-id="dac03-140">먼저, 호출된 메서드는 `in` 매개 변수에 직접 할당할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-140">First of all, the called method can't directly assign to an `in` parameter.</span></span> <span data-ttu-id="dac03-141">값이 `struct` 형식일 때 `in` 매개 변수의 모든 필드에 직접 할당할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-141">It can't directly assign to any field of an `in` parameter when that value is a `struct` type.</span></span> <span data-ttu-id="dac03-142">또한 `ref` 또는 `out` 한정자를 사용하여 모든 메서드에 `in` 매개 변수를 전달할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-142">In addition, you cannot pass an `in` parameter to any method using the `ref` or `out` modifier.</span></span>
<span data-ttu-id="dac03-143">이러한 규칙은 필드가 `struct` 형식이고 매개 변수 또한 `struct` 형식인 경우 `in` 매개 변수의 모든 필드에 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-143">These rules apply to any field of an `in` parameter, provided the field is a `struct` type and the parameter is also a `struct` type.</span></span> <span data-ttu-id="dac03-144">사실 이러한 규칙은 멤버 액세스의 모든 수준에서 형식이 `structs`인 경우 멤버 액세스의 여러 계층에 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-144">In fact, these rules apply for multiple layers of member access provided the types at all levels of member access are `structs`.</span></span> <span data-ttu-id="dac03-145">컴파일러는 `in` 인수로 전달된 `struct` 형식과 그 `struct` 멤버가 다른 메서드에 대한 인수로 사용될 경우 읽기 전용 변수가 되도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-145">The compiler enforces that `struct` types passed as  `in` arguments and their `struct` members are read-only variables when used as arguments to other methods.</span></span>

<span data-ttu-id="dac03-146">`in` 매개 변수를 사용하면 복사본 작성 시 발생할 수 있는 잠재적인 성능 비용을 방지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-146">The use of `in` parameters avoids the potential performance costs of making copies.</span></span> <span data-ttu-id="dac03-147">어떤 메서드 호출의 의미 체계도 변경되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-147">It does not change the semantics of any method call.</span></span> <span data-ttu-id="dac03-148">따라서 호출 사이트에서 `in` 한정자를 지정할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-148">Therefore, you do not need to specify the `in` modifier at the call site.</span></span> <span data-ttu-id="dac03-149">그러나 호출 사이트에서 `in` 한정자를 생략하면 다음과 같은 이유로 인수의 복사본을 만들 수 있음을 컴파일러에 알립니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-149">However, omitting the `in` modifier at the call site informs the compiler that it is allowed to make a copy of the argument for the following reasons:</span></span>

- <span data-ttu-id="dac03-150">암시적 변환은 있지만 인수 유형에서 매개 변수 유형으로의 ID 변환이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-150">There is an implicit conversion but not an identity conversion from the argument type to the parameter type.</span></span>
- <span data-ttu-id="dac03-151">인수는 식이지만 알려진 저장소 변수는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-151">The argument is an expression but does not have a known storage variable.</span></span>
- <span data-ttu-id="dac03-152">`in`의 유무의 따라 달라지는 오버로드가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-152">An overload exists that differs by the presence or absence of `in`.</span></span> <span data-ttu-id="dac03-153">이 경우에는 by 값 오버로드가 더 적합합니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-153">In that case, the by value overload is a better match.</span></span>

<span data-ttu-id="dac03-154">이러한 규칙은 읽기 전용 참조 인수를 사용하도록 기존 코드를 업데이트할 때 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-154">These rules are useful as you update existing code to use read-only reference arguments.</span></span> <span data-ttu-id="dac03-155">호출된 메서드 내에서 by 값 매개 변수를 사용하는 모든 인스턴스 메서드를 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-155">Inside the called method, you can call any instance method that uses by value parameters.</span></span> <span data-ttu-id="dac03-156">이러한 경우 `in` 매개 변수의 복사본이 만들어집니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-156">In those instances, a copy of the `in` parameter is created.</span></span> <span data-ttu-id="dac03-157">컴파일러가 `in` 매개 변수에 대한 임시 변수를 만들 수 있으므로 사용자는 `in` 매개 변수에 대한 기본값을 지정할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-157">Because the compiler can create a temporary variable for any `in` parameter, you can also specify default values for any `in` parameter.</span></span> <span data-ttu-id="dac03-158">다음 코드에서는 원점(포인트 0,0)을 두 번째 점의 기본값으로 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-158">The following code specifies the origin (point 0,0) as the default value for the second point:</span></span>

[!code-csharp[InArgumentDefault](../../samples/csharp/reference-semantics/Program.cs#InArgumentDefault "Specifying defaults for an in parameter")]

<span data-ttu-id="dac03-159">컴파일러가 읽기 전용 인수를 참조로 전달하도록 하려면 다음 코드에 나와 있는 것처럼 호출 사이트의 인수에 `in` 한정자를 지정합니다. </span><span class="sxs-lookup"><span data-stu-id="dac03-159">To force the compiler to pass read only arguments by reference, specify the `in` modifer on the arguments at the call site, as shown in the following code:</span></span>

[!code-csharp[UseInArgument](../../samples/csharp/reference-semantics/Program.cs#ExplicitInArgument "Specifying an In argument")]

<span data-ttu-id="dac03-160">이 동작을 통해 성능 향상이 가능한 대규모 코드 베이스에서 시간이 지남에 따라 `in` 매개 변수를 보다 쉽게 채택할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-160">This behavior makes it easier to adopt `in` parameters over time in large codebases where performance gains are possible.</span></span> <span data-ttu-id="dac03-161">먼저 메서드 서명에 `in` 한정자를 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-161">You add the `in` modifier to method signatures first.</span></span> <span data-ttu-id="dac03-162">그런 다음, 호출 사이트에 `in` 한정자를 추가하고 `readonly struct` 형식을 생성하여 컴파일러가 더 많은 위치에서 `in` 매개 변수의 방어 복사본을 만들지 않도록 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-162">Then, you can add the `in` modifier at callsites and create `readonly struct` types to enable the compiler to avoid creating defensive copies of `in` parameters in more locations.</span></span>

<span data-ttu-id="dac03-163">`in` 매개 변수 지정은 참조 형식 또는 숫자 값과 함께 사용될 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-163">The `in` parameter designation can also be used with reference types or numeric values.</span></span> <span data-ttu-id="dac03-164">그러나 두 경우 모두의 이점은 있다고 하더라도 아주 적습니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-164">However, the benefits in both cases are minimal, if any.</span></span>

## <a name="ref-readonly-returns"></a><span data-ttu-id="dac03-165">`ref readonly` return</span><span class="sxs-lookup"><span data-stu-id="dac03-165">`ref readonly` returns</span></span>

<span data-ttu-id="dac03-166">참조로 값 형식을 반환하되, 호출자가 해당 값을 수정하지 못하게 할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-166">You may also want to return a value type by reference, but disallow the caller from modifying that value.</span></span> <span data-ttu-id="dac03-167">`ref readonly` 한정자를 사용하여 해당 설계 의도를 표현합니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-167">Use the `ref readonly` modifier to express that design intent.</span></span> <span data-ttu-id="dac03-168">이 한정자는 기존 데이터에 대한 참조를 반환하지만, 수정을 허용하지 않음을 판독기에 알립니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-168">It notifies readers that you are returning a reference to existing data, but not allowing modification.</span></span> 

<span data-ttu-id="dac03-169">컴파일러는 호출자가 참조를 수정할 수 없음을 강제 적용합니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-169">The compiler enforces that the caller cannot modify the reference.</span></span> <span data-ttu-id="dac03-170">값을 직접 할당하려고 하면 컴파일 시간 오류가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-170">Attempts to assign the value directly generate a compile-time error.</span></span> <span data-ttu-id="dac03-171">그러나 컴파일러는 멤버 메서드가 구조체의 상태를 수정하는지를 알 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-171">However, the compiler cannot know if any member method modifies the state of the struct.</span></span>
<span data-ttu-id="dac03-172">개체가 수정되지 않도록 컴파일러는 복사본을 만들고 해당 복사본을 사용하여 멤버 참조를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-172">To ensure that the object is not modified, the compiler creates a copy and calls member references using that copy.</span></span> <span data-ttu-id="dac03-173">모든 수정은 해당 방어 복사본에 대한 것입니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-173">Any modifications are to that defensive copy.</span></span> 

<span data-ttu-id="dac03-174">`Point3D`를 사용하는 라이브러리에서는 흔히 코드 전체에서 원점을 사용할 가능성이 높습니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-174">It's likely that the library using `Point3D` would often use the origin throughout the code.</span></span> <span data-ttu-id="dac03-175">모든 인스턴스는 스택에 새 개체를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-175">Every instance creates a new object on the stack.</span></span> <span data-ttu-id="dac03-176">상수를 만들고 참조로 반환하는 것이 유용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-176">It may be advantageous to create a constant and return it by reference.</span></span> <span data-ttu-id="dac03-177">그러나 내부 저장소에 대한 참조를 반환하는 경우 호출자가 참조된 저장소를 수정할 수 없도록 강제 적용하려고 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-177">But, if you return a reference to internal storage, you may want to enforce that the caller cannot modify the referenced storage.</span></span> <span data-ttu-id="dac03-178">다음 코드는 원점을 지정하는 `Point3D`에 `readonly ref`를 반환하는 읽기 전용 속성을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-178">The following code defines a read-only property that returns a `readonly ref` to a `Point3D` that specifies the origin.</span></span>

[!code-csharp[OriginReference](../../samples/csharp/reference-semantics/Point3D.cs#OriginReference "Creating a readonly Origin reference")]

<span data-ttu-id="dac03-179">ref readonly return의 복사본을 만들기는 쉽습니다. `ref readonly` 한정자로 선언되지 않은 변수에 이를 할당하기만 하면 됩니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-179">Creating a copy of a ref readonly return is easy: Just assign it to a variable not declared with the `ref readonly` modifier.</span></span> <span data-ttu-id="dac03-180">컴파일러는 지정의 일부로 개체를 복사하는 코드를 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-180">The compiler generates code to copy the object as part of the assignment.</span></span> 

<span data-ttu-id="dac03-181">`ref readonly return`에 변수를 할당하면 `ref readonly` 변수나 읽기 전용 참조의 값 형식 복사본을 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-181">When you assign a variable to a `ref readonly return`, you can specify either a `ref readonly` variable, or a by-value copy of the read-only reference:</span></span>

[!code-csharp[AssignRefReadonly](../../samples/csharp/reference-semantics/Program.cs#AssignRefReadonly "Assigning a ref readonly")]

<span data-ttu-id="dac03-182">이전 코드의 첫 번째 할당에서는 `Origin` 상수의 복사본을 만들고 해당 복사본을 할당합니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-182">The first assignment in the preceding code makes a copy of the `Origin` constant and assigns that copy.</span></span> <span data-ttu-id="dac03-183">두 번째 할당에서는 참조를 할당합니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-183">The second assigns a reference.</span></span> <span data-ttu-id="dac03-184">`readonly` 한정자는 변수 선언의 일부여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-184">Notice that the `readonly` modifier must be part of the declaration of the variable.</span></span> <span data-ttu-id="dac03-185">참조하는 항목에 대한 참조는 수정할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-185">The reference to which it refers can't be modified.</span></span> <span data-ttu-id="dac03-186">이를 수행하려고 시도하면 컴파일 시간 오류가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-186">Attempts to do so result in a compile-time error.</span></span>

## <a name="readonly-struct-type"></a><span data-ttu-id="dac03-187">`readonly struct` 형식</span><span class="sxs-lookup"><span data-stu-id="dac03-187">`readonly struct` type</span></span>

<span data-ttu-id="dac03-188">구조체의 트래픽이 많은 사용에 `ref readonly`를 적용하는 것으로 충분할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-188">Applying `ref readonly` to high-traffic uses of a struct may be sufficient.</span></span>
<span data-ttu-id="dac03-189">그렇지 않은 경우에는 변경할 수 없는 구조체를 만들려고 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-189">Other times, you may want to create an immutable struct.</span></span> <span data-ttu-id="dac03-190">그런 다음, 항상 읽기 전용 참조로 전달할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-190">Then you can always pass by read-only reference.</span></span> <span data-ttu-id="dac03-191">이 방법을 사용하면 `in` 매개 변수로 사용되는 구조체의 메서드에 액세스할 때 발생하는 방어 복사본이 제거됩니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-191">That practice removes the defensive copies that take place when you access methods of a struct used as an `in` parameter.</span></span>

<span data-ttu-id="dac03-192">`readonly struct` 형식을 만들어 이렇게 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-192">You can do that by creating a `readonly struct` type.</span></span> <span data-ttu-id="dac03-193">구조체 선언에 `readonly` 한정자를 추가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-193">You can add the `readonly` modifier to a struct declaration.</span></span> <span data-ttu-id="dac03-194">컴파일러는 구조체의 모든 인스턴스 멤버가 `readonly`임을 강제 적용합니다. `struct`는 변경할 수 없어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-194">The compiler enforces that all instance members of the struct are `readonly`; the `struct` must be immutable.</span></span>

<span data-ttu-id="dac03-195">`readonly struct`에 대한 다른 최적화가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-195">There are other optimizations for a `readonly struct`.</span></span> <span data-ttu-id="dac03-196">`readonly struct`가 인수인 모든 위치에 `in` 한정자를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-196">You can use the `in` modifier at every location where a `readonly struct` is an argument.</span></span> <span data-ttu-id="dac03-197">또한 수명이 개체를 반환하는 메서드의 범위 이상으로 연장되는 개체를 반환할 때 `readonly struct`를 `ref return`으로 반환할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-197">In addition, you can return a `readonly struct` as a `ref return` when you are returning an object whose lifetime extends beyond the scope of the method returning the object.</span></span>

<span data-ttu-id="dac03-198">마지막으로 컴파일러는 `readonly struct`의 멤버를 호출할 때 더 효율적인 코드를 생성합니다. 수신기의 복사본 대신 `this` 참조는 항상 멤버 메서드에 대한 참조로 전달되는 `in` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-198">Finally, the compiler generates more efficient code when you call members of a `readonly struct`: The `this` reference, instead of a copy of the receiver, is always an `in` parameter passed by reference to the member method.</span></span> <span data-ttu-id="dac03-199">이 최적화는 `readonly struct`를 사용할 때 더 많은 복사 작업을 줄여줍니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-199">This optimization saves more copying when you use a `readonly struct`.</span></span> <span data-ttu-id="dac03-200">`Point3D`는 이 변경에 대한 좋은 후보입니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-200">The `Point3D` is a great candidate for this change.</span></span> <span data-ttu-id="dac03-201">다음 코드는 업데이트된 `ReadonlyPoint3D` 구조를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-201">The following code shows an updated `ReadonlyPoint3D` structure:</span></span>

[!code-csharp[ReadonlyOnlyPoint3D](../../samples/csharp/reference-semantics/Point3D.cs#ReadonlyOnlyPoint3D "Defining an immutable structure")]

## <a name="ref-struct-type"></a><span data-ttu-id="dac03-202">`ref struct` 형식</span><span class="sxs-lookup"><span data-stu-id="dac03-202">`ref struct` type</span></span>

<span data-ttu-id="dac03-203">또 다른 관련 언어 기능은 스택에 할당되어야 하는 값 형식을 선언하는 기능입니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-203">Another related language feature is the ability to declare a value type that must be stack allocated.</span></span> <span data-ttu-id="dac03-204">즉, 이러한 형식은 다른 클래스의 멤버로 힙에 만들어질 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-204">In other words, these types can never be created on the heap as a member of another class.</span></span> <span data-ttu-id="dac03-205">이 기능의 기본 동기 부여는 <xref:System.Span%601> 및 관련 구조였습니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-205">The primary motivation for this feature was <xref:System.Span%601> and related structures.</span></span> <span data-ttu-id="dac03-206"><xref:System.Span%601>는 해당 멤버 중 하나로 관리되는 포인터를 포함하고 나머지로는 범위 길이를 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-206"><xref:System.Span%601> may contain a managed pointer as one of its members, the other being the length of the span.</span></span> <span data-ttu-id="dac03-207">C#은 안전하지 않은 컨텍스트 외부에서 관리되는 메모리에 대한 포인터를 지원하지 않으므로 약간 다르게 구현됩니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-207">It's implemented a bit differently because C# doesn't support pointers to managed memory outside of an unsafe context.</span></span> <span data-ttu-id="dac03-208">포인터와 길이를 변경하는 모든 쓰기는 원자성이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-208">Any write that changes the pointer and the length is not atomic.</span></span> <span data-ttu-id="dac03-209">즉, <xref:System.Span%601>는 단일 스택 프레임으로 제약되지 않으므로 범위를 벗어나는 오류나 다른 형식 안전성 위반이 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-209">That means a <xref:System.Span%601> would be subject to out of range errors or other type safety violations were it not constrained to a single stack frame.</span></span> <span data-ttu-id="dac03-210">또한 GC 힙에 관리되는 포인터를 넣으면 일반적으로 JIT 시간에 충돌합니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-210">In addition, putting a managed pointer on the GC heap typically crashes at JIT time.</span></span>

<span data-ttu-id="dac03-211">[`stackalloc`](language-reference/keywords/stackalloc.md)을 사용하여 만들어진 메모리로 작업할 때나 interop API에서 메모리를 사용할 때도 유사한 요구 사항이 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-211">You may have similar requirements working with memory created using [`stackalloc`](language-reference/keywords/stackalloc.md) or when using memory from interop APIs.</span></span> <span data-ttu-id="dac03-212">해당 요구 사항에 대한 사용자 고유의 `ref struct` 형식을 정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-212">You can define your own `ref struct` types for those needs.</span></span> <span data-ttu-id="dac03-213">이 문서에서는 편의상 `Span<T>`를 사용하는 예를 살펴봅니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-213">In this article, you see examples using `Span<T>` for simplicity.</span></span>

<span data-ttu-id="dac03-214">`ref struct` 선언에서는 이 형식의 구조체가 스택에 있어야 함을 선언합니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-214">The `ref struct` declaration declares a struct of this type must be on the stack.</span></span> <span data-ttu-id="dac03-215">언어 규칙은 이러한 형식의 안전한 사용을 보장합니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-215">The language rules ensure the safe use of these types.</span></span> <span data-ttu-id="dac03-216">`ref struct`로 선언된 다른 형식은 <xref:System.ReadOnlySpan%601>를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-216">Other types declared as `ref struct` include <xref:System.ReadOnlySpan%601>.</span></span> 

<span data-ttu-id="dac03-217">`ref struct` 형식을 스택에 할당된 변수로 유지하는 목표로 인해 컴파일러가 모든 `ref struct` 형식에 대해 강제 적용하는 여러 규칙이 도입되었습니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-217">The goal of keeping a `ref struct` type as a stack-allocated variable introduces several rules that the compiler enforces for all `ref struct` types.</span></span>

- <span data-ttu-id="dac03-218">`ref struct`를 boxing할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-218">You can't box a `ref struct`.</span></span> <span data-ttu-id="dac03-219">`ref struct` 형식을 `object`, `dynamic` 형식 또는 인터페이스 유형의 변수에 할당할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-219">You cannot assign a `ref struct` type to a variable of type `object`, `dynamic`, or any interface type.</span></span>
- <span data-ttu-id="dac03-220">`ref struct`를 클래스 또는 일반 구조체의 멤버로 선언할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-220">You can't declare a `ref struct` as a member of a class or a normal struct.</span></span>
- <span data-ttu-id="dac03-221">비동기 메서드에 `ref struct` 형식인 로컬 변수를 선언할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-221">You cannot declare local variables that are `ref struct` types in async methods.</span></span> <span data-ttu-id="dac03-222">`Task`, `Task<T>` 또는 Task와 유사한 형식을 반환하는 동기 메서드에 선언할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-222">You can declare them in synchronous methods that return `Task`, `Task<T>` or Task-like types.</span></span>
- <span data-ttu-id="dac03-223">반복기에 `ref struct` 로컬 변수를 선언할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-223">You cannot declare `ref struct` local variables in iterators.</span></span>
- <span data-ttu-id="dac03-224">람다 식 또는 로컬 함수에서 `ref struct` 변수를 캡처할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-224">You cannot capture `ref struct` variables in lambda expressions or local functions.</span></span>

<span data-ttu-id="dac03-225">이러한 제한 사항은 실수로 `ref struct`를 관리되는 힙으로 승격할 수 있는 방식으로 이 구조체를 사용하지 않게 해줍니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-225">These restrictions ensure you do not accidentally use a `ref struct` in a manner that could promote it to the managed heap.</span></span>

## <a name="readonly-ref-struct-type"></a><span data-ttu-id="dac03-226">`readonly ref struct` 형식</span><span class="sxs-lookup"><span data-stu-id="dac03-226">`readonly ref struct` type</span></span>

<span data-ttu-id="dac03-227">구조체를 `readonly ref`로 선언하면 `ref struct` 및 `readonly struct` 선언의 이점과 제한이 결합됩니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-227">Declaring a struct as `readonly ref` combines the benefits and restrictions of `ref struct` and `readonly struct` declarations.</span></span> 

<span data-ttu-id="dac03-228">다음 예에서는 `readonly ref struct`의 선언을 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-228">The following example demonstrates the declaration of `readonly ref struct`.</span></span>

```csharp
readonly ref struct ReadOnlyRefPoint2D
{
    public int X { get; }
    public int Y { get; }
    
    public ReadOnlyRefPoint2D(int x, int y) => (X, Y) = (x, y);
}
```

## <a name="conclusions"></a><span data-ttu-id="dac03-229">결론</span><span class="sxs-lookup"><span data-stu-id="dac03-229">Conclusions</span></span>

<span data-ttu-id="dac03-230">C# 언어에 대한 이러한 향상된 기능은 필요한 성능을 달성하는 데 메모리 할당이 중요할 수 있는, 성능이 중요한 알고리즘을 위해 설계되었습니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-230">These enhancements to the C# language are designed for performance critical algorithms where memory allocations can be critical to achieving the necessary performance.</span></span> <span data-ttu-id="dac03-231">작성하는 코드에서 이러한 기능을 자주 사용하지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-231">You may find that you don't often use these features in the code you write.</span></span> <span data-ttu-id="dac03-232">그러나 이러한 향상된 기능은 .NET Framework의 많은 위치에 채택되었습니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-232">However, these enhancements have been adopted in many locations in the .NET Framework.</span></span> <span data-ttu-id="dac03-233">점점 더 많은 API에서 이러한 기능을 사용하므로 사용자의 응용 프로그램 성능이 개선되는 것을 알 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="dac03-233">As more and more APIs make use of these features, you'll see the performance of your own applications improve.</span></span>

---
title: "Visual Basic의 산술 연산자 | Microsoft 문서"
ms.custom: 
ms.date: 2015-07-20
ms.prod: .net
ms.reviewer: 
ms.suite: 
ms.technology:
- devlang-visual-basic
ms.topic: article
dev_langs:
- VB
helpviewer_keywords:
- type safety
- operators [Visual Basic], bitwise
- operators [Visual Basic], bit-shift
- bitwise operators
- bit-shift operators
- zero, division by zero
- operators [Visual Basic], arithmetic
- division, by zero
- Visual Basic code, operators
- arithmetic operators, about arithmetic operators
ms.assetid: 325dac7a-ea4f-41d5-8b48-f6e904211569
caps.latest.revision: 20
author: dotnet-bot
ms.author: dotnetcontent
translation.priority.ht:
- cs-cz
- de-de
- es-es
- fr-fr
- it-it
- ja-jp
- ko-kr
- pl-pl
- pt-br
- ru-ru
- tr-tr
- zh-cn
- zh-tw
ms.translationtype: Machine Translation
ms.sourcegitcommit: 9f5b8ebb69c9206ff90b05e748c64d29d82f7a16
ms.openlocfilehash: e80e7950abe035efe5294974937589a1af40f17c
ms.contentlocale: ko-kr
ms.lasthandoff: 04/12/2017

---
# <a name="arithmetic-operators-in-visual-basic"></a><span data-ttu-id="ada81-102">Visual Basic의 산술 연산자</span><span class="sxs-lookup"><span data-stu-id="ada81-102">Arithmetic Operators in Visual Basic</span></span>
<span data-ttu-id="ada81-103">산술 연산자는 많은 리터럴, 변수, 기타 식, 함수 및 속성 호출 및 상수를 나타내는 숫자 값의 계산을 수행 하는 친숙 한 산술 연산을 수행 하는 데 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ada81-103">Arithmetic operators are used to perform many of the familiar arithmetic operations that involve the calculation of numeric values represented by literals, variables, other expressions, function and property calls, and constants.</span></span> <span data-ttu-id="ada81-104">피연산자의 각 비트의 고 수준에서 작동 하 고 왼쪽 이나 오른쪽으로의 비트 패턴을 이동 하는 비트 시프트 연산자는 산술 연산자로 분류 합니다.</span><span class="sxs-lookup"><span data-stu-id="ada81-104">Also classified with arithmetic operators are the bit-shift operators, which act at the level of the individual bits of the operands and shift their bit patterns to the left or right.</span></span>  
  
## <a name="arithmetic-operations"></a><span data-ttu-id="ada81-105">산술 연산</span><span class="sxs-lookup"><span data-stu-id="ada81-105">Arithmetic Operations</span></span>  
 <span data-ttu-id="ada81-106">와 함께 식에서 두 개의 값을 추가할 수는 [+ 연산자](../../../../visual-basic/language-reference/operators/addition-operator.md), 더하거나은 다른는 [-연산자 (Visual Basic)](../../../../visual-basic/language-reference/operators/subtraction-operator.md)다음 예제 에서처럼, 합니다.</span><span class="sxs-lookup"><span data-stu-id="ada81-106">You can add two values in an expression together with the [+ Operator](../../../../visual-basic/language-reference/operators/addition-operator.md), or subtract one from another with the [- Operator (Visual Basic)](../../../../visual-basic/language-reference/operators/subtraction-operator.md), as the following example demonstrates.</span></span>  
  
 <span data-ttu-id="ada81-107">[!code-vb[VbVbalrOperators #&57;](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/arithmetic-operators_1.vb)]</span><span class="sxs-lookup"><span data-stu-id="ada81-107">[!code-vb[VbVbalrOperators#57](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/arithmetic-operators_1.vb)]</span></span>  
  
 <span data-ttu-id="ada81-108">부정 또한 사용 하 여는 [-연산자 (Visual Basic)](../../../../visual-basic/language-reference/operators/subtraction-operator.md), 없지만 하나만 피연산자와 함께 다음 예제와 같이 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="ada81-108">Negation also uses the [- Operator (Visual Basic)](../../../../visual-basic/language-reference/operators/subtraction-operator.md), but with only one operand, as the following example demonstrates.</span></span>  
  
 <span data-ttu-id="ada81-109">[!code-vb[VbVbalrOperators #&58;](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/arithmetic-operators_2.vb)]</span><span class="sxs-lookup"><span data-stu-id="ada81-109">[!code-vb[VbVbalrOperators#58](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/arithmetic-operators_2.vb)]</span></span>  
  
 <span data-ttu-id="ada81-110">사용 하 여 곱하기와 나누기는 [* 연산자](../../../../visual-basic/language-reference/operators/multiplication-operator.md) 및 [/ 연산자 (Visual Basic)](../../../../visual-basic/language-reference/operators/floating-point-division-operator.md), 다음 예제 에서처럼 각각.</span><span class="sxs-lookup"><span data-stu-id="ada81-110">Multiplication and division use the [* Operator](../../../../visual-basic/language-reference/operators/multiplication-operator.md) and [/ Operator (Visual Basic)](../../../../visual-basic/language-reference/operators/floating-point-division-operator.md), respectively, as the following example demonstrates.</span></span>  
  
 <span data-ttu-id="ada81-111">[!code-vb[VbVbalrOperators #&59;](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/arithmetic-operators_3.vb)]</span><span class="sxs-lookup"><span data-stu-id="ada81-111">[!code-vb[VbVbalrOperators#59](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/arithmetic-operators_3.vb)]</span></span>  
  
 <span data-ttu-id="ada81-112">지 수 연산을 사용 하 여는 [^ 연산자](../../../../visual-basic/language-reference/operators/exponentiation-operator.md)와 마찬가지로 다음 예제를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="ada81-112">Exponentiation uses the [^ Operator](../../../../visual-basic/language-reference/operators/exponentiation-operator.md), as the following example demonstrates.</span></span>  
  
 <span data-ttu-id="ada81-113">[!code-vb[VbVbalrOperators #&60;](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/arithmetic-operators_4.vb)]</span><span class="sxs-lookup"><span data-stu-id="ada81-113">[!code-vb[VbVbalrOperators#60](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/arithmetic-operators_4.vb)]</span></span>  
  
 <span data-ttu-id="ada81-114">정수 나누기가 사용 하 여 수행 된 [\ 연산자 (Visual Basic)](../../../../visual-basic/language-reference/operators/integer-division-operator.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="ada81-114">Integer division is carried out using the [\ Operator (Visual Basic)](../../../../visual-basic/language-reference/operators/integer-division-operator.md).</span></span> <span data-ttu-id="ada81-115">정수 나누기 몫을 반환 합니다, 그리고 즉, 횟수를 나타내는 정수 제도 나눌 수 있으며 나머지의 고려 사항 없이 피제수입니다.</span><span class="sxs-lookup"><span data-stu-id="ada81-115">Integer division returns the quotient, that is, the integer that represents the number of times the divisor can divide into the dividend without consideration of any remainder.</span></span> <span data-ttu-id="ada81-116">Divisor와 dividend 모두 정수 계열 형식 이어야 합니다 (`SByte`, `Byte`, `Short`, `UShort`, `Integer`, `UInteger`, `Long`, 및 `ULong`)이이 연산자에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="ada81-116">Both the divisor and the dividend must be integral types (`SByte`, `Byte`, `Short`, `UShort`, `Integer`, `UInteger`, `Long`, and `ULong`) for this operator.</span></span> <span data-ttu-id="ada81-117">먼저 다른 모든 형식은 정수 계열 형식으로 변환 합니다.</span><span class="sxs-lookup"><span data-stu-id="ada81-117">All other types must be converted to an integral type first.</span></span> <span data-ttu-id="ada81-118">다음 예제에서는 정수 나누기를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="ada81-118">The following example demonstrates integer division.</span></span>  
  
 <span data-ttu-id="ada81-119">[!code-vb[VbVbalrOperators #&61;](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/arithmetic-operators_5.vb)]</span><span class="sxs-lookup"><span data-stu-id="ada81-119">[!code-vb[VbVbalrOperators#61](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/arithmetic-operators_5.vb)]</span></span>  
  
 <span data-ttu-id="ada81-120">산술 나머지를 사용 하 여 수행 된 [Mod 연산자](../../../../visual-basic/language-reference/operators/mod-operator.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="ada81-120">Modulus arithmetic is performed using the [Mod Operator](../../../../visual-basic/language-reference/operators/mod-operator.md).</span></span> <span data-ttu-id="ada81-121">이 연산자 나머지를 반환 제 수를 피제수로 나눈 다음 정수 횟수입니다.</span><span class="sxs-lookup"><span data-stu-id="ada81-121">This operator returns the remainder after dividing the divisor into the dividend an integral number of times.</span></span> <span data-ttu-id="ada81-122">Divisor와 dividend 모두 정수 계열 형식이 경우 반환된 된 값은 정수입니다.</span><span class="sxs-lookup"><span data-stu-id="ada81-122">If both divisor and dividend are integral types, the returned value is integral.</span></span> <span data-ttu-id="ada81-123">Divisor와 dividend 부동 소수점 형식 경우 반환 되는 값 부동 소수점 이기도 합니다.</span><span class="sxs-lookup"><span data-stu-id="ada81-123">If divisor and dividend are floating-point types, the returned value is also floating-point.</span></span> <span data-ttu-id="ada81-124">다음 예제에서는이 동작을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="ada81-124">The following example demonstrates this behavior.</span></span>  
  
 <span data-ttu-id="ada81-125">[!code-vb[VbVbalrOperators #&62;](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/arithmetic-operators_6.vb)]</span><span class="sxs-lookup"><span data-stu-id="ada81-125">[!code-vb[VbVbalrOperators#62](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/arithmetic-operators_6.vb)]</span></span>  
  
 <span data-ttu-id="ada81-126">[!code-vb[VbVbalrOperators #&63;](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/arithmetic-operators_7.vb)]</span><span class="sxs-lookup"><span data-stu-id="ada81-126">[!code-vb[VbVbalrOperators#63](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/arithmetic-operators_7.vb)]</span></span>  
  
### <a name="attempted-division-by-zero"></a><span data-ttu-id="ada81-127">0으로 나누기</span><span class="sxs-lookup"><span data-stu-id="ada81-127">Attempted Division by Zero</span></span>  
 <span data-ttu-id="ada81-128">0으로 나누기는 관련 된 데이터 형식에 따라 다른 결과입니다.</span><span class="sxs-lookup"><span data-stu-id="ada81-128">Division by zero has different results depending on the data types involved.</span></span> <span data-ttu-id="ada81-129">In integral divisions (`SByte`, `Byte`, `Short`, `UShort`, `Integer`, `UInteger`, `Long`, `ULong`), the [!INCLUDE[dnprdnshort](../../../../csharp/getting-started/includes/dnprdnshort_md.md)] throws a <xref:System.DivideByZeroException> exception.</xref:System.DivideByZeroException></span><span class="sxs-lookup"><span data-stu-id="ada81-129">In integral divisions (`SByte`, `Byte`, `Short`, `UShort`, `Integer`, `UInteger`, `Long`, `ULong`), the [!INCLUDE[dnprdnshort](../../../../csharp/getting-started/includes/dnprdnshort_md.md)] throws a <xref:System.DivideByZeroException> exception.</span></span> <span data-ttu-id="ada81-130">나누기에 대 한 작업에는 `Decimal` 또는 `Single` 데이터 형식으로는 [!INCLUDE[dnprdnshort](../../../../csharp/getting-started/includes/dnprdnshort_md.md)] 또한 throw 하는 <xref:System.DivideByZeroException>예외.</xref:System.DivideByZeroException></span><span class="sxs-lookup"><span data-stu-id="ada81-130">In division operations on the `Decimal` or `Single` data type, the [!INCLUDE[dnprdnshort](../../../../csharp/getting-started/includes/dnprdnshort_md.md)] also throws a <xref:System.DivideByZeroException> exception.</span></span>  
  
 <span data-ttu-id="ada81-131">부동 소수점 나누기에서는 `Double` 데이터 형식 예외가 throw 되지 및 결과 나타내는 클래스 멤버는 <xref:System.Double.NaN>, <xref:System.Double.PositiveInfinity>, 또는 <xref:System.Double.NegativeInfinity>피제수에 따라.</xref:System.Double.NegativeInfinity> </xref:System.Double.PositiveInfinity> </xref:System.Double.NaN></span><span class="sxs-lookup"><span data-stu-id="ada81-131">In floating-point divisions involving the `Double` data type, no exception is thrown, and the result is the class member representing <xref:System.Double.NaN>, <xref:System.Double.PositiveInfinity>, or <xref:System.Double.NegativeInfinity>, depending on the dividend.</span></span> <span data-ttu-id="ada81-132">다음 표에서 나누기의 다양 한 결과 요약 한 `Double` 값을&0;으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="ada81-132">The following table summarizes the various results of attempting to divide a `Double` value by zero.</span></span>  
  
|<span data-ttu-id="ada81-133">피제수 데이터 형식</span><span class="sxs-lookup"><span data-stu-id="ada81-133">Dividend data type</span></span>|<span data-ttu-id="ada81-134">제 수 데이터 형식</span><span class="sxs-lookup"><span data-stu-id="ada81-134">Divisor data type</span></span>|<span data-ttu-id="ada81-135">피제수 값</span><span class="sxs-lookup"><span data-stu-id="ada81-135">Dividend value</span></span>|<span data-ttu-id="ada81-136">결과</span><span class="sxs-lookup"><span data-stu-id="ada81-136">Result</span></span>|  
|---|---|---|---|  
|`Double`|`Double`|<span data-ttu-id="ada81-137">0</span><span class="sxs-lookup"><span data-stu-id="ada81-137">0</span></span>|<span data-ttu-id="ada81-138"><xref:System.Double.NaN>(수학적으로 정의 된 숫자가 아님)</xref:System.Double.NaN></span><span class="sxs-lookup"><span data-stu-id="ada81-138"><xref:System.Double.NaN> (not a mathematically defined number)</span></span>|  
|`Double`|`Double`|<span data-ttu-id="ada81-139">> 0</span><span class="sxs-lookup"><span data-stu-id="ada81-139">> 0</span></span>|<span data-ttu-id="ada81-140"><xref:System.Double.PositiveInfinity></xref:System.Double.PositiveInfinity></span><span class="sxs-lookup"><span data-stu-id="ada81-140"><xref:System.Double.PositiveInfinity></span></span>|  
|`Double`|`Double`|<span data-ttu-id="ada81-141">\< 0</span><span class="sxs-lookup"><span data-stu-id="ada81-141">\< 0</span></span>|<span data-ttu-id="ada81-142"><xref:System.Double.NegativeInfinity></xref:System.Double.NegativeInfinity></span><span class="sxs-lookup"><span data-stu-id="ada81-142"><xref:System.Double.NegativeInfinity></span></span>|  
  
 <span data-ttu-id="ada81-143"><xref:System.DivideByZeroException>예외를 처리 합니다.에 도움이 되도록 멤버를 사용할 수</xref:System.DivideByZeroException> 는 catch</span><span class="sxs-lookup"><span data-stu-id="ada81-143">When you catch a <xref:System.DivideByZeroException> exception, you can use its members to help you handle it.</span></span> <span data-ttu-id="ada81-144">예를 들어는 <xref:System.Exception.Message%2A>속성 예외에 대 한 메시지 텍스트를 저장 합니다.</xref:System.Exception.Message%2A></span><span class="sxs-lookup"><span data-stu-id="ada81-144">For example, the <xref:System.Exception.Message%2A> property holds the message text for the exception.</span></span> <span data-ttu-id="ada81-145">자세한 내용은 참조 [시도 중... Catch... Finally 문](../../../../visual-basic/language-reference/statements/try-catch-finally-statement.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="ada81-145">For more information, see [Try...Catch...Finally Statement](../../../../visual-basic/language-reference/statements/try-catch-finally-statement.md).</span></span>  
  
## <a name="bit-shift-operations"></a><span data-ttu-id="ada81-146">비트 시프트 연산</span><span class="sxs-lookup"><span data-stu-id="ada81-146">Bit-Shift Operations</span></span>  
 <span data-ttu-id="ada81-147">비트 시프트 작업과 비트 패턴에 산술 시프트를 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="ada81-147">A bit-shift operation performs an arithmetic shift on a bit pattern.</span></span> <span data-ttu-id="ada81-148">오른쪽의 피연산자는 패턴을 이동할 위치의 수를 지정 하는 동안 패턴 왼쪽 피연산자에 포함 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ada81-148">The pattern is contained in the operand on the left, while the operand on the right specifies the number of positions to shift the pattern.</span></span> <span data-ttu-id="ada81-149">오른쪽으로 패턴을 이동할 수는 [>> 연산자](../../../../visual-basic/language-reference/operators/right-shift-operator.md) 또는 왼쪽에는 [ <> </> ](../../../../visual-basic/language-reference/operators/left-shift-operator.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="ada81-149">You can shift the pattern to the right with the [>> Operator](../../../../visual-basic/language-reference/operators/right-shift-operator.md) or to the left with the [<< Operator](../../../../visual-basic/language-reference/operators/left-shift-operator.md).</span></span>  
  
 <span data-ttu-id="ada81-150">패턴 피연산자의 데이터 형식 이어야 합니다 `SByte`, `Byte`, `Short`, `UShort`, `Integer`, `UInteger`, `Long`, 또는 `ULong`합니다.</span><span class="sxs-lookup"><span data-stu-id="ada81-150">The data type of the pattern operand must be `SByte`, `Byte`, `Short`, `UShort`, `Integer`, `UInteger`, `Long`, or `ULong`.</span></span> <span data-ttu-id="ada81-151">시프트 횟수 피연산자의 데이터 형식 이어야 합니다 `Integer` 으로 확대 변환 되어야 또는 `Integer`합니다.</span><span class="sxs-lookup"><span data-stu-id="ada81-151">The data type of the shift amount operand must be `Integer` or must widen to `Integer`.</span></span>  
  
 <span data-ttu-id="ada81-152">산술 시프트는 하지 순환 결과의 한쪽 끝에서 벗어나 이동한 비트는 다른 쪽 끝에서 다시 발생 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ada81-152">Arithmetic shifts are not circular, which means the bits shifted off one end of the result are not reintroduced at the other end.</span></span> <span data-ttu-id="ada81-153">이동 후 비워진 비트 위치는 다음과 같이 설정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ada81-153">The bit positions vacated by a shift are set as follows:</span></span>  
  
-   <span data-ttu-id="ada81-154">산술 왼쪽된 시프트에 대 한&0;</span><span class="sxs-lookup"><span data-stu-id="ada81-154">0 for an arithmetic left shift</span></span>  
  
-   <span data-ttu-id="ada81-155">양수의 산술 오른쪽 시프트에 대 한&0;</span><span class="sxs-lookup"><span data-stu-id="ada81-155">0 for an arithmetic right shift of a positive number</span></span>  
  
-   <span data-ttu-id="ada81-156">부호 없는 데이터 형식에 산술 오른쪽 시프트에 대 한&0; (`Byte`, `UShort`, `UInteger`, `ULong`)</span><span class="sxs-lookup"><span data-stu-id="ada81-156">0 for an arithmetic right shift of an unsigned data type (`Byte`, `UShort`, `UInteger`, `ULong`)</span></span>  
  
-   <span data-ttu-id="ada81-157">1은 음수의 산술 오른쪽 시프트 (`SByte`, `Short`, `Integer`, 또는 `Long`)</span><span class="sxs-lookup"><span data-stu-id="ada81-157">1 for an arithmetic right shift of a negative number (`SByte`, `Short`, `Integer`, or `Long`)</span></span>  
  
 <span data-ttu-id="ada81-158">다음 예제에서는 이동는 `Integer` 값을 왼쪽 및 오른쪽입니다.</span><span class="sxs-lookup"><span data-stu-id="ada81-158">The following example shifts an `Integer` value both left and right.</span></span>  
  
 <span data-ttu-id="ada81-159">[!code-vb[VbVbalrOperators #&64;](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/arithmetic-operators_8.vb)]</span><span class="sxs-lookup"><span data-stu-id="ada81-159">[!code-vb[VbVbalrOperators#64](../../../../visual-basic/language-reference/operators/codesnippet/VisualBasic/arithmetic-operators_8.vb)]</span></span>  
  
 <span data-ttu-id="ada81-160">이동 하는 산술 오버플로 예외를 생성 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ada81-160">Arithmetic shifts never generate overflow exceptions.</span></span>  
  
## <a name="bitwise-operations"></a><span data-ttu-id="ada81-161">비트 연산</span><span class="sxs-lookup"><span data-stu-id="ada81-161">Bitwise Operations</span></span>  
 <span data-ttu-id="ada81-162">논리 연산자로 사용 될 뿐 아니라 `Not`, `Or`, `And`, 및 `Xor` 숫자 값에 사용 될 경우 비트 연산도 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="ada81-162">In addition to being logical operators, `Not`, `Or`, `And`, and `Xor` also perform bitwise arithmetic when used on numeric values.</span></span> <span data-ttu-id="ada81-163">자세한 내용은 "비트 연산에서 참조 [논리 및 비트 Visual Basic의 연산자](../../../../visual-basic/programming-guide/language-features/operators-and-expressions/logical-and-bitwise-operators.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="ada81-163">For more information, see "Bitwise Operations" in [Logical and Bitwise Operators in Visual Basic](../../../../visual-basic/programming-guide/language-features/operators-and-expressions/logical-and-bitwise-operators.md).</span></span>  
  
## <a name="type-safety"></a><span data-ttu-id="ada81-164">형식 안전성</span><span class="sxs-lookup"><span data-stu-id="ada81-164">Type Safety</span></span>  
 <span data-ttu-id="ada81-165">동일한 형식의 피연산자는 일반적으로 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ada81-165">Operands should normally be of the same type.</span></span> <span data-ttu-id="ada81-166">예를 들어, 추가 하는 경우는 `Integer` 변수를 추가 해야 다른 `Integer` 변수에 결과 형식의 변수를 할당 해야 `Integer` 도 합니다.</span><span class="sxs-lookup"><span data-stu-id="ada81-166">For example, if you are doing addition with an `Integer` variable, you should add it to another `Integer` variable, and you should assign the result to a variable of type `Integer` as well.</span></span>  
  
 <span data-ttu-id="ada81-167">형식이 안전한 확인 하는 한 가지 방법은 코딩 방법 사용 하는 것은 [Option Strict 문](../../../../visual-basic/language-reference/statements/option-strict-statement.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="ada81-167">One way to ensure good type-safe coding practice is to use the [Option Strict Statement](../../../../visual-basic/language-reference/statements/option-strict-statement.md).</span></span> <span data-ttu-id="ada81-168">설정한 경우 `Option Strict On`, [!INCLUDE[vbprvb](../../../../csharp/programming-guide/concepts/linq/includes/vbprvb_md.md)] 자동으로 수행 *형식이 안전한* 변환 합니다.</span><span class="sxs-lookup"><span data-stu-id="ada81-168">If you set `Option Strict On`, [!INCLUDE[vbprvb](../../../../csharp/programming-guide/concepts/linq/includes/vbprvb_md.md)] automatically performs *type-safe* conversions.</span></span> <span data-ttu-id="ada81-169">예를 들어 추가 하려고 하면는 `Integer` 변수를 `Double` 변수 값을 할당 하 고는 `Double` 변수인 작업이 정상적으로 진행 하기 때문에 `Integer` 값을 변환할 수 `Double` 데이터 손실 없이.</span><span class="sxs-lookup"><span data-stu-id="ada81-169">For example, if you try to add an `Integer` variable to a `Double` variable and assign the value to a `Double` variable, the operation proceeds normally, because an `Integer` value can be converted to `Double` without loss of data.</span></span> <span data-ttu-id="ada81-170">형식 안전 하지 않은 변환에는 반면에으로 컴파일러 오류가 발생 `Option Strict On`합니다.</span><span class="sxs-lookup"><span data-stu-id="ada81-170">Type-unsafe conversions, on the other hand, cause a compiler error with `Option Strict On`.</span></span> <span data-ttu-id="ada81-171">예를 들어 추가 하려고 하면는 `Integer` 변수를 `Double` 변수 값을 할당 하 고는 `Integer` 변수인 컴파일러 오류가 발생 한 `Double` 변수 형식으로 암시적으로 변환 될 수 없습니다 `Integer`.</span><span class="sxs-lookup"><span data-stu-id="ada81-171">For example, if you try to add an `Integer` variable to a `Double` variable and assign the value to an `Integer` variable, a compiler error results, because a `Double` variable cannot be implicitly converted to type `Integer`.</span></span>  
  
 <span data-ttu-id="ada81-172">설정한 경우 `Option Strict Off`그러나 [!INCLUDE[vbprvb](../../../../csharp/programming-guide/concepts/linq/includes/vbprvb_md.md)] 암시적 축소 변환을 수행 하면 허용 예기치 않은 데이터 또는 정밀도 손실을 초래할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ada81-172">If you set `Option Strict Off`, however, [!INCLUDE[vbprvb](../../../../csharp/programming-guide/concepts/linq/includes/vbprvb_md.md)] allows implicit narrowing conversions to take place, although they can result in the unexpected loss of data or precision.</span></span> <span data-ttu-id="ada81-173">이러한 이유로 사용 하는 권장 `Option Strict On` 프로덕션 코드를 작성 하는 경우.</span><span class="sxs-lookup"><span data-stu-id="ada81-173">For this reason, we recommend that you use `Option Strict On` when writing production code.</span></span> <span data-ttu-id="ada81-174">자세한 내용은 참조 [확장 변환과 축소 변환](../../../../visual-basic/programming-guide/language-features/data-types/widening-and-narrowing-conversions.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="ada81-174">For more information, see [Widening and Narrowing Conversions](../../../../visual-basic/programming-guide/language-features/data-types/widening-and-narrowing-conversions.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="ada81-175">참고 항목</span><span class="sxs-lookup"><span data-stu-id="ada81-175">See Also</span></span>  
 <span data-ttu-id="ada81-176">[산술 연산자](../../../../visual-basic/language-reference/operators/arithmetic-operators.md) </span><span class="sxs-lookup"><span data-stu-id="ada81-176">[Arithmetic Operators](../../../../visual-basic/language-reference/operators/arithmetic-operators.md) </span></span>  
<span data-ttu-id="ada81-177"> [비트 시프트 연산자](../../../../visual-basic/language-reference/operators/bit-shift-operators.md) </span><span class="sxs-lookup"><span data-stu-id="ada81-177"> [Bit Shift Operators](../../../../visual-basic/language-reference/operators/bit-shift-operators.md) </span></span>  
<span data-ttu-id="ada81-178"> [Visual Basic의 비교 연산자](../../../../visual-basic/programming-guide/language-features/operators-and-expressions/comparison-operators.md) </span><span class="sxs-lookup"><span data-stu-id="ada81-178"> [Comparison Operators in Visual Basic](../../../../visual-basic/programming-guide/language-features/operators-and-expressions/comparison-operators.md) </span></span>  
<span data-ttu-id="ada81-179"> [Visual Basic의 연결 연산자](../../../../visual-basic/programming-guide/language-features/operators-and-expressions/concatenation-operators.md) </span><span class="sxs-lookup"><span data-stu-id="ada81-179"> [Concatenation Operators in Visual Basic](../../../../visual-basic/programming-guide/language-features/operators-and-expressions/concatenation-operators.md) </span></span>  
<span data-ttu-id="ada81-180"> [Visual Basic의 논리 및 비트 연산자](../../../../visual-basic/programming-guide/language-features/operators-and-expressions/logical-and-bitwise-operators.md) </span><span class="sxs-lookup"><span data-stu-id="ada81-180"> [Logical and Bitwise Operators in Visual Basic](../../../../visual-basic/programming-guide/language-features/operators-and-expressions/logical-and-bitwise-operators.md) </span></span>  
<span data-ttu-id="ada81-181"> [연산자의 효율적 결합](../../../../visual-basic/programming-guide/language-features/operators-and-expressions/efficient-combination-of-operators.md)</span><span class="sxs-lookup"><span data-stu-id="ada81-181"> [Efficient Combination of Operators](../../../../visual-basic/programming-guide/language-features/operators-and-expressions/efficient-combination-of-operators.md)</span></span>

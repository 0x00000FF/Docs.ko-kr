---
title: "상호 운용성 (Visual Basic) 문제 해결 | Microsoft 문서"
ms.custom: 
ms.date: 2015-07-20
ms.prod: .net
ms.reviewer: 
ms.suite: 
ms.technology:
- devlang-visual-basic
ms.topic: article
dev_langs:
- VB
helpviewer_keywords:
- interop, deploying assemblies
- assemblies [Visual Basic]
- interop, installing assemblies that share components
- COM objects, troubleshooting
- interop, sharing components
- troubleshooting interoperability
- interoperability, troubleshooting
- COM interop, troubleshooting
- assemblies [Visual Basic], deploying
- troubleshooting Visual Basic, interoperability
- interop assemblies
- interoperability, sharing components
- shared components, using with assemblies
ms.assetid: b324cc1e-b03c-4f39-aea6-6a6d5bfd0e37
caps.latest.revision: 21
author: dotnet-bot
ms.author: dotnetcontent
translation.priority.ht:
- cs-cz
- de-de
- es-es
- fr-fr
- it-it
- ja-jp
- ko-kr
- pl-pl
- pt-br
- ru-ru
- tr-tr
- zh-cn
- zh-tw
ms.translationtype: Machine Translation
ms.sourcegitcommit: 9f5b8ebb69c9206ff90b05e748c64d29d82f7a16
ms.openlocfilehash: f4a906b685ac02e89eb1dd94d538be3288b03ca1
ms.contentlocale: ko-kr
ms.lasthandoff: 04/12/2017

---
# <a name="troubleshooting-interoperability-visual-basic"></a><span data-ttu-id="7849e-102">상호 운용성 문제 해결(Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="7849e-102">Troubleshooting Interoperability (Visual Basic)</span></span>
<span data-ttu-id="7849e-103">COM 및 관리 코드의 상호 운용 하는 경우는 [!INCLUDE[dnprdnshort](../../../csharp/getting-started/includes/dnprdnshort_md.md)], 다음과 같은 일반적인 문제 중 하나 이상을 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7849e-103">When you interoperate between COM and the managed code of the [!INCLUDE[dnprdnshort](../../../csharp/getting-started/includes/dnprdnshort_md.md)], you may encounter one or more of the following common issues.</span></span>  
  
##  <span data-ttu-id="7849e-104"><a name="vbconinteroperabilitymarshalinganchor1"></a>Interop 마샬링</span><span class="sxs-lookup"><span data-stu-id="7849e-104"><a name="vbconinteroperabilitymarshalinganchor1"></a> Interop Marshaling</span></span>  
 <span data-ttu-id="7849e-105">되지 않는 데이터 형식을 사용 해야 하는 경우에 속하지는 [!INCLUDE[dnprdnshort](../../../csharp/getting-started/includes/dnprdnshort_md.md)]합니다.</span><span class="sxs-lookup"><span data-stu-id="7849e-105">At times, you may have to use data types that are not part of the [!INCLUDE[dnprdnshort](../../../csharp/getting-started/includes/dnprdnshort_md.md)].</span></span> <span data-ttu-id="7849e-106">Interop 어셈블리가 COM 개체에 대 한 작업의 대부분을 처리 하지만 관리 되는 개체는 COM에 노출 하는 경우 사용 되는 데이터 형식을 제어 해야 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7849e-106">Interop assemblies handle most of the work for COM objects, but you may have to control the data types that are used when managed objects are exposed to COM.</span></span> <span data-ttu-id="7849e-107">예를 들어 클래스 라이브러리의 구조 지정 해야는 `BStr` 관리 되지 않는 형식의 Visual Basic 6.0 및 이전 버전에서 만든 COM 개체로 보낸 문자열에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7849e-107">For example, structures in class libraries must specify the `BStr` unmanaged type on strings sent to COM objects created by Visual Basic 6.0 and earlier versions.</span></span> <span data-ttu-id="7849e-108">이러한 경우에 사용할 수 있습니다는 <xref:System.Runtime.InteropServices.MarshalAsAttribute>특성을 관리 되는 형식을 관리 되지 않는 형식으로 노출 되어야 합니다.</xref:System.Runtime.InteropServices.MarshalAsAttribute></span><span class="sxs-lookup"><span data-stu-id="7849e-108">In such cases, you can use the <xref:System.Runtime.InteropServices.MarshalAsAttribute> attribute to cause managed types to be exposed as unmanaged types.</span></span>  
  
##  <span data-ttu-id="7849e-109"><a name="vbconinteroperabilitymarshalinganchor2"></a>고정 길이 문자열 비관리 코드 내보내기</span><span class="sxs-lookup"><span data-stu-id="7849e-109"><a name="vbconinteroperabilitymarshalinganchor2"></a> Exporting Fixed-Length Strings to Unmanaged Code</span></span>  
 <span data-ttu-id="7849e-110">Visual Basic 6.0 및 이전 버전에서 문자열은 null 종결 문자를 제외한 바이트 시퀀스로 COM 개체에 내보내집니다.</span><span class="sxs-lookup"><span data-stu-id="7849e-110">In Visual Basic 6.0 and earlier versions, strings are exported to COM objects as sequences of bytes without a null termination character.</span></span> <span data-ttu-id="7849e-111">다른 언어와의 호환성에 대 한 [!INCLUDE[vbprvblong](../../../visual-basic/developing-apps/customizing-extending-my/includes/vbprvblong_md.md)] 문자열을 내보낼 때 종결 문자를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="7849e-111">For compatibility with other languages, [!INCLUDE[vbprvblong](../../../visual-basic/developing-apps/customizing-extending-my/includes/vbprvblong_md.md)] includes a termination character when exporting strings.</span></span> <span data-ttu-id="7849e-112">이러한 호환성 문제를 해결 하기 위한 가장 좋은 방법은 배열로 종결 문자가 없는 문자열을 내보낼 `Byte` 또는 `Char`합니다.</span><span class="sxs-lookup"><span data-stu-id="7849e-112">The best way to address this incompatibility is to export strings that lack the termination character as arrays of `Byte` or `Char`.</span></span>  
  
##  <span data-ttu-id="7849e-113"><a name="vbconinteroperabilitymarshalinganchor3"></a>상속 계층 구조 내보내기</span><span class="sxs-lookup"><span data-stu-id="7849e-113"><a name="vbconinteroperabilitymarshalinganchor3"></a> Exporting Inheritance Hierarchies</span></span>  
 <span data-ttu-id="7849e-114">클래스 계층 구조는 COM 개체로 노출 될 때 결합을 관리 합니다.</span><span class="sxs-lookup"><span data-stu-id="7849e-114">Managed class hierarchies flatten out when exposed as COM objects.</span></span> <span data-ttu-id="7849e-115">예를 들어, 기본 클래스 멤버를 정의 하 고 다음 COM 개체로 노출 되는 파생된 클래스에서 기본 클래스를 상속 하는 경우 COM 개체에서 파생된 된 클래스를 사용 하는 클라이언트는 상속 된 멤버를 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="7849e-115">For example, if you define a base class with a member, and then inherit the base class in a derived class that is exposed as a COM object, clients that use the derived class in the COM object will not be able to use the inherited members.</span></span> <span data-ttu-id="7849e-116">기본 클래스 멤버는 기본 클래스의 인스턴스로 COM 개체에서 액세스할 수 다음 경우에 기본 클래스는 COM 개체도 생성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="7849e-116">Base class members can be accessed from COM objects only as instances of a base class, and then only if the base class is also created as a COM object.</span></span>  
  
## <a name="overloaded-methods"></a><span data-ttu-id="7849e-117">오버로드된 메서드</span><span class="sxs-lookup"><span data-stu-id="7849e-117">Overloaded Methods</span></span>  
 <span data-ttu-id="7849e-118">오버 로드 된 메서드를 만들 수 있지만 [!INCLUDE[vbprvb](../../../csharp/programming-guide/concepts/linq/includes/vbprvb_md.md)], com 지원 되지 않습니다</span><span class="sxs-lookup"><span data-stu-id="7849e-118">Although you can create overloaded methods with [!INCLUDE[vbprvb](../../../csharp/programming-guide/concepts/linq/includes/vbprvb_md.md)], they are not supported by COM.</span></span> <span data-ttu-id="7849e-119">오버 로드 된 메서드를 포함 하는 클래스, COM 개체로 노출 되어 오버 로드 된 메서드에 대 한 새 메서드 이름이 생성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="7849e-119">When a class that contains overloaded methods is exposed as a COM object, new method names are generated for the overloaded methods.</span></span>  
  
 <span data-ttu-id="7849e-120">예를 들어 두 개의 오버 로드가 있는 클래스는 `Synch` 메서드.</span><span class="sxs-lookup"><span data-stu-id="7849e-120">For example, consider a class that has two overloads of the `Synch` method.</span></span> <span data-ttu-id="7849e-121">새로 생성 된 메서드 이름이 될 수는 클래스를 COM 개체로 노출할 `Synch` 및 `Synch_2`합니다.</span><span class="sxs-lookup"><span data-stu-id="7849e-121">When the class is exposed as a COM object, the new generated method names could be `Synch` and `Synch_2`.</span></span>  
  
 <span data-ttu-id="7849e-122">이름 바꾸기는 COM 개체의 소비자에 대 한 포함 된 두 가지 문제가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7849e-122">The renaming can cause two problems for consumers of the COM object.</span></span>  
  
1.  <span data-ttu-id="7849e-123">클라이언트에서 생성 된 메서드 이름이 예측할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="7849e-123">Clients might not expect the generated method names.</span></span>  
  
2.  <span data-ttu-id="7849e-124">새 오버 로드 된 클래스 또는 해당 기본 클래스에 추가 될 때 COM 개체로 노출 하는 클래스에서 생성 된 메서드 이름을 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7849e-124">The generated method names in the class exposed as a COM object can change when new overloads are added to the class or its base class.</span></span> <span data-ttu-id="7849e-125">이 버전 관리 문제가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7849e-125">This can cause versioning problems.</span></span>  
  
 <span data-ttu-id="7849e-126">이 두 가지 문제를 해결 하기 위해 각 메서드 오버 로딩을 COM 개체로 노출 될 개체를 개발할 때 사용 하는 대신 고유한 이름을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="7849e-126">To solve both problems, give each method a unique name, instead of using overloading, when you develop objects that will be exposed as COM objects.</span></span>  
  
##  <span data-ttu-id="7849e-127"><a name="vbconinteroperabilitymarshalinganchor4"></a>Interop 어셈블리를 통해 COM 개체 사용</span><span class="sxs-lookup"><span data-stu-id="7849e-127"><a name="vbconinteroperabilitymarshalinganchor4"></a> Use of COM Objects Through Interop Assemblies</span></span>  
 <span data-ttu-id="7849e-128">COM 개체에 대 한 관리 코드 대체는 마치 거의 interop 어셈블리를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="7849e-128">You use interop assemblies almost as if they are managed code replacements for the COM objects they represent.</span></span> <span data-ttu-id="7849e-129">그러나 이기 때문에 래퍼와 하지 실제 COM 개체는 interop 어셈블리와 표준 어셈블리를 사용 하 여 몇 가지 차이점은 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7849e-129">However, because they are wrappers and not actual COM objects, there are some differences between using interop assemblies and standard assemblies.</span></span> <span data-ttu-id="7849e-130">클래스 및 데이터 형식 매개 변수 및 반환 값에 대 한 노출을 포함 하는 차이점을이 보입니다.</span><span class="sxs-lookup"><span data-stu-id="7849e-130">These areas of difference include the exposure of classes, and data types for parameters and return values.</span></span>  
  
##  <span data-ttu-id="7849e-131"><a name="vbconinteroperabilitymarshalinganchor5"></a>두 인터페이스 모두으로 노출 하는 클래스 및 클래스</span><span class="sxs-lookup"><span data-stu-id="7849e-131"><a name="vbconinteroperabilitymarshalinganchor5"></a> Classes Exposed as Both Interfaces and Classes</span></span>  
 <span data-ttu-id="7849e-132">표준 어셈블리의 클래스와는 달리 COM 클래스는 인터페이스 및 COM 클래스를 나타내는 클래스를 둘 다로 interop 어셈블리에 노출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="7849e-132">Unlike classes in standard assemblies, COM classes are exposed in interop assemblies as both an interface and a class that represents the COM class.</span></span> <span data-ttu-id="7849e-133">인터페이스의 이름이 COM 클래스의 동일 합니다.</span><span class="sxs-lookup"><span data-stu-id="7849e-133">The interface's name is identical to that of the COM class.</span></span> <span data-ttu-id="7849e-134">Interop 클래스의 이름을 원래 COM 클래스와 동일 하지만 "Class" 라는 단어를 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="7849e-134">The name of the interop class is the same as that of the original COM class, but with the word "Class" appended.</span></span> <span data-ttu-id="7849e-135">예를 들어, COM 개체에 대 한 interop 어셈블리에 대 한 참조를 사용 하 여 프로젝트를 있다고 가정 합니다.</span><span class="sxs-lookup"><span data-stu-id="7849e-135">For example, suppose you have a project with a reference to an interop assembly for a COM object.</span></span> <span data-ttu-id="7849e-136">COM 클래스의 이름이 `MyComClass`, IntelliSense 및 개체 브라우저 표시 라는 인터페이스가 `MyComClass` 라는 클래스 및 `MyComClassClass`합니다.</span><span class="sxs-lookup"><span data-stu-id="7849e-136">If the COM class is named `MyComClass`, IntelliSense and the Object Browser show an interface named `MyComClass` and a class named `MyComClassClass`.</span></span>  
  
##  <span data-ttu-id="7849e-137"><a name="vbconinteroperabilitymarshalinganchor6"></a>.NET Framework 클래스의 인스턴스 만들기</span><span class="sxs-lookup"><span data-stu-id="7849e-137"><a name="vbconinteroperabilitymarshalinganchor6"></a> Creating Instances of a .NET Framework Class</span></span>  
 <span data-ttu-id="7849e-138">인스턴스를 만들 수는 일반적으로 [!INCLUDE[dnprdnshort](../../../csharp/getting-started/includes/dnprdnshort_md.md)] 클래스를 사용 하 여는 `New` 클래스 이름으로 문의 합니다.</span><span class="sxs-lookup"><span data-stu-id="7849e-138">Generally, you create an instance of a [!INCLUDE[dnprdnshort](../../../csharp/getting-started/includes/dnprdnshort_md.md)] class using the `New` statement with a class name.</span></span> <span data-ttu-id="7849e-139">사용할 수 있는 유일한 경우는 COM 클래스를 interop 어셈블리로 표시 하는 것은 `New` 인터페이스를 사용 하 여 문을 합니다.</span><span class="sxs-lookup"><span data-stu-id="7849e-139">Having a COM class represented by an interop assembly is the one case in which you can use the `New` statement with an interface.</span></span> <span data-ttu-id="7849e-140">사용 하 여 COM 클래스를 사용 하지 않는 한 `Inherits` 문을 클래스는 것 처럼 인터페이스를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7849e-140">Unless you are using the COM class with an `Inherits` statement, you can use the interface just as you would a class.</span></span> <span data-ttu-id="7849e-141">다음 코드는 만드는 방법을 보여 줍니다.는 `Command` Microsoft ActiveX 데이터 개체 2.8 라이브러리 COM 개체에 대 한 참조가 있는 프로젝트의에서 개체:</span><span class="sxs-lookup"><span data-stu-id="7849e-141">The following code demonstrates how to create a `Command` object in a project that has a reference to the Microsoft ActiveX Data Objects 2.8 Library COM object:</span></span>  
  
 <span data-ttu-id="7849e-142">[!code-vb[VbVbalrInterop #&20;](../../../visual-basic/programming-guide/com-interop/codesnippet/VisualBasic/troubleshooting-interoperability_1.vb)]</span><span class="sxs-lookup"><span data-stu-id="7849e-142">[!code-vb[VbVbalrInterop#20](../../../visual-basic/programming-guide/com-interop/codesnippet/VisualBasic/troubleshooting-interoperability_1.vb)]</span></span>  
  
 <span data-ttu-id="7849e-143">그러나 파생된 클래스에 대 한 기반으로 COM 클래스를 사용 하는 경우 다음 코드와 같이 COM 클래스를 나타내는 interop 클래스를 사용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="7849e-143">However, if you are using the COM class as the base for a derived class, you must use the interop class that represents the COM class, as in the following code:</span></span>  
  
 <span data-ttu-id="7849e-144">[!code-vb[VbVbalrInterop #&21;](../../../visual-basic/programming-guide/com-interop/codesnippet/VisualBasic/troubleshooting-interoperability_2.vb)]</span><span class="sxs-lookup"><span data-stu-id="7849e-144">[!code-vb[VbVbalrInterop#21](../../../visual-basic/programming-guide/com-interop/codesnippet/VisualBasic/troubleshooting-interoperability_2.vb)]</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="7849e-145">Interop 어셈블리는 암시적으로 COM 클래스를 나타내는 인터페이스를 구현 합니다.</span><span class="sxs-lookup"><span data-stu-id="7849e-145">Interop assemblies implicitly implement interfaces that represent COM classes.</span></span> <span data-ttu-id="7849e-146">사용 하려고 해야는 `Implements` 오류가 또는 이러한 인터페이스를 구현 하는 문을 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="7849e-146">You should not try to use the `Implements` statement to implement these interfaces or an error will result.</span></span>  
  
##  <span data-ttu-id="7849e-147"><a name="vbconinteroperabilitymarshalinganchor7"></a>매개 변수 및 반환 값에 대 한 데이터 형식</span><span class="sxs-lookup"><span data-stu-id="7849e-147"><a name="vbconinteroperabilitymarshalinganchor7"></a> Data Types for Parameters and Return Values</span></span>  
 <span data-ttu-id="7849e-148">표준 어셈블리 멤버와는 달리 interop 어셈블리 멤버에는 원래 개체 선언에 사용 된 것과 다른 데이터 형식을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7849e-148">Unlike members of standard assemblies, interop assembly members may have data types that differ from those used in the  original object declaration.</span></span> <span data-ttu-id="7849e-149">Interop 어셈블리는 COM 형식을 호환 공용 언어 런타임 형식에 암시적으로 변환, 있지만 런타임 오류를 방지 하려면 양쪽 모두에서 사용 되는 데이터 형식에는 주의 기울여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="7849e-149">Although interop assemblies implicitly convert COM types to compatible common language runtime types, you should pay attention to the data types that are used by both sides to prevent runtime errors.</span></span> <span data-ttu-id="7849e-150">예를 들어, Visual Basic 6.0 및 이전 버전에서는 형식의 값에서 생성 된 COM 개체에서에서 `Integer` 가정은 [!INCLUDE[dnprdnshort](../../../csharp/getting-started/includes/dnprdnshort_md.md)] 해당 하는 형식을 `Short`합니다.</span><span class="sxs-lookup"><span data-stu-id="7849e-150">For example, in COM objects created in Visual Basic 6.0 and earlier versions, values of type `Integer` assume the [!INCLUDE[dnprdnshort](../../../csharp/getting-started/includes/dnprdnshort_md.md)] equivalent type, `Short`.</span></span> <span data-ttu-id="7849e-151">개체 브라우저를 사용 하 여 사용 하기 전에 가져온된 멤버의 특성을 검토 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="7849e-151">It is recommended that you use the Object Browser to examine the characteristics of imported members before you use them.</span></span>  
  
##  <span data-ttu-id="7849e-152"><a name="vbconinteroperabilitymarshalinganchor8"></a>모듈 수준 COM 메서드</span><span class="sxs-lookup"><span data-stu-id="7849e-152"><a name="vbconinteroperabilitymarshalinganchor8"></a> Module level COM methods</span></span>  
 <span data-ttu-id="7849e-153">대부분 COM 개체를 사용 하 여 사용 하 여 COM 클래스의 인스턴스를 만들고 여는 `New` 키워드와 다음 개체의 메서드를 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="7849e-153">Most COM objects are used by creating an instance of a COM class using the `New` keyword and then calling methods of the object.</span></span> <span data-ttu-id="7849e-154">이 규칙의 한 가지 예외를 포함 하는 COM 개체 관련 `AppObj` 또는 `GlobalMultiUse` COM 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="7849e-154">One exception to this rule involves COM objects that contain `AppObj` or `GlobalMultiUse` COM classes.</span></span> <span data-ttu-id="7849e-155">이러한 클래스의 모듈 수준 메서드와 비슷하게 [!INCLUDE[vbprvblong](../../../visual-basic/developing-apps/customizing-extending-my/includes/vbprvblong_md.md)] 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="7849e-155">Such classes resemble module level methods in [!INCLUDE[vbprvblong](../../../visual-basic/developing-apps/customizing-extending-my/includes/vbprvblong_md.md)] classes.</span></span> <span data-ttu-id="7849e-156">Visual Basic 6.0 및 이전 버전 암시적으로 만들 이러한 개체의 인스턴스를 해당 메서드 중 하나를 호출 하는 처음으로.</span><span class="sxs-lookup"><span data-stu-id="7849e-156">Visual Basic 6.0 and earlier versions implicitly create instances of such objects for you the first time that you call one of their methods.</span></span> <span data-ttu-id="7849e-157">예를 들어, Visual Basic 6.0에서 추가할 수 있습니다 Microsoft DAO 3.6 개체 라이브러리 및 호출에 대 한 참조는 `DBEngine` 첫 번째 인스턴스를 만들지 않고 메서드:</span><span class="sxs-lookup"><span data-stu-id="7849e-157">For example, in Visual Basic 6.0 you can add a reference to the Microsoft DAO 3.6 Object Library and call the `DBEngine` method without first creating an instance:</span></span>  
  
```  
Dim db As DAO.Database  
' Open the database.  
Set db = DBEngine.OpenDatabase("C:\nwind.mdb")  
' Use the database object.  
```  
  
 [!INCLUDE[vbprvblong](../../../visual-basic/developing-apps/customizing-extending-my/includes/vbprvblong_md.md)]<span data-ttu-id="7849e-158">만들어야 항상 COM 개체의 인스턴스 메서드를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7849e-158"> requires that you always create instances of COM objects before you can use their methods.</span></span> <span data-ttu-id="7849e-159">이러한 메서드를 사용 하 여 [!INCLUDE[vbprvblong](../../../visual-basic/developing-apps/customizing-extending-my/includes/vbprvblong_md.md)]원하는 클래스의 변수를 선언 하 고 새 키워드를 사용 하 여 개체 변수에 개체를 할당 합니다.</span><span class="sxs-lookup"><span data-stu-id="7849e-159">To use these methods in [!INCLUDE[vbprvblong](../../../visual-basic/developing-apps/customizing-extending-my/includes/vbprvblong_md.md)], declare a variable of the desired class and use the new keyword to assign the object to the object variable.</span></span> <span data-ttu-id="7849e-160">`Shared` 있는지 확인 하려는 경우에 키워드를 사용할 수 있습니다 클래스의 인스턴스를 하나만 생성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="7849e-160">The `Shared` keyword can be used when you want to make sure that only one instance of the class is created.</span></span>  
  
 <span data-ttu-id="7849e-161">[!code-vb[VbVbalrInterop&23;](../../../visual-basic/programming-guide/com-interop/codesnippet/VisualBasic/troubleshooting-interoperability_3.vb)]</span><span class="sxs-lookup"><span data-stu-id="7849e-161">[!code-vb[VbVbalrInterop#23](../../../visual-basic/programming-guide/com-interop/codesnippet/VisualBasic/troubleshooting-interoperability_3.vb)]</span></span>  
  
##  <span data-ttu-id="7849e-162"><a name="vbconinteroperabilitymarshalinganchor9"></a>이벤트 처리기에서 처리 되지 않은 오류</span><span class="sxs-lookup"><span data-stu-id="7849e-162"><a name="vbconinteroperabilitymarshalinganchor9"></a> Unhandled Errors in Event Handlers</span></span>  
 <span data-ttu-id="7849e-163">하나의 일반적인 상호 운용성 문제는 COM 개체에서 발생 한 이벤트를 처리 하는 이벤트 처리기에 오류가 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="7849e-163">One common interop problem involves errors in event handlers that handle events raised by COM objects.</span></span> <span data-ttu-id="7849e-164">구체적으로 사용 하 여 오류를 확인 하지 않는 한 이러한 오류는 무시 됩니다 `On Error` 또는 `Try...Catch...Finally` 문입니다.</span><span class="sxs-lookup"><span data-stu-id="7849e-164">Such errors are ignored unless you specifically check for errors using `On Error` or `Try...Catch...Finally` statements.</span></span> <span data-ttu-id="7849e-165">다음 예제는 예를 들어 한 [!INCLUDE[vbprvblong](../../../visual-basic/developing-apps/customizing-extending-my/includes/vbprvblong_md.md)] Microsoft ActiveX 데이터 개체 2.8 라이브러리 COM 개체에 대 한 참조를 지정 된 프로젝트입니다.</span><span class="sxs-lookup"><span data-stu-id="7849e-165">For example, the following example is from a [!INCLUDE[vbprvblong](../../../visual-basic/developing-apps/customizing-extending-my/includes/vbprvblong_md.md)] project that has a reference to the Microsoft ActiveX Data Objects 2.8 Library COM object.</span></span>  
  
 <span data-ttu-id="7849e-166">[!code-vb[VbVbalrInterop #&24;](../../../visual-basic/programming-guide/com-interop/codesnippet/VisualBasic/troubleshooting-interoperability_4.vb)]</span><span class="sxs-lookup"><span data-stu-id="7849e-166">[!code-vb[VbVbalrInterop#24](../../../visual-basic/programming-guide/com-interop/codesnippet/VisualBasic/troubleshooting-interoperability_4.vb)]</span></span>  
  
 <span data-ttu-id="7849e-167">이 예제에서는 예상 대로 오류가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="7849e-167">This example raises an error as expected.</span></span> <span data-ttu-id="7849e-168">그러나 없이 동일한 예제를 실행 하는 경우는 `Try...Catch...Finally` 사용한 경우 처럼 블록, 오류는 무시 됩니다는 `OnError Resume Next` 문입니다.</span><span class="sxs-lookup"><span data-stu-id="7849e-168">However, if you try the same example without the `Try...Catch...Finally` block, the error is ignored as if you used the `OnError Resume Next` statement.</span></span> <span data-ttu-id="7849e-169">오류를 처리 하지 않고&0;으로 나누기 자동으로 실패합니다.</span><span class="sxs-lookup"><span data-stu-id="7849e-169">Without error handling, the division by zero silently fails.</span></span> <span data-ttu-id="7849e-170">이러한 오류는 처리 되지 않은 예외 오류를 발생 하지 않습니다, 이므로 일종의 COM 개체에서 이벤트를 처리 하는 이벤트 처리기에서 예외 처리를 사용 하는 것이 중요 합니다.</span><span class="sxs-lookup"><span data-stu-id="7849e-170">Because such errors never raise unhandled exception errors, it is important that you use some form of exception handling in event handlers that handle events from COM objects.</span></span>  
  
### <a name="understanding-com-interop-errors"></a><span data-ttu-id="7849e-171">COM interop 오류 이해</span><span class="sxs-lookup"><span data-stu-id="7849e-171">Understanding COM interop errors</span></span>  
 <span data-ttu-id="7849e-172">오류를 처리 하지 interop 호출이 종종 많은 정보를 제공 하는 오류를 생성 합니다.</span><span class="sxs-lookup"><span data-stu-id="7849e-172">Without error handling, interop calls often generate errors that provide little information.</span></span> <span data-ttu-id="7849e-173">가능 하면 구조화 된 오류 발생 시 문제에 대 한 자세한 정보를 제공 하는 처리를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="7849e-173">Whenever possible, use structured error handling to provide more information about problems when they occur.</span></span> <span data-ttu-id="7849e-174">이 응용 프로그램을 디버깅할 때 특히 유용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7849e-174">This can be especially helpful when you debug applications.</span></span> <span data-ttu-id="7849e-175">예:</span><span class="sxs-lookup"><span data-stu-id="7849e-175">For example:</span></span>  
  
 <span data-ttu-id="7849e-176">[!code-vb[VbVbalrInterop #&25;](../../../visual-basic/programming-guide/com-interop/codesnippet/VisualBasic/troubleshooting-interoperability_5.vb)]</span><span class="sxs-lookup"><span data-stu-id="7849e-176">[!code-vb[VbVbalrInterop#25](../../../visual-basic/programming-guide/com-interop/codesnippet/VisualBasic/troubleshooting-interoperability_5.vb)]</span></span>  
  
 <span data-ttu-id="7849e-177">예외 개체의 내용을 검사 하 여 오류 설명, HRESULT 및 COM 오류의 소스와 같은 정보를 찾을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7849e-177">You can find information such as the error description, HRESULT, and the source of COM errors by examining the contents of the exception object.</span></span>  
  
##  <span data-ttu-id="7849e-178"><a name="vbconinteroperabilitymarshalinganchor10"></a>ActiveX 컨트롤 문제</span><span class="sxs-lookup"><span data-stu-id="7849e-178"><a name="vbconinteroperabilitymarshalinganchor10"></a> ActiveX Control Issues</span></span>  
 <span data-ttu-id="7849e-179">Visual Basic 6.0을 사용 하는 대부분의 ActiveX 컨트롤 사용 [!INCLUDE[vbprvblong](../../../visual-basic/developing-apps/customizing-extending-my/includes/vbprvblong_md.md)] 문제 없이 합니다.</span><span class="sxs-lookup"><span data-stu-id="7849e-179">Most ActiveX controls that work with Visual Basic 6.0 work with [!INCLUDE[vbprvblong](../../../visual-basic/developing-apps/customizing-extending-my/includes/vbprvblong_md.md)] without trouble.</span></span> <span data-ttu-id="7849e-180">중요 한 예외는 컨테이너 컨트롤 또는 다른 컨트롤을 시각적으로 포함 하는 컨트롤입니다.</span><span class="sxs-lookup"><span data-stu-id="7849e-180">The main exceptions are container controls, or controls that visually contain other controls.</span></span> <span data-ttu-id="7849e-181">이전 버전에서 올바르게 작동 하지 않는 컨트롤의 몇 가지 예 [!INCLUDE[vsprvs](../../../csharp/includes/vsprvs_md.md)] 은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="7849e-181">Some examples of older controls that do not work correctly with [!INCLUDE[vsprvs](../../../csharp/includes/vsprvs_md.md)] are as follows:</span></span>  
  
-   <span data-ttu-id="7849e-182">Microsoft Forms 2.0 프레임 제어</span><span class="sxs-lookup"><span data-stu-id="7849e-182">Microsoft Forms 2.0 Frame control</span></span>  
  
-   <span data-ttu-id="7849e-183">Up-down 컨트롤을 라고도 스핀 컨트롤</span><span class="sxs-lookup"><span data-stu-id="7849e-183">Up-Down control, also known as the spin control</span></span>  
  
-   <span data-ttu-id="7849e-184">Sheridan 탭 컨트롤</span><span class="sxs-lookup"><span data-stu-id="7849e-184">Sheridan Tab Control</span></span>  
  
 <span data-ttu-id="7849e-185">지원 되지 않는 ActiveX 컨트롤 문제에 대 한 몇 가지 대안만 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7849e-185">There are only a few workarounds for unsupported ActiveX control problems.</span></span> <span data-ttu-id="7849e-186">기존 컨트롤을 마이그레이션할 수 있는 [!INCLUDE[vsprvs](../../../csharp/includes/vsprvs_md.md)] 원래 소스 코드를 소유 합니다.</span><span class="sxs-lookup"><span data-stu-id="7849e-186">You can migrate existing controls to [!INCLUDE[vsprvs](../../../csharp/includes/vsprvs_md.md)] if you own the original source code.</span></span> <span data-ttu-id="7849e-187">그렇지 않은 경우 업데이트에 대 한 소프트웨어 공급 업체에 확인할 수 있습니다. NET 호환 버전을 대체 하는 컨트롤의 ActiveX 컨트롤을 지원 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="7849e-187">Otherwise, you can check with software vendors for updated .NET-compatible versions of controls to replace unsupported ActiveX controls.</span></span>  
  
##  <span data-ttu-id="7849e-188"><a name="vbconinteroperabilitymarshalinganchor11"></a>ByRef 컨트롤의 읽기 전용 속성에 전달</span><span class="sxs-lookup"><span data-stu-id="7849e-188"><a name="vbconinteroperabilitymarshalinganchor11"></a> Passing ReadOnly Properties of Controls ByRef</span></span>  
 [!INCLUDE[vbprvblong](../../../visual-basic/developing-apps/customizing-extending-my/includes/vbprvblong_md.md)]<span data-ttu-id="7849e-189">전달 하는 경우 때로는 "오류 0x800A017F CTL_E_SETNOTSUPPORTED"와 같은 COM 오류를 발생 시킵니다 `ReadOnly` 로 일부 오래 된 ActiveX 컨트롤의 속성 `ByRef` 다른 프로시저에 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="7849e-189"> sometimes raises COM errors such as "Error 0x800A017F CTL_E_SETNOTSUPPORTED" when you pass `ReadOnly` properties of some older ActiveX controls as `ByRef` parameters to other procedures.</span></span> <span data-ttu-id="7849e-190">Visual Basic 6.0에서 유사한 프로시저 호출 하는 오류를 발생 시 키 지 및 매개 변수는 값으로 전달 된 것 처럼 처리 됩니다.</span><span class="sxs-lookup"><span data-stu-id="7849e-190">Similar procedure calls from Visual Basic 6.0 do not raise an error, and the parameters are treated as if you passed them by value.</span></span> <span data-ttu-id="7849e-191">오류 메시지에 나와 있는 [!INCLUDE[vbprvblong](../../../visual-basic/developing-apps/customizing-extending-my/includes/vbprvblong_md.md)] 속성이 없는 속성을 변경 하려는 보고 하는 COM 개체는 `Set` 프로시저입니다.</span><span class="sxs-lookup"><span data-stu-id="7849e-191">The error message you see in [!INCLUDE[vbprvblong](../../../visual-basic/developing-apps/customizing-extending-my/includes/vbprvblong_md.md)] is the COM object reporting that you are trying to change a property that does not have a property `Set` procedure.</span></span>  
  
 <span data-ttu-id="7849e-192">사용 하 여이 오류를 방지할 수 호출 되는 프로시저에 대 한 액세스를 사용 하는 경우는 `ByVal` 을 받아들이는 매개 변수를 선언 하려면 키워드 `ReadOnly` 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="7849e-192">If you have access to the procedure being called, you can prevent this error by using the `ByVal` keyword to declare parameters that accept `ReadOnly` properties.</span></span> <span data-ttu-id="7849e-193">예:</span><span class="sxs-lookup"><span data-stu-id="7849e-193">For example:</span></span>  
  
 <span data-ttu-id="7849e-194">[!code-vb[VbVbalrInterop #&26;](../../../visual-basic/programming-guide/com-interop/codesnippet/VisualBasic/troubleshooting-interoperability_6.vb)]</span><span class="sxs-lookup"><span data-stu-id="7849e-194">[!code-vb[VbVbalrInterop#26](../../../visual-basic/programming-guide/com-interop/codesnippet/VisualBasic/troubleshooting-interoperability_6.vb)]</span></span>  
  
 <span data-ttu-id="7849e-195">호출 되는 프로시저에 대 한 소스 코드에 대 한 액세스를 하지 않은 경우 속성을 호출 하는 프로시저 주위에 대괄호를 추가 하 여 값으로 전달 되도록 강제할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7849e-195">If you do not have access to the source code for the procedure being called, you can force the property to be passed by value by adding an extra set of brackets around the calling procedure.</span></span> <span data-ttu-id="7849e-196">예를 들어, Microsoft ActiveX 데이터 개체 2.8 라이브러리 COM 개체에 대 한 참조가 있는 프로젝트에서 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7849e-196">For example, in a project that has a reference to the Microsoft ActiveX Data Objects 2.8 Library COM object, you can use:</span></span>  
  
 <span data-ttu-id="7849e-197">[!code-vb[VbVbalrInterop #&27;](../../../visual-basic/programming-guide/com-interop/codesnippet/VisualBasic/troubleshooting-interoperability_7.vb)]</span><span class="sxs-lookup"><span data-stu-id="7849e-197">[!code-vb[VbVbalrInterop#27](../../../visual-basic/programming-guide/com-interop/codesnippet/VisualBasic/troubleshooting-interoperability_7.vb)]</span></span>  
  
##  <span data-ttu-id="7849e-198"><a name="vbconinteroperabilitymarshalinganchor12"></a>Interop을 노출 하는 어셈블리 배포</span><span class="sxs-lookup"><span data-stu-id="7849e-198"><a name="vbconinteroperabilitymarshalinganchor12"></a> Deploying Assemblies That Expose Interop</span></span>  
 <span data-ttu-id="7849e-199">몇 가지 주의할 점이 표시 COM 인터페이스를 노출 하는 어셈블리를 배포 합니다.</span><span class="sxs-lookup"><span data-stu-id="7849e-199">Deploying assemblies that expose COM interfaces presents some unique challenges.</span></span> <span data-ttu-id="7849e-200">예를 들어, 잠재적인 문제를 별도 응용 프로그램에서 같은 COM 어셈블리를 참조 하는 경우에 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="7849e-200">For example, a potential problem occurs when separate applications reference the same COM assembly.</span></span> <span data-ttu-id="7849e-201">이 경우 일반적인 경우 어셈블리의 새 버전을 설치 하 고 다른 응용 프로그램은 이전 버전의 어셈블리를 사용 하 여 계속 합니다.</span><span class="sxs-lookup"><span data-stu-id="7849e-201">This situation is common when a new version of an assembly is installed and another application is still using the old version of the assembly.</span></span> <span data-ttu-id="7849e-202">DLL을 공유 하는 어셈블리를 제거 하는 경우 있습니다 수 하지 못할 다른 어셈블리에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7849e-202">If you uninstall an assembly that shares a DLL, you can unintentionally make it unavailable to the other assemblies.</span></span>  
  
 <span data-ttu-id="7849e-203">이 문제를 방지 하려면 공유 어셈블리를 전역 어셈블리 캐시 (GAC)에 설치 하 고 구성 요소에 대 한 병합 모듈을 사용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="7849e-203">To avoid this problem, you should install shared assemblies to the Global Assembly Cache (GAC) and use a MergeModule for the component.</span></span> <span data-ttu-id="7849e-204">GAC에 응용 프로그램을 설치할 수 없는 경우 설치 해야 CommonFilesFolder을 버전별 하위 디렉터리에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7849e-204">If you cannot install the application in the GAC, it should be installed to CommonFilesFolder in a version-specific subdirectory.</span></span>  
  
 <span data-ttu-id="7849e-205">공유 되지 않는 어셈블리는 호출 응용 프로그램을 사용 하 여 디렉터리에 함께 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="7849e-205">Assemblies that are not shared should be located side by side in the directory with the calling application.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="7849e-206">참고 항목</span><span class="sxs-lookup"><span data-stu-id="7849e-206">See Also</span></span>  
 <span data-ttu-id="7849e-207"><xref:System.Runtime.InteropServices.MarshalAsAttribute></xref:System.Runtime.InteropServices.MarshalAsAttribute></span><span class="sxs-lookup"><span data-stu-id="7849e-207"><xref:System.Runtime.InteropServices.MarshalAsAttribute></span></span>   
<span data-ttu-id="7849e-208"> [COM Interop](../../../visual-basic/programming-guide/com-interop/index.md) </span><span class="sxs-lookup"><span data-stu-id="7849e-208"> [COM Interop](../../../visual-basic/programming-guide/com-interop/index.md) </span></span>  
<span data-ttu-id="7849e-209"> [Tlbimp.exe (형식 라이브러리 가져오기)](http://msdn.microsoft.com/library/ec0a8d63-11b3-4acd-b398-da1e37e97382) </span><span class="sxs-lookup"><span data-stu-id="7849e-209"> [Tlbimp.exe (Type Library Importer)](http://msdn.microsoft.com/library/ec0a8d63-11b3-4acd-b398-da1e37e97382) </span></span>  
<span data-ttu-id="7849e-210"> [Tlbexp.exe (형식 라이브러리 내보내기)](http://msdn.microsoft.com/library/a487d61b-d166-467b-a7ca-d8b52fbff42d) </span><span class="sxs-lookup"><span data-stu-id="7849e-210"> [Tlbexp.exe (Type Library Exporter)](http://msdn.microsoft.com/library/a487d61b-d166-467b-a7ca-d8b52fbff42d) </span></span>  
<span data-ttu-id="7849e-211"> [연습: COM 개체를 사용한 상속 구현](../../../visual-basic/programming-guide/com-interop/walkthrough-implementing-inheritance-with-com-objects.md) </span><span class="sxs-lookup"><span data-stu-id="7849e-211"> [Walkthrough: Implementing Inheritance with COM Objects](../../../visual-basic/programming-guide/com-interop/walkthrough-implementing-inheritance-with-com-objects.md) </span></span>  
<span data-ttu-id="7849e-212"> [Inherits 문](../../../visual-basic/language-reference/statements/inherits-statement.md) </span><span class="sxs-lookup"><span data-stu-id="7849e-212"> [Inherits Statement](../../../visual-basic/language-reference/statements/inherits-statement.md) </span></span>  
<span data-ttu-id="7849e-213"> [전역 어셈블리 캐시](http://msdn.microsoft.com/library/cf5eacd0-d3ec-4879-b6da-5fd5e4372202)</span><span class="sxs-lookup"><span data-stu-id="7849e-213"> [Global Assembly Cache](http://msdn.microsoft.com/library/cf5eacd0-d3ec-4879-b6da-5fd5e4372202)</span></span>

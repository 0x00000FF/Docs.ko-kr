---
title: "연습: Windows Api 호출 (Visual Basic) | Microsoft 문서"
ms.custom: 
ms.date: 2015-07-20
ms.prod: .net
ms.reviewer: 
ms.suite: 
ms.technology:
- devlang-visual-basic
ms.topic: article
dev_langs:
- VB
helpviewer_keywords:
- DLLs, calling
- Windows API, walkthroughs
- platform invoke, walkthroughs
- API calls, walkthroughs [Visual Basic]
- Windows API, calling
- walkthroughs [Visual Basic], API calls
- DllImport attribute, calling Windows API
- Declare statement, declaring DLL functions
ms.assetid: 9280ca96-7a93-47a3-8d01-6d01be0657cb
caps.latest.revision: 20
author: dotnet-bot
ms.author: dotnetcontent
translation.priority.ht:
- cs-cz
- de-de
- es-es
- fr-fr
- it-it
- ja-jp
- ko-kr
- pl-pl
- pt-br
- ru-ru
- tr-tr
- zh-cn
- zh-tw
ms.translationtype: Machine Translation
ms.sourcegitcommit: 9f5b8ebb69c9206ff90b05e748c64d29d82f7a16
ms.openlocfilehash: ae1ef60e6e27658c872689f5bfe2779493d42e7a
ms.contentlocale: ko-kr
ms.lasthandoff: 04/12/2017

---
# <a name="walkthrough-calling-windows-apis-visual-basic"></a><span data-ttu-id="03ada-102">연습: Windows API 호출(Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="03ada-102">Walkthrough: Calling Windows APIs (Visual Basic)</span></span>
<span data-ttu-id="03ada-103">Windows Api는 Windows 운영 체제의 일부인 동적 연결 라이브러리 (Dll)입니다.</span><span class="sxs-lookup"><span data-stu-id="03ada-103">Windows APIs are dynamic-link libraries (DLLs) that are part of the Windows operating system.</span></span> <span data-ttu-id="03ada-104">프로시저를 직접 작성 하기 어려운 경우 작업을 수행 하 고를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="03ada-104">You use them to perform tasks when it is difficult to write equivalent procedures of your own.</span></span> <span data-ttu-id="03ada-105">Windows 라는 함수를 제공 하는 예를 들어 `FlashWindowEx` 밝은 영역과 어두운 음영을 교대로 제목 표시줄에 응용 프로그램을 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="03ada-105">For example, Windows provides a function named `FlashWindowEx` that lets you make the title bar for an application alternate between light and dark shades.</span></span>  
  
 <span data-ttu-id="03ada-106">Windows Api를 사용 하 여 코드에서의 장점은 사용 하기 위해 대기 하 고 여러 가지 유용한 함수가 이미 작성 된 포함 하기 때문에 개발 시간을 절약할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="03ada-106">The advantage of using Windows APIs in your code is that they can save development time because they contain dozens of useful functions that are already written and waiting to be used.</span></span> <span data-ttu-id="03ada-107">단점은 Windows Api는 간편 하 고 철 문제가 발생할 때 어려울 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="03ada-107">The disadvantage is that Windows APIs can be difficult to work with and unforgiving when things go wrong.</span></span>  
  
 <span data-ttu-id="03ada-108">Windows Api의 상호 운용성 특정 범주를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="03ada-108">Windows APIs represent a special category of interoperability.</span></span> <span data-ttu-id="03ada-109">Windows Api 관리 되는 코드를 사용 하지 않는, 기본 제공 라이브러리를 입력 하 고 Visual Studio와 함께 사용 되는 것과 다른 데이터 형식을 사용할 필요는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="03ada-109">Windows APIs do not use managed code, do not have built-in type libraries, and use data types that are different than those used with Visual Studio.</span></span> <span data-ttu-id="03ada-110">이러한 차이 때문에 있고 Windows Api는 COM 개체, Windows Api와의 상호 운용성 및 [!INCLUDE[dnprdnshort](../../../csharp/getting-started/includes/dnprdnshort_md.md)] 플랫폼을 사용 하 여 이루어집니다를 호출 pinvoke입니다.</span><span class="sxs-lookup"><span data-stu-id="03ada-110">Because of these differences, and because Windows APIs are not COM objects, interoperability with Windows APIs and the [!INCLUDE[dnprdnshort](../../../csharp/getting-started/includes/dnprdnshort_md.md)] is performed using platform invoke, or PInvoke.</span></span> <span data-ttu-id="03ada-111">플랫폼 호출 수 있도록 Dll에서 구현 하는 관리 되지 않는 함수를 호출 하는 코드를 관리 하는 서비스입니다.</span><span class="sxs-lookup"><span data-stu-id="03ada-111">Platform invoke is a service that enables managed code to call unmanaged functions implemented in DLLs.</span></span> <span data-ttu-id="03ada-112">자세한 내용은 참조 [관리 되지 않는 DLL 함수를 사용해](http://msdn.microsoft.com/library/eca7606e-ebfb-4f47-b8d9-289903fdc045)합니다.</span><span class="sxs-lookup"><span data-stu-id="03ada-112">For more information, see [Consuming Unmanaged DLL Functions](http://msdn.microsoft.com/library/eca7606e-ebfb-4f47-b8d9-289903fdc045).</span></span> <span data-ttu-id="03ada-113">PInvoke를 사용할 수 있습니다 [!INCLUDE[vbprvb](../../../csharp/programming-guide/concepts/linq/includes/vbprvb_md.md)] 중 하나를 사용 하 여는 `Declare` 문 또는 적용는 `DllImport` 빈 프로시저에 대 한 특성입니다.</span><span class="sxs-lookup"><span data-stu-id="03ada-113">You can use PInvoke in [!INCLUDE[vbprvb](../../../csharp/programming-guide/concepts/linq/includes/vbprvb_md.md)] by using either the `Declare` statement or applying the `DllImport` attribute to an empty procedure.</span></span>  
  
 <span data-ttu-id="03ada-114">Windows API 호출의 중요 한 부분이 되었습니다 [!INCLUDE[vbprvb](../../../csharp/programming-guide/concepts/linq/includes/vbprvb_md.md)] 과거에서 프로그래밍, 하지만 대부분의 경우에 필요 [!INCLUDE[vbprvblong](../../../visual-basic/developing-apps/customizing-extending-my/includes/vbprvblong_md.md)]합니다.</span><span class="sxs-lookup"><span data-stu-id="03ada-114">Windows API calls were an important part of [!INCLUDE[vbprvb](../../../csharp/programming-guide/concepts/linq/includes/vbprvb_md.md)] programming in the past, but are seldom necessary with [!INCLUDE[vbprvblong](../../../visual-basic/developing-apps/customizing-extending-my/includes/vbprvblong_md.md)].</span></span> <span data-ttu-id="03ada-115">관리 되는 코드를 사용 해야 가능 하다 면는 [!INCLUDE[dnprdnshort](../../../csharp/getting-started/includes/dnprdnshort_md.md)] Windows API를 호출 하는 대신 작업을 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="03ada-115">Whenever possible, you should use managed code from the [!INCLUDE[dnprdnshort](../../../csharp/getting-started/includes/dnprdnshort_md.md)] to perform tasks, instead of Windows API calls.</span></span> <span data-ttu-id="03ada-116">이 연습을 사용 하 여 이러한 상황에 대 한 정보를 제공 합니다. Windows Api는 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="03ada-116">This walkthrough provides information for those situations in which using Windows APIs is necessary.</span></span>  
  
[!INCLUDE[note_settings_general](../../../csharp/language-reference/compiler-messages/includes/note_settings_general_md.md)]  
  
## <a name="api-calls-using-declare"></a><span data-ttu-id="03ada-117">API 호출을 사용 하 여 선언</span><span class="sxs-lookup"><span data-stu-id="03ada-117">API Calls Using Declare</span></span>  
 <span data-ttu-id="03ada-118">Windows Api를 호출 하는 가장 일반적인 방법은 사용 하는 것은 `Declare` 문입니다.</span><span class="sxs-lookup"><span data-stu-id="03ada-118">The most common way to call Windows APIs is by using the `Declare` statement.</span></span>  
  
#### <a name="to-declare-a-dll-procedure"></a><span data-ttu-id="03ada-119">DLL 프로시저를 선언 하려면</span><span class="sxs-lookup"><span data-stu-id="03ada-119">To declare a DLL procedure</span></span>  
  
1.  <span data-ttu-id="03ada-120">를 호출 하려면 원하는 함수 관련 인수, 인수 형식을의 이름을 확인 하 고 값 뿐만 아니라 이름 및 포함 된 DLL의 위치를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="03ada-120">Determine the name of the function you want to call, plus its arguments, argument types, and return value, as well as the name and location of the DLL that contains it.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="03ada-121">Windows Api에 대 한 자세한 내용은 플랫폼 SDK Windows API에서 Win32 SDK 설명서를 참조 합니다.</span><span class="sxs-lookup"><span data-stu-id="03ada-121">For complete information about the Windows APIs, see the Win32 SDK documentation in the Platform SDK Windows API.</span></span> <span data-ttu-id="03ada-122">Windows Api를 사용 하는 상수에 대 한 자세한 내용은 Platform SDK에 포함 된 h와 같은 헤더 파일을 검사 합니다.</span><span class="sxs-lookup"><span data-stu-id="03ada-122">For more information about the constants that Windows APIs use, examine the header files such as Windows.h included with the Platform SDK.</span></span>  
  
2.  <span data-ttu-id="03ada-123">클릭 하 여 새 Windows 응용 프로그램 프로젝트를 열고 **새로** 에 **파일** 메뉴를 클릭 한 다음 **프로젝트**합니다.</span><span class="sxs-lookup"><span data-stu-id="03ada-123">Open a new Windows Application project by clicking **New** on the **File** menu, and then clicking **Project**.</span></span> <span data-ttu-id="03ada-124">**새 프로젝트** 대화 상자가 나타납니다.</span><span class="sxs-lookup"><span data-stu-id="03ada-124">The **New Project** dialog box appears.</span></span>  
  
3.  <span data-ttu-id="03ada-125">선택 **Windows 응용 프로그램** 목록에서 [!INCLUDE[vbprvb](../../../csharp/programming-guide/concepts/linq/includes/vbprvb_md.md)] 프로젝트 템플릿이 포함 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="03ada-125">Select **Windows Application** from the list of [!INCLUDE[vbprvb](../../../csharp/programming-guide/concepts/linq/includes/vbprvb_md.md)] project templates.</span></span> <span data-ttu-id="03ada-126">새 프로젝트가 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="03ada-126">The new project is displayed.</span></span>  
  
4.  <span data-ttu-id="03ada-127">다음 코드를 추가 `Declare` 클래스 또는 DLL을 사용 하 여 원하는 모듈에 작동 합니다.</span><span class="sxs-lookup"><span data-stu-id="03ada-127">Add the following `Declare` function either to the class or module in which you want to use the DLL:</span></span>  
  
     <span data-ttu-id="03ada-128">[!code-vb[VbVbalrInterop #&9;](../../../visual-basic/programming-guide/com-interop/codesnippet/VisualBasic/walkthrough-calling-windows-apis_1.vb)]</span><span class="sxs-lookup"><span data-stu-id="03ada-128">[!code-vb[VbVbalrInterop#9](../../../visual-basic/programming-guide/com-interop/codesnippet/VisualBasic/walkthrough-calling-windows-apis_1.vb)]</span></span>  
  
### <a name="parts-of-the-declare-statement"></a><span data-ttu-id="03ada-129">부분은 Declare 문</span><span class="sxs-lookup"><span data-stu-id="03ada-129">Parts of the Declare Statement</span></span>  
 <span data-ttu-id="03ada-130">`Declare` 문에 다음과 같은 요소가 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="03ada-130">The `Declare` statement includes the following elements.</span></span>  
  
#### <a name="auto-modifier"></a><span data-ttu-id="03ada-131">Auto 한정자</span><span class="sxs-lookup"><span data-stu-id="03ada-131">Auto modifier</span></span>  
 <span data-ttu-id="03ada-132">`Auto` 한정자는 런타임에 공용 언어 런타임 규칙 (또는 별칭 이름을 지정 하는 경우)에 따라 메서드 이름에 따라 문자열을 변환 하도록 지시 합니다.</span><span class="sxs-lookup"><span data-stu-id="03ada-132">The `Auto` modifier instructs the runtime to convert the string based on the method name according to common language runtime rules (or alias name if specified).</span></span>  
  
#### <a name="lib-and-alias-keywords"></a><span data-ttu-id="03ada-133">Lib 및 별칭 키워드</span><span class="sxs-lookup"><span data-stu-id="03ada-133">Lib and Alias keywords</span></span>  
 <span data-ttu-id="03ada-134">다음 이름은 `Function` 키워드는 프로그램에서 가져온된 함수에 액세스 하는 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="03ada-134">The name following the `Function` keyword is the name your program uses to access the imported function.</span></span> <span data-ttu-id="03ada-135">함수를 호출 하는 실제 이름과 동일 또는 다른 유효한 프로시저 이름 및 사용한 다음에 사용할 수는 `Alias` 키워드를 호출 하는 함수의 실제 이름을 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="03ada-135">It can be the same as the real name of the function you are calling, or you can use any valid procedure name and then employ the `Alias` keyword to specify the real name of the function you are calling.</span></span>  
  
 <span data-ttu-id="03ada-136">지정 된 `Lib` 키워드와 이름 및 함수를 호출 하는 포함 하는 DLL의 위치입니다.</span><span class="sxs-lookup"><span data-stu-id="03ada-136">Specify the `Lib` keyword, followed by the name and location of the DLL that contains the function you are calling.</span></span> <span data-ttu-id="03ada-137">Windows 시스템 디렉터리에 있는 파일에 대 한 경로를 지정할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="03ada-137">You do not need to specify the path for files located in the Windows system directories.</span></span>  
  
 <span data-ttu-id="03ada-138">사용 하는 `Alias` 호출 하는 함수 이름이 유효한 키워드 [!INCLUDE[vbprvb](../../../csharp/programming-guide/concepts/linq/includes/vbprvb_md.md)] 프로시저 이름 또는 응용 프로그램에서 다른 항목의 이름과 충돌 합니다.</span><span class="sxs-lookup"><span data-stu-id="03ada-138">Use the `Alias` keyword if the name of the function you are calling is not a valid [!INCLUDE[vbprvb](../../../csharp/programming-guide/concepts/linq/includes/vbprvb_md.md)] procedure name, or conflicts with the name of other items in your application.</span></span> <span data-ttu-id="03ada-139">`Alias`호출 되는 함수의의 실제 이름을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="03ada-139">`Alias` indicates the true name of the function being called.</span></span>  
  
#### <a name="argument-and-data-type-declarations"></a><span data-ttu-id="03ada-140">인수 및 데이터 형식 선언</span><span class="sxs-lookup"><span data-stu-id="03ada-140">Argument and Data Type Declarations</span></span>  
 <span data-ttu-id="03ada-141">인수 및 해당 데이터 형식을 선언 합니다.</span><span class="sxs-lookup"><span data-stu-id="03ada-141">Declare the arguments and their data types.</span></span> <span data-ttu-id="03ada-142">Windows에서 사용 하는 데이터 형식 Visual Studio 데이터 형식에 대응 되지 않기 때문에이 부분을 매우 어려울 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="03ada-142">This part can be challenging because the data types that Windows uses do not correspond to Visual Studio data types.</span></span> [!INCLUDE[vbprvb](../../../csharp/programming-guide/concepts/linq/includes/vbprvb_md.md)]<span data-ttu-id="03ada-143">호환 되는 데이터 형식, 라고 하는 프로세스에 인수를 변환 하는 많은 작업을 수행 *마샬링*합니다.</span><span class="sxs-lookup"><span data-stu-id="03ada-143"> does a lot of the work for you by converting arguments to compatible data types, a process called *marshaling*.</span></span> <span data-ttu-id="03ada-144">인수를 사용 하 여 마샬링되는 방법을 명시적으로 제어할 수는 <xref:System.Runtime.InteropServices.MarshalAsAttribute>에 정의 된 특성의 <xref:System.Runtime.InteropServices>네임 스페이스.</xref:System.Runtime.InteropServices> </xref:System.Runtime.InteropServices.MarshalAsAttribute></span><span class="sxs-lookup"><span data-stu-id="03ada-144">You can explicitly control how arguments are marshaled by using the <xref:System.Runtime.InteropServices.MarshalAsAttribute> attribute defined in the <xref:System.Runtime.InteropServices> namespace.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="03ada-145">이전 버전의 [!INCLUDE[vbprvb](../../../csharp/programming-guide/concepts/linq/includes/vbprvb_md.md)] 매개 변수를 선언 하는 데 사용할 수 `As Any`, 즉 모든 데이터의 해당 데이터 형식을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="03ada-145">Previous versions of [!INCLUDE[vbprvb](../../../csharp/programming-guide/concepts/linq/includes/vbprvb_md.md)] allowed you to declare parameters `As Any`, meaning that data of any data type could be used.</span></span> [!INCLUDE[vbprvb](../../../csharp/programming-guide/concepts/linq/includes/vbprvb_md.md)]<span data-ttu-id="03ada-146">특정 데이터 형식을 사용 하 여 모든 필요한 `Declare` 문입니다.</span><span class="sxs-lookup"><span data-stu-id="03ada-146"> requires that you use a specific data type for all `Declare` statements.</span></span>  
  
#### <a name="windows-api-constants"></a><span data-ttu-id="03ada-147">Windows API 상수</span><span class="sxs-lookup"><span data-stu-id="03ada-147">Windows API Constants</span></span>  
 <span data-ttu-id="03ada-148">일부 인수는 상수의 조합입니다.</span><span class="sxs-lookup"><span data-stu-id="03ada-148">Some arguments are combinations of constants.</span></span> <span data-ttu-id="03ada-149">예를 들어는 `MessageBox` 라는 정수 인수를 허용 하는이 연습에 표시 되는 API `Typ` 메시지 상자가 표시 되는 방식을 제어 하 합니다.</span><span class="sxs-lookup"><span data-stu-id="03ada-149">For example, the `MessageBox` API shown in this walkthrough accepts an integer argument called `Typ` that controls how the message box is displayed.</span></span> <span data-ttu-id="03ada-150">검사 하 여 이러한 상수 중 숫자 값을 확인할 수는 `#define` WinUser.h 파일에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="03ada-150">You can determine the numeric value of these constants by examining the `#define` statements in the file WinUser.h.</span></span> <span data-ttu-id="03ada-151">숫자 값은&16; 진수, 일반적으로 표시는 계산기를 사용 하 여 추가 하 고&10; 진수로 변환 해야 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="03ada-151">The numeric values are generally shown in hexadecimal, so you may want to use a calculator to add them and convert to decimal.</span></span> <span data-ttu-id="03ada-152">예를 들어 감탄 스타일에 대 한 상수를 결합 하려면 `MB_ICONEXCLAMATION` 0x00000030 Yes/스타일 없음 `MB_YESNO` 0x00000004, 숫자를 추가 하 고 10 진수 0x00000034, 또는 52의 결과 얻을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="03ada-152">For example, if you want to combine the constants for the exclamation style `MB_ICONEXCLAMATION` 0x00000030 and the Yes/No style `MB_YESNO` 0x00000004, you can add the numbers and get a result of 0x00000034, or 52 decimal.</span></span> <span data-ttu-id="03ada-153">응용 프로그램에서 상수로 이러한 값을 선언 하 고 결합 하는 것이 좋습니다&10; 진수 결과 직접 사용할 수 있지만 사용 하는 `Or` 연산자입니다.</span><span class="sxs-lookup"><span data-stu-id="03ada-153">Although you can use the decimal result directly, it is better to declare these values as constants in your application and combine them using the `Or` operator.</span></span>  
  
###### <a name="to-declare-constants-for-windows-api-calls"></a><span data-ttu-id="03ada-154">Windows API 호출에 대 한 상수를 선언 하려면</span><span class="sxs-lookup"><span data-stu-id="03ada-154">To declare constants for Windows API calls</span></span>  
  
1.  <span data-ttu-id="03ada-155">호출 하는 Windows 함수에 대 한 설명서를 참조 하십시오.</span><span class="sxs-lookup"><span data-stu-id="03ada-155">Consult the documentation for the Windows function you are calling.</span></span> <span data-ttu-id="03ada-156">이러한 상수에 대 한 숫자 값을 포함 하는.h 파일의 이름과 사용 되는 상수의 이름을 결정 합니다.</span><span class="sxs-lookup"><span data-stu-id="03ada-156">Determine the name of the constants it uses and the name of the .h file that contains the numeric values for these constants.</span></span>  
  
2.  <span data-ttu-id="03ada-157">헤더 (.h) 파일의 내용을 보려면 메모장 같은 텍스트 편집기를 사용 하 고 사용 하는 상수와 관련 된 값을 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="03ada-157">Use a text editor, such as Notepad, to view the contents of the header (.h) file, and find the values associated with the constants you are using.</span></span> <span data-ttu-id="03ada-158">예를 들어는 `MessageBox` API 상수를 사용 하 여 `MB_ICONQUESTION` 메시지 상자에 물음표를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="03ada-158">For example, the `MessageBox` API uses the constant `MB_ICONQUESTION` to show a question mark in the message box.</span></span> <span data-ttu-id="03ada-159">에 대 한 정의가 `MB_ICONQUESTION` WinUser.h 이며 다음과 같이 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="03ada-159">The definition for `MB_ICONQUESTION` is in WinUser.h and appears as follows:</span></span>  
  
     `#define MB_ICONQUESTION             0x00000020L`  
  
3.  <span data-ttu-id="03ada-160">해당 하는 추가 `Const` 문을 클래스나 모듈 이러한 상수를 응용 프로그램에서 사용할 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="03ada-160">Add equivalent `Const` statements to your class or module to make these constants available to your application.</span></span> <span data-ttu-id="03ada-161">예:</span><span class="sxs-lookup"><span data-stu-id="03ada-161">For example:</span></span>  
  
     <span data-ttu-id="03ada-162">[!code-vb[VbVbalrInterop #&11;](../../../visual-basic/programming-guide/com-interop/codesnippet/VisualBasic/walkthrough-calling-windows-apis_2.vb)]</span><span class="sxs-lookup"><span data-stu-id="03ada-162">[!code-vb[VbVbalrInterop#11](../../../visual-basic/programming-guide/com-interop/codesnippet/VisualBasic/walkthrough-calling-windows-apis_2.vb)]</span></span>  
  
###### <a name="to-call-the-dll-procedure"></a><span data-ttu-id="03ada-163">DLL 프로시저를 호출 하려면</span><span class="sxs-lookup"><span data-stu-id="03ada-163">To call the DLL procedure</span></span>  
  
1.  <span data-ttu-id="03ada-164">이라는 단추를 추가 `Button1` 시작 프로젝트를 만들어 해당 코드를 보려면 두 번 클릭 합니다.</span><span class="sxs-lookup"><span data-stu-id="03ada-164">Add a button named `Button1` to the startup form for your project, and then double-click it to view its code.</span></span> <span data-ttu-id="03ada-165">단추에 대 한 이벤트 처리기가 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="03ada-165">The event handler for the button is displayed.</span></span>  
  
2.  <span data-ttu-id="03ada-166">코드를 추가 하는 `Click` 프로시저를 호출 하 고 적절 한 인수를 제공 하려면 추가한 단추에 대 한 이벤트 처리기:</span><span class="sxs-lookup"><span data-stu-id="03ada-166">Add code to the `Click` event handler for the button you added, to call the procedure and provide the appropriate arguments:</span></span>  
  
     <span data-ttu-id="03ada-167">[!code-vb[VbVbalrInterop #&12;](../../../visual-basic/programming-guide/com-interop/codesnippet/VisualBasic/walkthrough-calling-windows-apis_3.vb)]</span><span class="sxs-lookup"><span data-stu-id="03ada-167">[!code-vb[VbVbalrInterop#12](../../../visual-basic/programming-guide/com-interop/codesnippet/VisualBasic/walkthrough-calling-windows-apis_3.vb)]</span></span>  
  
3.  <span data-ttu-id="03ada-168">F5 키를 눌러 프로젝트를 실행 합니다.</span><span class="sxs-lookup"><span data-stu-id="03ada-168">Run the project by pressing F5.</span></span> <span data-ttu-id="03ada-169">메시지 상자가 모두와 함께 표시 됩니다 **예** 및 **No** 응답 단추가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="03ada-169">The message box is displayed with both **Yes** and **No** response buttons.</span></span> <span data-ttu-id="03ada-170">중 하나를 클릭 합니다.</span><span class="sxs-lookup"><span data-stu-id="03ada-170">Click either one.</span></span>  
  
#### <a name="data-marshaling"></a><span data-ttu-id="03ada-171">데이터 마샬링</span><span class="sxs-lookup"><span data-stu-id="03ada-171">Data Marshaling</span></span>  
 [!INCLUDE[vbprvb](../../../csharp/programming-guide/concepts/linq/includes/vbprvb_md.md)]<span data-ttu-id="03ada-172">자동 변환 매개 변수 및 반환 값 수 있지만 Windows API 호출에 대 한 데이터 형식을 사용할 수는 `MarshalAs` 특성을 API에 필요한 관리 되지 않는 데이터 형식을 명시적으로 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="03ada-172"> automatically converts the data types of parameters and return values for Windows API calls, but you can use the `MarshalAs` attribute to explicitly specify unmanaged data types that an API expects.</span></span> <span data-ttu-id="03ada-173">Interop 마샬링 하는 방법에 대 한 자세한 내용은 참조 [Interop 마샬링](http://msdn.microsoft.com/library/115f7a2f-d422-4605-ab36-13a8dd28142a)합니다.</span><span class="sxs-lookup"><span data-stu-id="03ada-173">For more information about interop marshaling, see [Interop Marshaling](http://msdn.microsoft.com/library/115f7a2f-d422-4605-ab36-13a8dd28142a).</span></span>  
  
###### <a name="to-use-declare-and-marshalas-in-an-api-call"></a><span data-ttu-id="03ada-174">API 호출에 Declare 및 MarshalAs를 사용 하 여</span><span class="sxs-lookup"><span data-stu-id="03ada-174">To use Declare and MarshalAs in an API call</span></span>  
  
1.  <span data-ttu-id="03ada-175">해당 인수, 데이터 형식, 호출 하고자 하는 함수 이름을 확인 하 고 값을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="03ada-175">Determine the name of the function you want to call, plus its arguments, data types, and return value.</span></span>  
  
2.  <span data-ttu-id="03ada-176">에 대 한 액세스를 간소화 하는 `MarshalAs` 특성을 추가 `Imports` 클래스 또는 다음 예제와 같이 모듈에 대 한 코드의 맨 위에 문을:</span><span class="sxs-lookup"><span data-stu-id="03ada-176">To simplify access to the `MarshalAs` attribute, add an `Imports` statement to the top of the code for the class or module, as in the following example:</span></span>  
  
     <span data-ttu-id="03ada-177">[!code-vb[VbVbalrInterop #&13;](../../../visual-basic/programming-guide/com-interop/codesnippet/VisualBasic/walkthrough-calling-windows-apis_4.vb)]</span><span class="sxs-lookup"><span data-stu-id="03ada-177">[!code-vb[VbVbalrInterop#13](../../../visual-basic/programming-guide/com-interop/codesnippet/VisualBasic/walkthrough-calling-windows-apis_4.vb)]</span></span>  
  
3.  <span data-ttu-id="03ada-178">클래스 또는 모듈을 사용 하는 및 적용에 가져온된 함수에 대 한 함수 프로토타입을 추가 `MarshalAs` 특성을 매개 변수 또는 반환 값입니다.</span><span class="sxs-lookup"><span data-stu-id="03ada-178">Add a function prototype for the imported function to the class or module you are using, and apply the `MarshalAs` attribute to the parameters or return value.</span></span> <span data-ttu-id="03ada-179">다음 예제에서는 형식을 예상 하는 API 호출에서에서 `void*` 로 마샬링됩니다 `AsAny`:</span><span class="sxs-lookup"><span data-stu-id="03ada-179">In the following example, an API call that expects the type `void*` is marshaled as `AsAny`:</span></span>  
  
     <span data-ttu-id="03ada-180">[!code-vb[VbVbalrInterop #&14;](../../../visual-basic/programming-guide/com-interop/codesnippet/VisualBasic/walkthrough-calling-windows-apis_5.vb)]</span><span class="sxs-lookup"><span data-stu-id="03ada-180">[!code-vb[VbVbalrInterop#14](../../../visual-basic/programming-guide/com-interop/codesnippet/VisualBasic/walkthrough-calling-windows-apis_5.vb)]</span></span>  
  
## <a name="api-calls-using-dllimport"></a><span data-ttu-id="03ada-181">DllImport를 사용 하 여 API 호출</span><span class="sxs-lookup"><span data-stu-id="03ada-181">API Calls Using DllImport</span></span>  
 <span data-ttu-id="03ada-182">`DllImport` 특성은 형식 라이브러리 없이 Dll에서 함수를 호출 하는 두 번째 방법을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="03ada-182">The `DllImport` attribute provides a second way to call functions in DLLs without type libraries.</span></span> <span data-ttu-id="03ada-183">`DllImport`사용 하 여 거의 같습니다는 `Declare` 문은 함수를 호출 하는 방법을 보다 자세히 제어를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="03ada-183">`DllImport` is roughly equivalent to using a `Declare` statement but provides more control over how functions are called.</span></span>  
  
 <span data-ttu-id="03ada-184">사용할 수 있습니다 `DllImport` 대부분 Windows API와 공유를 호출은으로 호출 (라고도 *정적*) 메서드가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="03ada-184">You can use `DllImport` with most Windows API calls as long as the call refers to a shared (sometimes called *static*) method.</span></span> <span data-ttu-id="03ada-185">클래스의 인스턴스를 필요로 하는 메서드를 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="03ada-185">You cannot use methods that require an instance of a class.</span></span> <span data-ttu-id="03ada-186">와 달리 `Declare` 문, `DllImport` 호출을 사용할 수 없습니다는 `MarshalAs` 특성입니다.</span><span class="sxs-lookup"><span data-stu-id="03ada-186">Unlike `Declare` statements, `DllImport` calls cannot use the `MarshalAs` attribute.</span></span>  
  
#### <a name="to-call-a-windows-api-using-the-dllimport-attribute"></a><span data-ttu-id="03ada-187">DllImport 특성을 사용 하 여 Windows API를 호출 하려면</span><span class="sxs-lookup"><span data-stu-id="03ada-187">To call a Windows API using the DllImport attribute</span></span>  
  
1.  <span data-ttu-id="03ada-188">클릭 하 여 새 Windows 응용 프로그램 프로젝트를 열고 **새로** 에 **파일** 메뉴를 클릭 한 다음 **프로젝트**합니다.</span><span class="sxs-lookup"><span data-stu-id="03ada-188">Open a new Windows Application project by clicking **New** on the **File** menu, and then clicking **Project**.</span></span> <span data-ttu-id="03ada-189">**새 프로젝트** 대화 상자가 나타납니다.</span><span class="sxs-lookup"><span data-stu-id="03ada-189">The **New Project** dialog box appears.</span></span>  
  
2.  <span data-ttu-id="03ada-190">선택 **Windows 응용 프로그램** 목록에서 [!INCLUDE[vbprvb](../../../csharp/programming-guide/concepts/linq/includes/vbprvb_md.md)] 프로젝트 템플릿이 포함 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="03ada-190">Select **Windows Application** from the list of [!INCLUDE[vbprvb](../../../csharp/programming-guide/concepts/linq/includes/vbprvb_md.md)] project templates.</span></span> <span data-ttu-id="03ada-191">새 프로젝트가 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="03ada-191">The new project is displayed.</span></span>  
  
3.  <span data-ttu-id="03ada-192">이라는 단추를 추가 `Button2` 시작 폼입니다.</span><span class="sxs-lookup"><span data-stu-id="03ada-192">Add a button named `Button2` to the startup form.</span></span>  
  
4.  <span data-ttu-id="03ada-193">두 번 클릭 `Button2` 폼에 대 한 코드 보기를 엽니다.</span><span class="sxs-lookup"><span data-stu-id="03ada-193">Double-click `Button2` to open the code view for the form.</span></span>  
  
5.  <span data-ttu-id="03ada-194">에 대 한 액세스를 간소화 하기 위해 `DllImport`, 추가 된 `Imports` 시작 폼 클래스에 대 한 코드의 맨 위에 문을:</span><span class="sxs-lookup"><span data-stu-id="03ada-194">To simplify access to `DllImport`, add an `Imports` statement to the top of the code for the startup form class:</span></span>  
  
     <span data-ttu-id="03ada-195">[!code-vb[VbVbalrInterop #&13;](../../../visual-basic/programming-guide/com-interop/codesnippet/VisualBasic/walkthrough-calling-windows-apis_4.vb)]</span><span class="sxs-lookup"><span data-stu-id="03ada-195">[!code-vb[VbVbalrInterop#13](../../../visual-basic/programming-guide/com-interop/codesnippet/VisualBasic/walkthrough-calling-windows-apis_4.vb)]</span></span>  
  
6.  <span data-ttu-id="03ada-196">위의 빈 함수를 선언는 `End Class` 함수 이름을 확인 하 고 폼에 대 한 문을 `MoveFile`합니다.</span><span class="sxs-lookup"><span data-stu-id="03ada-196">Declare an empty function preceding the `End Class` statement for the form, and name the function `MoveFile`.</span></span>  
  
7.  <span data-ttu-id="03ada-197">적용 된 `Public` 및 `Shared` 함수 선언 및 매개 변수를 설정에 대 한 한정자 `MoveFile` Windows API 함수를 사용 하는 인수에 따라:</span><span class="sxs-lookup"><span data-stu-id="03ada-197">Apply the `Public` and `Shared` modifiers to the function declaration and set parameters for `MoveFile` based on the arguments the Windows API function uses:</span></span>  
  
     <span data-ttu-id="03ada-198">[!code-vb[VbVbalrInterop #&16;](../../../visual-basic/programming-guide/com-interop/codesnippet/VisualBasic/walkthrough-calling-windows-apis_6.vb)]</span><span class="sxs-lookup"><span data-stu-id="03ada-198">[!code-vb[VbVbalrInterop#16](../../../visual-basic/programming-guide/com-interop/codesnippet/VisualBasic/walkthrough-calling-windows-apis_6.vb)]</span></span>  
  
     <span data-ttu-id="03ada-199">함수 이름에는 제한이 유효한 프로시저; `DllImport` 특성 DLL의 이름을 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="03ada-199">Your function can have any valid procedure name; the `DllImport` attribute specifies the name in the DLL.</span></span> <span data-ttu-id="03ada-200">또한 상호 운용성 마샬링 매개 변수를 처리 및 반환 값, 데이터와 마찬가지로 Visual Studio 데이터 형식을 선택할 수 있는 형식과 API가 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="03ada-200">It also handles interoperability marshaling for the parameters and return values, so you can choose Visual Studio data types that are similar to the data types the API uses.</span></span>  
  
8.  <span data-ttu-id="03ada-201">적용 된 `DllImport` 특성을 빈 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="03ada-201">Apply the `DllImport` attribute to the empty function.</span></span> <span data-ttu-id="03ada-202">첫 번째 매개 변수는 이름과 호출 하는 함수를 포함 하는 DLL의 위치입니다.</span><span class="sxs-lookup"><span data-stu-id="03ada-202">The first parameter is the name and location of the DLL containing the function you are calling.</span></span> <span data-ttu-id="03ada-203">Windows 시스템 디렉터리에 있는 파일에 대 한 경로를 지정할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="03ada-203">You do not need to specify the path for files located in the Windows system directories.</span></span> <span data-ttu-id="03ada-204">두 번째 매개 변수는 Windows API에는 함수의 이름을 지정 하는 명명 된 인수입니다.</span><span class="sxs-lookup"><span data-stu-id="03ada-204">The second parameter is a named argument that specifies the name of the function in the Windows API.</span></span> <span data-ttu-id="03ada-205">이 예제는 `DllImport` 특성에 대 한 호출을 강제로 `MoveFile` 전달할 `MoveFileW` KERNEL32에서. DLL입니다.</span><span class="sxs-lookup"><span data-stu-id="03ada-205">In this example, the `DllImport` attribute forces calls to `MoveFile` to be forwarded to `MoveFileW` in KERNEL32.DLL.</span></span> <span data-ttu-id="03ada-206">`MoveFileW` 경로에서 파일을 복사 하는 메서드 `src` 경로에 `dst`합니다.</span><span class="sxs-lookup"><span data-stu-id="03ada-206">The `MoveFileW` method copies a file from the path `src` to the path `dst`.</span></span>  
  
     <span data-ttu-id="03ada-207">[!code-vb[VbVbalrInterop #&17;](../../../visual-basic/programming-guide/com-interop/codesnippet/VisualBasic/walkthrough-calling-windows-apis_7.vb)]</span><span class="sxs-lookup"><span data-stu-id="03ada-207">[!code-vb[VbVbalrInterop#17](../../../visual-basic/programming-guide/com-interop/codesnippet/VisualBasic/walkthrough-calling-windows-apis_7.vb)]</span></span>  
  
9. <span data-ttu-id="03ada-208">코드를 추가 하는 `Button2_Click` 이벤트 처리기 함수를 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="03ada-208">Add code to the `Button2_Click` event handler to call the function:</span></span>  
  
     <span data-ttu-id="03ada-209">[!code-vb[VbVbalrInterop #&18;](../../../visual-basic/programming-guide/com-interop/codesnippet/VisualBasic/walkthrough-calling-windows-apis_8.vb)]</span><span class="sxs-lookup"><span data-stu-id="03ada-209">[!code-vb[VbVbalrInterop#18](../../../visual-basic/programming-guide/com-interop/codesnippet/VisualBasic/walkthrough-calling-windows-apis_8.vb)]</span></span>  
  
10. <span data-ttu-id="03ada-210">Test.txt 파일을 만들고 하드 드라이브에 C:\Tmp 디렉터리에 배치 합니다.</span><span class="sxs-lookup"><span data-stu-id="03ada-210">Create a file named Test.txt and place it in the C:\Tmp directory on your hard drive.</span></span> <span data-ttu-id="03ada-211">필요한 경우 Tmp 디렉터리를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="03ada-211">Create the Tmp directory if necessary.</span></span>  
  
11. <span data-ttu-id="03ada-212">F5 키를 눌러 응용 프로그램을 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="03ada-212">Press F5 to start the application.</span></span> <span data-ttu-id="03ada-213">기본 폼이 나타납니다.</span><span class="sxs-lookup"><span data-stu-id="03ada-213">The main form appears.</span></span>  
  
12. <span data-ttu-id="03ada-214">클릭 **Button2**합니다.</span><span class="sxs-lookup"><span data-stu-id="03ada-214">Click **Button2**.</span></span> <span data-ttu-id="03ada-215">파일을 이동할 수 있는 경우 "파일이 성공적으로 이동" 메시지가 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="03ada-215">The message "The file was moved successfully" is displayed if the file can be moved.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="03ada-216">참고 항목</span><span class="sxs-lookup"><span data-stu-id="03ada-216">See Also</span></span>  
 <span data-ttu-id="03ada-217"><xref:System.Runtime.InteropServices.DllImportAttribute></xref:System.Runtime.InteropServices.DllImportAttribute></span><span class="sxs-lookup"><span data-stu-id="03ada-217"><xref:System.Runtime.InteropServices.DllImportAttribute></span></span>   
 <span data-ttu-id="03ada-218"><xref:System.Runtime.InteropServices.MarshalAsAttribute></xref:System.Runtime.InteropServices.MarshalAsAttribute></span><span class="sxs-lookup"><span data-stu-id="03ada-218"><xref:System.Runtime.InteropServices.MarshalAsAttribute></span></span>   
<span data-ttu-id="03ada-219"> [Declare 문](../../../visual-basic/language-reference/statements/declare-statement.md) </span><span class="sxs-lookup"><span data-stu-id="03ada-219"> [Declare Statement](../../../visual-basic/language-reference/statements/declare-statement.md) </span></span>  
<span data-ttu-id="03ada-220"> [자동](../../../visual-basic/language-reference/modifiers/auto.md) </span><span class="sxs-lookup"><span data-stu-id="03ada-220"> [Auto](../../../visual-basic/language-reference/modifiers/auto.md) </span></span>  
<span data-ttu-id="03ada-221"> [별칭](../../../visual-basic/language-reference/statements/alias-clause.md) </span><span class="sxs-lookup"><span data-stu-id="03ada-221"> [Alias](../../../visual-basic/language-reference/statements/alias-clause.md) </span></span>  
<span data-ttu-id="03ada-222"> [COM Interop](../../../visual-basic/programming-guide/com-interop/index.md) </span><span class="sxs-lookup"><span data-stu-id="03ada-222"> [COM Interop](../../../visual-basic/programming-guide/com-interop/index.md) </span></span>  
<span data-ttu-id="03ada-223"> [관리 코드에서 프로토타입 만들기](http://msdn.microsoft.com/library/ecdcf25d-cae3-4f07-a2b6-8397ac6dc42d) </span><span class="sxs-lookup"><span data-stu-id="03ada-223"> [Creating Prototypes in Managed Code](http://msdn.microsoft.com/library/ecdcf25d-cae3-4f07-a2b6-8397ac6dc42d) </span></span>  
<span data-ttu-id="03ada-224"> [콜백 메서드로 대리자 마샬링](http://msdn.microsoft.com/library/6ddd7866-9804-4571-84de-83f5cc017a5a)</span><span class="sxs-lookup"><span data-stu-id="03ada-224"> [Marshaling a Delegate as a Callback Method](http://msdn.microsoft.com/library/6ddd7866-9804-4571-84de-83f5cc017a5a)</span></span>

---
title: 서버를 사용 하지 않는 아키텍처 고려 사항-서버 리스 앱
description: 상태 관리 및 영구 저장소에서 크기 조정, 로깅, 추적 및 진단으로 서버 리스 응용 프로그램을 설계 하는 문제를 이해 합니다.
author: JEREMYLIKNESS
ms.author: jeliknes
ms.date: 06/26/2018
ms.openlocfilehash: c856683cf6910be98661e634246cd003b93a6d76
ms.sourcegitcommit: 4f4a32a5c16a75724920fa9627c59985c41e173c
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 10/17/2019
ms.locfileid: "72522435"
---
# <a name="serverless-architecture-considerations"></a><span data-ttu-id="4be1e-103">서버리스 아키텍처 고려 사항</span><span class="sxs-lookup"><span data-stu-id="4be1e-103">Serverless architecture considerations</span></span>

<span data-ttu-id="4be1e-104">서버를 사용 하지 않는 아키텍처를 채택 하면 특정 과제가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="4be1e-104">Adopting a serverless architecture does come with certain challenges.</span></span> <span data-ttu-id="4be1e-105">이 섹션에서는 알아야 할 몇 가지 일반적인 고려 사항을 살펴봅니다.</span><span class="sxs-lookup"><span data-stu-id="4be1e-105">This section explores some of the more common considerations to be aware of.</span></span> <span data-ttu-id="4be1e-106">이러한 모든 문제에는 솔루션이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4be1e-106">All of these challenges have solutions.</span></span> <span data-ttu-id="4be1e-107">모든 아키텍처를 선택 하는 것과 마찬가지로 서버를 사용 하지 않는 것은 장점 및 단점을 신중 하 게 고려한 후에만 수행 하도록 결정 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4be1e-107">As with all architecture choices, the decision to go serverless should be made only after carefully considering the pros and cons.</span></span> <span data-ttu-id="4be1e-108">응용 프로그램의 요구에 따라 서버 리스 구현이 특정 구성 요소에 적합 한 솔루션이 아님을 결정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4be1e-108">Depending on the needs of your application, you may decide a serverless implementation isn't the right solution for certain components.</span></span>

## <a name="managing-state"></a><span data-ttu-id="4be1e-109">상태 관리</span><span class="sxs-lookup"><span data-stu-id="4be1e-109">Managing state</span></span>

<span data-ttu-id="4be1e-110">일반적으로 마이크로 서비스와 마찬가지로 서버를 사용 하지 않는 함수는 기본적으로 상태 비저장입니다.</span><span class="sxs-lookup"><span data-stu-id="4be1e-110">Serverless functions, as with microservices in general, are stateless by default.</span></span> <span data-ttu-id="4be1e-111">상태를 방지 하면 서버 리스를 사용 하지 않도록 설정 하 고, 규모를 확장 하 고, 중앙의 실패 지점 없이 복원 력을 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4be1e-111">Avoiding state enables serverless to be ephemeral, to scale out, and to provide resiliency without a central point of failure.</span></span> <span data-ttu-id="4be1e-112">경우에 따라 비즈니스 프로세스에는 상태가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="4be1e-112">In some circumstances, business processes require state.</span></span> <span data-ttu-id="4be1e-113">프로세스에 상태가 필요한 경우 두 가지 옵션이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4be1e-113">If your process requires state, you have two options.</span></span> <span data-ttu-id="4be1e-114">서버를 사용 하지 않는 모델을 채택 하거나 상태를 제공 하는 별도의 서비스와 상호 작용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4be1e-114">You can adopt a model other than serverless, or interact with a separate service that provides state.</span></span> <span data-ttu-id="4be1e-115">상태를 추가 하면 솔루션이 복잡 해질 수 있으며 확장 하기가 더 어렵고 잠재적으로 단일 실패 지점이 생성 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4be1e-115">Adding state can complicate the solution and make it harder to scale, and potentially create a single point of failure.</span></span> <span data-ttu-id="4be1e-116">함수가 반드시 상태를 요구 하는지 신중 하 게 고려해 야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4be1e-116">Carefully consider whether your function absolutely requires state.</span></span> <span data-ttu-id="4be1e-117">대답이 "예" 인 경우 서버를 사용 하지 않는 상태로 구현 하는 것이 적절 한지 여부를 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="4be1e-117">If the answer is "yes," determine whether it still makes sense to implement it with serverless.</span></span>

<span data-ttu-id="4be1e-118">서버 리스의 이점을 손상 시 키 지 않고 상태를 채택 하는 여러 솔루션이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4be1e-118">There are several solutions to adopt state without compromising the benefits of serverless.</span></span> <span data-ttu-id="4be1e-119">가장 인기 있는 솔루션 중 일부는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="4be1e-119">Some of the more popular solutions include:</span></span>

- <span data-ttu-id="4be1e-120">Redis와 같은 임시 데이터 저장소 또는 분산 캐시를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="4be1e-120">Use a temporary data store or distributed cache, like Redis</span></span>
- <span data-ttu-id="4be1e-121">SQL 또는 CosmosDB와 같은 데이터베이스에 상태를 저장 합니다.</span><span class="sxs-lookup"><span data-stu-id="4be1e-121">Store state in a database, like SQL or CosmosDB</span></span>
- <span data-ttu-id="4be1e-122">지속형 함수와 같은 워크플로 엔진을 통해 상태를 처리 합니다.</span><span class="sxs-lookup"><span data-stu-id="4be1e-122">Handle state through a workflow engine like durable functions</span></span>

<span data-ttu-id="4be1e-123">아래 줄은 서버를 사용 하지 않는 상태로 구현 하려는 프로세스 내에서 상태 관리의 필요성에 대해 알고 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4be1e-123">The bottom line is that you should be aware of the need for any state management within processes you're considering to implement with serverless.</span></span>

## <a name="long-running-processes"></a><span data-ttu-id="4be1e-124">장기 실행 프로세스</span><span class="sxs-lookup"><span data-stu-id="4be1e-124">Long-running processes</span></span>

<span data-ttu-id="4be1e-125">서버를 사용 하지 않는 여러 가지 이점은 삭제 중인 프로세스를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="4be1e-125">Many benefits of serverless rely on the processes being ephemeral.</span></span> <span data-ttu-id="4be1e-126">짧은 실행 시간을 사용 하면 서버를 사용 하지 않는 공급자가 함수 종료와 호스트 간에 함수를 공유 하는 리소스를 더 쉽게 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4be1e-126">Short run times make it easier for the serverless provider to free up resources as functions end and share functions across hosts.</span></span> <span data-ttu-id="4be1e-127">대부분의 클라우드 공급자는 함수를 실행할 수 있는 총 시간을 10 분 정도 제한 합니다.</span><span class="sxs-lookup"><span data-stu-id="4be1e-127">Most cloud providers limit the total time your function can run to around 10 minutes.</span></span> <span data-ttu-id="4be1e-128">프로세스에 더 많은 시간이 걸릴 수 있는 경우 대체 구현을 고려할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4be1e-128">If your process may take longer, you might consider an alternative implementation.</span></span>

<span data-ttu-id="4be1e-129">몇 가지 예외와 솔루션이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4be1e-129">There are a few exceptions and solutions.</span></span> <span data-ttu-id="4be1e-130">한 가지 해결 방법은 프로세스를 개별적으로 실행 하는 데 걸리는 시간을 단축 하는 작은 구성 요소로 나누는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="4be1e-130">One solution may be to break your process into smaller components that individually take less time to run.</span></span> <span data-ttu-id="4be1e-131">종속성으로 인해 프로세스가 장시간 실행 되는 경우 지속형 함수와 같은 솔루션을 사용 하 여 비동기 워크플로를 고려할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4be1e-131">If your process runs long because of dependencies, you can also consider an asynchronous workflow using a solution like durable functions.</span></span> <span data-ttu-id="4be1e-132">지 속성 함수는 외부 프로세스가 완료 될 때까지 대기 하는 동안 프로세스의 상태를 일시 중지 하 고 유지 합니다.</span><span class="sxs-lookup"><span data-stu-id="4be1e-132">Durable functions pause and maintain the state of your process while it's waiting on an external process to finish.</span></span> <span data-ttu-id="4be1e-133">비동기 처리를 통해 실제 프로세스가 실행 되는 시간이 줄어듭니다.</span><span class="sxs-lookup"><span data-stu-id="4be1e-133">Asynchronous handling reduces the time the actual process runs.</span></span>

## <a name="startup-time"></a><span data-ttu-id="4be1e-134">시작 시간</span><span class="sxs-lookup"><span data-stu-id="4be1e-134">Startup time</span></span>

<span data-ttu-id="4be1e-135">서버를 사용 하지 않는 구현의 한 가지 잠재적인 문제는 시작 시간입니다.</span><span class="sxs-lookup"><span data-stu-id="4be1e-135">One potential concern with serverless implementations is startup time.</span></span> <span data-ttu-id="4be1e-136">리소스를 절약 하기 위해 서버를 사용 하지 않는 많은 공급자는 "주문형" 인프라를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="4be1e-136">To conserve resources, many serverless providers create infrastructure "on demand."</span></span> <span data-ttu-id="4be1e-137">서버를 사용 하지 않는 함수를 일정 시간 후에 트리거되면 함수를 호스트 하는 리소스를 만들거나 다시 시작 해야 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4be1e-137">When a serverless function is triggered after a period of time, the resources to host the function may need to be created or restarted.</span></span> <span data-ttu-id="4be1e-138">콜드 시작으로 인해 몇 초 정도 지연 될 수 있는 경우도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4be1e-138">In some situations, cold starts may result in delays of several seconds.</span></span> <span data-ttu-id="4be1e-139">시작 시간은 공급자와 서비스 수준에 따라 달라 집니다.</span><span class="sxs-lookup"><span data-stu-id="4be1e-139">Startup time varies across providers and service levels.</span></span> <span data-ttu-id="4be1e-140">응용 프로그램의 성공 여부를 최소화 하는 것이 중요 한 경우 시작 시간을 해결 하는 몇 가지 방법이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4be1e-140">There are a few approaches to address startup time if it's important to minimize for the success of the app.</span></span>

- <span data-ttu-id="4be1e-141">일부 공급자는 사용자가 인프라를 "항상 사용" 하도록 보장 하는 서비스 수준에 대해 지불할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4be1e-141">Some providers allow users to pay for service levels that guarantee infrastructure is "always on".</span></span>
- <span data-ttu-id="4be1e-142">연결 유지 메커니즘을 구현 합니다 (끝점을 ping 하 여 "활성" 상태로 유지).</span><span class="sxs-lookup"><span data-stu-id="4be1e-142">Implement a keep-alive mechanism (ping the endpoint to keep it "awake").</span></span>
- <span data-ttu-id="4be1e-143">컨테이너 화 된 함수를 사용 하 여 Kubernetes와 같은 오케스트레이션을 사용 합니다. 호스트는 이미 실행 되 고 있으므로 새 인스턴스를 빠르게 회전 합니다.</span><span class="sxs-lookup"><span data-stu-id="4be1e-143">Use orchestration like Kubernetes with a containerized function approach (the host is already running so spinning up new instances is extremely fast).</span></span>

## <a name="database-updates-and-migrations"></a><span data-ttu-id="4be1e-144">데이터베이스 업데이트 및 마이그레이션</span><span class="sxs-lookup"><span data-stu-id="4be1e-144">Database updates and migrations</span></span>

<span data-ttu-id="4be1e-145">서버를 사용 하지 않는 코드의 이점은 전체 응용 프로그램을 다시 배포 하지 않고도 새 함수를 해제할 수 있다는 점입니다.</span><span class="sxs-lookup"><span data-stu-id="4be1e-145">An advantage of serverless code is that you can release new functions without having to redeploy the entire application.</span></span> <span data-ttu-id="4be1e-146">이러한 이점은 관련 된 관계형 데이터베이스가 있는 경우에 단점이 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4be1e-146">This advantage can become a disadvantage when there's a relational database involved.</span></span> <span data-ttu-id="4be1e-147">데이터베이스 스키마에 대 한 변경 내용은 서버를 사용 하지 않는 업데이트와 동기화 하기 어렵습니다.</span><span class="sxs-lookup"><span data-stu-id="4be1e-147">Changes to database schemas are difficult to synchronize with serverless updates.</span></span> <span data-ttu-id="4be1e-148">문제가 발생 하 여 변경 내용을 롤백해야 하는 경우 추가 과제가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="4be1e-148">Additional challenges are posed when things go wrong and the changes must be rolled back.</span></span> <span data-ttu-id="4be1e-149">데이터 무결성은 마이크로 서비스 및 서버를 사용 하지 않는 함수에 대 한 모범 사례는 자신의 데이터를 소유 하는 한 가지 이유입니다.</span><span class="sxs-lookup"><span data-stu-id="4be1e-149">Data integrity is one reason that a best practice for microservices and serverless functions is that they own their own data.</span></span> <span data-ttu-id="4be1e-150">변경 내용을 계산 및 데이터의 단일 단위로 배포할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4be1e-150">It is possible to deploy changes as a single unit of compute and data.</span></span> <span data-ttu-id="4be1e-151">현실에서는 많은 레거시 시스템에서 서버를 사용 하지 않는 아키텍처와 조정 해야 하는 대량 백 엔드 데이터베이스를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4be1e-151">The reality is that many legacy systems feature a large back-end database that must be reconciled with the serverless architecture.</span></span>

<span data-ttu-id="4be1e-152">스키마 버전 관리를 해결 하는 일반적인 방법은 기존 속성 및 열을 수정 하지 않고 새 정보를 추가 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="4be1e-152">A popular approach to solve schema versioning is to never modify existing properties and columns, but instead add new information.</span></span> <span data-ttu-id="4be1e-153">예를 들어 작업 목록에 대 한 부울 "완료 됨" 플래그에서 "완료 된 날짜"로 이동 하기 위해 변경 내용을 고려 합니다.</span><span class="sxs-lookup"><span data-stu-id="4be1e-153">For example, consider a change to move from a Boolean "completed" flag for a todo list to a "completed date."</span></span> <span data-ttu-id="4be1e-154">이전 필드를 제거 하는 대신 데이터베이스 변경 작업은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="4be1e-154">Instead of removing the old field, the database change will:</span></span>

1. <span data-ttu-id="4be1e-155">새 "완료 된 날짜" 필드를 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="4be1e-155">Add a new "completed date" field.</span></span>
1. <span data-ttu-id="4be1e-156">"Completed" 부울 필드를 완료 된 날짜가 현재 날짜 이후 인지 여부를 평가 하는 계산 함수로 변환 합니다.</span><span class="sxs-lookup"><span data-stu-id="4be1e-156">Transform the "completed" Boolean field to a computed function that evaluates whether the completed date is after the current date.</span></span>
1. <span data-ttu-id="4be1e-157">완료 된 부울이 true로 설정 된 경우 완료 된 날짜를 현재 날짜로 설정 하는 트리거를 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="4be1e-157">Add a trigger to set the completed date to the current date when the completed Boolean is set to true.</span></span>

<span data-ttu-id="4be1e-158">새 서버를 사용 하지 않는 함수는 새 필드를 활용할 수 있지만 변경 시퀀스를 통해 레거시 코드는 "있는 그대로" 계속 실행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="4be1e-158">The sequence of changes ensures that legacy code continues to run "as is" while newer serverless functions can take advantage of the new field.</span></span>

<span data-ttu-id="4be1e-159">서버를 사용 하지 않는 아키텍처의 데이터에 대 한 자세한 내용은 [분산 데이터 관리를 위한 과제 및 해결 방법](../microservices/architect-microservice-container-applications/distributed-data-management.md)을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="4be1e-159">For more information about data in serverless architectures, see [Challenges and solutions for distributed data management](../microservices/architect-microservice-container-applications/distributed-data-management.md).</span></span>

## <a name="scaling"></a><span data-ttu-id="4be1e-160">배율 조정</span><span class="sxs-lookup"><span data-stu-id="4be1e-160">Scaling</span></span>

<span data-ttu-id="4be1e-161">서버를 사용 하지 않는 일반적인 오해 "서버 없음"을 의미 합니다.</span><span class="sxs-lookup"><span data-stu-id="4be1e-161">It's a common misconception that serverless means "no server."</span></span> <span data-ttu-id="4be1e-162">실제로 "서버 없음"입니다.</span><span class="sxs-lookup"><span data-stu-id="4be1e-162">It's in fact "less server."</span></span> <span data-ttu-id="4be1e-163">크기를 조정 해야 하는 경우를 이해 하는 것이 중요 합니다.</span><span class="sxs-lookup"><span data-stu-id="4be1e-163">The fact there is a backing infrastructure is important to understand when it comes to scaling.</span></span> <span data-ttu-id="4be1e-164">서버를 사용 하지 않는 대부분의 플랫폼에서는 이벤트 밀도가 증가할 때 인프라의 크기를 조정 하는 방법을 처리 하는 컨트롤 집합을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="4be1e-164">Most serverless platforms provide a set of controls to handle how the infrastructure should scale when event density increases.</span></span> <span data-ttu-id="4be1e-165">다양 한 옵션 중에서 선택할 수 있지만 전략은 함수에 따라 달라질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4be1e-165">You can choose from a variety of options, but your strategy may vary depending on the function.</span></span> <span data-ttu-id="4be1e-166">또한 함수는 일반적으로 관련 호스트에서 실행 되므로 동일한 호스트의 함수는 동일한 크기 조정 옵션을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4be1e-166">Furthermore, functions are typically run under a related host, so that functions on the same host have the same scale options.</span></span> <span data-ttu-id="4be1e-167">따라서 크기 조정 요구 사항에 따라 함께 호스트 되는 함수를 구성 하 고 세우고 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4be1e-167">Therefore it is necessary to organize and strategize which functions are hosted together based on scale requirements.</span></span>

<span data-ttu-id="4be1e-168">규칙은 다양 한 매개 변수에 따라 확장 (호스트 리소스 증가) 및 확장 (호스트 인스턴스 수 증가)을 지정 하는 방법을 지정 하는 경우가 많습니다.</span><span class="sxs-lookup"><span data-stu-id="4be1e-168">Rules often specify how to scale-up (increase the host resources) and scale-out (increase the number of host instances) based on varying parameters.</span></span> <span data-ttu-id="4be1e-169">크기 조정에 대 한 트리거는 일정, 요청 속도, CPU 사용률 및 메모리 사용을 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4be1e-169">Triggers for scales may include schedule, request rates, CPU utilization, and memory usage.</span></span> <span data-ttu-id="4be1e-170">성능이 높을수록 비용이 더 많이 듭니다.</span><span class="sxs-lookup"><span data-stu-id="4be1e-170">Higher performance often comes at a greater cost.</span></span> <span data-ttu-id="4be1e-171">저렴 하 고 소비 기반 접근 방식은 요청 속도가 갑자기 증가 하는 경우 신속 하 게 확장 되지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4be1e-171">The less expensive, consumption-based approaches may not scale as quickly when the request rate suddenly increases.</span></span> <span data-ttu-id="4be1e-172">"보험 비용"을 지불 하는 것과 ' 지불 비용 '을 엄격히 절충 하는 것과 갑작스러운 수요 급증으로 인해 응답 속도가 느려질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4be1e-172">There is a trade-off between paying up front "insurance cost" versus paying strictly "as you go" and risking slower responses due to sudden increases in demand.</span></span>

## <a name="monitoring-tracing-and-logging"></a><span data-ttu-id="4be1e-173">모니터링, 추적 및 로깅</span><span class="sxs-lookup"><span data-stu-id="4be1e-173">Monitoring, tracing, and logging</span></span>

<span data-ttu-id="4be1e-174">DevOps의 종종 간과 되는 측면은 배포 된 응용 프로그램을 모니터링 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="4be1e-174">An often overlooked aspect of DevOps is monitoring applications once deployed.</span></span> <span data-ttu-id="4be1e-175">서버를 사용 하지 않는 함수를 모니터링 하기 위한 전략을 수립 하는 것이 중요 합니다.</span><span class="sxs-lookup"><span data-stu-id="4be1e-175">It's important to have a strategy for monitoring serverless functions.</span></span> <span data-ttu-id="4be1e-176">가장 큰 문제는 종종 상관 관계 이거나 사용자가 동일한 상호 작용의 일부로 여러 함수를 호출 하는 경우를 인식 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="4be1e-176">The biggest challenge is often correlation, or recognizing when a user calls multiple functions as part of the same interaction.</span></span> <span data-ttu-id="4be1e-177">서버를 사용 하지 않는 대부분의 플랫폼에서는 타사 도구로 가져올 수 있는 콘솔 로깅을 허용 합니다.</span><span class="sxs-lookup"><span data-stu-id="4be1e-177">Most serverless platforms allow console logging that can be imported into third-party tools.</span></span> <span data-ttu-id="4be1e-178">원격 분석 컬렉션을 자동화 하 고 상관 관계 Id를 생성 및 추적 하 고 특정 작업을 모니터링 하 여 자세한 정보를 제공 하는 옵션도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4be1e-178">There are also options to automate collection of telemetry, generate and track correlation IDs, and monitor specific actions to provide detailed insights.</span></span> <span data-ttu-id="4be1e-179">Azure는 모니터링 및 분석을 위한 고급 [Application Insights 플랫폼](https://docs.microsoft.com/azure/azure-functions/functions-monitoring) 을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="4be1e-179">Azure provides the advanced [Application Insights platform](https://docs.microsoft.com/azure/azure-functions/functions-monitoring) for monitoring and analytics.</span></span>

## <a name="inter-service-dependencies"></a><span data-ttu-id="4be1e-180">서비스 간 종속성</span><span class="sxs-lookup"><span data-stu-id="4be1e-180">Inter-service dependencies</span></span>

<span data-ttu-id="4be1e-181">서버를 사용 하지 않는 아키텍처에는 다른 함수를 사용 하는 함수가 포함 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4be1e-181">A serverless architecture may include functions that rely on other functions.</span></span> <span data-ttu-id="4be1e-182">실제로 여러 서비스가 상호 작용 또는 분산 트랜잭션의 일부로 서로 호출 하는 서버를 사용 하지 않는 아키텍처에서는 일반적이 지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="4be1e-182">In fact, it isn't uncommon in a serverless architecture to have multiple services call each other as part of an interaction or distributed transaction.</span></span> <span data-ttu-id="4be1e-183">강력한 결합을 방지 하려면 서비스에서 서로를 직접 참조 하지 않는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="4be1e-183">To avoid strong coupling, it's recommended that services don't reference each other directly.</span></span> <span data-ttu-id="4be1e-184">서비스의 끝점을 변경 해야 하는 경우 직접 참조로 인해 주요 리팩터링이 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4be1e-184">When the endpoint for a service needs to change, direct references could result in major refactoring.</span></span> <span data-ttu-id="4be1e-185">권장 되는 해결 방법은 요청 유형에 적합 한 끝점을 제공 하는 서비스 검색 메커니즘 (예: 레지스트리)을 제공 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="4be1e-185">A suggested solution is to provide a service discovery mechanism, such as a registry, that provides the appropriate end point for a request type.</span></span> <span data-ttu-id="4be1e-186">또 다른 해결 방법은 서비스 간 통신에 큐 또는 항목과 같은 메시징 서비스를 활용 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="4be1e-186">Another solution is to leverage messaging services like queues or topics for communication between services.</span></span>

## <a name="managing-failure-and-providing-resiliency"></a><span data-ttu-id="4be1e-187">오류 관리 및 복원 력 제공</span><span class="sxs-lookup"><span data-stu-id="4be1e-187">Managing failure and providing resiliency</span></span>

<span data-ttu-id="4be1e-188">*회로 차단기 패턴*을 고려해 야 합니다. 어떤 이유로 서비스가 계속 실패 하는 경우에는 해당 서비스를 반복 해 서 호출 하지 않는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="4be1e-188">It's also important to consider the *circuit-breaker pattern*: If, for some reason, a service continues to fail, it isn't advisable to call that service repeatedly.</span></span> <span data-ttu-id="4be1e-189">대신, 대체 서비스를 호출 하거나 종속 서비스의 상태가 다시 설정 될 때까지 메시지를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="4be1e-189">Instead, an alternative service is called or a message returned until the health of the dependent service is re-established.</span></span> <span data-ttu-id="4be1e-190">서버를 사용 하지 않는 아키텍처는 서비스 간 종속성을 확인 하 고 관리 하기 위한 전략을 고려해 야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4be1e-190">The serverless architecture needs to take into account the strategy for resolving and managing inter-service dependencies.</span></span>

<span data-ttu-id="4be1e-191">회로 차단기 패턴을 계속 하려면 서비스에 내결함성 및 복원 력이 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4be1e-191">To continue the circuit-breaker pattern, services need to be fault tolerant and resilient.</span></span> <span data-ttu-id="4be1e-192">내결함성은 예기치 않은 예외 또는 잘못 된 상태 발생 후에도 응용 프로그램을 계속 실행 하는 기능을 의미 합니다.</span><span class="sxs-lookup"><span data-stu-id="4be1e-192">Fault tolerance refers to the ability of your application to continue running even after unexpected exceptions or invalid states are encountered.</span></span> <span data-ttu-id="4be1e-193">내결함성은 일반적으로 코드 자체의 기능이 며 예외를 처리 하기 위해 작성 되는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="4be1e-193">Fault tolerance is typically a function of the code itself and how it's written to handle exceptions.</span></span> <span data-ttu-id="4be1e-194">복원 력은 응용 프로그램에서 오류를 복구할 수 있는 방법을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="4be1e-194">Resiliency refers to how capable the app is at recovering from failures.</span></span> <span data-ttu-id="4be1e-195">복원 력은 종종 서버를 사용 하지 않는 플랫폼에서 관리 됩니다.</span><span class="sxs-lookup"><span data-stu-id="4be1e-195">Resiliency is often managed by the serverless platform.</span></span> <span data-ttu-id="4be1e-196">플랫폼은 기존 서버를 사용 하지 않을 때 새 서버를 사용 하지 않는 함수 인스턴스를 실행할 수 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4be1e-196">The platform should be able to spin up a new serverless function instance when the existing one fails.</span></span> <span data-ttu-id="4be1e-197">또한 플랫폼은 모든 새 인스턴스가 실패할 때 새 인스턴스를 중지 하기에 충분히 지능적 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4be1e-197">The platform should also be intelligent enough to stop spinning up new instances when every new instance fails.</span></span>

<span data-ttu-id="4be1e-198">자세한 내용은 [회로 차단기 패턴 구현](../microservices/implement-resilient-applications/implement-circuit-breaker-pattern.md)을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="4be1e-198">For more information, see [Implementing the Circuit Breaker pattern](../microservices/implement-resilient-applications/implement-circuit-breaker-pattern.md).</span></span>

## <a name="versioning-and-greenblue-deployments"></a><span data-ttu-id="4be1e-199">버전 관리 및 녹색/파랑 배포</span><span class="sxs-lookup"><span data-stu-id="4be1e-199">Versioning and green/blue deployments</span></span>

<span data-ttu-id="4be1e-200">서버를 사용 하지 않는 주요 혜택은 전체 응용 프로그램을 다시 배포할 필요 없이 특정 기능을 업그레이드 하는 기능입니다.</span><span class="sxs-lookup"><span data-stu-id="4be1e-200">A major benefit of serverless is the ability to upgrade a specific function without having to redeploy the entire application.</span></span> <span data-ttu-id="4be1e-201">업그레이드에 성공 하려면 함수를 호출 하는 서비스가 올바른 버전의 코드로 라우팅되도록 함수를 버전 관리 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4be1e-201">For upgrades to be successful, functions must be versioned so that services calling them are routed to the correct version of code.</span></span> <span data-ttu-id="4be1e-202">새 버전을 배포 하는 전략도 중요 합니다.</span><span class="sxs-lookup"><span data-stu-id="4be1e-202">A strategy for deploying new versions is also important.</span></span> <span data-ttu-id="4be1e-203">일반적인 방법은 "녹색/파랑 배포"를 사용 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="4be1e-203">A common approach is to use "green/blue deployments."</span></span> <span data-ttu-id="4be1e-204">녹색 배포는 현재 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="4be1e-204">The green deployment is the current function.</span></span> <span data-ttu-id="4be1e-205">새 "blue" 버전이 프로덕션에 배포 되 고 테스트 됩니다.</span><span class="sxs-lookup"><span data-stu-id="4be1e-205">A new "blue" version is deployed to production and tested.</span></span> <span data-ttu-id="4be1e-206">테스트를 통과 하면 녹색 및 파란색 버전이 교체 되어 새 버전이 라이브 상태가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="4be1e-206">When testing passes, the green and blue versions are swapped so the new version comes live.</span></span> <span data-ttu-id="4be1e-207">문제가 발생 하는 경우 다시 바꿀 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4be1e-207">If any issues are encountered, they can be swapped back.</span></span> <span data-ttu-id="4be1e-208">버전 관리 및 녹색/파랑 배포를 지원 하려면 버전 변경을 수용 하 고 서버를 사용 하지 않는 플랫폼을 사용 하 여 배포를 처리 하는 함수를 작성 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4be1e-208">Supporting versioning and green/blue deployments requires a combination of authoring the functions to accommodate version changes and working with the serverless platform to handle deployments.</span></span> <span data-ttu-id="4be1e-209">가능한 한 가지 방법은 [Azure 서버](azure-functions.md#proxies) 를 사용 하지 않는 플랫폼 챕터에 설명 된 프록시를 사용 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="4be1e-209">One possible approach is to use proxies, which are described in the [Azure serverless platform](azure-functions.md#proxies) chapter.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="4be1e-210">[이전](serverless-architecture.md)
>[다음](serverless-design-examples.md)</span><span class="sxs-lookup"><span data-stu-id="4be1e-210">[Previous](serverless-architecture.md)
[Next](serverless-design-examples.md)</span></span>

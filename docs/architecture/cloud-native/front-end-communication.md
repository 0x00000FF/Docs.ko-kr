---
title: 프런트 엔드 클라이언트 통신
description: 프런트 엔드 클라이언트가 클라우드 네이티브 시스템과 통신하는 방법 알아보기
author: robvet
ms.date: 09/08/2019
ms.openlocfilehash: af26873381509df7807db6ecb37a7d73669adb37
ms.sourcegitcommit: e3cbf26d67f7e9286c7108a2752804050762d02d
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 04/09/2020
ms.locfileid: "80989079"
---
# <a name="front-end-client-communication"></a><span data-ttu-id="1f938-103">프런트 엔드 클라이언트 통신</span><span class="sxs-lookup"><span data-stu-id="1f938-103">Front-end client communication</span></span>

[!INCLUDE [book-preview](../../../includes/book-preview.md)]

<span data-ttu-id="1f938-104">클라우드 네이티브 시스템에서 프런트 엔드 클라이언트(모바일, 웹 및 데스크톱 응용 프로그램)는 독립적인 백 엔드 마이크로 서비스와 상호 작용하기 위해 통신 채널이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-104">In a cloud-native system, front-end clients (mobile, web, and desktop applications) require a communication channel to interact with independent back-end microservices.</span></span>  

<span data-ttu-id="1f938-105">옵션은 무엇입니까?</span><span class="sxs-lookup"><span data-stu-id="1f938-105">What are the options?</span></span>

<span data-ttu-id="1f938-106">간단하게 하기 위해 프런트 엔드 클라이언트는 그림 4-2에 표시된 백 엔드 마이크로 서비스와 *직접 통신할* 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-106">To keep things simple, a front-end client could *directly communicate* with the back-end microservices, shown in Figure 4-2.</span></span>

![클라이언트를 서비스 통신으로 유도](./media/direct-client-to-service-communication.png)

<span data-ttu-id="1f938-108">**그림 4-2.**</span><span class="sxs-lookup"><span data-stu-id="1f938-108">**Figure 4-2.**</span></span> <span data-ttu-id="1f938-109">클라이언트를 서비스 통신으로 유도</span><span class="sxs-lookup"><span data-stu-id="1f938-109">Direct client to service communication</span></span>

<span data-ttu-id="1f938-110">이 방법을 사용하면 각 마이크로 서비스에프런트 엔드 클라이언트가 액세스할 수 있는 공용 끝점이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-110">With this approach, each microservice has a public endpoint that is accessible by front-end clients.</span></span> <span data-ttu-id="1f938-111">프로덕션 환경에서는 트래픽을 비례적으로 라우팅하여 마이크로 서비스 앞에 로드 밸러블러를 배치해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-111">In a production environment, you'd place a load balancer in front of the microservices, routing traffic proportionately.</span></span>

<span data-ttu-id="1f938-112">구현은 간단하지만 직접 클라이언트 통신은 간단한 마이크로 서비스 응용 프로그램에서만 허용됩니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-112">While simple to implement, direct client communication would be acceptable only for simple microservice applications.</span></span> <span data-ttu-id="1f938-113">이 패턴은 프론트 엔드 클라이언트를 핵심 백 엔드 서비스와 긴밀하게 결합하여 다음과 같은 여러 가지 문제에 대한 문을 열어 주며 다음과 같은 여러 가지 문제에 대한 문을 열어 주며 다음과 같은 문제를 해결합니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-113">This pattern tightly couples front-end clients to core back-end services, opening the door for a number of problems, including:</span></span>

- <span data-ttu-id="1f938-114">백 엔드 서비스 리팩터링에 대한 클라이언트 감수성.</span><span class="sxs-lookup"><span data-stu-id="1f938-114">Client susceptibility to back-end service refactoring.</span></span>
- <span data-ttu-id="1f938-115">코어 백 엔드 서비스가 직접 노출됨에 따라 공격 표면이 넓어집니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-115">A wider attack surface as core back-end services are directly exposed.</span></span>
- <span data-ttu-id="1f938-116">각 마이크로 서비스 전반에 걸친 교차 절단 문제의 중복.</span><span class="sxs-lookup"><span data-stu-id="1f938-116">Duplication of cross-cutting concerns across each microservice.</span></span>
- <span data-ttu-id="1f938-117">지나치게 복잡한 클라이언트 코드 - 클라이언트는 여러 끝점을 추적하고 복원력 있는 방식으로 오류를 처리해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-117">Overly complex client code - clients must keep track of multiple endpoints and handle failures in a resilient way.</span></span>

<span data-ttu-id="1f938-118">대신 널리 사용되는 클라우드 디자인 패턴은 프런트 엔드 응용 프로그램과 백 엔드 서비스 간에 [API 게이트웨이](../microservices/architect-microservice-container-applications/direct-client-to-microservice-communication-versus-the-api-gateway-pattern.md) 서비스를 구현하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-118">Instead, a widely accepted cloud design pattern is to implement an [API Gateway Service](../microservices/architect-microservice-container-applications/direct-client-to-microservice-communication-versus-the-api-gateway-pattern.md) between the front-end applications and back-end services.</span></span> <span data-ttu-id="1f938-119">패턴은 도 4-3에 도시되어 있다.</span><span class="sxs-lookup"><span data-stu-id="1f938-119">The pattern is shown in Figure 4-3.</span></span>

![API 게이트웨이 패턴](./media/api-gateway-pattern.png)

<span data-ttu-id="1f938-121">**그림 4-3.**</span><span class="sxs-lookup"><span data-stu-id="1f938-121">**Figure 4-3.**</span></span> <span data-ttu-id="1f938-122">API 게이트웨이 패턴</span><span class="sxs-lookup"><span data-stu-id="1f938-122">API gateway pattern</span></span>

<span data-ttu-id="1f938-123">이전 그림에서는 API 게이트웨이 서비스가 백 엔드 코어 마이크로 서비스를 추상화하는 방법을 알아두습니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-123">In the previous figure, note how the API Gateway service abstracts the back-end core microservices.</span></span> <span data-ttu-id="1f938-124">웹 API로 구현되는 이 프록시는 *역방향 프록시*역할을 하며 들어오는 트래픽을 내부 마이크로 서비스로 라우팅합니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-124">Implemented as a web API, it acts as a *reverse proxy*, routing incoming traffic to the internal microservices.</span></span>

<span data-ttu-id="1f938-125">게이트웨이는 클라이언트를 내부 서비스 분할 및 리팩터링으로부터 격리합니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-125">The gateway insulates the client from internal service partitioning and refactoring.</span></span> <span data-ttu-id="1f938-126">백 엔드 서비스를 변경하는 경우 클라이언트를 손상시키지 않고 게이트웨이에서 서비스를 수용합니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-126">If you change a back-end service, you accommodate for it in the gateway without breaking the client.</span></span> <span data-ttu-id="1f938-127">또한 ID, 캐싱, 복원력, 계량 및 제한과 같은 교차 절단 문제에 대한 첫 번째 방어선이기도 합니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-127">It's also your first line of defense for cross-cutting concerns, such as identity, caching, resiliency, metering, and throttling.</span></span> <span data-ttu-id="1f938-128">이러한 교차 절단 문제 중 대부분은 백 엔드 코어 서비스에서 게이트웨이로 오프로드되어 백 엔드 서비스를 단순화할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-128">Many of these cross-cutting concerns can be off-loaded from the back-end core services to the gateway, simplifying the back-end services.</span></span>

<span data-ttu-id="1f938-129">API 게이트웨이를 간단하고 빠르게 유지하려면 주의해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-129">Care must be taken to keep the API Gateway simple and fast.</span></span> <span data-ttu-id="1f938-130">일반적으로 비즈니스 논리는 게이트웨이에서 유지됩니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-130">Typically, business logic is kept out of the gateway.</span></span> <span data-ttu-id="1f938-131">복잡한 게이트웨이는 병목 현상이 되고 결국에는 모놀리스 자체가 될 위험이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-131">A complex gateway risks becoming a bottleneck and eventually a monolith itself.</span></span> <span data-ttu-id="1f938-132">대규모 시스템에서는 클라이언트 유형(모바일, 웹, 데스크톱) 또는 백 엔드 기능별로 분할된 여러 API 게이트웨이가 노출되는 경우가 많습니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-132">Larger systems often expose multiple API Gateways segmented by client type (mobile, web, desktop) or back-end functionality.</span></span> <span data-ttu-id="1f938-133">[프런트 엔드용 백 엔드](https://docs.microsoft.com/azure/architecture/patterns/backends-for-frontends) 패턴은 여러 게이트웨이를 구현하기 위한 방향을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-133">The [Backend for Frontends](https://docs.microsoft.com/azure/architecture/patterns/backends-for-frontends) pattern provides direction for implementing multiple gateways.</span></span> <span data-ttu-id="1f938-134">패턴은 도 4-4에 도시되어 있다.</span><span class="sxs-lookup"><span data-stu-id="1f938-134">The pattern is shown in Figure 4-4.</span></span>

![API 게이트웨이 패턴](./media/backend-for-frontend-pattern.png)

<span data-ttu-id="1f938-136">**그림 4-4.**</span><span class="sxs-lookup"><span data-stu-id="1f938-136">**Figure 4-4.**</span></span> <span data-ttu-id="1f938-137">프런트 엔드 패턴용 백엔드</span><span class="sxs-lookup"><span data-stu-id="1f938-137">Backend for frontend pattern</span></span>

<span data-ttu-id="1f938-138">이전 그림에서는 클라이언트 유형(웹, 모바일 또는 데스크톱 앱)에 따라 들어오는 트래픽이 특정 API 게이트웨이로 전송되는 방법을 참고합니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-138">Note in the previous figure how incoming traffic is sent to a specific API gateway - based upon client type: web, mobile, or desktop app.</span></span> <span data-ttu-id="1f938-139">이 방법은 폼 팩터, 성능 및 디스플레이 제한에 따라 각 장치의 기능이 크게 다르기 때문에 의미가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-139">This approach makes sense as the capabilities of each device differ significantly across form factor, performance, and display limitations.</span></span> <span data-ttu-id="1f938-140">일반적으로 모바일 응용 프로그램은 브라우저 또는 데스크톱 응용 프로그램보다 기능이 적습니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-140">Typically mobile applications expose less functionality than a browser or desktop applications.</span></span> <span data-ttu-id="1f938-141">각 게이트웨이는 해당 장치의 기능 및 기능에 맞게 최적화할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-141">Each gateway can be optimized to match the capabilities and functionality of the corresponding device.</span></span>

<span data-ttu-id="1f938-142">시작하려면 자체 API 게이트웨이 서비스를 빌드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-142">To start, you could build your own API Gateway service.</span></span> <span data-ttu-id="1f938-143">GitHub의 빠른 검색은 많은 예제를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-143">A quick search of GitHub will provide many examples.</span></span> <span data-ttu-id="1f938-144">그러나 여러 프레임워크와 상용 게이트웨이 제품을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-144">However, there are several frameworks and commercial gateway products available.</span></span>

## <a name="ocelot-gateway"></a><span data-ttu-id="1f938-145">오셀롯 게이트웨이</span><span class="sxs-lookup"><span data-stu-id="1f938-145">Ocelot Gateway</span></span>

<span data-ttu-id="1f938-146">간단한 .NET 클라우드 네이티브 응용 프로그램의 경우 [Ocelot 게이트웨이를](https://github.com/ThreeMammals/Ocelot)고려할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-146">For simple .NET cloud-native applications, you might consider the [Ocelot Gateway](https://github.com/ThreeMammals/Ocelot).</span></span> <span data-ttu-id="1f938-147">Ocelot는 .NET 마이크로 서비스에 대해 생성된 오픈 소스 API 게이트웨이로, 시스템에 통합된 진입점이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-147">Ocelot is an Open Source API Gateway created for .NET microservices that require a unified point of entry into their system.</span></span> <span data-ttu-id="1f938-148">가볍고 빠르며 확장성이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-148">It's lightweight, fast, scalable.</span></span>

<span data-ttu-id="1f938-149">다른 API 게이트웨이와 마찬가지로 주요 기능은 들어오는 HTTP 요청을 다운스트림 서비스로 전달하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-149">Like any API Gateway, its primary functionality is to forward incoming HTTP requests to downstream services.</span></span> <span data-ttu-id="1f938-150">또한 .NET Core 미들웨어 파이프라인에서 구성할 수 있는 다양한 기능을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-150">Additionally, it supports a wide variety of capabilities that are configurable in a .NET Core middleware pipeline.</span></span> <span data-ttu-id="1f938-151">해당 기능 집합은 다음 표에 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-151">Its feature set is presented in following table.</span></span>

|<span data-ttu-id="1f938-152">오셀롯 특징</span><span class="sxs-lookup"><span data-stu-id="1f938-152">Ocelot Features</span></span>  | |
| :-------- | :-------- |
| <span data-ttu-id="1f938-153">라우팅</span><span class="sxs-lookup"><span data-stu-id="1f938-153">Routing</span></span> | <span data-ttu-id="1f938-154">인증</span><span class="sxs-lookup"><span data-stu-id="1f938-154">Authentication</span></span> |
| <span data-ttu-id="1f938-155">요청 집계</span><span class="sxs-lookup"><span data-stu-id="1f938-155">Request Aggregation</span></span> | <span data-ttu-id="1f938-156">권한 부여</span><span class="sxs-lookup"><span data-stu-id="1f938-156">Authorization</span></span> |
| <span data-ttu-id="1f938-157">서비스 디스커버리(영사 및 유레카)</span><span class="sxs-lookup"><span data-stu-id="1f938-157">Service Discovery (with Consul and Eureka)</span></span> | <span data-ttu-id="1f938-158">제한</span><span class="sxs-lookup"><span data-stu-id="1f938-158">Throttling</span></span> |
| <span data-ttu-id="1f938-159">부하 분산</span><span class="sxs-lookup"><span data-stu-id="1f938-159">Load Balancing</span></span> | <span data-ttu-id="1f938-160">로깅, 추적</span><span class="sxs-lookup"><span data-stu-id="1f938-160">Logging, Tracing</span></span> |
| <span data-ttu-id="1f938-161">캐싱</span><span class="sxs-lookup"><span data-stu-id="1f938-161">Caching</span></span> | <span data-ttu-id="1f938-162">헤더/쿼리 문자열 변환</span><span class="sxs-lookup"><span data-stu-id="1f938-162">Headers/Query String Transformation</span></span> |
| <span data-ttu-id="1f938-163">상관 관계 통과</span><span class="sxs-lookup"><span data-stu-id="1f938-163">Correlation Pass-Through</span></span> | <span data-ttu-id="1f938-164">사용자 정의 미들웨어</span><span class="sxs-lookup"><span data-stu-id="1f938-164">Custom Middleware</span></span> |
| <span data-ttu-id="1f938-165">서비스 품질</span><span class="sxs-lookup"><span data-stu-id="1f938-165">Quality of Service</span></span> | <span data-ttu-id="1f938-166">다시 시도 정책</span><span class="sxs-lookup"><span data-stu-id="1f938-166">Retry Policies</span></span> |

<span data-ttu-id="1f938-167">각 Ocelot 게이트웨이는 JSON 구성 파일에서 업스트림 및 다운스트림 주소와 구성 가능한 기능을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-167">Each Ocelot gateway specifies the upstream and downstream addresses and configurable features in a JSON configuration file.</span></span> <span data-ttu-id="1f938-168">클라이언트는 Ocelot 게이트웨이에 HTTP 요청을 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-168">The client sends an HTTP request to the Ocelot gateway.</span></span> <span data-ttu-id="1f938-169">수신되면 Ocelot는 해당 파이프라인을 통해 HttpRequest 개체를 구성에 의해 지정된 상태로 조작합니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-169">Once received, Ocelot passes the HttpRequest object through its pipeline manipulating it into the state specified by its configuration.</span></span> <span data-ttu-id="1f938-170">파이프라인이 끝나면 Ocelot는 새 HTTPResponseObject를 만들고 다운스트림 서비스에 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-170">At the end of pipeline, Ocelot creates a new HTTPResponseObject and passes it to the downstream service.</span></span> <span data-ttu-id="1f938-171">응답의 경우 Ocelot는 파이프라인을 반대로 하여 응답을 클라이언트로 다시 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-171">For the response, Ocelot reverses the pipeline, sending the response back to client.</span></span>

<span data-ttu-id="1f938-172">오셀롯은 NuGet 패키지로 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-172">Ocelot is available as a NuGet package.</span></span> <span data-ttu-id="1f938-173">NET 표준 2.0을 대상으로 하여 .NET Core 2.0+ 및 .NET Framework 4.6.1+ 런타임과 호환됩니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-173">It targets the NET Standard 2.0, making it compatible with both .NET Core 2.0+ and .NET Framework 4.6.1+ runtimes.</span></span> <span data-ttu-id="1f938-174">OcelotHTTP를 말하는 모든 것과 통합 하 고 .NET 코어 지원 하는 플랫폼에서 실행: 리눅스, 맥 OS, 그리고 윈도우.</span><span class="sxs-lookup"><span data-stu-id="1f938-174">Ocelot integrates with anything that speaks HTTP and runs on the platforms which .NET Core supports: Linux, macOS, and Windows.</span></span> <span data-ttu-id="1f938-175">Ocelot은 확장 가능하며 Docker 컨테이너, Azure Kubernetes 서비스 또는 기타 퍼블릭 클라우드를 비롯한 많은 최신 플랫폼을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-175">Ocelot is extensible and supports many modern platforms, including Docker containers, Azure Kubernetes Services, or other public clouds.</span></span>  <span data-ttu-id="1f938-176">오셀롯은 [영사,](https://www.consul.io) [GraphQL,](https://graphql.org)넷플릭스의 [유레카](https://github.com/Netflix/eureka)와 같은 오픈 소스 패키지와 통합된다.</span><span class="sxs-lookup"><span data-stu-id="1f938-176">Ocelot integrates with open-source packages like [Consul](https://www.consul.io), [GraphQL](https://graphql.org), and Netflix's [Eureka](https://github.com/Netflix/eureka).</span></span>

<span data-ttu-id="1f938-177">상용 API 게이트웨이의 풍부한 기능 집합이 필요하지 않은 간단한 클라우드 네이티브 응용 프로그램에 Ocelot을 고려하십시오.</span><span class="sxs-lookup"><span data-stu-id="1f938-177">Consider Ocelot for simple cloud-native applications that don't require the rich feature-set of a commercial API gateway.</span></span>

## <a name="azure-application-gateway"></a><span data-ttu-id="1f938-178">Azure Application Gateway</span><span class="sxs-lookup"><span data-stu-id="1f938-178">Azure Application Gateway</span></span>

<span data-ttu-id="1f938-179">간단한 게이트웨이 요구 사항의 경우 [Azure 응용 프로그램 게이트웨이](https://docs.microsoft.com/azure/application-gateway/overview)를 고려할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-179">For simple gateway requirements, you may consider [Azure Application Gateway](https://docs.microsoft.com/azure/application-gateway/overview).</span></span> <span data-ttu-id="1f938-180">Azure [PaaS 서비스로](https://azure.microsoft.com/overview/what-is-paas/)사용할 수 있으며 URL 라우팅, SSL 종료 및 웹 응용 프로그램 방화벽과 같은 기본 게이트웨이 기능이 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-180">Available as an Azure [PaaS service](https://azure.microsoft.com/overview/what-is-paas/), it includes basic gateway features such as URL routing, SSL termination, and a Web Application Firewall.</span></span> <span data-ttu-id="1f938-181">이 서비스는 [계층-7 부하 분산](https://www.nginx.com/resources/glossary/layer-7-load-balancing/) 기능을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-181">The service supports [Layer-7 load balancing](https://www.nginx.com/resources/glossary/layer-7-load-balancing/) capabilities.</span></span> <span data-ttu-id="1f938-182">계층 7에서는 하위 수준 TCP 네트워크 패킷뿐만 아니라 HTTP 메시지의 실제 내용을 기반으로 요청을 라우팅할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-182">With Layer 7, you can route requests based on the actual content of an HTTP message, not just low-level TCP network packets.</span></span>

<span data-ttu-id="1f938-183">이 책 전반에 걸쳐, 우리는 [Kubernetes에서](https://www.infoworld.com/article/3268073/what-is-kubernetes-your-next-application-platform.html)클라우드 네이티브 시스템을 호스팅하는 것을 전파합니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-183">Throughout this book, we evangelize hosting cloud-native systems in [Kubernetes](https://www.infoworld.com/article/3268073/what-is-kubernetes-your-next-application-platform.html).</span></span> <span data-ttu-id="1f938-184">컨테이너 오케스트레이터인 Kubernetes는 컨테이너화된 워크로드의 배포, 크기 조정 및 운영 문제를 자동화합니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-184">A container orchestrator, Kubernetes automates the deployment, scaling, and operational concerns of containerized workloads.</span></span> <span data-ttu-id="1f938-185">Azure 응용 프로그램 게이트웨이Azure [Kubernetes 서비스](https://azure.microsoft.com/services/kubernetes-service/) 클러스터에 대 한 API 게이트웨이로 구성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-185">Azure Application Gateway can be configured as an API gateway for [Azure Kubernetes Service](https://azure.microsoft.com/services/kubernetes-service/) cluster.</span></span>

<span data-ttu-id="1f938-186">[응용 프로그램 게이트웨이 침투 컨트롤러를](https://azure.github.io/application-gateway-kubernetes-ingress/) 사용 하 고 Azure 응용 프로그램 게이트웨이 Azure [Kubernetes 서비스로](https://azure.microsoft.com/services/kubernetes-service/)직접 작동 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-186">The [Application Gateway Ingress Controller](https://azure.github.io/application-gateway-kubernetes-ingress/) enables Azure Application Gateway to work directly with [Azure Kubernetes Service](https://azure.microsoft.com/services/kubernetes-service/).</span></span> <span data-ttu-id="1f938-187">그림 4.5는 아키텍처를 나타낸다.</span><span class="sxs-lookup"><span data-stu-id="1f938-187">Figure 4.5 shows the architecture.</span></span>

![Application Gateway 수신 컨트롤러](./media/application-gateway-ingress-controller.png)

<span data-ttu-id="1f938-189">**그림 4-5.**</span><span class="sxs-lookup"><span data-stu-id="1f938-189">**Figure 4-5.**</span></span> <span data-ttu-id="1f938-190">Application Gateway 수신 컨트롤러</span><span class="sxs-lookup"><span data-stu-id="1f938-190">Application Gateway Ingress Controller</span></span>

<span data-ttu-id="1f938-191">Kubernetes에는 침투라는 HTTP(레벨 7) 부하 분산을 지원하는 기본 제공 기능이 포함되어 [있습니다.](https://kubernetes.io/docs/concepts/services-networking/ingress/)</span><span class="sxs-lookup"><span data-stu-id="1f938-191">Kubernetes includes a built-in feature that supports HTTP (Level 7) load balancing, called [Ingress](https://kubernetes.io/docs/concepts/services-networking/ingress/).</span></span> <span data-ttu-id="1f938-192">Inress는 AKS 내의 마이크로 서비스 인스턴스가 외부 세계에 노출되는 방법에 대한 규칙 집합을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-192">Ingress defines a set of rules for how microservice instances inside AKS can be exposed to the outside world.</span></span> <span data-ttu-id="1f938-193">이전 이미지에서 inress 컨트롤러는 클러스터에 대해 구성된 inress 규칙을 해석하고 Azure 응용 프로그램 게이트웨이를 자동으로 구성합니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-193">In the previous image, the ingress controller interprets the ingress rules configured for the cluster and automatically configures the Azure Application Gateway.</span></span> <span data-ttu-id="1f938-194">이러한 규칙에 따라 응용 프로그램 게이트웨이는 AKS 내에서 실행되는 마이크로 서비스로 트래픽을 라우팅합니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-194">Based on those rules, the Application Gateway routes traffic to microservices running inside AKS.</span></span> <span data-ttu-id="1f938-195">수신 컨트롤러는 수신 규칙의 변경 내용을 수신하고 Azure 응용 프로그램 게이트웨이를 적절하게 변경합니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-195">The ingress controller listens for changes to ingress rules and makes the appropriate changes to the Azure Application Gateway.</span></span>

## <a name="azure-api-management"></a><span data-ttu-id="1f938-196">Azure API Management</span><span class="sxs-lookup"><span data-stu-id="1f938-196">Azure API Management</span></span>

<span data-ttu-id="1f938-197">보통에서 대규모 클라우드 네이티브 시스템의 경우 [Azure API 관리를](https://azure.microsoft.com/services/api-management/)고려할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-197">For moderate to large-scale cloud-native systems, you may consider [Azure API Management](https://azure.microsoft.com/services/api-management/).</span></span> <span data-ttu-id="1f938-198">이는 API 게이트웨이 요구 사항을 해결할 뿐만 아니라 모든 기능을 갖춘 개발자 및 관리 환경을 제공하는 클라우드 기반 서비스입니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-198">It's a cloud-based service that not only solves your API Gateway needs, but provides a full-featured developer and administrative experience.</span></span> <span data-ttu-id="1f938-199">API 관리는 그림 4-6에 나와 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-199">API Management is shown in Figure 4-6.</span></span>

![Azure API Management](./media/azure-api-management.png)

<span data-ttu-id="1f938-201">**그림 4-6.**</span><span class="sxs-lookup"><span data-stu-id="1f938-201">**Figure 4-6.**</span></span> <span data-ttu-id="1f938-202">Azure API Management</span><span class="sxs-lookup"><span data-stu-id="1f938-202">Azure API Management</span></span>

<span data-ttu-id="1f938-203">먼저 API Management는 구성 가능한 규칙 및 정책에 따라 백 엔드 서비스에 대한 제어된 액세스를 허용하는 게이트웨이 서버를 노출합니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-203">To start, API Management exposes a gateway server that allows controlled access to back-end services based upon configurable rules and policies.</span></span> <span data-ttu-id="1f938-204">이러한 서비스는 Azure 클라우드, 온-프레임 데이터 센터 또는 기타 공용 클라우드에 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-204">These services can be in the Azure cloud, your on-prem data center, or other public clouds.</span></span> <span data-ttu-id="1f938-205">API 키와 JWT 토큰은 누가 무엇을 할 수 있는지를 결정합니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-205">API keys and JWT tokens determine who can do what.</span></span> <span data-ttu-id="1f938-206">모든 트래픽은 분석 목적으로 기록됩니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-206">All traffic is logged for analytical purposes.</span></span>

<span data-ttu-id="1f938-207">개발자의 경우 API Management는 서비스, 설명서 및 샘플 코드를 호출하기 위한 액세스 권한을 제공하는 개발자 포털을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-207">For developers, API Management offers a developer portal that provides access to services, documentation, and sample code for invoking them.</span></span> <span data-ttu-id="1f938-208">개발자는 Swagger/Open API를 사용하여 서비스 끝점을 검사하고 사용량을 분석할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-208">Developers can use Swagger/Open API to inspect service endpoints and analyze their usage.</span></span> <span data-ttu-id="1f938-209">이 서비스는 .NET, Java, Golang 등 주요 개발 플랫폼에서 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-209">The service works across the major development platforms: .NET, Java, Golang, and more.</span></span>

<span data-ttu-id="1f938-210">게시자 포털은 관리자가 API를 노출하고 동작을 관리하는 관리 대시보드를 노출합니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-210">The publisher portal exposes a management dashboard where administrators expose APIs and manage their behavior.</span></span> <span data-ttu-id="1f938-211">서비스 액세스 권한을 부여하고, 서비스 상태를 모니터링하고, 서비스 원격 분석을 수집할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-211">Service access can be granted, service health monitored, and service telemetry gathered.</span></span> <span data-ttu-id="1f938-212">관리자는 각 끝점에 *정책을* 적용하여 동작에 영향을 미칩니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-212">Administrators apply *policies* to each endpoint to affect behavior.</span></span> <span data-ttu-id="1f938-213">[정책은](https://docs.microsoft.com/azure/api-management/api-management-howto-policies) 각 서비스 호출에 대해 순차적으로 실행되는 미리 빌드된 명령문입니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-213">[Policies](https://docs.microsoft.com/azure/api-management/api-management-howto-policies) are pre-built statements that execute sequentially for each service call.</span></span>  <span data-ttu-id="1f938-214">정책은 인바운드 호출, 아웃바운드 호출 또는 오류 시 호출에 대해 구성됩니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-214">Policies are configured for an inbound call, outbound call, or invoked upon an error.</span></span> <span data-ttu-id="1f938-215">정책을 결합할 때 결정적인 순서를 사용할 수 있도록 다양한 서비스 범위에 정책을 적용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-215">Policies can be applied at different service scopes as to enable deterministic ordering when combining policies.</span></span> <span data-ttu-id="1f938-216">이 제품은 미리 빌드된 [정책이](https://docs.microsoft.com/azure/api-management/api-management-policies)다수 와 함께 제공됩니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-216">The product ships with a large number of prebuilt [policies](https://docs.microsoft.com/azure/api-management/api-management-policies).</span></span>

<span data-ttu-id="1f938-217">다음은 정책이 클라우드 네이티브 서비스의 동작에 영향을 줄 수 있는 예입니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-217">Here are examples of how policies can affect the behavior of your cloud-native services:</span></span>  

- <span data-ttu-id="1f938-218">서비스 액세스를 제한합니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-218">Restrict service access.</span></span>
- <span data-ttu-id="1f938-219">인증을 적용합니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-219">Enforce authentication.</span></span>  
- <span data-ttu-id="1f938-220">필요한 경우 단일 소스에서 호출하는 스로틀입니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-220">Throttle calls from a single source, if necessary.</span></span>
- <span data-ttu-id="1f938-221">캐싱을 사용하도록 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-221">Enable caching.</span></span>
- <span data-ttu-id="1f938-222">특정 IP 주소의 통화를 차단합니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-222">Block calls from specific IP addresses.</span></span>
- <span data-ttu-id="1f938-223">서비스의 흐름을 제어합니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-223">Control the flow of the service.</span></span>
- <span data-ttu-id="1f938-224">SOAP에서 REST로 또는 XML에서 JSON으로 다른 데이터 형식 간에 요청을 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-224">Convert requests from SOAP to REST or between different data formats, such as from XML to JSON.</span></span>

<span data-ttu-id="1f938-225">Azure API Management는 클라우드 또는 데이터 센터에서 어디서나 호스팅되는 백 엔드 서비스를 노출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-225">Azure API Management can expose back-end services that are hosted anywhere – in the cloud or your data center.</span></span> <span data-ttu-id="1f938-226">클라우드 네이티브 시스템에 노출될 수 있는 레거시 서비스의 경우 REST API와 SOAP API를 모두 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-226">For legacy services that you may expose in your cloud-native systems, it supports both REST and SOAP APIs.</span></span> <span data-ttu-id="1f938-227">API 관리를 통해 다른 Azure 서비스도 노출될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-227">Even other Azure services can be exposed through API Management.</span></span> <span data-ttu-id="1f938-228">Azure [Service Bus](https://azure.microsoft.com/services/service-bus/) 또는 Azure 논리 앱과 같은 Azure 백업 서비스 위에 관리되는 API를 배치할 수 [있습니다.](https://azure.microsoft.com/services/logic-apps/)</span><span class="sxs-lookup"><span data-stu-id="1f938-228">You could place a managed API on top of an Azure backing service like [Azure Service Bus](https://azure.microsoft.com/services/service-bus/) or [Azure Logic Apps](https://azure.microsoft.com/services/logic-apps/).</span></span> <span data-ttu-id="1f938-229">Azure API Management에는 기본 제공 로드 밸런싱 지원이 포함되어 있지 않으며 로드 밸런싱 서비스와 함께 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-229">Azure API Management doesn't include built-in load-balancing support and should be used in conjunction with a load-balancing service.</span></span>

<span data-ttu-id="1f938-230">Azure API 관리는 [네 가지 계층에서](https://azure.microsoft.com/pricing/details/api-management/)사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-230">Azure API Management is available across [four different tiers](https://azure.microsoft.com/pricing/details/api-management/):</span></span>

- <span data-ttu-id="1f938-231">Developer</span><span class="sxs-lookup"><span data-stu-id="1f938-231">Developer</span></span>
- <span data-ttu-id="1f938-232">Basic</span><span class="sxs-lookup"><span data-stu-id="1f938-232">Basic</span></span>
- <span data-ttu-id="1f938-233">Standard</span><span class="sxs-lookup"><span data-stu-id="1f938-233">Standard</span></span>
- <span data-ttu-id="1f938-234">Premium</span><span class="sxs-lookup"><span data-stu-id="1f938-234">Premium</span></span>

<span data-ttu-id="1f938-235">개발자 계층은 비프로덕션 워크로드 및 평가를 위한 것입니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-235">The Developer tier is meant for non-production workloads and evaluation.</span></span> <span data-ttu-id="1f938-236">다른 계층은 점진적으로 더 많은 전력, 기능 및 더 높은 서비스 수준 계약(SLA)을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-236">The other tiers offer progressively more power, features, and higher service level agreements (SLAs).</span></span> <span data-ttu-id="1f938-237">프리미엄 계층은 [Azure 가상 네트워크](https://docs.microsoft.com/azure/virtual-network/virtual-networks-overview) 및 [다중 지역 지원을](https://docs.microsoft.com/azure/api-management/api-management-howto-deploy-multi-region)제공합니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-237">The Premium tier provides [Azure Virtual Network](https://docs.microsoft.com/azure/virtual-network/virtual-networks-overview) and [multi-region support](https://docs.microsoft.com/azure/api-management/api-management-howto-deploy-multi-region).</span></span> <span data-ttu-id="1f938-238">모든 등급은 시간당 고정 가격을 가합니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-238">All tiers have a fixed price per hour.</span></span>

<span data-ttu-id="1f938-239">최근 Microsoft는 Azure API 관리를 위한 [API 관리 서버없는 계층을](https://azure.microsoft.com/blog/announcing-azure-api-management-for-serverless-architectures/) 발표했습니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-239">Recently, Microsoft announced a [API Management serverless tier](https://azure.microsoft.com/blog/announcing-azure-api-management-for-serverless-architectures/) for Azure API Management.</span></span> <span data-ttu-id="1f938-240">소비 가격 *책정 계층이라고*하는 이 서비스는 서버리스 컴퓨팅 모델을 중심으로 설계된 API 관리의 변형입니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-240">Referred to as the *consumption pricing tier*, the service is a variant of API Management designed around the serverless computing model.</span></span> <span data-ttu-id="1f938-241">이전에 표시된 "사전 할당된" 가격 책정 계층과 달리 소비 계층은 즉각적인 프로비저닝 및 액션당 지불 가격을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-241">Unlike the "pre-allocated" pricing tiers previously shown, the consumption tier provides  instant provisioning and pay-per-action pricing.</span></span>

<span data-ttu-id="1f938-242">API 게이트웨이 기능을 사용하면 다음과 같은 사용 사례에 대해 다음과 같은 기능을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-242">It enables API Gateway features for the following use cases:</span></span>

- <span data-ttu-id="1f938-243">마이크로 서비스는 Azure Functions 및 Azure [논리 앱과](https://azure.microsoft.com/services/logic-apps/)같은 서버없는 기술을 사용하여 [구현되었습니다.](https://docs.microsoft.com/azure/azure-functions/functions-overview)</span><span class="sxs-lookup"><span data-stu-id="1f938-243">Microservices implemented using serverless technologies such as [Azure Functions](https://docs.microsoft.com/azure/azure-functions/functions-overview) and [Azure Logic Apps](https://azure.microsoft.com/services/logic-apps/).</span></span>
- <span data-ttu-id="1f938-244">서비스 버스 큐 및 토픽, Azure 저장소 등과 같은 Azure 백업 서비스 리소스입니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-244">Azure backing service resources such as Service Bus queues and topics, Azure storage, and others.</span></span>
- <span data-ttu-id="1f938-245">트래픽이 가끔 큰 스파이크를 가지고 있지만 대부분의 시간 동안 낮은 남아 있는 마이크로 서비스.</span><span class="sxs-lookup"><span data-stu-id="1f938-245">Microservices where traffic has occasional large spikes but remains low the majority of the time.</span></span>

<span data-ttu-id="1f938-246">소비 계층은 동일한 기본 서비스 API 관리 구성 요소를 사용하지만 동적으로 할당된 리소스를 기반으로 완전히 다른 아키텍처를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-246">The consumption tier uses the same underlying service API Management components, but employs an entirely different architecture based on dynamically allocated resources.</span></span> <span data-ttu-id="1f938-247">서버리스 컴퓨팅 모델과 완벽하게 일치합니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-247">It aligns perfectly with the serverless computing model:</span></span>

- <span data-ttu-id="1f938-248">관리할 인프라가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-248">No infrastructure to manage.</span></span>
- <span data-ttu-id="1f938-249">유휴 용량이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-249">No idle capacity.</span></span>
- <span data-ttu-id="1f938-250">고가용성.</span><span class="sxs-lookup"><span data-stu-id="1f938-250">High-availability.</span></span>
- <span data-ttu-id="1f938-251">자동 배율 조정.</span><span class="sxs-lookup"><span data-stu-id="1f938-251">Automatic scaling.</span></span>
- <span data-ttu-id="1f938-252">비용은 실제 사용량을 기준으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-252">Cost is based on actual usage.</span></span>
  
<span data-ttu-id="1f938-253">새로운 소비 계층은 서버없는 리소스를 API로 노출시키는 클라우드 네이티브 시스템에 적합합니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-253">The new consumption tier is a great choice for cloud-native systems that expose serverless resources as APIs.</span></span>

> <span data-ttu-id="1f938-254">작성 시 소비 계층은 Azure 클라우드에서 미리 보기상태입니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-254">At the time of writing, the consumption tier is in preview in the Azure cloud.</span></span>

## <a name="real-time-communication"></a><span data-ttu-id="1f938-255">실시간 통신</span><span class="sxs-lookup"><span data-stu-id="1f938-255">Real-time communication</span></span>

<span data-ttu-id="1f938-256">실시간 또는 푸시 통신은 HTTP를 통해 백 엔드 클라우드 네이티브 시스템과 통신하는 프런트 엔드 애플리케이션의 또 다른 옵션입니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-256">Real-time, or push, communication is another option for front-end applications that communicate with back-end cloud-native systems over HTTP.</span></span> <span data-ttu-id="1f938-257">금융 시세, 온라인 교육, 게임 및 작업 진행 업데이트와 같은 응용 프로그램에는 백 엔드에서 즉각적인 실시간 응답이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-257">Applications, such as financial-tickers, online education, gaming, and job-progress updates, require instantaneous, real-time responses from the back-end.</span></span> <span data-ttu-id="1f938-258">일반 HTTP 통신에서는 클라이언트가 새 데이터를 사용할 수 있는 시기를 알 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-258">With normal HTTP communication, there's no way for the client to know when new data is available.</span></span> <span data-ttu-id="1f938-259">클라이언트는 지속적으로 *폴링하거나* 서버에 요청을 보내야 합니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-259">The client must continually *poll* or send requests to the server.</span></span> <span data-ttu-id="1f938-260">*실시간* 통신을 통해 서버는 언제든지 새 데이터를 클라이언트에 푸시할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-260">With *real-time* communication, the server can push new data to the client at any time.</span></span>

<span data-ttu-id="1f938-261">실시간 시스템은 종종 고주파 데이터 흐름과 많은 수의 동시 클라이언트 연결을 특징으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-261">Real-time systems are often characterized by high-frequency data flows and large numbers of concurrent client connections.</span></span> <span data-ttu-id="1f938-262">실시간 연결을 수동으로 구현하면 빠르게 복잡해질 수 있으며, 연결된 클라이언트에 대한 확장성과 안정적인 메시징을 보장하기 위해 사소한 인프라가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-262">Manually implementing real-time connectivity can quickly become complex, requiring non-trivial infrastructure to ensure scalability and reliable messaging to connected clients.</span></span> <span data-ttu-id="1f938-263">Azure Redis Cache의 인스턴스와 클라이언트 선호도에 대한 고정 세션으로 구성된 로드 밸런서 집합을 관리하는 자신을 찾을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-263">You could find yourself managing an  instance of Azure Redis Cache and a set of load balancers configured with sticky sessions for client affinity.</span></span>

<span data-ttu-id="1f938-264">[Azure SignalR 서비스는](https://azure.microsoft.com/services/signalr-service/) 클라우드 네이티브 응용 프로그램에 대한 실시간 통신을 간소화하는 완전히 관리되는 Azure 서비스입니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-264">[Azure SignalR Service](https://azure.microsoft.com/services/signalr-service/) is a fully managed Azure service that simplifies real-time communication for your cloud-native applications.</span></span> <span data-ttu-id="1f938-265">용량 프로비저닝, 크기 조정 및 영구 연결과 같은 기술 구현 세부 정보는 추상화됩니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-265">Technical implementation details like capacity provisioning, scaling, and persistent connections are abstracted away.</span></span> <span data-ttu-id="1f938-266">99.9%의 서비스 수준 계약으로 처리됩니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-266">They're handled for you with a 99.9% service-level agreement.</span></span> <span data-ttu-id="1f938-267">인프라 배관이 아닌 응용 프로그램 기능에 중점을 둡니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-267">You focus on application features, not infrastructure plumbing.</span></span>

<span data-ttu-id="1f938-268">클라우드 기반 HTTP 서비스가 활성화되면 브라우저, 모바일 및 데스크톱 응용 프로그램을 비롯한 연결된 클라이언트에 직접 콘텐츠 업데이트를 푸시할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-268">Once enabled, a cloud-based HTTP service can push content updates directly to connected clients, including browser, mobile and desktop applications.</span></span> <span data-ttu-id="1f938-269">클라이언트는 서버를 폴링할 필요 없이 업데이트됩니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-269">Clients are updated without the need to poll the server.</span></span> <span data-ttu-id="1f938-270">Azure SignalR는 WebSocket, 서버 측 이벤트 및 긴 폴링을 포함하여 실시간 연결을 만드는 전송 기술을 추상화합니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-270">Azure SignalR abstracts the transport technologies that create real-time connectivity, including WebSockets, Server-Side Events, and Long Polling.</span></span> <span data-ttu-id="1f938-271">개발자는 연결된 클라이언트의 전체 또는 특정 하위 집합에 메시지를 보내는 데 중점을 둡니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-271">Developers focus on sending messages to all or specific subsets of connected clients.</span></span>

<span data-ttu-id="1f938-272">그림 4-7은 Azure SignalR이 활성화된 클라우드 네이티브 응용 프로그램에 연결하는 HTTP 클라이언트 집합을 보여 주며 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-272">Figure 4-7 shows a set of HTTP Clients connecting to a Cloud-native application with Azure SignalR enabled.</span></span>

![Azure SignalR](./media/azure-signalr-service.png)

<span data-ttu-id="1f938-274">**그림 4-7.**</span><span class="sxs-lookup"><span data-stu-id="1f938-274">**Figure 4-7.**</span></span> <span data-ttu-id="1f938-275">Azure SignalR</span><span class="sxs-lookup"><span data-stu-id="1f938-275">Azure SignalR</span></span>

<span data-ttu-id="1f938-276">Azure SignalR 서비스의 또 다른 장점은 서버리스 클라우드 네이티브 서비스를 구현하는 데 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-276">Another advantage of Azure SignalR Service comes with implementing Serverless cloud-native services.</span></span> <span data-ttu-id="1f938-277">Azure Functions 트리거를 통해 코드가 요청 시 실행될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-277">Perhaps your code is executed on demand with Azure Functions triggers.</span></span> <span data-ttu-id="1f938-278">이 시나리오는 코드가 클라이언트와의 긴 연결을 유지하지 않기 때문에 까다로울 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-278">This scenario can be tricky because your code doesn't maintain long connections with clients.</span></span> <span data-ttu-id="1f938-279">Azure SignalR Service는 이미 사용자를 위해 연결을 관리하므로 이러한 상황을 처리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-279">Azure SignalR Service can handle this situation since the service already manages connections for you.</span></span>

<span data-ttu-id="1f938-280">Azure SignalR 서비스는 Azure SQL Database, Service Bus 또는 Redis Cache와 같은 다른 Azure 서비스와 긴밀하게 통합되어 클라우드 네이티브 응용 프로그램에 대한 많은 가능성을 열어줍니다.</span><span class="sxs-lookup"><span data-stu-id="1f938-280">Azure SignalR Service closely integrates with other Azure services, such as Azure SQL Database, Service Bus, or Redis Cache, opening up many possibilities for your cloud-native applications.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="1f938-281">[이전](communication-patterns.md)
>[다음](service-to-service-communication.md)</span><span class="sxs-lookup"><span data-stu-id="1f938-281">[Previous](communication-patterns.md)
[Next](service-to-service-communication.md)</span></span>

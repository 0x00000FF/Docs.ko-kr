---
title: gRPC
description: gRPC, 클라우드 네이티브 응용 프로그램에서의 역할 및 HTTP RESTful 통신과 어떻게 다른지 알아봅니다.
author: robvet
ms.date: 03/31/2020
ms.openlocfilehash: 28a07ad5ec105d3fc5b65e4cf0ac0cd85eb16627
ms.sourcegitcommit: 79b0dd8bfc63f33a02137121dd23475887ecefda
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 04/01/2020
ms.locfileid: "80524210"
---
# <a name="grpc"></a><span data-ttu-id="15cdd-103">gRPC</span><span class="sxs-lookup"><span data-stu-id="15cdd-103">gRPC</span></span>

[!INCLUDE [book-preview](../../../includes/book-preview.md)]

<span data-ttu-id="15cdd-104">지금까지 이 책에서는 [REST 기반](https://docs.microsoft.com/azure/architecture/best-practices/api-design) 커뮤니케이션에 중점을 두어 왔습니다.</span><span class="sxs-lookup"><span data-stu-id="15cdd-104">So far in this book, we've focused on [REST-based](https://docs.microsoft.com/azure/architecture/best-practices/api-design) communication.</span></span> <span data-ttu-id="15cdd-105">REST는 엔터티 리소스에 대해 CRUD 기반 작업을 정의하는 유연한 아키텍처 스타일임을 알 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="15cdd-105">We've seen that REST is a flexible architectural style that defines CRUD-based operations against entity resources.</span></span> <span data-ttu-id="15cdd-106">클라이언트는 요청/응답 통신 모델과 HTTP 전체의 리소스와 상호 작용합니다.</span><span class="sxs-lookup"><span data-stu-id="15cdd-106">Clients interact with resources across HTTP with a request/response communication model.</span></span> <span data-ttu-id="15cdd-107">REST가 널리 구현되는 동안, 새로운 통신 기술, gRPC는 클라우드 네이티브 커뮤니티전반에 걸쳐 엄청난 추진력을 얻고 있다.</span><span class="sxs-lookup"><span data-stu-id="15cdd-107">While REST is widely implemented, a newer communication technology, gRPC, has gained tremendous momentum across the cloud-native community.</span></span>

## <a name="what-is-grpc"></a><span data-ttu-id="15cdd-108">gRPC란 무엇입니까?</span><span class="sxs-lookup"><span data-stu-id="15cdd-108">What is gRPC?</span></span>

<span data-ttu-id="15cdd-109">gRPC는 오래된 [RPC(원격 프로시저 호출)](https://en.wikipedia.org/wiki/Remote_procedure_call) 프로토콜을 발전시키는 최신 고성능 프레임워크입니다.</span><span class="sxs-lookup"><span data-stu-id="15cdd-109">gRPC is a modern, high-performance framework that evolves the age-old [remote procedure call (RPC)](https://en.wikipedia.org/wiki/Remote_procedure_call) protocol.</span></span> <span data-ttu-id="15cdd-110">응용 프로그램 수준에서 gRPC는 클라이언트와 백 엔드 서비스 간의 메시징을 간소화합니다.</span><span class="sxs-lookup"><span data-stu-id="15cdd-110">At the application level, gRPC streamlines messaging between clients and back-end services.</span></span> <span data-ttu-id="15cdd-111">구글에서 유래한 gRPC는 오픈 소스이며 클라우드 네이티브 오퍼링의 [CNCF(클라우드 네이티브 컴퓨팅 재단)](https://www.cncf.io/) 생태계의 일부입니다.</span><span class="sxs-lookup"><span data-stu-id="15cdd-111">Originating from Google, gRPC is open source and part of the  [Cloud Native Computing Foundation (CNCF)](https://www.cncf.io/) ecosystem of cloud-native offerings.</span></span> <span data-ttu-id="15cdd-112">CNCF는 gRPC를 [인큐베이팅 프로젝트로 간주합니다.](https://github.com/cncf/toc/blob/master/process/graduation_criteria.adoc)</span><span class="sxs-lookup"><span data-stu-id="15cdd-112">CNCF considers gRPC an [incubating project](https://github.com/cncf/toc/blob/master/process/graduation_criteria.adoc).</span></span> <span data-ttu-id="15cdd-113">인큐베이팅은 최종 사용자가 프로덕션 응용 프로그램에서 기술을 사용하고 있으며 프로젝트에는 건강한 수의 기여자가 있음을 의미합니다.</span><span class="sxs-lookup"><span data-stu-id="15cdd-113">Incubating means end users are using the technology in production applications, and the project has a healthy number of contributors.</span></span>

<span data-ttu-id="15cdd-114">일반적인 gRPC 클라이언트 앱은 비즈니스 작업을 구현하는 로컬 프로세스 내 함수를 노출합니다.</span><span class="sxs-lookup"><span data-stu-id="15cdd-114">A typical gRPC client app will expose a local, in-process function that implements a business operation.</span></span> <span data-ttu-id="15cdd-115">커버 아래에서 해당 로컬 함수는 원격 컴퓨터에서 다른 함수를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="15cdd-115">Under the covers, that local function invokes another function on a remote machine.</span></span> <span data-ttu-id="15cdd-116">로컬 호출로 보이는 것은 기본적으로 원격 서비스에 대한 투명한 프로세스 외 호출이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="15cdd-116">What appears to be a local call essentially becomes a transparent out-of-process call to a remote service.</span></span> <span data-ttu-id="15cdd-117">RPC 배관은 컴퓨터 간의 지점 간 네트워킹 통신, 직렬화 및 실행을 추상화합니다.</span><span class="sxs-lookup"><span data-stu-id="15cdd-117">The RPC plumbing abstracts the point-to-point networking communication, serialization, and execution between computers.</span></span>

<span data-ttu-id="15cdd-118">클라우드 네이티브 응용 프로그램에서 개발자는 프로그래밍 언어, 프레임워크 및 기술 에서 작업하는 경우가 많습니다.</span><span class="sxs-lookup"><span data-stu-id="15cdd-118">In cloud-native applications, developers often work across programming languages, frameworks, and technologies.</span></span> <span data-ttu-id="15cdd-119">이러한 *상호 운용성은* 메시지 계약과 플랫폼 간 통신에 필요한 배관을 복잡하게 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="15cdd-119">This *interoperability* complicates message contracts and the plumbing required for cross-platform communication.</span></span>  <span data-ttu-id="15cdd-120">gRPC는 이러한 문제를 추상화하는 "균일한 수평 레이어"를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="15cdd-120">gRPC provides a "uniform horizontal layer" that abstracts these concerns.</span></span> <span data-ttu-id="15cdd-121">개발자는 기본 플랫폼의 코드로 비즈니스 기능에 중점을 두고 gRPC는 통신 배관을 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="15cdd-121">Developers code in their native platform focused on business functionality, while gRPC handles communication plumbing.</span></span>

<span data-ttu-id="15cdd-122">gRPC는 Java, JavaScript, C#, Go, Swift 및 NodeJS를 포함하여 가장 인기 있는 개발 스택에서 포괄적인 지원을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="15cdd-122">gRPC offers comprehensive support across most popular development stacks, including Java, JavaScript, C#, Go, Swift, and NodeJS.</span></span>

## <a name="grpc-benefits"></a><span data-ttu-id="15cdd-123">gRPC 혜택</span><span class="sxs-lookup"><span data-stu-id="15cdd-123">gRPC Benefits</span></span>

<span data-ttu-id="15cdd-124">gRPC는 전송 프로토콜에 HTTP/2를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="15cdd-124">gRPC uses HTTP/2 for its transport protocol.</span></span> <span data-ttu-id="15cdd-125">HTTP 1.1과 호환되는 동안 HTTP/2에는 다음과 같은 많은 고급 기능이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="15cdd-125">While compatible with HTTP 1.1, HTTP/2 features many advanced capabilities:</span></span>

- <span data-ttu-id="15cdd-126">데이터를 일반 텍스트로 전송하는 HTTP 1.1과 달리 데이터 전송을 위한 이진 프로토콜입니다.</span><span class="sxs-lookup"><span data-stu-id="15cdd-126">A binary protocol for data transport - unlike HTTP 1.1, which sends data as clear text.</span></span>
- <span data-ttu-id="15cdd-127">동일한 연결을 통해 여러 병렬 요청을 전송하기 위한 다중 화 지원 - HTTP 1.1은 한 번에 하나의 요청/응답 메시지로 처리를 제한합니다.</span><span class="sxs-lookup"><span data-stu-id="15cdd-127">Multiplexing support for sending multiple parallel requests over the same connection - HTTP 1.1 limits processing to one request/response message at a time.</span></span>
- <span data-ttu-id="15cdd-128">클라이언트 요청과 서버 응답을 동시에 전송하기 위한 양방향 전이중 통신.</span><span class="sxs-lookup"><span data-stu-id="15cdd-128">Bidirectional full-duplex communication for sending both client requests and server responses simultaneously.</span></span>
- <span data-ttu-id="15cdd-129">기본 제공 스트리밍을 통해 대용량 데이터 세트를 비동기적으로 스트리밍하는 요청 및 응답을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="15cdd-129">Built-in streaming enabling requests and responses to asynchronously stream large data sets.</span></span>

<span data-ttu-id="15cdd-130">gRPC는 가볍고 성능이 우수합니다.</span><span class="sxs-lookup"><span data-stu-id="15cdd-130">gRPC is lightweight and highly performant.</span></span> <span data-ttu-id="15cdd-131">60~80% 더 작은 메시지로 JSON 직렬화보다 최대 8배 더 빠를 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="15cdd-131">It can be up to 8x faster than JSON serialization with messages 60-80% smaller.</span></span> <span data-ttu-id="15cdd-132">마이크로소프트 [윈도 커뮤니케이션 재단 (WCF)](https://docs.microsoft.com/dotnet/framework/wcf/whats-wcf) 말에서, gRPC 성능 속도 및 고도로 최적화 된 [NetTCP 바인딩의](https://docs.microsoft.com/dotnet/api/system.servicemodel.nettcpbinding?view=netframework-4.8)효율성을 초과 .</span><span class="sxs-lookup"><span data-stu-id="15cdd-132">In Microsoft [Windows Communication Foundation (WCF)](https://docs.microsoft.com/dotnet/framework/wcf/whats-wcf) parlance, gRPC performance exceeds the speed and efficiency of the highly optimized [NetTCP bindings](https://docs.microsoft.com/dotnet/api/system.servicemodel.nettcpbinding?view=netframework-4.8).</span></span> <span data-ttu-id="15cdd-133">마이크로소프트 스택을 선호하는 NetTCP와 달리 gRPC는 크로스 플랫폼입니다.</span><span class="sxs-lookup"><span data-stu-id="15cdd-133">Unlike NetTCP, which favors the Microsoft stack, gRPC is cross-platform.</span></span>

## <a name="protocol-buffers"></a><span data-ttu-id="15cdd-134">프로토콜 버퍼</span><span class="sxs-lookup"><span data-stu-id="15cdd-134">Protocol Buffers</span></span>

<span data-ttu-id="15cdd-135">gRPC는 프로토콜 버퍼라는 오픈 소스 기술을 [수용합니다.](https://developers.google.com/protocol-buffers/docs/overview)</span><span class="sxs-lookup"><span data-stu-id="15cdd-135">gRPC embraces an open-source technology called [Protocol Buffers](https://developers.google.com/protocol-buffers/docs/overview).</span></span> <span data-ttu-id="15cdd-136">서비스가 서로 보내는 구조화 된 메시지를 직렬화하기 위한 매우 효율적이고 플랫폼 중립적인 직렬화 형식을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="15cdd-136">They provide a highly efficient and platform-neutral serialization format for serializing structured messages that services send to each other.</span></span> <span data-ttu-id="15cdd-137">개발자는 플랫폼 간 인터페이스 정의 언어(IDL)를 사용하여 각 마이크로 서비스에 대한 서비스 계약을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="15cdd-137">Using a cross-platform Interface Definition Language (IDL), developers define a service contract for each microservice.</span></span> <span data-ttu-id="15cdd-138">텍스트 기반 `.proto` 파일로 구현된 계약은 각 서비스에 대한 메서드, 입력 및 출력을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="15cdd-138">The contract, implemented as a text-based `.proto` file, describes the methods, inputs, and outputs for each service.</span></span> <span data-ttu-id="15cdd-139">동일한 계약 파일을 다른 개발 플랫폼에 구축된 gRPC 클라이언트 및 서비스에 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="15cdd-139">The same contract file can be used for gRPC clients and services built on different development platforms.</span></span>

<span data-ttu-id="15cdd-140">프로토 파일인 Protobuf 컴파일러를 `protoc`사용하여 대상 플랫폼에 대한 클라이언트 및 서비스 코드를 모두 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="15cdd-140">Using the proto file, the Protobuf compiler, `protoc`, generates both client and service code for your target platform.</span></span> <span data-ttu-id="15cdd-141">코드에는 다음 구성 요소가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="15cdd-141">The code includes the following components:</span></span>

- <span data-ttu-id="15cdd-142">메시지에 대한 서비스 작업 및 데이터 요소를 나타내는 클라이언트 및 서비스에서 공유하는 강력한 형식의 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="15cdd-142">Strongly-typed objects, shared by the client and service, that represent the service operations and data elements for a message.</span></span>
- <span data-ttu-id="15cdd-143">원격 gRPC 서비스가 상속하고 확장할 수 있는 필수 네트워크 배관이 있는 강력한 형식의 기본 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="15cdd-143">A strongly-typed base class with the required network plumbing that the remote gRPC service can inherit and extend.</span></span>
- <span data-ttu-id="15cdd-144">원격 gRPC 서비스를 호출하는 데 필요한 배관이 포함된 클라이언트 스텁입니다.</span><span class="sxs-lookup"><span data-stu-id="15cdd-144">A client stub that contains the required plumbing to invoke the remote gRPC service.</span></span>

<span data-ttu-id="15cdd-145">런타임시 각 메시지는 표준 Protobuf 표현으로 직렬화되고 클라이언트와 원격 서비스 간에 교환됩니다.</span><span class="sxs-lookup"><span data-stu-id="15cdd-145">At runtime, each message is serialized as a standard Protobuf representation and exchanged between the client and remote service.</span></span> <span data-ttu-id="15cdd-146">JSON 또는 XML과 달리 Protobuf 메시지는 컴파일된 이진 바이트로 직렬화됩니다.</span><span class="sxs-lookup"><span data-stu-id="15cdd-146">Unlike JSON or XML, Protobuf messages are serialized as compiled binary bytes.</span></span>

<span data-ttu-id="15cdd-147">Microsoft 아키텍처 사이트에서 사용할 수 있는 [WCF 개발자를 위한 gRPC](https://docs.microsoft.com/dotnet/architecture/grpc-for-wcf-developers/)책에서는 gRPC 및 프로토콜 버퍼에 대한 심층적인 커버리지를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="15cdd-147">The book, [gRPC for WCF Developers](https://docs.microsoft.com/dotnet/architecture/grpc-for-wcf-developers/), available from the Microsoft Architecture site, provides in-depth coverage of gRPC and Protocol Buffers.</span></span>

## <a name="grpc-support-in-net"></a><span data-ttu-id="15cdd-148">.NET에서 gRPC 지원</span><span class="sxs-lookup"><span data-stu-id="15cdd-148">gRPC support in .NET</span></span>

<span data-ttu-id="15cdd-149">gRPC는 .NET 코어 3.0 SDK 이상에 통합됩니다.</span><span class="sxs-lookup"><span data-stu-id="15cdd-149">gRPC is integrated into .NET Core 3.0 SDK or later.</span></span> <span data-ttu-id="15cdd-150">다음 도구는 이를 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="15cdd-150">The following tools support it:</span></span>

- <span data-ttu-id="15cdd-151">웹 개발 워크로드가 설치된 Visual Studio 2019 버전 16.3 이상입니다.</span><span class="sxs-lookup"><span data-stu-id="15cdd-151">Visual Studio 2019, version 16.3 or later, with the web development workload installed.</span></span>
- <span data-ttu-id="15cdd-152">Visual Studio Code</span><span class="sxs-lookup"><span data-stu-id="15cdd-152">Visual Studio Code</span></span>
- <span data-ttu-id="15cdd-153">도트넷 CLI</span><span class="sxs-lookup"><span data-stu-id="15cdd-153">the dotnet CLI</span></span>

<span data-ttu-id="15cdd-154">SDK에는 엔드포인트 라우팅, 기본 제공 IoC 및 로깅을 위한 툴링이 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="15cdd-154">The SDK includes tooling for endpoint routing, built-in IoC, and logging.</span></span> <span data-ttu-id="15cdd-155">오픈 소스 Kestrel 웹 서버는 HTTP/2 연결을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="15cdd-155">The open-source Kestrel web server supports HTTP/2 connections.</span></span> <span data-ttu-id="15cdd-156">그림 4-20은 gRPC 서비스에 대한 스켈레톤 프로젝트를 스캐폴드하는 Visual Studio 2019 템플릿을 보여 주었습니다.</span><span class="sxs-lookup"><span data-stu-id="15cdd-156">Figure 4-20 shows a Visual Studio 2019 template that scaffolds a skeleton project for a gRPC service.</span></span> <span data-ttu-id="15cdd-157">.NET Core가 Windows, Linux 및 macOS를 완전히 지원하는 방법을 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="15cdd-157">Note how .NET Core fully supports Windows, Linux, and macOS.</span></span>

![비주얼 스튜디오 2019에서 gRPC 지원](./media/visual-studio-2019-grpc-template.png)

<span data-ttu-id="15cdd-159">**그림 4-20**.</span><span class="sxs-lookup"><span data-stu-id="15cdd-159">**Figure 4-20**.</span></span> <span data-ttu-id="15cdd-160">비주얼 스튜디오 2019에서 gRPC 지원</span><span class="sxs-lookup"><span data-stu-id="15cdd-160">gRPC support in Visual Studio 2019</span></span>
  
<span data-ttu-id="15cdd-161">그림 4-21은 Visual Studio 2019에 포함된 내장 스캐폴딩으로부터 생성된 스켈레톤 gRPC 서비스를 보여 주었습니다.</span><span class="sxs-lookup"><span data-stu-id="15cdd-161">Figure 4-21 shows the skeleton gRPC service generated from the built-in scaffolding included in Visual Studio 2019.</span></span>  

![비주얼 스튜디오 2019의 gRPC 프로젝트](./media/grpc-project.png  )

<span data-ttu-id="15cdd-163">**그림 4-21**.</span><span class="sxs-lookup"><span data-stu-id="15cdd-163">**Figure 4-21**.</span></span> <span data-ttu-id="15cdd-164">비주얼 스튜디오 2019의 gRPC 프로젝트</span><span class="sxs-lookup"><span data-stu-id="15cdd-164">gRPC project in Visual Studio 2019</span></span>

<span data-ttu-id="15cdd-165">이전 그림에서 프로토 설명 파일 및 서비스 코드를 기록합니다.</span><span class="sxs-lookup"><span data-stu-id="15cdd-165">In the previous figure, note the proto description file and service code.</span></span> <span data-ttu-id="15cdd-166">곧 보시다시피 Visual Studio는 시작 클래스와 기본 프로젝트 파일 모두에서 추가 구성을 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="15cdd-166">As you'll see shortly, Visual Studio generates additional configuration in both the Startup class and underlying project file.</span></span>

## <a name="grpc-usage"></a><span data-ttu-id="15cdd-167">gRPC 사용량</span><span class="sxs-lookup"><span data-stu-id="15cdd-167">gRPC usage</span></span>

<span data-ttu-id="15cdd-168">다음 시나리오에 대 한 gRPC를 선호 합니다.</span><span class="sxs-lookup"><span data-stu-id="15cdd-168">Favor gRPC for the following scenarios:</span></span>

- <span data-ttu-id="15cdd-169">처리를 계속하려면 즉각적인 응답이 필요한 동기 백엔드 마이크로 서비스-마이크로 서비스 통신입니다.</span><span class="sxs-lookup"><span data-stu-id="15cdd-169">Synchronous backend microservice-to-microservice communication where an immediate response is required to continue processing.</span></span>
- <span data-ttu-id="15cdd-170">혼합 프로그래밍 플랫폼을 지원해야 하는 수개 국어 환경입니다.</span><span class="sxs-lookup"><span data-stu-id="15cdd-170">Polyglot environments that need to support mixed programming platforms.</span></span>
- <span data-ttu-id="15cdd-171">성능이 중요한 낮은 대기 시간 및 높은 처리량 통신.</span><span class="sxs-lookup"><span data-stu-id="15cdd-171">Low latency and high throughput communication where performance is critical.</span></span>
- <span data-ttu-id="15cdd-172">지점 간 실시간 통신 - gRPC는 폴링 없이 실시간으로 메시지를 푸시할 수 있으며 양방향 스트리밍을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="15cdd-172">Point-to-point real-time communication - gRPC can push messages in real time without polling and has excellent support for bi-directional streaming.</span></span>
- <span data-ttu-id="15cdd-173">네트워크 제한 환경 - 이진 gRPC 메시지는 항상 동등한 텍스트 기반 JSON 메시지보다 작습니다.</span><span class="sxs-lookup"><span data-stu-id="15cdd-173">Network constrained environments – binary gRPC messages are always smaller than an equivalent text-based JSON message.</span></span>

<span data-ttu-id="15cdd-174">당시, 이 글의 gRPC는 주로 백 엔드 서비스와 함께 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="15cdd-174">At the time, of this writing, gRPC is primarily used with backend services.</span></span> <span data-ttu-id="15cdd-175">대부분의 최신 브라우저는 프런트 엔드 gRPC 클라이언트를 지원하는 데 필요한 HTTP/2 컨트롤 수준을 제공할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="15cdd-175">Most modern browsers can't provide the level of HTTP/2 control required to support a front-end gRPC client.</span></span> <span data-ttu-id="15cdd-176">즉, 자바 스크립트 또는 Blazor 웹 어셈블리 기술로 구축 된 브라우저 기반 앱에서 gRPC 통신을 가능하게하는 [초기 이니셔티브가](https://devblogs.microsoft.com/aspnet/grpc-web-experiment/) 있습니다.</span><span class="sxs-lookup"><span data-stu-id="15cdd-176">That said, there's an [early initiative](https://devblogs.microsoft.com/aspnet/grpc-web-experiment/) that enables gRPC communication from browser-based apps built with JavaScript or Blazor WebAssembly technologies.</span></span> <span data-ttu-id="15cdd-177">[.NET용 gRPC-Web을](https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-WEB.md) 사용하면 ASP.NET 코어 gRPC 앱이 브라우저 앱에서 gRPC 기능을 지원할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="15cdd-177">The  [gRPC-Web for .NET](https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-WEB.md) enables an ASP.NET Core gRPC app to support gRPC features in browser apps:</span></span>

- <span data-ttu-id="15cdd-178">강력한 형식의 코드 생성 클라이언트</span><span class="sxs-lookup"><span data-stu-id="15cdd-178">Strongly-typed code-generated clients</span></span>
- <span data-ttu-id="15cdd-179">소형 프로토부프 메시지</span><span class="sxs-lookup"><span data-stu-id="15cdd-179">Compact Protobuf messages</span></span>
- <span data-ttu-id="15cdd-180">서버 스트리밍</span><span class="sxs-lookup"><span data-stu-id="15cdd-180">Server streaming</span></span>

## <a name="grpc-implementation"></a><span data-ttu-id="15cdd-181">gRPC 구현</span><span class="sxs-lookup"><span data-stu-id="15cdd-181">gRPC implementation</span></span>

<span data-ttu-id="15cdd-182">마이크로 서비스 참조 아키텍처인 [eShop on Containers는](https://github.com/dotnet-architecture/eShopOnContainers).NET Core 응용 프로그램에서 gRPC 서비스를 구현하는 방법을 보여 주며,</span><span class="sxs-lookup"><span data-stu-id="15cdd-182">The microservice reference architecture, [eShop on Containers](https://github.com/dotnet-architecture/eShopOnContainers), from Microsoft, shows how to implement gRPC services in .NET Core applications.</span></span> <span data-ttu-id="15cdd-183">그림 4-22는 백 엔드 아키텍처를 제시합니다.</span><span class="sxs-lookup"><span data-stu-id="15cdd-183">Figure 4-22 presents the back-end architecture.</span></span>

![컨테이너에 eShop을 위한 백 엔드 아키텍처](./media/eshop-with-aggregators.png)

<span data-ttu-id="15cdd-185">**그림 4-22**.</span><span class="sxs-lookup"><span data-stu-id="15cdd-185">**Figure 4-22**.</span></span> <span data-ttu-id="15cdd-186">컨테이너에 eShop을 위한 백 엔드 아키텍처</span><span class="sxs-lookup"><span data-stu-id="15cdd-186">Backend architecture for eShop on Containers</span></span>

<span data-ttu-id="15cdd-187">이전 그림에서 eShop이 여러 API 게이트웨이를 노출하여 [프런트 엔드 패턴(BFF)에 대한 백 엔드를](https://docs.microsoft.com/azure/architecture/patterns/backends-for-frontends) 수용하는 방법을 알아두십시오.</span><span class="sxs-lookup"><span data-stu-id="15cdd-187">In the previous figure, note how eShop embraces the [Backend for Frontends pattern](https://docs.microsoft.com/azure/architecture/patterns/backends-for-frontends) (BFF) by exposing multiple API gateways.</span></span> <span data-ttu-id="15cdd-188">이 장의 앞에서 BFF 패턴에 대해 설명했습니다.</span><span class="sxs-lookup"><span data-stu-id="15cdd-188">We discussed the BFF pattern earlier in this chapter.</span></span> <span data-ttu-id="15cdd-189">웹 쇼핑 API 게이트웨이와 백 엔드 쇼핑 마이크로 서비스 사이에 있는 애그리게이터 마이크로 서비스(회색)에 주의하십시오.</span><span class="sxs-lookup"><span data-stu-id="15cdd-189">Pay close attention to the Aggregator microservice (in gray) that sits between the Web-Shopping API Gateway and backend Shopping microservices.</span></span> <span data-ttu-id="15cdd-190">Aggregator는 클라이언트로부터 단일 요청을 수신하고, 다양한 마이크로 서비스로 디스패치하고, 결과를 집계한 다음, 요청 클라이언트로 다시 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="15cdd-190">The Aggregator receives a single request from a client, dispatches it to various microservices, aggregates the results, and sends them back to the requesting client.</span></span> <span data-ttu-id="15cdd-191">이러한 작업에는 일반적으로 즉각적인 응답을 생성하기 위해 동기 통신이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="15cdd-191">Such operations typically require synchronous communication as to produce an immediate response.</span></span> <span data-ttu-id="15cdd-192">eShop에서는 그림 4-23과 같이 gRPC를 사용하여 애그리게이터의 백엔드 호출이 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="15cdd-192">In eShop, backend calls from the Aggregator are performed using gRPC as shown in Figure 4-23.</span></span>

![컨테이너에 eShop에서 gRPC](./media/grpc-implementation.png)

<span data-ttu-id="15cdd-194">**그림 4-23**</span><span class="sxs-lookup"><span data-stu-id="15cdd-194">**Figure 4-23**.</span></span> <span data-ttu-id="15cdd-195">컨테이너에 eShop에서 gRPC</span><span class="sxs-lookup"><span data-stu-id="15cdd-195">gRPC in eShop on Containers</span></span>

<span data-ttu-id="15cdd-196">gRPC 통신에는 클라이언트와 서버 구성 요소가 모두 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="15cdd-196">gRPC communication requires both client and server components.</span></span> <span data-ttu-id="15cdd-197">이전 그림에서는 쇼핑 애그리게이터가 gRPC 클라이언트를 구현하는 방법을 알아두고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="15cdd-197">In the previous figure, note how the Shopping Aggregator implements a gRPC client.</span></span> <span data-ttu-id="15cdd-198">클라이언트는 각각 gRPC 서버를 구현하는 백엔드 마이크로 서비스에 동기 gRPC 호출(빨간색)을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="15cdd-198">The client makes synchronous gRPC calls (in red) to backend microservices, each of which implement a gRPC server.</span></span> <span data-ttu-id="15cdd-199">클라이언트와 서버 모두 .NET Core 3.0 SDK의 기본 제공 gRPC 배관을 활용합니다.</span><span class="sxs-lookup"><span data-stu-id="15cdd-199">Both the client and server take advantage of the built-in gRPC plumbing from the .NET Core 3.0 SDK.</span></span> <span data-ttu-id="15cdd-200">클라이언트 측 *스텁은* 원격 gRPC 호출을 호출하는 배관을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="15cdd-200">Client-side *stubs* provide the plumbing to invoke remote gRPC calls.</span></span> <span data-ttu-id="15cdd-201">서버 측 구성 요소는 사용자 지정 서비스 클래스가 상속하고 사용할 수 있는 gRPC 배관을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="15cdd-201">Server-side components provide gRPC plumbing that custom service classes can inherit and consume.</span></span>

<span data-ttu-id="15cdd-202">RESTful API와 gRPC 통신을 모두 노출하는 마이크로 서비스는 트래픽을 관리하기 위해 여러 개의 끝점이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="15cdd-202">Microservices that expose both a RESTful API and gRPC communication require multiple endpoints to manage traffic.</span></span> <span data-ttu-id="15cdd-203">RESTful 호출에 대한 HTTP 트래픽을 수신하는 끝점과 gRPC 호출에 대해 다른 끝점을 엽니다.</span><span class="sxs-lookup"><span data-stu-id="15cdd-203">You would open an endpoint that listens for HTTP traffic for the RESTful calls and another for gRPC calls.</span></span> <span data-ttu-id="15cdd-204">gRPC 통신에 필요한 HTTP/2 프로토콜에 대해 gRPC 끝점을 구성해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="15cdd-204">The gRPC endpoint must be configured for the HTTP/2 protocol that is required for gRPC communication.</span></span>

<span data-ttu-id="15cdd-205">마이크로 서비스를 비동기 통신 패턴으로 분리하려고 노력하지만 일부 작업에는 직접 호출이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="15cdd-205">While we strive to decouple microservices with asynchronous communication patterns, some operations require direct calls.</span></span> <span data-ttu-id="15cdd-206">gRPC는 마이크로 서비스 간의 직접 동기 통신을 위한 기본 선택이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="15cdd-206">gRPC should be the primary choice for direct synchronous communication between microservices.</span></span> <span data-ttu-id="15cdd-207">HTTP/2 및 프로토콜 버퍼를 기반으로 하는 고성능 통신 프로토콜은 완벽한 선택입니다.</span><span class="sxs-lookup"><span data-stu-id="15cdd-207">Its high-performance communication protocol, based on HTTP/2 and protocol buffers, make it a perfect choice.</span></span>

## <a name="looking-ahead"></a><span data-ttu-id="15cdd-208">앞을 내다보며</span><span class="sxs-lookup"><span data-stu-id="15cdd-208">Looking ahead</span></span>

<span data-ttu-id="15cdd-209">앞으로 gRPC는 클라우드 네이티브 시스템에 대한 견인력을 계속 얻을 것입니다.</span><span class="sxs-lookup"><span data-stu-id="15cdd-209">Looking ahead, gRPC will continue to gain traction for cloud-native systems.</span></span> <span data-ttu-id="15cdd-210">성능 이점과 개발 용이성은 매력적입니다.</span><span class="sxs-lookup"><span data-stu-id="15cdd-210">The performance benefits and ease of development are compelling.</span></span> <span data-ttu-id="15cdd-211">그러나 REST는 오랫동안 주변에 있을 가능성이 높습니다.</span><span class="sxs-lookup"><span data-stu-id="15cdd-211">However, REST will likely be around for a long time.</span></span> <span data-ttu-id="15cdd-212">공개적으로 노출된 API와 이전 버전과의 호환성을 위해 탁월합니다.</span><span class="sxs-lookup"><span data-stu-id="15cdd-212">It excels for publicly exposed APIs and for backward compatibility reasons.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="15cdd-213">[이전](service-to-service-communication.md)
>[다음](service-mesh-communication-infrastructure.md)</span><span class="sxs-lookup"><span data-stu-id="15cdd-213">[Previous](service-to-service-communication.md)
[Next](service-mesh-communication-infrastructure.md)</span></span>

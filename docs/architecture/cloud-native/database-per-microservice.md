---
title: 마이크로 서비스당 데이터베이스
description: 모놀리식 및 클라우드 네이티브 애플리케이션에서 데이터 스토리지를 대조합니다.
author: robvet
ms.date: 01/22/2020
ms.openlocfilehash: c0c5611fa866d70f155e4bdad2eee1181b13c065
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/12/2020
ms.locfileid: "79141447"
---
# <a name="database-per-microservice"></a>마이크로 서비스당 데이터베이스

[!INCLUDE [book-preview](../../../includes/book-preview.md)]

이 책에서 보았듯이 클라우드 네이티브 접근 방식은 응용 프로그램을 디자인, 배포 및 관리하는 방식을 변경합니다. 또한 데이터를 관리하고 저장하는 방식도 변경됩니다.

그림 5-1은 차이점과 대조됩니다.

![클라우드 네이티브 애플리케이션의 데이터 스토리지](./media/distributed-data.png)

**그림 5-1**. 클라우드 네이티브 애플리케이션의 데이터 관리

숙련된 개발자는 그림 5-1의 왼쪽에 있는 아키텍처를 쉽게 인식할 수 있습니다. 이 *모놀리식 응용 프로그램에서*비즈니스 서비스 구성 요소는 단일 관계형 데이터베이스의 데이터를 공유하여 공유 서비스 계층에서 함께 배치합니다.

여러 가지 방법으로 단일 데이터베이스는 데이터 관리를 단순하게 유지합니다. 여러 테이블에서 데이터를 쿼리하는 것은 간단합니다. 데이터 변경 사항이 함께 업데이트되거나 모두 롤백됩니다. [ACID 거래는](https://docs.microsoft.com/windows/desktop/cossdk/acid-properties) 강력하고 즉각적인 일관성을 보장합니다.

클라우드 네이티브를 위한 설계에서는 다른 접근 방식을 취합니다. 그림 5-1의 오른쪽에 있는 비즈니스 기능이 어떻게 작고 독립적인 마이크로 서비스로 분리되는지 알아두십시오. 각 마이크로 서비스는 특정 비즈니스 기능과 자체 데이터를 캡슐화합니다. 모놀리식 데이터베이스는 마이크로 서비스와 정렬되는 많은 작은 데이터베이스가 있는 분산 데이터 모델로 분해됩니다. 연기가 지워지면 *마이크로 서비스당 데이터베이스를*노출하는 디자인이 나타납니다.

## <a name="why"></a>그 이유는

마이크로 서비스당 이 데이터베이스는 특히 빠르게 진화하고 대규모를 지원해야 하는 시스템에 많은 이점을 제공합니다. 이 모델로 ...

- 도메인 데이터가 서비스 내에 캡슐화됩니다.
- 데이터 스키마는 다른 서비스에 직접적인 영향을 주지 않고 진화할 수 있습니다.
- 각 데이터 저장소는 독립적으로 확장할 수 있습니다.
- 한 서비스의 데이터 저장소 오류는 다른 서비스에 직접적인 영향을 미치지 않습니다.

또한 데이터를 분리하면 각 마이크로 서비스가 워크로드, 저장소 요구 사항 및 읽기/쓰기 패턴에 가장 최적화된 데이터 저장소 형식을 구현할 수 있습니다. 선택 사항에는 관계형, 문서, 키-값 및 그래프 기반 데이터 저장소가 포함됩니다.

그림 5-2는 클라우드 네이티브 시스템에서 수개 국어 지속성의 원리를 제시한다.

![수개 국어 데이터 지속성](./media/polyglot-data-persistence.png)

**그림 5-2**. 수개 국어 데이터 지속성

이전 그림에서는 각 마이크로 서비스가 다른 유형의 데이터 저장소를 지원하는 방법을 설명합니다.

- 제품 카탈로그 마이크로 서비스는 기본 데이터의 풍부한 관계형 구조를 수용하기 위해 관계형 데이터베이스를 사용합니다.
- 장바구니 마이크로 서비스는 간단한 키 값 데이터 저장소를 지원하는 분산 캐시를 사용합니다.
- 주문 마이크로 서비스는 대량의 읽기 작업을 수용하기 위해 비정규화된 키/값 저장소와 함께 쓰기 작업에 NoSql 문서 데이터베이스를 모두 사용합니다.
  
관계형 데이터베이스는 복잡한 데이터가 있는 마이크로 서비스와 관련이 있지만 NoSQL 데이터베이스는 상당한 인기를 얻고 있습니다. 대규모 규모와 고가용성을 제공합니다. 스키마가 없는 특성을 통해 개발자는 형식이 변경되는 데이터 클래스 및 ORM의 아키텍처에서 벗어나 변경 비용이 많이 들고 시간이 많이 소요됩니다. 이 장의 후반부에서는 NoSQL 데이터베이스를 다룹니다.

 데이터를 별도의 마이크로 서비스로 캡슐화하면 민첩성, 성능 및 확장성이 향상될 수 있지만 많은 과제가 있습니다. 다음 섹션에서는 이러한 과제를 극복하는 데 도움이 되는 패턴 및 관행과 함께 논의합니다.  

## <a name="cross-service-queries"></a>서비스 간 쿼리

마이크로 서비스는 독립적이며 인벤토리, 배송 또는 주문과 같은 특정 기능 기능에 중점을 두지만 다른 마이크로 서비스와의 통합이 필요한 경우가 자주 있습니다. 통합에는 한 마이크로 서비스가 다른 마이크로 서비스 쿼리를 통해 데이터를 *쿼리하는* 경우가 많습니다. 그림 5-3은 시나리오를 보여 주다.

![마이크로 서비스 간 쿼리](./media/cross-service-query.png)

**그림 5-3**. 마이크로 서비스 간 쿼리

앞그림에서는 사용자의 장바구니에 항목을 추가하는 장바구니 마이크로 서비스가 표시됩니다. 이 마이크로 서비스의 데이터 저장소에는 바구니 및 광고 항목 데이터가 포함되어 있지만 제품 또는 가격 데이터는 유지 관리되지 않습니다. 대신 이러한 데이터 항목은 카탈로그 및 가격 책정 마이크로 서비스에 의해 소유됩니다. 이것은 문제를 제시한다. 장바구니 마이크로 서비스는 데이터베이스에 제품이나 가격 데이터가 없을 때 어떻게 사용자의 장바구니에 제품을 추가할 수 있습니까?

4장에서 설명하는 한 가지 옵션은 장바구니에서 카탈로그 및 가격 책정 마이크로 서비스로 [직접 HTTP 호출하는](service-to-service-communication.md#queries) 것입니다. 그러나 4장에서는 동기식 HTTP가 마이크로 서비스를 *함께* 호출하여 자율성을 줄이고 아키텍처상의 이점을 감소시킵니다.

또한 각 서비스에 대해 별도의 인바운드 및 아웃바운드 큐가 있는 요청 회신 패턴을 구현할 수도 있습니다. 그러나 이 패턴은 복잡하며 요청 및 응답 메시지의 상관 관계를 지정하려면 배관이 필요합니다.
백 엔드 마이크로 서비스 호출을 분리하지만 호출 서비스는 호출이 완료될 때까지 동기적으로 기다려야 합니다. 네트워크 정체, 일시적인 오류 또는 오버로드된 마이크로 서비스로 인해 장기 실행 및 실패한 작업이 발생할 수 있습니다.

대신 서비스 간 종속성을 제거하기 위해 널리 사용되는 패턴은 그림 5-4에 표시된 [구체화된 뷰 패턴입니다.](https://docs.microsoft.com/azure/architecture/patterns/materialized-view)

![구체화된 뷰 패턴](./media/materialized-view-pattern.png)

**그림 5-4**. 구체화된 뷰 패턴

이 패턴을 사용하면 장바구니 서비스에 로컬 데이터 *테이블(읽기 모델이라고*함)을 배치합니다. 이 테이블에는 제품 및 가격 책정 마이크로 서비스에서 필요한 데이터의 비정규화된 복사본이 포함되어 있습니다. 데이터를 장바구니 마이크로 서비스에 직접 복사하면 비용이 많이 드는 교차 서비스 호출이 필요하지 않습니다. 서비스에 로컬 데이터를 사용하면 서비스의 응답 시간과 안정성을 향상시킬 수 있습니다. 또한 자체 데이터 복사본을 사용하면 장바구니 서비스의 복원력이 향상됩니다. 카탈로그 서비스를 사용할 수 없는 경우 장바구니 서비스에 직접적인 영향을 미치지 않습니다. 쇼핑 바구니는 자체 저장소의 데이터로 계속 작동할 수 있습니다.

이 방법의 가장 큰 문제는 이제 시스템에 중복 데이터가 있다는 것입니다. 그러나 클라우드 네이티브 시스템에서 *데이터를 전략적으로* 복제하는 것은 확립된 관행이며 패턴 방지 또는 나쁜 관행으로 간주되지 않습니다. *하나만 하나의 서비스만* 데이터 집합을 소유하고 데이터 집합에 대한 권한을 가질 수 있습니다. 레코드 시스템이 업데이트될 때 읽기 모델을 동기화해야 합니다. 동기화는 일반적으로 그림 5.4와 같이 [게시/구독 패턴을](service-to-service-communication.md#events)가진 비동기 메시징을 통해 구현됩니다.

## <a name="distributed-transactions"></a>분산 트랜잭션

마이크로 서비스 간에 데이터를 쿼리하는 것은 어렵지만 여러 마이크로 서비스에서 트랜잭션을 구현하는 것은 훨씬 더 복잡합니다. 서로 다른 마이크로 서비스의 독립적인 데이터 원본에서 데이터 일관성을 유지하는 본질적인 과제는 과소평가할 수 없습니다. 클라우드 네이티브 응용 프로그램에서 분산 트랜잭션이 없다는 것은 분산 트랜잭션을 프로그래밍 방식으로 관리해야 한다는 것을 의미합니다. *즉각적인 일관성의* 세계에서 최종 *일관성의*세계로 이동합니다.

그림 5-5는 문제를 보여줍니다.

![사가 패턴의 거래](./media/saga-transaction-operation.png)

**그림 5-5 .** 마이크로 서비스 전반에 걸쳐 트랜잭션 구현

앞그림에서는 5개의 독립적인 마이크로 서비스가 주문을 만드는 분산 트랜잭션에 참여합니다. 각 마이크로 서비스는 자체 데이터 저장소를 유지하고 해당 저장소에 대한 로컬 트랜잭션을 구현합니다. 주문을 만들려면 *각* 개별 마이크로 서비스에 대한 로컬 트랜잭션이 성공해야 하거나 *모두* 작업을 중단하고 롤백해야 합니다. 각 마이크로 서비스 내에서 기본 제공 트랜잭션 지원을 사용할 수 있지만 데이터를 일관되게 유지하기 위해 5개 서비스 모두에 걸쳐 있는 분산 트랜잭션에 대한 지원은 없습니다.

대신 이 분산 트랜잭션을 *프로그래밍 방식으로*구성해야 합니다.

분산 트랜잭션 지원을 추가하는 데 널리 사용되는 패턴은 Saga 패턴입니다. 로컬 트랜잭션을 프로그래밍 방식으로 그룹화하고 순차적으로 각 트랜잭션을 호출하여 구현합니다. 로컬 트랜잭션중 어느 개라도 실패하면 Saga는 작업을 중단하고 [보상 트랜잭션 집합을 호출합니다.](https://docs.microsoft.com/azure/architecture/patterns/compensating-transaction) 보정 트랜잭션은 이전 로컬 트랜잭션의 변경 내용을 취소하고 데이터 일관성을 복원합니다. 그림 5-6은 Saga 패턴으로 실패한 트랜잭션을 보여줍니다.

![사가 무늬로 롤백](./media/saga-rollback-operation.png)

**그림 5-6**. 트랜잭션 롤백

이전 그림에서 *인벤토리 업데이트* 작업이 인벤토리 마이크로 서비스에서 실패했습니다. Saga는 보상 트랜잭션 집합(빨간색)을 호출하여 재고 수를 조정하고, 결제 및 주문을 취소하고, 각 마이크로 서비스에 대한 데이터를 일관된 상태로 반환합니다.

사가 패턴은 일반적으로 일련의 관련 이벤트로 안무되거나 관련 명령 집합으로 오케스트레이션됩니다. 4장에서는 오케스트레이션된 사가 구현의 토대가 될 서비스 애그리게이터 패턴에 대해 설명했습니다. 또한 안무사가 구현의 토대가 될 Azure Service Bus 및 Azure Event Grid 주제와 함께 이벤트에 대해서도 설명했습니다.

## <a name="high-volume-data"></a>대용량 데이터

대용량 클라우드 네이티브 응용 프로그램은 대용량 데이터 요구 사항을 지원하는 경우가 많습니다. 이러한 시나리오에서는 기존의 데이터 저장소 기술로 인해 병목 현상이 발생할 수 있습니다. 대규모로 배포되는 복잡한 시스템의 경우 CQRS(명령 및 쿼리 책임 분리) 및 이벤트 소싱이 모두 응용 프로그램 성능을 향상시킬 수 있습니다.  

### <a name="cqrs"></a>CQRS

[CQRS는](https://docs.microsoft.com/azure/architecture/patterns/cqrs)성능, 확장성 및 보안을 최대화하는 데 도움이 되는 아키텍처 패턴입니다. 패턴은 데이터를 읽는 작업과 데이터를 작성하는 작업을 구분합니다.

일반적인 시나리오의 경우 *읽기* 및 쓰기 작업에 동일한 엔터티 모델 및 데이터 리포지토리 개체가 사용됩니다.

그러나 대용량 데이터 시나리오는 읽기 및 쓰기에 대해 별도의 모델 및 데이터 테이블의 이점을 활용할 수 있습니다. 성능을 향상시키기 위해 읽기 작업은 비용이 많이 드는 반복 테이블 조인 및 테이블 잠금을 피하기 위해 데이터의 비정규화 된 표현에 대해 쿼리 할 수 있습니다. *명령이라고*하는 *쓰기* 작업은 일관성을 보장하는 데이터의 완전히 정규화된 표현에 대해 업데이트됩니다. 그런 다음 두 표현을 동기화상태로 유지하는 메커니즘을 구현해야 합니다. 일반적으로 쓰기 테이블을 수정할 때마다 수정 내용을 읽기 테이블에 복제하는 이벤트를 게시합니다.

도 5-7은 CQRS 패턴의 구현을 나타낸다.

![명령 및 쿼리 책임 분리](./media/cqrs-implementation.png)

**그림 5-7**. CQRS 구현

이전 그림에서는 별도의 명령 및 쿼리 모델이 구현됩니다. 각 데이터 쓰기 작업은 쓰기 저장소에 저장된 다음 읽기 저장소로 전파됩니다. 데이터 전파 프로세스가 [최종 일관성](http://www.cloudcomputingpatterns.org/eventual_consistency/)원칙에 따라 어떻게 작동하는지에 주의하십시오. 읽기 모델은 결국 쓰기 모델과 동기화되지만 프로세스에 약간의 지연이 있을 수 있습니다. 다음 섹션에서최종 일관성에 대해 설명합니다.

이러한 분리를 통해 읽기 및 쓰기를 독립적으로 확장할 수 있습니다. 읽기 작업은 쿼리에 최적화된 스키마를 사용하고 쓰기는 업데이트에 최적화된 스키마를 사용합니다. 읽기 쿼리는 비정규화된 데이터에 대해 적용되고 복잡한 비즈니스 논리는 쓰기 모델에 적용할 수 있습니다. 또한 읽기를 노출하는 것보다 쓰기 작업에 더 엄격한 보안을 부과할 수 있습니다.

CQRS를 구현하면 클라우드 네이티브 서비스에 대한 응용 프로그램 성능을 향상시킬 수 있습니다. 그러나 더 복잡한 디자인이 발생합니다. 이 원칙을 클라우드 네이티브 응용 프로그램의 해당 섹션에 신중하고 전략적으로 적용하면 이 원칙을 활용할 수 있습니다. CQRS에 대한 자세한 내용은 Microsoft 도서 [.NET 마이크로 서비스: 컨테이너화된 .NET 응용 프로그램에 대한 아키텍처를](https://docs.microsoft.com/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/apply-simplified-microservice-cqrs-ddd-patterns)참조하십시오.

### <a name="event-sourcing"></a>이벤트 소싱

대용량 데이터 시나리오를 최적화하는 또 다른 방법은 [이벤트 소싱을](https://docs.microsoft.com/azure/architecture/patterns/event-sourcing)포함합니다.

시스템은 일반적으로 데이터 엔터티의 현재 상태를 저장합니다. 예를 들어 사용자가 전화 번호를 변경하면 고객 레코드가 새 번호로 업데이트됩니다. 항상 데이터 엔터티의 현재 상태를 알고 있지만 각 업데이트는 이전 상태를 덮어씁니다.

대부분의 경우 이 모델은 정상적으로 작동합니다. 그러나 대량 시스템에서는 트랜잭션 잠금 및 빈번한 업데이트 작업의 오버헤드가 데이터베이스 성능, 응답성 및 확장성에 영향을 줄 수 있습니다.

이벤트 소싱은 데이터 캡처에 대해 다른 접근 방식을 취합니다. 데이터에 영향을 주는 각 작업은 이벤트 저장소에 유지됩니다. 데이터 레코드의 상태를 업데이트하는 대신 각 변경 을 회계사의 원장과 유사한 과거 이벤트의 순차적 목록에 추가합니다. 이벤트 저장소는 데이터에 대한 레코드 시스템이 됩니다. 마이크로 서비스의 경계된 컨텍스트 내에서 다양 한 구체화 된 뷰를 전파 하는 데 사용 됩니다. 도 5.8은 패턴을 나타낸다.

![이벤트 소싱](./media/event-sourcing.png)

**그림 5-8**. 이벤트 소싱

이전 그림에서는 사용자의 장바구니에 대한 각 항목(파란색)이 기본 이벤트 저장소에 어떻게 추가되는지 확인합니다. 인접한 구체화된 보기에서 시스템은 각 장바구니와 관련된 모든 이벤트를 재생하여 현재 상태를 투영합니다. 이 보기 또는 읽기 모델은 UI에 다시 노출됩니다. 이벤트는 외부 시스템 및 응용 프로그램과 통합하거나 엔터티의 현재 상태를 결정하기 위해 쿼리할 수도 있습니다. 이 방법을 사용하면 기록을 유지합니다. 엔터티의 현재 상태뿐만 아니라 이 상태에 도달한 방법도 알 수 있습니다.

기계적으로 말하자면, 이벤트 소싱은 쓰기 모델을 단순화합니다. 업데이트 또는 삭제가 없습니다. 각 데이터 항목을 변경할 수 없는 이벤트로 추가하면 관계형 데이터베이스와 관련된 경합, 잠금 및 동시성 충돌이 최소화됩니다. 구체화된 뷰 패턴을 사용하여 읽기 모델을 작성하면 뷰를 쓰기 모델에서 분리하고 응용 프로그램 UI의 요구 사항을 최적화하기 위해 최상의 데이터 저장소를 선택할 수 있습니다.

이 패턴의 경우 이벤트 소싱을 직접 지원하는 데이터 저장소를 고려하십시오. Azure 코스모스 DB, 몽고DB, 카산드라, 카우치DB, 레이븐DB가 좋은 후보입니다.

모든 패턴과 기술과 마찬가지로 전략적으로 필요할 때 구현합니다. 이벤트 소싱은 향상된 성능과 확장성을 제공할 수 있지만 복잡성과 학습 곡선을 희생해야 합니다.

>[!div class="step-by-step"]
>[이전](service-mesh-communication-infrastructure.md)
>[다음](relational-vs-nosql-data.md)

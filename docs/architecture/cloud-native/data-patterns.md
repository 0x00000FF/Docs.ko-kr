---
title: 클라우드 네이티브 데이터 패턴
description: Azure 용 클라우드 네이티브 .NET 앱 설계 | 클라우드 네이티브 데이터 패턴
ms.date: 06/30/2019
ms.openlocfilehash: 9e90409b0b633796b452cfcfecb3896e79002d4d
ms.sourcegitcommit: 30a558d23e3ac5a52071121a52c305c85fe15726
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 12/25/2019
ms.locfileid: "75337418"
---
# <a name="cloud-native-data-patterns"></a>클라우드 네이티브 데이터 패턴

[!INCLUDE [book-preview](../../../includes/book-preview.md)]

분산 된 데이터는 향상 된 성능, 확장성 및 비용 절감으로 이어질 수 있지만 많은 과제가 발생 합니다. 마이크로 서비스에서 데이터를 쿼리 하는 것은 복잡 합니다. 클라우드 네이티브 응용 프로그램에서는 분산 트랜잭션이 지원 되지 않으므로 마이크로 서비스에 걸쳐 있는 트랜잭션을 프로그래밍 방식으로 관리 해야 합니다. *즉시 일관성* 의 세계에서 *최종 일관성*으로 이동 합니다.

지금 이러한 문제에 대해 논의 합니다.

## <a name="cross-service-queries"></a>서비스 간 쿼리

응용 프로그램은 여러 독립 마이크로 서비스에 분산 된 데이터를 어떻게 쿼리 하나요?

그림 5-4에서는이 시나리오를 보여 줍니다.

![마이크로 서비스 간 쿼리](./media/cross-service-query.png)

**그림 5-4**. 마이크로 서비스 간 쿼리

이전 그림에서 사용자의 쇼핑 카트에 항목을 추가 하는 시장 바구니 마이크로 서비스이 표시 됩니다. 시장 바구니의 데이터 저장소에는 바구니 및 lineItem 테이블이 포함 되어 있지만 제품 및 가격 마이크로 서비스에서 이러한 항목을 찾을 수 있으므로 제품 또는 가격 책정 데이터는 포함 되지 않습니다. 항목을 추가 하려면 마이크로 서비스 시장 바구니에 제품 데이터 및 가격 데이터가 필요 합니다. 제품 및 가격 데이터를 얻기 위한 옵션은 무엇 인가요?

그림 5-5에는 제품 카탈로그 및 가격 마이크로 서비스에 대 한 직접 HTTP 호출을 수행 하는 시장 바구니 마이크로 서비스 나와 있습니다.

![직접 http 통신](./media/direct-http-communication.png)

**그림 5-5**. 직접 HTTP 통신

구현 하는 것이 가능 하지만 4 장에서는 마이크로 서비스에 대 한 HTTP 호출에서 시스템을 두는 방법에 대해 설명 했지만 좋은 방법으로 간주 되지 않습니다.

그림 5-6에 표시 된 집계 마이크로 서비스을 구현할 수 있습니다.

![집계 마이크로 서비스](./media/aggregator-microservice.png)

**그림 5-6.** 집계 마이크로 서비스

이 접근 방식은 개별 마이크로 서비스 비즈니스 작업 워크플로를 캡슐화 하는 반면, 복잡성을 추가 하 고 여전히 HTTP 호출을 직접 발생 합니다.

서비스 간 쿼리를 실행 하는 일반적인 방법은 그림 5-7에 표시 된 [구체화 된 뷰 패턴](https://docs.microsoft.com/azure/architecture/patterns/materialized-view)을 사용 하는 것입니다.

![구체화 된 뷰 패턴](./media/materialized-view-pattern.png)

**Figure5-7**. 구체화 된 뷰 패턴

이 패턴을 사용 하면 제품 및 가격 마이크로 서비스에서 필요한 정규화 되지 않은 데이터 복사본을 포함 하는 지역 테이블 ( *읽기 모델*이라고 함)을 시장 바구니 서비스에 직접 저장할 수 있습니다. 이러한 데이터를 시장 바구니 마이크로 서비스 내에 배치 하면 비용이 많이 드는 서비스 간 호출을 호출할 필요가 없습니다. 서비스의 로컬 데이터를 사용 하 여 응답 시간과 안정성을 향상 시킬 수 있습니다.

이 방법을 사용 하는 경우 시스템에 중복 된 데이터가 있습니다. 클라우드 네이티브 시스템에서 중복 데이터는 [앤티 무늬로](https://en.wikipedia.org/wiki/Anti-pattern) 간주 되지 않으며 일반적으로 클라우드 네이티브 시스템에서 구현 됩니다. 그러나 한 가지 시스템은 모든 데이터 집합의 소유자가 될 수 있으며, 기본 데이터가 변경 될 때마다 연결 된 모든 읽기 모델을 업데이트 하기 위해 레코드 시스템에 대 한 동기화 메커니즘을 구현 해야 합니다.

## <a name="transactional-support"></a>트랜잭션 지원

마이크로 서비스에 대 한 쿼리는 어려운 반면 마이크로 서비스에 걸쳐 트랜잭션을 구현 하는 것은 복잡할 수 있습니다. 다른 마이크로 서비스에 상주 하는 데이터 원본에서 데이터 일관성을 유지 하는 내재 된 과제는 understated 수 없습니다. 그림 5-8에서는 문제를 보여 줍니다.

![Saga 패턴의 트랜잭션](./media/saga-transaction-operation.png)

**그림 5-8**. 마이크로 서비스에서 트랜잭션 구현

위의 그림에서 5 개의 독립 마이크로 서비스는 모두 분산 된 *Create Order* 트랜잭션에 참여 하는 방법을 확인 합니다. 그러나 5 개의 개별 마이크로 서비스 각각에 대 한 트랜잭션은 성공 해야 하며, 그렇지 않으면 모두 작업을 중단 하 고 롤백해야 합니다. 기본 제공 트랜잭션 지원은 각 마이크로 서비스 내에서 사용할 수 있지만 모든 5 개 서비스에서 분산 트랜잭션을 지원 하지 않습니다.

이러한 작업은 각 마이크로 서비스에서 데이터를 일관 되 게 유지 하기 위해 트랜잭션 지원이 필수적 이므로 프로그래밍 방식으로 분산 트랜잭션을 생성 해야 합니다.

프로그래밍 방식으로 트랜잭션 지원을 추가 하는 일반적인 패턴은 [Saga 패턴](https://blog.couchbase.com/saga-pattern-implement-business-transactions-using-microservices-part/)입니다. 로컬 트랜잭션을 하나로 그룹화 하 고 각 트랜잭션을 순차적으로 호출 하 여 구현 합니다. 로컬 트랜잭션이 실패 하면 Saga는 작업을 중단 하 고 [보정 트랜잭션](https://docs.microsoft.com/azure/architecture/patterns/compensating-transaction) 집합을 호출 하 여 이전 로컬 트랜잭션에의 한 변경 내용을 취소 합니다. 그림 5-9에서는 Saga 패턴을 사용 하는 실패 한 트랜잭션을 보여 줍니다.

![Saga 패턴으로 롤백](./media/saga-rollback-operation.png)

**그림 5-9**. 트랜잭션 롤백

위의 그림에서 *GenerateContent* 작업은 music 마이크로 서비스에 실패 했습니다. Saga는 보정 트랜잭션 (빨간색)을 호출 하 여 콘텐츠를 제거 하 고, 지불을 취소 하 고, 주문을 취소 하 고 각 마이크로 서비스에 대 한 데이터를 다시 일관 된 상태로 반환 합니다.

Saga 패턴은 일반적으로 일련의 관련 이벤트 또는 오케스트레이션 관련 된 명령 집합으로 조율 됩니다.

## <a name="cqrs-pattern"></a>CQRS 패턴

CQRS 또는 [명령과 쿼리의 역할 분리](https://docs.microsoft.com/azure/architecture/patterns/cqrs)는 데이터를 쓰는 작업에서 데이터를 읽는 작업을 구분 하는 아키텍처 패턴입니다. 이 패턴은 성능, 확장성 및 보안을 최대화 하는 데 도움이 됩니다.

일반적인 데이터 액세스 시나리오에서는 읽기 및 쓰기 데이터 작업을 *모두* 수행 하는 단일 모델 (엔터티 및 리포지토리 개체)을 구현 합니다.

그러나 고급 데이터 액세스 시나리오는 읽기 및 쓰기에 대 한 별도의 모델 및 데이터 테이블을 활용 하는 것이 좋습니다. 성능 향상을 위해 *쿼리*라고 하는 읽기 작업은 비용이 많이 드는 반복적인 테이블 조인을 방지 하기 위해 매우 비 정규화 된 데이터 표현을 쿼리할 수 있습니다. 반면 *쓰기* 작업 ( *명령*이라고 함)은 완전히 정규화 된 데이터 표현에 대해 업데이트 될 수 있습니다. 그런 다음 두 표현을 동기화 하기 위한 메커니즘을 구현 해야 합니다. 일반적으로 쓰기 테이블은 수정 될 때마다 데이터 수정을 읽기 테이블로 복제 하는 이벤트를 발생 시킵니다.

그림 5-10에서는 CQRS 패턴의 구현을 보여 줍니다.

![CQRS 구현](./media/cqrs-implementation.png)

**그림 5-10**. CQRS 구현

위의 그림에서 별도의 명령 및 쿼리 모델을 구현 하는 방법을 확인 합니다. 또한 각 데이터 쓰기 작업은 쓰기 저장소에 저장 된 다음 읽기 저장소로 전파 됩니다. [최종 일관성](https://www.cloudcomputingpatterns.org/eventual_consistency/)의 원칙에 따라 전파 프로세스가 작동 하는 방식에 대 한 주의를 기울여야 하지만 읽기 모델은 궁극적으로 쓰기 모델과 동기화 되지만 프로세스가 지연 될 수 있습니다.

분리를 구현 하 여 읽기 및 쓰기를 별도로 확장할 수 있습니다. 또한 읽기와 관련 된 쓰기 작업 보다 더 강력한 보안을 적용할 수 있습니다.

일반적으로 CQRS 패턴은 특정 요구 사항에 따라 시스템의 제한 된 섹션에 적용 됩니다.

## <a name="relational-vs-nosql"></a>관계형 vs NoSQL

[Nosql](https://www.geeksforgeeks.org/introduction-to-nosql/) 기술의 영향을 외 수 없습니다. 특히 분산 된 클라우드 네이티브 시스템의 경우입니다. 이러한 공간에서 새로운 데이터 기술의 확산에는 관계형 데이터베이스에 독점적으로 의존 하는 중단 된 솔루션이 있습니다.

관계형 데이터베이스는 한 쪽에서 수십 년 동안 널리 사용할 수 있는 기술입니다. 이는 완벽 하 고 검증 되며 광범위 하 게 구현 됩니다. 경쟁 데이터베이스 제품, 전문 지식 및 도구 abounds. 관계형 데이터베이스는 관련 데이터 테이블의 저장소를 제공 합니다. 이러한 테이블에는 고정 스키마가 있으며 SQL (구조적 쿼리 언어)을 사용 하 여 데이터를 관리 하 고 [ACID](https://www.geeksforgeeks.org/acid-properties-in-dbms/) (원자성, 일관성, 격리 및 내구성)가 보장 됩니다.

이외에도 SQL 데이터베이스는 고성능의 비관계형 데이터 저장소를 참조 합니다. 이러한 사용자는 사용 편의성, 확장성, 복원 력 및 가용성 특성을 사용 합니다. NoSQL은 정규화 된 데이터 테이블을 조인 하는 대신, 일반적으로 JSON 문서에 자체 설명 (schemaless) 데이터를 저장 합니다. [ACID](https://www.geeksforgeeks.org/acid-properties-in-dbms/) 보장을 제공 하지 않습니다.

이러한 데이터베이스 유형 간의 차이점을 이해 하는 방법은 상태를 저장 하는 분산 시스템에 적용할 수 있는 일련의 원칙을 [CAP 정리](https://towardsdatascience.com/cap-theorem-and-distributed-database-management-systems-5c2be977950e)에서 찾을 수 있습니다. 그림 5-11에서는 CAP 정리의 세 가지 속성을 보여 줍니다.

![단면 정리](./media/cap-theorem.png)

**그림 5-11**. 캡 정리

정리 모든 분산 데이터 시스템이 일관성, 가용성 및 파티션 허용 오차를 절충 하는 것을 제공 하 고 모든 데이터베이스는 세 가지 속성

- *일관성*: 모든 복제본이 올바르게 업데이트 될 때까지 요청을 차단 해야 하는 경우에도 클러스터의 모든 노드가 최신 데이터로 응답 합니다.

- *가용성*: 모든 노드는 해당 응답이 가장 최근 데이터가 아닌 경우에도 적절 한 시간 내에 응답을 반환 합니다.

- *파티션 허용 오차*: 노드가 실패 하거나 다른 노드에 대 한 연결이 끊어지면 시스템이 계속 작동 하도록 보장 합니다.

관계형 데이터베이스는 일관성과 가용성을 나타내지만 파티션 허용 오차는 발생 하지 않습니다. 분할와 같은 관계형 데이터베이스를 분할 하는 것은 어렵고 성능에 영향을 줄 수 있습니다.

반면에 NoSQL 데이터베이스는 일반적으로 파티션 허용 범위 (수평 확장성 및 고가용성)를 나타냅니다. CAP 정리에서 지정 하는 것 처럼 세 가지 원칙이 있을 수 있으며 일관성 속성이 손실 됩니다.

NoSQL 데이터베이스는 일반적으로 상용 서버에서 분산 되 고 확장 됩니다. 이렇게 하면 저렴 한 비용으로 지리적 지역 내 및 지역에서 뛰어난 가용성을 제공할 수 있습니다. 이러한 컴퓨터 또는 노드 간에 데이터를 분할 하 고 복제 하 여 중복성 및 내결함성을 제공할 수 있습니다. 단점은 일관성이 있습니다. 한 NoSQL 노드의 데이터 변경 내용을 다른 노드로 전파 하는 데 다소 시간이 걸릴 수 있습니다. 일반적으로 NoSQL 데이터베이스 노드는 제공 하는 데이터가 오래 되어 아직 업데이트 되지 않은 경우에도 쿼리에 즉시 응답을 제공 합니다.

이는 ACID 트랜잭션이 지원 되지 않는 분산 데이터 시스템의 특징 인 알려진 [최종 일관성](https://www.cloudcomputingpatterns.org/eventual_consistency/)입니다. 데이터 항목 업데이트와 각 복제본 노드에 해당 업데이트를 전파 하는 데 걸리는 시간 사이에는 짧은 지연이 있습니다. 미국의 NoSQL 데이터베이스의 제품 항목을 업데이트 하지만 유럽의 복제본 노드에서 동일한 데이터 항목을 쿼리 하는 경우에는 유럽 노드가 제품 변경 내용으로 업데이트 될 때까지 이전 제품 정보를 검색할 수 있습니다. 절충은 [강력한 일관성을 유지](https://en.wikipedia.org/wiki/Strong_consistency)하 고, 모든 복제본 노드가 쿼리 결과를 반환 하기 전에 업데이트 될 때까지 대기 하는 것입니다. 따라서 대량의 크기와 트래픽 볼륨을 지원할 수 있지만 이전 데이터를 발표할 가능성이 있습니다.

NoSQL 데이터베이스는 다음 네 가지 모델로 분류할 수 있습니다.

- *문서 저장소* (MongoDB, 관계형으로,는 데이터 및 해당 메타 데이터)는 데이터베이스 내부의 비 정규화 된 JSON 기반 문서에서 비-저장 됩니다.

- *키/값 저장소* (Redis, Riak, memcached): 데이터는 사용자 데이터 값에 매핑되는 고유 액세스 키에 대해 수행 되는 시스템 작업과 함께 간단한 키-값 쌍에 저장 됩니다.

- *Wide Column 저장소* (HBase, Cassandra): 관련 된 데이터는 여러 테이블을 함께 조인 하지 않고도 일반적으로 단일 단위로 검색 되는 데이터를 포함 하는 단일 열 내의 중첩 키/값 쌍 집합으로 열 형식으로 저장 됩니다.

- *Graph stores* (neo4j, 티 탄): 데이터는 노드 간 관계를 지정 하는 가장자리와 함께 노드 내에 그래픽 표현으로 저장 됩니다.

NoSQL 데이터베이스는 대규모 데이터를 처리 하도록 최적화 될 수 있습니다. 특히 데이터가 비교적 단순 합니다. NoSQL 데이터베이스는 다음과 같은 경우에 살펴보겠습니다.

- 워크 로드에는 대규모 및 높은 동시성이 필요 합니다.
- 많은 수의 사용자가 있습니다.
- 데이터는 관계 없이 간단 하 게 표현할 수 있습니다.
- 데이터를 지리적으로 분산 해야 합니다.
- ACID 보장은 필요 하지 않습니다.
- 는 상용 하드웨어에 배포 됩니다.

그런 다음 다음과 같은 경우 관계형 데이터베이스를 살펴보겠습니다.

- 워크 로드에는 중간에서 대규모 확장이 필요 합니다.
- 동시성이 중요 한 문제가 아닙니다.
- ACID를 보장 해야 합니다.
- 데이터는 관계형으로로 가장 잘 표현 됩니다.
- 응용 프로그램은 대규모의 첨단 하드웨어에 배포 됩니다.

다음으로, Azure 클라우드의 데이터 저장소를 살펴보겠습니다.

>[!div class="step-by-step"]
>[이전](distributed-data.md)
>[다음](azure-data-storage.md)

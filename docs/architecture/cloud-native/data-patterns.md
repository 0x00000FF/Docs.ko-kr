---
title: 클라우드 네이티브 데이터 패턴
description: Azure 용 클라우드 네이티브 .NET 앱 설계 | 클라우드 네이티브 데이터 패턴
ms.date: 06/30/2019
ms.openlocfilehash: 0d251f3046fcd3f3a2f5d856a123a35d3f7ecff2
ms.sourcegitcommit: 559fcfbe4871636494870a8b716bf7325df34ac5
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 10/30/2019
ms.locfileid: "73841824"
---
# <a name="cloud-native-data-patterns"></a><span data-ttu-id="540f9-103">클라우드 네이티브 데이터 패턴</span><span class="sxs-lookup"><span data-stu-id="540f9-103">Cloud-native data patterns</span></span>

[!INCLUDE [book-preview](../../../includes/book-preview.md)]

<span data-ttu-id="540f9-104">분산 된 데이터는 향상 된 성능, 확장성 및 비용 절감으로 이어질 수 있지만 많은 과제가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="540f9-104">While decentralized data can lead to improved performance, scalability, and cost savings, it also presents many challenges.</span></span> <span data-ttu-id="540f9-105">마이크로 서비스에서 데이터를 쿼리 하는 것은 복잡 합니다.</span><span class="sxs-lookup"><span data-stu-id="540f9-105">Querying for data across microservices is complex.</span></span> <span data-ttu-id="540f9-106">클라우드 네이티브 응용 프로그램에서는 분산 트랜잭션이 지원 되지 않으므로 마이크로 서비스에 걸쳐 있는 트랜잭션을 프로그래밍 방식으로 관리 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="540f9-106">A transaction that spans microservices must be managed programmatically as distributed transactions aren't supported in cloud-native applications.</span></span> <span data-ttu-id="540f9-107">*즉시 일관성* 의 세계에서 *최종 일관성*으로 이동 합니다.</span><span class="sxs-lookup"><span data-stu-id="540f9-107">You  move from a world of *immediate consistency* to *eventual consistency*.</span></span>

<span data-ttu-id="540f9-108">지금 이러한 문제에 대해 논의 합니다.</span><span class="sxs-lookup"><span data-stu-id="540f9-108">We discuss these challenges now.</span></span>

## <a name="cross-service-queries"></a><span data-ttu-id="540f9-109">서비스 간 쿼리</span><span class="sxs-lookup"><span data-stu-id="540f9-109">Cross-service queries</span></span>

<span data-ttu-id="540f9-110">응용 프로그램은 여러 독립 마이크로 서비스에 분산 된 데이터를 어떻게 쿼리 하나요?</span><span class="sxs-lookup"><span data-stu-id="540f9-110">How does an application query data that is spread across many independent microservices?</span></span>

<span data-ttu-id="540f9-111">그림 5-4에서는이 시나리오를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="540f9-111">Figure 5-4 shows this scenario.</span></span>

![마이크로 서비스 간 쿼리](./media/cross-service-query.png)

<span data-ttu-id="540f9-113">**그림 5-4**.</span><span class="sxs-lookup"><span data-stu-id="540f9-113">**Figure 5-4**.</span></span> <span data-ttu-id="540f9-114">마이크로 서비스 간 쿼리</span><span class="sxs-lookup"><span data-stu-id="540f9-114">Querying across microservices</span></span>

<span data-ttu-id="540f9-115">이전 그림에서 사용자의 쇼핑 카트에 항목을 추가 하는 시장 바구니 마이크로 서비스이 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="540f9-115">Note how in the previous figure we see a shopping basket microservice that adds an item to a user's shopping cart.</span></span> <span data-ttu-id="540f9-116">시장 바구니의 데이터 저장소에는 바구니 및 lineItem 테이블이 포함 되어 있지만 제품 및 가격 마이크로 서비스에서 이러한 항목을 찾을 수 있으므로 제품 또는 가격 책정 데이터는 포함 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="540f9-116">While the shopping basket's data store contains a basket and lineItem table, it doesn't contain product or pricing data as those items are found in the product and price microservices.</span></span> <span data-ttu-id="540f9-117">항목을 추가 하려면 마이크로 서비스 시장 바구니에 제품 데이터 및 가격 데이터가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="540f9-117">To add an item, the shopping basket microservice needs product data and pricing data.</span></span> <span data-ttu-id="540f9-118">제품 및 가격 데이터를 얻기 위한 옵션은 무엇 인가요?</span><span class="sxs-lookup"><span data-stu-id="540f9-118">What are options to obtain the product and pricing data?</span></span>

<span data-ttu-id="540f9-119">그림 5-5에는 제품 카탈로그 및 가격 마이크로 서비스에 대 한 직접 HTTP 호출을 수행 하는 시장 바구니 마이크로 서비스 나와 있습니다.</span><span class="sxs-lookup"><span data-stu-id="540f9-119">Figure 5-5 shows the shopping basket microservice making a direct HTTP call to both the product catalog and pricing microservices.</span></span>

![직접 http 통신](./media/direct-http-communication.png)

<span data-ttu-id="540f9-121">**그림 5-5**.</span><span class="sxs-lookup"><span data-stu-id="540f9-121">**Figure 5-5**.</span></span> <span data-ttu-id="540f9-122">직접 HTTP 통신</span><span class="sxs-lookup"><span data-stu-id="540f9-122">Direct HTTP communication</span></span>

<span data-ttu-id="540f9-123">구현 하는 것이 가능 하지만 4 장에서는 마이크로 서비스에 대 한 HTTP 호출에서 시스템을 두는 방법에 대해 설명 했지만 좋은 방법으로 간주 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="540f9-123">While feasible to implement, in chapter 4 we discussed how direct HTTP calls across microservices couple the system and aren't considered a good practice.</span></span>

<span data-ttu-id="540f9-124">그림 5-6에 표시 된 집계 마이크로 서비스을 구현할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="540f9-124">We could implement an aggregator microservice shown in Figure 5-6.</span></span>

![집계 마이크로 서비스](./media/aggregator-microservice.png)

<span data-ttu-id="540f9-126">**그림 5-6.**</span><span class="sxs-lookup"><span data-stu-id="540f9-126">**Figure 5-6.**</span></span> <span data-ttu-id="540f9-127">집계 마이크로 서비스</span><span class="sxs-lookup"><span data-stu-id="540f9-127">Aggregator microservice</span></span>

<span data-ttu-id="540f9-128">이 접근 방식은 개별 마이크로 서비스 비즈니스 작업 워크플로를 캡슐화 하는 반면, 복잡성을 추가 하 고 여전히 HTTP 호출을 직접 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="540f9-128">While this approach encapsulates the business operation workflow in an individual microservice, it adds complexity and still results in direct HTTP calls.</span></span>

<span data-ttu-id="540f9-129">서비스 간 쿼리를 실행 하는 일반적인 방법은 그림 5-7에 표시 된 [구체화 된 뷰 패턴](https://docs.microsoft.com/azure/architecture/patterns/materialized-view)을 사용 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="540f9-129">A common approach for executing cross-service queries uses the [Materialized View Pattern](https://docs.microsoft.com/azure/architecture/patterns/materialized-view), shown in Figure 5-7.</span></span>

![구체화 된 뷰 패턴](./media/materialized-view-pattern.png)

<span data-ttu-id="540f9-131">**Figure5-7**.</span><span class="sxs-lookup"><span data-stu-id="540f9-131">**Figure5-7**.</span></span> <span data-ttu-id="540f9-132">구체화 된 뷰 패턴</span><span class="sxs-lookup"><span data-stu-id="540f9-132">Materialized View Pattern</span></span>

<span data-ttu-id="540f9-133">이 패턴을 사용 하면 제품 및 가격 마이크로 서비스에서 필요한 정규화 되지 않은 데이터 복사본을 포함 하는 지역 테이블 ( *읽기 모델*이라고 함)을 시장 바구니 서비스에 직접 저장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="540f9-133">With this pattern, you directly place a local table (known as a *read model*) in the shopping basket service that contains a denormalized copy of the data that is needed from the product and pricing microservices.</span></span> <span data-ttu-id="540f9-134">이러한 데이터를 시장 바구니 마이크로 서비스 내에 배치 하면 비용이 많이 드는 서비스 간 호출을 호출할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="540f9-134">Placing that data inside the shopping basket microservice eliminates the need for invoking expensive cross-service calls.</span></span> <span data-ttu-id="540f9-135">서비스의 로컬 데이터를 사용 하 여 응답 시간과 안정성을 향상 시킬 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="540f9-135">With the data local to the service, you improve response time and reliability.</span></span>

<span data-ttu-id="540f9-136">이 방법을 사용 하는 경우 시스템에 중복 된 데이터가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="540f9-136">The catch with this approach is you now have duplicate data in your system.</span></span> <span data-ttu-id="540f9-137">클라우드 네이티브 시스템에서 중복 데이터는 [앤티 무늬로](https://en.wikipedia.org/wiki/Anti-pattern) 간주 되지 않으며 일반적으로 클라우드 네이티브 시스템에서 구현 됩니다.</span><span class="sxs-lookup"><span data-stu-id="540f9-137">In cloud-native systems, duplicate data isn't considered an [anti-pattern](https://en.wikipedia.org/wiki/Anti-pattern) and is commonly implemented in cloud-native systems.</span></span> <span data-ttu-id="540f9-138">그러나 한 가지 시스템은 모든 데이터 집합의 소유자가 될 수 있으며, 기본 데이터가 변경 될 때마다 연결 된 모든 읽기 모델을 업데이트 하기 위해 레코드 시스템에 대 한 동기화 메커니즘을 구현 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="540f9-138">However, one and only one system can be the owner of any dataset, and you'll need to implement a synchronization mechanism for the system of record to update all of the associated read models, whenever a change to its underlying data occurs.</span></span>

## <a name="transactional-support"></a><span data-ttu-id="540f9-139">트랜잭션 지원</span><span class="sxs-lookup"><span data-stu-id="540f9-139">Transactional support</span></span>

<span data-ttu-id="540f9-140">마이크로 서비스에 대 한 쿼리는 어려운 반면 마이크로 서비스에 걸쳐 트랜잭션을 구현 하는 것은 복잡할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="540f9-140">While queries across microservices are challenging, implementing a transaction across microservices can be complex.</span></span> <span data-ttu-id="540f9-141">다른 마이크로 서비스에 상주 하는 데이터 원본에서 데이터 일관성을 유지 하는 내재 된 과제는 understated 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="540f9-141">The inherent challenge of maintaining data consistency across data sources that reside in different microservices can't be understated.</span></span> <span data-ttu-id="540f9-142">그림 5-8에서는 문제를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="540f9-142">Figure 5-8 shows the problem.</span></span>

![Saga 패턴의 트랜잭션](./media/saga-transaction-operation.png)

<span data-ttu-id="540f9-144">**그림 5-8**.</span><span class="sxs-lookup"><span data-stu-id="540f9-144">**Figure 5-8**.</span></span> <span data-ttu-id="540f9-145">마이크로 서비스에서 트랜잭션 구현</span><span class="sxs-lookup"><span data-stu-id="540f9-145">Implementing a transaction across microservices</span></span>

<span data-ttu-id="540f9-146">위의 그림에서 5 개의 독립 마이크로 서비스는 모두 분산 된 *Create Order* 트랜잭션에 참여 하는 방법을 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="540f9-146">Note how in the previous figure five independent microservices all participate in a distributed *Create Order* transaction.</span></span> <span data-ttu-id="540f9-147">그러나 5 개의 개별 마이크로 서비스 각각에 대 한 트랜잭션은 성공 해야 하며, 그렇지 않으면 모두 작업을 중단 하 고 롤백해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="540f9-147">However, the transaction for each of the five individual microservices must succeed, or all must abort and roll-back the operation.</span></span> <span data-ttu-id="540f9-148">기본 제공 트랜잭션 지원은 각 마이크로 서비스 내에서 사용할 수 있지만 모든 5 개 서비스에서 분산 트랜잭션을 지원 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="540f9-148">While built-in transactional support is available inside each of the microservices, there's no support for a distributed transaction across all five services.</span></span>

<span data-ttu-id="540f9-149">이러한 작업은 각 마이크로 서비스에서 데이터를 일관 되 게 유지 하기 위해 트랜잭션 지원이 필수적 이므로 프로그래밍 방식으로 분산 트랜잭션을 생성 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="540f9-149">Since transactional support is essential for this operation to keep the data consistent in each of the microservices, you have to programmatically construct a distributed transaction.</span></span>

<span data-ttu-id="540f9-150">프로그래밍 방식으로 트랜잭션 지원을 추가 하는 일반적인 패턴은 [Saga 패턴](https://blog.couchbase.com/saga-pattern-implement-business-transactions-using-microservices-part/)입니다.</span><span class="sxs-lookup"><span data-stu-id="540f9-150">A popular pattern for programmatically adding transactional support is the [Saga pattern](https://blog.couchbase.com/saga-pattern-implement-business-transactions-using-microservices-part/).</span></span> <span data-ttu-id="540f9-151">로컬 트랜잭션을 하나로 그룹화 하 고 각 트랜잭션을 순차적으로 호출 하 여 구현 합니다.</span><span class="sxs-lookup"><span data-stu-id="540f9-151">It's implemented by grouping local transactions together and sequentially invoking each one.</span></span> <span data-ttu-id="540f9-152">로컬 트랜잭션이 실패 하면 Saga는 작업을 중단 하 고 [보정 트랜잭션](https://docs.microsoft.com/azure/architecture/patterns/compensating-transaction) 집합을 호출 하 여 이전 로컬 트랜잭션에의 한 변경 내용을 취소 합니다.</span><span class="sxs-lookup"><span data-stu-id="540f9-152">If a local transaction fails, the Saga aborts the operation and invokes a set of [compensating transactions](https://docs.microsoft.com/azure/architecture/patterns/compensating-transaction) to undo the changes made by the preceding local transactions.</span></span> <span data-ttu-id="540f9-153">그림 5-9에서는 Saga 패턴을 사용 하는 실패 한 트랜잭션을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="540f9-153">Figure 5-9 shows a failed transaction with the Saga pattern.</span></span>

![Saga 패턴에서 롤백](./media/saga-rollback-operation.png)

<span data-ttu-id="540f9-155">**그림 5-9**.</span><span class="sxs-lookup"><span data-stu-id="540f9-155">**Figure 5-9**.</span></span> <span data-ttu-id="540f9-156">트랜잭션 롤백</span><span class="sxs-lookup"><span data-stu-id="540f9-156">Rolling back a transaction</span></span>

<span data-ttu-id="540f9-157">위의 그림에서 *GenerateContent* 작업은 music 마이크로 서비스에 실패 했습니다.</span><span class="sxs-lookup"><span data-stu-id="540f9-157">Note how in the previous figure the *GenerateContent* operation has failed in the music microservice.</span></span> <span data-ttu-id="540f9-158">Saga는 보정 트랜잭션 (빨간색)을 호출 하 여 콘텐츠를 제거 하 고, 지불을 취소 하 고, 주문을 취소 하 고 각 마이크로 서비스에 대 한 데이터를 다시 일관 된 상태로 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="540f9-158">The Saga invokes compensating transactions (in red) to remove the content, cancel the payment, and cancel the order, returning the data for each microservice back to a consistent state.</span></span>

<span data-ttu-id="540f9-159">Saga 패턴은 일반적으로 일련의 관련 이벤트 또는 오케스트레이션 관련 된 명령 집합으로 조율 됩니다.</span><span class="sxs-lookup"><span data-stu-id="540f9-159">Saga patterns are typically choreographed as a series of related events or orchestrated as a set of related commands.</span></span>

## <a name="cqrs-pattern"></a><span data-ttu-id="540f9-160">CQRS 패턴</span><span class="sxs-lookup"><span data-stu-id="540f9-160">CQRS pattern</span></span>

<span data-ttu-id="540f9-161">CQRS 또는 [명령과 쿼리의 역할 분리](https://docs.microsoft.com/azure/architecture/patterns/cqrs)는 데이터를 쓰는 작업에서 데이터를 읽는 작업을 구분 하는 아키텍처 패턴입니다.</span><span class="sxs-lookup"><span data-stu-id="540f9-161">CQRS, or [Command and Query Responsibility Segregation](https://docs.microsoft.com/azure/architecture/patterns/cqrs), is an architectural pattern that separate operations that read data from those that write data.</span></span> <span data-ttu-id="540f9-162">이 패턴은 성능, 확장성 및 보안을 최대화 하는 데 도움이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="540f9-162">This pattern can help maximize performance, scalability, and security.</span></span>

<span data-ttu-id="540f9-163">일반적인 데이터 액세스 시나리오에서는 읽기 및 쓰기 데이터 작업을 *모두* 수행 하는 단일 모델 (엔터티 및 리포지토리 개체)을 구현 합니다.</span><span class="sxs-lookup"><span data-stu-id="540f9-163">In normal data access scenarios, you implement a single model (entity and repository object) that perform *both* read and write data operations.</span></span>

<span data-ttu-id="540f9-164">그러나 고급 데이터 액세스 시나리오는 읽기 및 쓰기에 대 한 별도의 모델 및 데이터 테이블을 활용 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="540f9-164">However, a more advanced data access scenario might benefit from separate models and data tables for reads and writes.</span></span> <span data-ttu-id="540f9-165">성능 향상을 위해 *쿼리*라고 하는 읽기 작업은 비용이 많이 드는 반복적인 테이블 조인을 방지 하기 위해 매우 비 정규화 된 데이터 표현을 쿼리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="540f9-165">To improve performance, the read operation, known as a *query*, might query against a highly denormalized representation of the data to avoid expensive repetitive table joins.</span></span> <span data-ttu-id="540f9-166">반면 *쓰기* 작업 ( *명령*이라고 함)은 완전히 정규화 된 데이터 표현에 대해 업데이트 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="540f9-166">Whereas the *write* operation, known as a *command*, might update against a fully normalized representation of the data.</span></span> <span data-ttu-id="540f9-167">그런 다음 두 표현을 동기화 하기 위한 메커니즘을 구현 해야 합니다. 일반적으로 쓰기 테이블은 수정 될 때마다 데이터 수정을 읽기 테이블로 복제 하는 이벤트를 발생 시킵니다.</span><span class="sxs-lookup"><span data-stu-id="540f9-167">You would then need to implement a mechanism to keep both representations in sync. Typically, whenever the write table is modified, it raises an event that replicates the data modification to the read table.</span></span>

<span data-ttu-id="540f9-168">그림 5-10에서는 CQRS 패턴의 구현을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="540f9-168">Figure 5-10 shows an implementation of the CQRS pattern.</span></span>

![CQRS 구현](./media/cqrs-implementation.png)

<span data-ttu-id="540f9-170">**그림 5-10**.</span><span class="sxs-lookup"><span data-stu-id="540f9-170">**Figure 5-10**.</span></span> <span data-ttu-id="540f9-171">CQRS 구현</span><span class="sxs-lookup"><span data-stu-id="540f9-171">CQRS implementation</span></span>

<span data-ttu-id="540f9-172">위의 그림에서 별도의 명령 및 쿼리 모델을 구현 하는 방법을 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="540f9-172">Note how in the previous figure separate command and query models are implemented.</span></span> <span data-ttu-id="540f9-173">또한 각 데이터 쓰기 작업은 쓰기 저장소에 저장 된 다음 읽기 저장소로 전파 됩니다.</span><span class="sxs-lookup"><span data-stu-id="540f9-173">Moreover, each data write operation is saved to the write store and then propagated to the read store.</span></span> <span data-ttu-id="540f9-174">[최종 일관성](https://www.cloudcomputingpatterns.org/eventual_consistency/)의 원칙에 따라 전파 프로세스가 작동 하는 방식에 대 한 주의를 기울여야 하지만 읽기 모델은 궁극적으로 쓰기 모델과 동기화 되지만 프로세스가 지연 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="540f9-174">Pay close attention to how the propagation process operates on the principle of [eventual consistency](https://www.cloudcomputingpatterns.org/eventual_consistency/), whereas the read model eventually synchronizes with the write model, but there may be some lag in the process.</span></span>

<span data-ttu-id="540f9-175">분리를 구현 하 여 읽기 및 쓰기를 별도로 확장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="540f9-175">By implementing separation, you have the ability to scale reads and writes separately.</span></span> <span data-ttu-id="540f9-176">또한 읽기와 관련 된 쓰기 작업 보다 더 강력한 보안을 적용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="540f9-176">As well, you might impose tighter security on write operations than those concerning reads.</span></span>

<span data-ttu-id="540f9-177">일반적으로 CQRS 패턴은 특정 요구 사항에 따라 시스템의 제한 된 섹션에 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="540f9-177">Typically, CQRS patterns are applied to limited sections of your system based upon specific needs.</span></span>

## <a name="relational-vs-nosql"></a><span data-ttu-id="540f9-178">관계형 vs NoSQL</span><span class="sxs-lookup"><span data-stu-id="540f9-178">Relational vs NoSQL</span></span>

<span data-ttu-id="540f9-179">[Nosql](https://www.geeksforgeeks.org/introduction-to-nosql/) 기술의 영향을 외 수 없습니다. 특히 분산 된 클라우드 네이티브 시스템의 경우입니다.</span><span class="sxs-lookup"><span data-stu-id="540f9-179">The impact of [NoSQL](https://www.geeksforgeeks.org/introduction-to-nosql/) technologies can't be overstated, especially for distributed cloud-native systems.</span></span> <span data-ttu-id="540f9-180">이러한 공간에서 새로운 데이터 기술의 확산에는 관계형 데이터베이스에 독점적으로 의존 하는 중단 된 솔루션이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="540f9-180">The proliferation of new data technologies in this space has disrupted solutions that once exclusively relied on relational databases.</span></span>

<span data-ttu-id="540f9-181">관계형 데이터베이스는 한 쪽에서 수십 년 동안 널리 사용할 수 있는 기술입니다.</span><span class="sxs-lookup"><span data-stu-id="540f9-181">On the one side, relational databases have been a prevalent technology for decades.</span></span> <span data-ttu-id="540f9-182">이는 완벽 하 고 검증 되며 광범위 하 게 구현 됩니다.</span><span class="sxs-lookup"><span data-stu-id="540f9-182">They're mature, proven, and widely implemented.</span></span> <span data-ttu-id="540f9-183">경쟁 데이터베이스 제품, 전문 지식 및 도구 abounds.</span><span class="sxs-lookup"><span data-stu-id="540f9-183">Competing database products, expertise and tooling abounds.</span></span> <span data-ttu-id="540f9-184">관계형 데이터베이스는 관련 데이터 테이블의 저장소를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="540f9-184">Relational databases provide a store of related data tables.</span></span> <span data-ttu-id="540f9-185">이러한 테이블에는 고정 스키마가 있으며 SQL (구조적 쿼리 언어)을 사용 하 여 데이터를 관리 하 고 [ACID](https://www.geeksforgeeks.org/acid-properties-in-dbms/) (원자성, 일관성, 격리 및 내구성)가 보장 됩니다.</span><span class="sxs-lookup"><span data-stu-id="540f9-185">These tables have a fixed schema, use SQL (Structured Query Language) to manage data and have [ACID](https://www.geeksforgeeks.org/acid-properties-in-dbms/) (also known as Atomicity, Consistency, Isolation, and Durability) guarantees.</span></span>

<span data-ttu-id="540f9-186">이외에도 SQL 데이터베이스는 고성능의 비관계형 데이터 저장소를 참조 합니다.</span><span class="sxs-lookup"><span data-stu-id="540f9-186">No-SQL databases, on the other side, refer to high-performance, non-relational data stores.</span></span> <span data-ttu-id="540f9-187">이러한 사용자는 사용 편의성, 확장성, 복원 력 및 가용성 특성을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="540f9-187">They excel in their ease-of-use, scalability, resilience, and availability characteristics.</span></span> <span data-ttu-id="540f9-188">NoSQL은 정규화 된 데이터 테이블을 조인 하는 대신, 일반적으로 JSON 문서에 자체 설명 (schemaless) 데이터를 저장 합니다.</span><span class="sxs-lookup"><span data-stu-id="540f9-188">Instead of joining tables of normalized data, NoSQL stores self-describing (schemaless) data typically in JSON documents.</span></span> <span data-ttu-id="540f9-189">[ACID](https://www.geeksforgeeks.org/acid-properties-in-dbms/) 보장을 제공 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="540f9-189">They don't offer [ACID](https://www.geeksforgeeks.org/acid-properties-in-dbms/) guarantees.</span></span>

<span data-ttu-id="540f9-190">이러한 데이터베이스 유형 간의 차이점을 이해 하는 방법은 상태를 저장 하는 분산 시스템에 적용할 수 있는 일련의 원칙을 [CAP 정리](https://towardsdatascience.com/cap-theorem-and-distributed-database-management-systems-5c2be977950e)에서 찾을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="540f9-190">A way to understand the differences between these types of databases can be found in the [CAP theorem](https://towardsdatascience.com/cap-theorem-and-distributed-database-management-systems-5c2be977950e), a set of principles that can be applied to distributed systems that store state.</span></span> <span data-ttu-id="540f9-191">그림 5-11에서는 CAP 정리의 세 가지 속성을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="540f9-191">Figure 5-11 shows the three properties of the CAP theorem.</span></span>

![단면 정리](./media/cap-theorem.png)

<span data-ttu-id="540f9-193">**그림 5-11**.</span><span class="sxs-lookup"><span data-stu-id="540f9-193">**Figure 5-11**.</span></span> <span data-ttu-id="540f9-194">캡 정리</span><span class="sxs-lookup"><span data-stu-id="540f9-194">The CAP theorem</span></span>

<span data-ttu-id="540f9-195">정리 모든 분산 데이터 시스템이 일관성, 가용성 및 파티션 허용 오차를 절충 하는 것을 제공 하 고 모든 데이터베이스는 세 가지 속성</span><span class="sxs-lookup"><span data-stu-id="540f9-195">The theorem states that any distributed data system will offer a trade-off between consistency, availability, and partition tolerance, and that any database can only guarantee two of the three properties:</span></span>

- <span data-ttu-id="540f9-196">*일관성*: 모든 복제본이 올바르게 업데이트 될 때까지 요청을 차단 해야 하는 경우에도 클러스터의 모든 노드가 최신 데이터로 응답 합니다.</span><span class="sxs-lookup"><span data-stu-id="540f9-196">*Consistency*: every node in the cluster will respond with the most recent data, even if it requires blocking a request until all replicas are correctly updated.</span></span>

- <span data-ttu-id="540f9-197">*가용성*: 모든 노드는 해당 응답이 가장 최근 데이터가 아닌 경우에도 적절 한 시간 내에 응답을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="540f9-197">*Availability*: every node will return a response in a reasonable amount of time, even if that response isn't the most recent data.</span></span>

- <span data-ttu-id="540f9-198">*파티션 허용 오차*: 노드가 실패 하거나 다른 노드에 대 한 연결이 끊어지면 시스템이 계속 작동 하도록 보장 합니다.</span><span class="sxs-lookup"><span data-stu-id="540f9-198">*Partition Tolerance*: guarantees that the system will continue operating if a node fails or loses connectivity with another.</span></span>

<span data-ttu-id="540f9-199">관계형 데이터베이스는 일관성과 가용성을 나타내지만 파티션 허용 오차는 발생 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="540f9-199">Relational databases exhibit consistency and availability, but not partition tolerance.</span></span> <span data-ttu-id="540f9-200">분할와 같은 관계형 데이터베이스를 분할 하는 것은 어렵고 성능에 영향을 줄 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="540f9-200">Partitioning a relational database, such as sharding, is difficult and can impact performance.</span></span>

<span data-ttu-id="540f9-201">반면에 NoSQL 데이터베이스는 일반적으로 파티션 허용 범위 (수평 확장성 및 고가용성)를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="540f9-201">On the other hand, NoSQL databases typically exhibit partition tolerance, known as horizontal scalability, and high availability.</span></span> <span data-ttu-id="540f9-202">CAP 정리에서 지정 하는 것 처럼 세 가지 원칙이 있을 수 있으며 일관성 속성이 손실 됩니다.</span><span class="sxs-lookup"><span data-stu-id="540f9-202">As the CAP theorem specifies, you can only have two of the three principles, and you lose the  consistency property.</span></span>

<span data-ttu-id="540f9-203">NoSQL 데이터베이스는 일반적으로 상용 서버에서 분산 되 고 확장 됩니다.</span><span class="sxs-lookup"><span data-stu-id="540f9-203">NoSQL databases are distributed and commonly scaled out across commodity servers.</span></span> <span data-ttu-id="540f9-204">이렇게 하면 저렴 한 비용으로 지리적 지역 내 및 지역에서 뛰어난 가용성을 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="540f9-204">Doing so can provide great availability, both within and across geographical regions at a reduced cost.</span></span> <span data-ttu-id="540f9-205">이러한 컴퓨터 또는 노드 간에 데이터를 분할 하 고 복제 하 여 중복성 및 내결함성을 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="540f9-205">Data can be partitioned and replicated across these machines, or nodes, providing redundancy and fault tolerance.</span></span> <span data-ttu-id="540f9-206">단점은 일관성이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="540f9-206">The downside is consistency.</span></span> <span data-ttu-id="540f9-207">한 NoSQL 노드의 데이터 변경 내용을 다른 노드로 전파 하는 데 다소 시간이 걸릴 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="540f9-207">A change to data on one NoSQL node can take some time to propagate to other nodes.</span></span> <span data-ttu-id="540f9-208">일반적으로 NoSQL 데이터베이스 노드는 제공 하는 데이터가 오래 되어 아직 업데이트 되지 않은 경우에도 쿼리에 즉시 응답을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="540f9-208">Typically, a NoSQL database node will provide an immediate response to a query, even if the data that it is presenting is stale and has not been updated yet.</span></span>

<span data-ttu-id="540f9-209">이는 ACID 트랜잭션이 지원 되지 않는 분산 데이터 시스템의 특징 인 알려진 [최종 일관성](https://www.cloudcomputingpatterns.org/eventual_consistency/)입니다.</span><span class="sxs-lookup"><span data-stu-id="540f9-209">This is known [eventual consistency](https://www.cloudcomputingpatterns.org/eventual_consistency/), a characteristic of distributed data systems where ACID transactions aren't supported.</span></span> <span data-ttu-id="540f9-210">데이터 항목 업데이트와 각 복제본 노드에 해당 업데이트를 전파 하는 데 걸리는 시간 사이에는 짧은 지연이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="540f9-210">It's a brief delay between the update of a data item and time that it takes to propagate that update to each of the replica nodes.</span></span> <span data-ttu-id="540f9-211">미국의 NoSQL 데이터베이스의 제품 항목을 업데이트 하지만 유럽의 복제본 노드에서 동일한 데이터 항목을 쿼리 하는 경우에는 유럽 노드가 제품 변경 내용으로 업데이트 될 때까지 이전 제품 정보를 검색할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="540f9-211">If you update a product item in a NoSQL database in the United States, but at same time query that same data item from a replica node in Europe, you might retrieve the earlier product information - until the European node has been updated with product change.</span></span> <span data-ttu-id="540f9-212">절충은 [강력한 일관성을 유지](https://en.wikipedia.org/wiki/Strong_consistency)하 고, 모든 복제본 노드가 쿼리 결과를 반환 하기 전에 업데이트 될 때까지 대기 하는 것입니다. 따라서 대량의 크기와 트래픽 볼륨을 지원할 수 있지만 이전 데이터를 발표할 가능성이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="540f9-212">The trade-off is that by giving up [strong consistency](https://en.wikipedia.org/wiki/Strong_consistency),  waiting for all replica nodes to update before returning a query result, you can support enormous scale and traffic volume, but with the possibility of presenting older data.</span></span>

<span data-ttu-id="540f9-213">NoSQL 데이터베이스는 다음 네 가지 모델로 분류할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="540f9-213">NoSQL databases can be categorized by the following four models:</span></span>

- <span data-ttu-id="540f9-214">*문서 저장소* (MongoDB, 관계형으로,는 데이터 및 해당 메타 데이터)는 데이터베이스 내부의 비 정규화 된 JSON 기반 문서에서 비-저장 됩니다.</span><span class="sxs-lookup"><span data-stu-id="540f9-214">*Document Store* (MongoDB, CouchDB, Couchbase): data (and corresponding metadata) is stored non-relationally in denormalized JSON-based documents inside the database.</span></span>

- <span data-ttu-id="540f9-215">*키/값 저장소* (Redis, Riak, memcached): 데이터는 사용자 데이터 값에 매핑되는 고유 액세스 키에 대해 수행 되는 시스템 작업과 함께 간단한 키-값 쌍에 저장 됩니다.</span><span class="sxs-lookup"><span data-stu-id="540f9-215">*Key/Value Store* (Redis, Riak, memcached): data is stored in simple key-value pairs with system operations performed against a unique access key that is mapped to a value of user data.</span></span>

- <span data-ttu-id="540f9-216">*Wide Column 저장소* (HBase, Cassandra): 관련 된 데이터는 여러 테이블을 함께 조인 하지 않고도 일반적으로 단일 단위로 검색 되는 데이터를 포함 하는 단일 열 내의 중첩 키/값 쌍 집합으로 열 형식으로 저장 됩니다.</span><span class="sxs-lookup"><span data-stu-id="540f9-216">*Wide-Column Store* (HBase, Cassandra): related Data is stored in a columnar format as a set of nested-key/value pairs within a single column with data typically retrieved as a single unit without having to join multiple tables together.</span></span>

- <span data-ttu-id="540f9-217">*Graph stores* (neo4j, 티 탄): 데이터는 노드 간 관계를 지정 하는 가장자리와 함께 노드 내에 그래픽 표현으로 저장 됩니다.</span><span class="sxs-lookup"><span data-stu-id="540f9-217">*Graph stores* (neo4j, titan): data is stored as a graphical representation within a node along with edges that specify the relationship between the nodes.</span></span>

<span data-ttu-id="540f9-218">NoSQL 데이터베이스는 대규모 데이터를 처리 하도록 최적화 될 수 있습니다. 특히 데이터가 비교적 단순 합니다.</span><span class="sxs-lookup"><span data-stu-id="540f9-218">NoSQL databases can be optimized to deal with large-scale data, especially when the data is relatively simple.</span></span> <span data-ttu-id="540f9-219">NoSQL 데이터베이스는 다음과 같은 경우에 살펴보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="540f9-219">Consider a NoSQL database when:</span></span>

- <span data-ttu-id="540f9-220">워크 로드에는 대규모 및 높은 동시성이 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="540f9-220">Your workload requires large-scale and high-concurrency.</span></span>
- <span data-ttu-id="540f9-221">많은 수의 사용자가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="540f9-221">You have large numbers of users.</span></span>
- <span data-ttu-id="540f9-222">데이터는 관계 없이 간단 하 게 표현할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="540f9-222">Your data can be expressed simply without relationships.</span></span>
- <span data-ttu-id="540f9-223">데이터를 지리적으로 분산 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="540f9-223">You need to geographically distribute your data.</span></span>
- <span data-ttu-id="540f9-224">ACID 보장은 필요 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="540f9-224">You don't need ACID guarantees.</span></span>
- <span data-ttu-id="540f9-225">는 상용 하드웨어에 배포 됩니다.</span><span class="sxs-lookup"><span data-stu-id="540f9-225">Will be deployed to commodity hardware.</span></span>

<span data-ttu-id="540f9-226">그런 다음 다음과 같은 경우 관계형 데이터베이스를 살펴보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="540f9-226">Then, consider a relational database when:</span></span>

- <span data-ttu-id="540f9-227">워크 로드에는 중간에서 대규모 확장이 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="540f9-227">Your workloads require medium to large scale.</span></span>
- <span data-ttu-id="540f9-228">동시성이 중요 한 문제가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="540f9-228">Concurrency isn't a major concern.</span></span>
- <span data-ttu-id="540f9-229">ACID를 보장 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="540f9-229">ACID guarantees are needed.</span></span>
- <span data-ttu-id="540f9-230">데이터는 관계형으로로 가장 잘 표현 됩니다.</span><span class="sxs-lookup"><span data-stu-id="540f9-230">Data is best expressed relationally.</span></span>
- <span data-ttu-id="540f9-231">응용 프로그램은 대규모의 첨단 하드웨어에 배포 됩니다.</span><span class="sxs-lookup"><span data-stu-id="540f9-231">Your application will be deployed to large, high-end hardware.</span></span>

<span data-ttu-id="540f9-232">다음으로, Azure 클라우드의 데이터 저장소를 살펴보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="540f9-232">Next, we look at data storage in the Azure cloud.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="540f9-233">[이전](distributed-data.md)
>[다음](azure-data-storage.md)</span><span class="sxs-lookup"><span data-stu-id="540f9-233">[Previous](distributed-data.md)
[Next](azure-data-storage.md)</span></span>

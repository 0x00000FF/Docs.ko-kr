---
title: 클라우드 네이티브 정의
description: 클라우드 네이티브 시스템의 기반을 제공하는 기본 기둥에 대해 알아보십시오.
author: robvet
ms.date: 08/20/2019
ms.openlocfilehash: 756a2565bd77fcef19a5f15579987836ff0e75a4
ms.sourcegitcommit: e3cbf26d67f7e9286c7108a2752804050762d02d
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 04/09/2020
ms.locfileid: "80989092"
---
# <a name="defining-cloud-native"></a><span data-ttu-id="ba7f0-103">클라우드 네이티브 정의</span><span class="sxs-lookup"><span data-stu-id="ba7f0-103">Defining cloud native</span></span>

[!INCLUDE [book-preview](../../../includes/book-preview.md)]

<span data-ttu-id="ba7f0-104">현재 하고 있는 작업을 중지하고 동료 10명에게 문자를 보입니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-104">Stop what you're doing and text ten of your colleagues.</span></span> <span data-ttu-id="ba7f0-105">그들에게 "클라우드 네이티브"라는 용어를 정의하도록 요청합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-105">Ask them to define the term "Cloud Native".</span></span> <span data-ttu-id="ba7f0-106">좋은 기회는 당신은 여덟 가지 답변을 얻을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-106">Good chance you'll get eight different answers.</span></span>

<span data-ttu-id="ba7f0-107">클라우드 네이티브는 중요한 비즈니스 시스템 구축에 대한 사고 방식을 바꾸는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-107">Cloud native is all about changing the way we think about constructing critical business systems.</span></span>

<span data-ttu-id="ba7f0-108">클라우드 네이티브 시스템은 급격한 변화, 대규모 및 복원력을 수용하도록 설계되었습니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-108">Cloud-native systems are designed to embrace rapid change, large scale, and resilience.</span></span>

<span data-ttu-id="ba7f0-109">클라우드 네이티브 컴퓨팅 재단은 [공식적인 정의를](https://github.com/cncf/foundation/blob/master/charter.md)제공합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-109">The Cloud Native Computing Foundation provides an [official definition](https://github.com/cncf/foundation/blob/master/charter.md):</span></span>

> <span data-ttu-id="ba7f0-110">*클라우드 네이티브 기술을 통해 조직은 퍼블릭, 프라이빗 및 하이브리드 클라우드와 같은 현대적이고 역동적인 환경에서 확장 가능한 애플리케이션을 구축하고 실행할 수 있습니다. 컨테이너, 서비스 메시, 마이크로 서비스, 불변 인프라 및 선언적 API는 이 접근 방식을 예로 들 수 있습니다.*</span><span class="sxs-lookup"><span data-stu-id="ba7f0-110">*Cloud-native technologies empower organizations to build and run scalable applications in modern, dynamic environments such as public, private, and hybrid clouds. Containers, service meshes, microservices, immutable infrastructure, and declarative APIs exemplify this approach.*</span></span>

> <span data-ttu-id="ba7f0-111">*이러한 기술을 사용하면 복원력 있고 관리가 용이하며 관찰 가능한 느슨하게 결합된 시스템을 사용할 수 있습니다. 강력한 자동화와 결합하여 엔지니어는 최소한의 수고로 자주 예측 가능한 고영향 변경을 할 수 있습니다.*</span><span class="sxs-lookup"><span data-stu-id="ba7f0-111">*These techniques enable loosely coupled systems that are resilient, manageable, and observable. Combined with robust automation, they allow engineers to make high-impact changes frequently and predictably with minimal toil.*</span></span>

<span data-ttu-id="ba7f0-112">응용 프로그램은 점점 더 많은 것을 요구하는 사용자로 점점 더 복잡해지고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-112">Applications have become increasingly complex with users demanding more and more.</span></span> <span data-ttu-id="ba7f0-113">사용자는 신속한 응답성, 혁신적인 기능 및 가동 중지 시간 제로를 기대합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-113">Users expect rapid responsiveness, innovative features, and zero downtime.</span></span> <span data-ttu-id="ba7f0-114">성능 문제, 반복되는 오류 및 빠르게 이동할 수 없는 기능은 더 이상 허용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-114">Performance problems, recurring errors, and the inability to move fast are no longer acceptable.</span></span> <span data-ttu-id="ba7f0-115">그들은 쉽게 경쟁 업체로 이동합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-115">They'll easily move to your competitor.</span></span>

<span data-ttu-id="ba7f0-116">클라우드 네이티브는 *속도와* *민첩성에*관한 것입니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-116">Cloud native is much about *speed* and *agility*.</span></span> <span data-ttu-id="ba7f0-117">비즈니스 시스템은 비즈니스 역량을 지원하는 것에서 전략적 혁신의 무기로 진화하여 비즈니스 속도와 성장을 가속화하고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-117">Business systems are evolving from enabling business capabilities to weapons of strategic transformation, accelerating business velocity and growth.</span></span> <span data-ttu-id="ba7f0-118">아이디어를 즉시 시장에 출시하는 것이 필수적입니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-118">It's imperative to get ideas to market immediately.</span></span>

<span data-ttu-id="ba7f0-119">다음은 이러한 기술을 구현한 회사입니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-119">Here are some companies who have implemented these techniques.</span></span> <span data-ttu-id="ba7f0-120">그들이 달성한 속도, 민첩성 및 확장성에 대해 생각해 보십시오.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-120">Think about the speed, agility, and scalability they've achieved.</span></span>

| <span data-ttu-id="ba7f0-121">회사</span><span class="sxs-lookup"><span data-stu-id="ba7f0-121">Company</span></span> | <span data-ttu-id="ba7f0-122">환경</span><span class="sxs-lookup"><span data-stu-id="ba7f0-122">Experience</span></span> |
| :-------- | :-------- |
| [<span data-ttu-id="ba7f0-123">Netflix</span><span class="sxs-lookup"><span data-stu-id="ba7f0-123">Netflix</span></span>](https://www.infoq.com/news/2013/06/netflix/) | <span data-ttu-id="ba7f0-124">생산에 600 개 이상의 서비스가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-124">Has 600+ services in production.</span></span> <span data-ttu-id="ba7f0-125">하루에 100번 배포합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-125">Deploys a hundred times per day.</span></span> |
| [<span data-ttu-id="ba7f0-126">동네 짱</span><span class="sxs-lookup"><span data-stu-id="ba7f0-126">Uber</span></span>](https://eng.uber.com/micro-deploy/) | <span data-ttu-id="ba7f0-127">생산에 저장된 1,000 개 이상의 서비스를 보유하고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-127">Has 1,000+ services stored in production.</span></span> <span data-ttu-id="ba7f0-128">매주 수천 개의 빌드를 배포합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-128">Deploys several thousand builds each week.</span></span> |
| [<span data-ttu-id="ba7f0-129">WeChat</span><span class="sxs-lookup"><span data-stu-id="ba7f0-129">WeChat</span></span>](https://www.cs.columbia.edu/~ruigu/papers/socc18-final100.pdf) | <span data-ttu-id="ba7f0-130">생산에 300 개 이상의 서비스가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-130">Has 300+ services in production.</span></span> <span data-ttu-id="ba7f0-131">하루에 거의 1,000번변경합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-131">Makes almost 1,000 changes per day.</span></span> |

<span data-ttu-id="ba7f0-132">보시다시피 넷플릭스, Uber 및 WeChat은 수백 개의 독립적인 마이크로 서비스로 구성된 시스템을 노출합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-132">As you can see, Netflix, Uber, and WeChat expose systems that consist of hundreds of independent microservices.</span></span> <span data-ttu-id="ba7f0-133">이 건축 양식은 시장 상황에 신속하게 대응할 수 있게 해줍니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-133">This architectural style enables them to rapidly respond to market conditions.</span></span> <span data-ttu-id="ba7f0-134">라이브, 복잡한 응용 프로그램의 작은 영역을 즉시 업데이트하고 필요에 따라 해당 영역을 개별적으로 확장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-134">They can instantaneously update small areas of a live, complex application, and individually scale those areas as needed.</span></span>

<span data-ttu-id="ba7f0-135">클라우드 네이티브의 속도와 민첩성은 여러 가지 요인에서 비롯됩니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-135">The speed and agility of cloud native come about from a number of factors.</span></span> <span data-ttu-id="ba7f0-136">가장 중요한 것은 클라우드 인프라입니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-136">Foremost is cloud infrastructure.</span></span> <span data-ttu-id="ba7f0-137">그림 1-3에 표시된 5개의 추가 기본 기둥은 클라우드 네이티브 시스템의 기반이기도 합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-137">Five additional foundational pillars shown in Figure 1-3 also provide the bedrock for cloud-native systems.</span></span>

![클라우드 네이티브 기본 기둥](./media/cloud-native-foundational-pillars.png)

<span data-ttu-id="ba7f0-139">**그림 1-3 .**</span><span class="sxs-lookup"><span data-stu-id="ba7f0-139">**Figure 1-3**.</span></span> <span data-ttu-id="ba7f0-140">클라우드 네이티브 기본 기둥</span><span class="sxs-lookup"><span data-stu-id="ba7f0-140">Cloud-native foundational pillars</span></span>

<span data-ttu-id="ba7f0-141">각 기둥의 중요성을 더 잘 이해하기 위해 시간을 내어 봅시다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-141">Let's take some time to better understand the significance of each pillar.</span></span>

## <a name="the-cloud"></a><span data-ttu-id="ba7f0-142">구름...</span><span class="sxs-lookup"><span data-stu-id="ba7f0-142">The cloud…</span></span>

<span data-ttu-id="ba7f0-143">클라우드 네이티브 시스템은 클라우드 서비스 모델을 최대한 활용합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-143">Cloud-native systems take full advantage of the cloud service model.</span></span>

<span data-ttu-id="ba7f0-144">동적 가상화된 클라우드 환경에서 번창하도록 설계된 이러한 시스템은 [플랫폼을 PaaS(서비스)로](https://azure.microsoft.com/overview/what-is-paas/) 광범위하게 사용하여 인프라 및 관리형 서비스를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-144">Designed to thrive in a dynamic, virtualized cloud environment, these systems make extensive use of [Platform as a Service (PaaS)](https://azure.microsoft.com/overview/what-is-paas/) compute infrastructure and managed services.</span></span> <span data-ttu-id="ba7f0-145">기본 인프라를 자동화를 통해 몇 분 만에 프로비저닝하고 필요에 따라 크기를 조정, 확장, 이동 또는 파괴한 *일회용* 인프라로 취급합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-145">They treat the underlying infrastructure as *disposable* - provisioned in minutes and resized, scaled, moved, or destroyed on demand – via automation.</span></span>

<span data-ttu-id="ba7f0-146">[애완 동물 대 가축의](https://medium.com/@Joachim8675309/devops-concepts-pets-vs-cattle-2380b5aab313)널리 받아들여지는 DevOps 개념을 고려하십시오.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-146">Consider the widely accepted DevOps concept of [Pets vs. Cattle](https://medium.com/@Joachim8675309/devops-concepts-pets-vs-cattle-2380b5aab313).</span></span> <span data-ttu-id="ba7f0-147">기존 데이터 센터에서 서버는 의미 있는 이름을 부여하고 돌보는 실제 컴퓨터인 *Pets로*취급됩니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-147">In a traditional data center, servers are treated as *Pets*: a physical machine, given a meaningful name, and cared for.</span></span> <span data-ttu-id="ba7f0-148">동일한 컴퓨터에 더 많은 리소스를 추가하여 확장합니다(확장).</span><span class="sxs-lookup"><span data-stu-id="ba7f0-148">You scale by adding more resources to the same machine (scaling up).</span></span> <span data-ttu-id="ba7f0-149">서버가 아프면 다시 건강을 간호합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-149">If the server becomes sick, you nurse it back to health.</span></span> <span data-ttu-id="ba7f0-150">서버를 사용할 수 없게 되면 모든 사용자가 알 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-150">Should the server become unavailable, everyone notices.</span></span>

<span data-ttu-id="ba7f0-151">*가축* 서비스 모델은 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-151">The *Cattle* service model is different.</span></span> <span data-ttu-id="ba7f0-152">각 인스턴스를 가상 컴퓨터 또는 컨테이너로 프로비전합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-152">You provision each instance as a virtual machine or container.</span></span> <span data-ttu-id="ba7f0-153">동일하며 Service-01, Service-02 등과 같은 시스템 식별자가 할당됩니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-153">They're identical and assigned a system identifier such as Service-01, Service-02, and so on.</span></span> <span data-ttu-id="ba7f0-154">더 많은 것을 만들어 확장합니다(확장).</span><span class="sxs-lookup"><span data-stu-id="ba7f0-154">You scale by creating more of them (scaling out).</span></span> <span data-ttu-id="ba7f0-155">하나를 사용할 수 없게되면 아무도 알지 못합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-155">When one becomes unavailable, nobody notices.</span></span>

<span data-ttu-id="ba7f0-156">가축 모델은 *불변의 인프라를*포용합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-156">The cattle model embraces *immutable infrastructure*.</span></span> <span data-ttu-id="ba7f0-157">서버는 수리 또는 수정되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-157">Servers aren't repaired or modified.</span></span> <span data-ttu-id="ba7f0-158">실패하거나 업데이트가 필요한 경우, 자동화를 통해 수행되는 새 프로비저닝이 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-158">If one fails or requires updating, it's destroyed and a new one is provisioned – all done via automation.</span></span>

<span data-ttu-id="ba7f0-159">클라우드 네이티브 시스템은 가축 서비스 모델을 수용합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-159">Cloud-native systems embrace the Cattle service model.</span></span> <span data-ttu-id="ba7f0-160">인프라가 실행되는 컴퓨터와 관계없이 인프라가 확장될 때 계속 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-160">They continue to run as the infrastructure scales in or out with no regard to the machines upon which they're running.</span></span>

<span data-ttu-id="ba7f0-161">Azure 클라우드 플랫폼은 자동 크기 조정, 자체 복구 및 모니터링 기능을 통해 이러한 유형의 고탄력적 인프라를 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-161">The Azure cloud platform supports this type of highly elastic infrastructure with automatic scaling, self-healing, and monitoring capabilities.</span></span>

## <a name="modern-design"></a><span data-ttu-id="ba7f0-162">모던 한 디자인</span><span class="sxs-lookup"><span data-stu-id="ba7f0-162">Modern design</span></span>

<span data-ttu-id="ba7f0-163">클라우드 네이티브 앱을 어떻게 디자인하시겠습니까?</span><span class="sxs-lookup"><span data-stu-id="ba7f0-163">How would you design a cloud-native app?</span></span> <span data-ttu-id="ba7f0-164">아키텍처는 어떤 모습일까요?</span><span class="sxs-lookup"><span data-stu-id="ba7f0-164">What would your architecture look like?</span></span> <span data-ttu-id="ba7f0-165">어떤 원칙, 패턴 및 모범 사례를 준수하시겠습니까?</span><span class="sxs-lookup"><span data-stu-id="ba7f0-165">To what principles, patterns, and best practices would you adhere?</span></span> <span data-ttu-id="ba7f0-166">어떤 인프라와 운영상의 문제가 중요할까요?</span><span class="sxs-lookup"><span data-stu-id="ba7f0-166">What infrastructure and operational concerns would be important?</span></span>

### <a name="the-twelve-factor-application"></a><span data-ttu-id="ba7f0-167">12단계 응용 프로그램</span><span class="sxs-lookup"><span data-stu-id="ba7f0-167">The Twelve-Factor Application</span></span>

<span data-ttu-id="ba7f0-168">클라우드 기반 응용 프로그램을 구축하기 위한 널리 사용되는 방법은 [12단계 응용 프로그램입니다.](https://12factor.net/)</span><span class="sxs-lookup"><span data-stu-id="ba7f0-168">A widely accepted methodology for constructing cloud-based applications is the [Twelve-Factor Application](https://12factor.net/).</span></span> <span data-ttu-id="ba7f0-169">개발자가 최신 클라우드 환경에 최적화된 응용 프로그램을 구성하기 위해 따르는 일련의 원칙과 사례에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-169">It describes a set of principles and practices that developers follow to construct applications optimized for modern cloud environments.</span></span> <span data-ttu-id="ba7f0-170">환경 전반의 이식성과 선언적 자동화에 특별한 주의를 기울입니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-170">Special attention is given to portability across environments and declarative automation.</span></span>

<span data-ttu-id="ba7f0-171">모든 웹 기반 응용 프로그램에 적용할 수 있지만 많은 실무자는 클라우드 네이티브 앱을 빌드하기 위한 견고한 기반으로 간주합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-171">While applicable to any web-based application, many practitioners consider it as a solid foundation for building cloud-native apps.</span></span> <span data-ttu-id="ba7f0-172">이러한 원칙을 기반으로 구축된 시스템은 신속하게 배포 및 확장하고 시장 변화에 신속하게 대응할 수 있는 기능을 추가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-172">Systems built upon these principles can deploy and scale rapidly and add features to react quickly to market changes.</span></span>

<span data-ttu-id="ba7f0-173">다음 표에서는 12단계 방법론을 중점으로 강조합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-173">The following table highlights the Twelve-Factor methodology:</span></span>

|    |  <span data-ttu-id="ba7f0-174">요소</span><span class="sxs-lookup"><span data-stu-id="ba7f0-174">Factor</span></span> | <span data-ttu-id="ba7f0-175">설명</span><span class="sxs-lookup"><span data-stu-id="ba7f0-175">Explanation</span></span>  |
| :-------- | :-------- | :-------- |
| <span data-ttu-id="ba7f0-176">1</span><span class="sxs-lookup"><span data-stu-id="ba7f0-176">1</span></span> | <span data-ttu-id="ba7f0-177">코드 베이스</span><span class="sxs-lookup"><span data-stu-id="ba7f0-177">Code Base</span></span> | <span data-ttu-id="ba7f0-178">자체 리포지토리에 저장된 각 마이크로 서비스에 대한 단일 코드 베이스입니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-178">A single code base for each microservice, stored in its own repository.</span></span> <span data-ttu-id="ba7f0-179">버전 제어를 사용하여 추적하면 여러 환경(QA, 스테이징, 프로덕션)에 배포할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-179">Tracked with version control, it can deploy to multiple environments (QA, Staging, Production).</span></span> |
| <span data-ttu-id="ba7f0-180">2</span><span class="sxs-lookup"><span data-stu-id="ba7f0-180">2</span></span> | <span data-ttu-id="ba7f0-181">종속성</span><span class="sxs-lookup"><span data-stu-id="ba7f0-181">Dependencies</span></span> | <span data-ttu-id="ba7f0-182">각 마이크로 서비스는 전체 시스템에 영향을 주지 않고 변경 내용을 수용하면서 자체 종속성을 격리하고 패키지화합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-182">Each microservice isolates and packages its own dependencies, embracing changes without impacting the entire system.</span></span> |
| <span data-ttu-id="ba7f0-183">3</span><span class="sxs-lookup"><span data-stu-id="ba7f0-183">3</span></span> | <span data-ttu-id="ba7f0-184">구성</span><span class="sxs-lookup"><span data-stu-id="ba7f0-184">Configurations</span></span>  | <span data-ttu-id="ba7f0-185">구성 정보는 마이크로 서비스에서 이동하고 코드 외부의 구성 관리 도구를 통해 외부화됩니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-185">Configuration information is moved out of the microservice and externalized through a configuration management tool outside of the code.</span></span> <span data-ttu-id="ba7f0-186">동일한 배포가 올바른 구성이 적용된 환경 간에 전파될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-186">The same deployment can propagate across environments with the correct configuration applied.</span></span>  |
| <span data-ttu-id="ba7f0-187">4</span><span class="sxs-lookup"><span data-stu-id="ba7f0-187">4</span></span> | <span data-ttu-id="ba7f0-188">백업 서비스</span><span class="sxs-lookup"><span data-stu-id="ba7f0-188">Backing Services</span></span> | <span data-ttu-id="ba7f0-189">보조 리소스(데이터 저장소, 캐시, 메시지 브로커)는 주소 지정 이 가능한 URL을 통해 노출되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-189">Ancillary resources (data stores, caches, message brokers) should be exposed via an addressable URL.</span></span> <span data-ttu-id="ba7f0-190">이렇게 하면 응용 프로그램에서 리소스가 분리되어 상호 교환할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-190">Doing so decouples the resource from the application, enabling it to be interchangeable.</span></span>  |
| <span data-ttu-id="ba7f0-191">5</span><span class="sxs-lookup"><span data-stu-id="ba7f0-191">5</span></span> | <span data-ttu-id="ba7f0-192">빌드, 릴리스, 실행</span><span class="sxs-lookup"><span data-stu-id="ba7f0-192">Build, Release, Run</span></span> | <span data-ttu-id="ba7f0-193">각 릴리스는 빌드, 릴리스 및 실행 단계 간에 엄격한 분리를 적용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-193">Each release must enforce a strict separation across the build, release, and run stages.</span></span> <span data-ttu-id="ba7f0-194">각 ID는 고유 ID로 태그지정해야 하며 롤백 기능을 지원해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-194">Each should be tagged with a unique ID and support the ability to roll back.</span></span> <span data-ttu-id="ba7f0-195">최신 CI/CD 시스템은 이러한 원칙을 충족하는 데 도움이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-195">Modern CI/CD systems help fulfill this principle.</span></span> |
| <span data-ttu-id="ba7f0-196">6</span><span class="sxs-lookup"><span data-stu-id="ba7f0-196">6</span></span> | <span data-ttu-id="ba7f0-197">프로세스</span><span class="sxs-lookup"><span data-stu-id="ba7f0-197">Processes</span></span> | <span data-ttu-id="ba7f0-198">각 마이크로 서비스는 실행 중인 다른 서비스와 격리된 자체 프로세스에서 실행되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-198">Each microservice should execute in its own process,  isolated from other running services.</span></span> <span data-ttu-id="ba7f0-199">분산 캐시 또는 데이터 저장소와 같은 백업 서비스에 필요한 상태를 외부화합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-199">Externalize required state to a backing service such as a distributed cache or data store.</span></span> |
| <span data-ttu-id="ba7f0-200">7</span><span class="sxs-lookup"><span data-stu-id="ba7f0-200">7</span></span> | <span data-ttu-id="ba7f0-201">포트 바인딩</span><span class="sxs-lookup"><span data-stu-id="ba7f0-201">Port Binding</span></span> | <span data-ttu-id="ba7f0-202">각 마이크로 서비스는 자체 포트에 노출된 인터페이스와 기능을 사용하여 자체 포함해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-202">Each microservice should be self-contained with its interfaces and functionality exposed on its own port.</span></span> <span data-ttu-id="ba7f0-203">이렇게 하면 다른 마이크로 서비스와 격리됩니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-203">Doing so provides isolation from other microservices.</span></span> |
| <span data-ttu-id="ba7f0-204">8</span><span class="sxs-lookup"><span data-stu-id="ba7f0-204">8</span></span> | <span data-ttu-id="ba7f0-205">동시성</span><span class="sxs-lookup"><span data-stu-id="ba7f0-205">Concurrency</span></span> | <span data-ttu-id="ba7f0-206">서비스는 사용 가능한 가장 강력한 컴퓨터에서 단일 큰 인스턴스를 확장하는 것이 아니라 많은 수의 작은 동일한 프로세스(복사본)에 걸쳐 확장됩니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-206">Services scale out across a large number of small identical processes (copies) as opposed to scaling-up a single large instance on the most powerful machine available.</span></span> |
| <span data-ttu-id="ba7f0-207">9</span><span class="sxs-lookup"><span data-stu-id="ba7f0-207">9</span></span> | <span data-ttu-id="ba7f0-208">분리 가능성</span><span class="sxs-lookup"><span data-stu-id="ba7f0-208">Disposability</span></span> | <span data-ttu-id="ba7f0-209">서비스 인스턴스는 일회용이어야 하며, 빠른 신생 기업은 확장성 기회를 늘리고 시스템을 올바른 상태로 사용할 수 있도록 종료해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-209">Service instances should be disposable, favoring fast startups to increase scalability opportunities and graceful shutdowns to leave the system in a correct state.</span></span> <span data-ttu-id="ba7f0-210">오케스트레이터와 함께 Docker 컨테이너는 본질적으로 이 요구 사항을 충족합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-210">Docker containers along with an orchestrator inherently satisfy this requirement.</span></span> |
| <span data-ttu-id="ba7f0-211">10</span><span class="sxs-lookup"><span data-stu-id="ba7f0-211">10</span></span> | <span data-ttu-id="ba7f0-212">개발/프로드 패리티</span><span class="sxs-lookup"><span data-stu-id="ba7f0-212">Dev/Prod Parity</span></span> | <span data-ttu-id="ba7f0-213">비용이 많이 드는 바로 가기를 방지하여 응용 프로그램 수명 주기 전반에 걸쳐 환경을 최대한 유사하게 유지합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-213">Keep environments across the application lifecycle as similar as possible, avoiding costly shortcuts.</span></span> <span data-ttu-id="ba7f0-214">여기서 컨테이너의 채택은 동일한 실행 환경을 촉진하여 크게 기여할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-214">Here, the adoption of containers can greatly contribute by promoting the same execution environment.</span></span> |
| <span data-ttu-id="ba7f0-215">11</span><span class="sxs-lookup"><span data-stu-id="ba7f0-215">11</span></span> | <span data-ttu-id="ba7f0-216">로깅</span><span class="sxs-lookup"><span data-stu-id="ba7f0-216">Logging</span></span> | <span data-ttu-id="ba7f0-217">마이크로 서비스에서 생성된 로그를 이벤트 스트림으로 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-217">Treat logs generated by microservices as event streams.</span></span> <span data-ttu-id="ba7f0-218">이벤트 집계자를 사용하여 처리하고 Azure Monitor 또는 Splunk와 같은 데이터 마이닝/로그 관리 도구에 데이터를 전파하고 결국 장기 보관합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-218">Process them with an event aggregator and propagate the data to data-mining/log management tools like Azure Monitor or Splunk and eventually long-term archival.</span></span> |
| <span data-ttu-id="ba7f0-219">12</span><span class="sxs-lookup"><span data-stu-id="ba7f0-219">12</span></span> | <span data-ttu-id="ba7f0-220">관리자 프로세스</span><span class="sxs-lookup"><span data-stu-id="ba7f0-220">Admin Processes</span></span> | <span data-ttu-id="ba7f0-221">관리/관리 작업을 일회성 프로세스로 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-221">Run administrative/management tasks as one-off processes.</span></span> <span data-ttu-id="ba7f0-222">작업에는 보고서에 대한 데이터 정리 및 분석 끌어당기기가 포함될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-222">Tasks can include data cleanup and pulling analytics for a report.</span></span> <span data-ttu-id="ba7f0-223">이러한 작업을 실행하는 도구는 프로덕션 환경에서 호출해야 하지만 응용 프로그램과 는 별도로 호출해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-223">Tools executing these tasks should be  invoked from the production environment, but separately from the application.</span></span> |

<span data-ttu-id="ba7f0-224">책에서, [열두 요인 응용 프로그램을 넘어,](https://content.pivotal.io/blog/beyond-the-twelve-factor-app)저자 케빈 호프만 (2011 년에 작성) 원래 12 요인의 각각을 자세히 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-224">In the book, [Beyond the Twelve-Factor App](https://content.pivotal.io/blog/beyond-the-twelve-factor-app), author Kevin Hoffman details each of the original 12 factors (written in 2011).</span></span> <span data-ttu-id="ba7f0-225">또한 이 책에서는 오늘날의 최신 클라우드 응용 프로그램 디자인을 반영하는 세 가지 추가 요소를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-225">Additionally, the book provides three additional factors that reflect today's modern cloud application design.</span></span>

|    |  <span data-ttu-id="ba7f0-226">새 요소</span><span class="sxs-lookup"><span data-stu-id="ba7f0-226">New Factor</span></span> | <span data-ttu-id="ba7f0-227">설명</span><span class="sxs-lookup"><span data-stu-id="ba7f0-227">Explanation</span></span>  |
| :-------- | :-------- | :-------- |
| <span data-ttu-id="ba7f0-228">13</span><span class="sxs-lookup"><span data-stu-id="ba7f0-228">13</span></span> | <span data-ttu-id="ba7f0-229">API 우선</span><span class="sxs-lookup"><span data-stu-id="ba7f0-229">API First</span></span> | <span data-ttu-id="ba7f0-230">모든 것을 서비스로 만드십시오.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-230">Make everything a service.</span></span> <span data-ttu-id="ba7f0-231">코드가 프런트 엔드 클라이언트, 게이트웨이 또는 다른 서비스에서 사용된다고 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-231">Assume your code will be consumed by a front-end client, gateway, or another service.</span></span> |
| <span data-ttu-id="ba7f0-232">14</span><span class="sxs-lookup"><span data-stu-id="ba7f0-232">14</span></span> | <span data-ttu-id="ba7f0-233">원격 분석</span><span class="sxs-lookup"><span data-stu-id="ba7f0-233">Telemetry</span></span> | <span data-ttu-id="ba7f0-234">워크스테이션에서 응용 프로그램 및 해당 동작에 대한 심층적인 가시성을 확보할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-234">On a workstation, you have deep visibility into your application and its behavior.</span></span> <span data-ttu-id="ba7f0-235">클라우드에서는 그렇지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-235">In the cloud, you don't.</span></span> <span data-ttu-id="ba7f0-236">디자인에 모니터링, 도메인별 및 상태/시스템 데이터의 컬렉션이 포함되어 있는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-236">Make sure your design includes the collection of monitoring, domain-specific, and health/system data.</span></span> |
| <span data-ttu-id="ba7f0-237">15</span><span class="sxs-lookup"><span data-stu-id="ba7f0-237">15</span></span> | <span data-ttu-id="ba7f0-238">인증/권한 부여</span><span class="sxs-lookup"><span data-stu-id="ba7f0-238">Authentication/ Authorization</span></span>  | <span data-ttu-id="ba7f0-239">처음부터 ID를 구현합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-239">Implement identity from the start.</span></span> <span data-ttu-id="ba7f0-240">공용 클라우드에서 사용할 수 있는 [RBAC(역할 기반 액세스 제어)](https://docs.microsoft.com/azure/role-based-access-control/overview) 기능을 고려합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-240">Consider [RBAC (role-based access control)](https://docs.microsoft.com/azure/role-based-access-control/overview) features available in public clouds.</span></span>  |

<span data-ttu-id="ba7f0-241">이 장과 책 전체에 걸쳐 12+ 요인의 많은 참조 합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-241">We'll refer to many of the 12+ factors in this chapter and throughout the book.</span></span>

### <a name="critical-design-considerations"></a><span data-ttu-id="ba7f0-242">중요한 설계 고려 사항</span><span class="sxs-lookup"><span data-stu-id="ba7f0-242">Critical Design Considerations</span></span>

<span data-ttu-id="ba7f0-243">12단계 방법론에서 제공하는 지침 외에도 분산 시스템을 구성할 때 결정해야 하는 몇 가지 중요한 설계 결정이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-243">Beyond the guidance provided from the twelve-factor methodology, there are several critical design decisions you must make when constructing distributed systems.</span></span>

<span data-ttu-id="ba7f0-244">*통신*</span><span class="sxs-lookup"><span data-stu-id="ba7f0-244">*Communication*</span></span>

<span data-ttu-id="ba7f0-245">프런트 엔드 클라이언트 응용 프로그램은 백업 형 핵심 서비스와 어떻게 통신할 것인가?</span><span class="sxs-lookup"><span data-stu-id="ba7f0-245">How will front-end client applications communicate with backed-end core services?</span></span> <span data-ttu-id="ba7f0-246">직접 통신을 허용하시겠습니까?</span><span class="sxs-lookup"><span data-stu-id="ba7f0-246">Will you allow direct communication?</span></span> <span data-ttu-id="ba7f0-247">또는 유연성, 제어 및 보안을 제공하는 게이트웨이 외관을 통해 백 엔드 서비스를 추상화할 수 있습니까?</span><span class="sxs-lookup"><span data-stu-id="ba7f0-247">Or, might you abstract the back-end services with a gateway façade that provides  flexibility, control, and security?</span></span>

<span data-ttu-id="ba7f0-248">백 엔드 코어 서비스는 서로 어떻게 통신할 것인가?</span><span class="sxs-lookup"><span data-stu-id="ba7f0-248">How will back-end core services communicate with each other?</span></span> <span data-ttu-id="ba7f0-249">커플링으로 이어지는 직접 HTTP 호출을 허용하고 성능과 민첩성에 영향을 미치도록 하시겠습니까?</span><span class="sxs-lookup"><span data-stu-id="ba7f0-249">Will you allow direct HTTP calls that lead to coupling and impact performance and agility?</span></span> <span data-ttu-id="ba7f0-250">또는 큐 및 토픽 기술과 분리된 메시징을 고려할 수 있습니까?</span><span class="sxs-lookup"><span data-stu-id="ba7f0-250">Or might you consider decoupled messaging with queue and topic technologies?</span></span>

<span data-ttu-id="ba7f0-251">통신은 4장, 클라우드 *네이티브 커뮤니케이션 패턴에*대해 자세히 다룹니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-251">Communication is covered in detail Chapter 4, *Cloud-Native Communication Patterns*.</span></span>

<span data-ttu-id="ba7f0-252">*복원력*</span><span class="sxs-lookup"><span data-stu-id="ba7f0-252">*Resiliency*</span></span>

<span data-ttu-id="ba7f0-253">마이크로 서비스 아키텍처는 시스템을 프로세스 내에서 네트워크 통신으로 이동합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-253">A microservices architecture moves your system from in-process to network communication.</span></span> <span data-ttu-id="ba7f0-254">분산 환경에서 서비스 B가 서비스 A의 호출에 응답하지 않을 때 어떻게 해야 합니까?</span><span class="sxs-lookup"><span data-stu-id="ba7f0-254">In a distributed environment, what will you do when Service B isn't responding to a call from Service A?</span></span> <span data-ttu-id="ba7f0-255">서비스 C가 일시적으로 사용할 수 없게 되고 다른 서비스가 스택을 호출하여 시스템 성능을 저하시키면 어떻게 됩니까?</span><span class="sxs-lookup"><span data-stu-id="ba7f0-255">What happens when Service C becomes up temporarily unavailable and other services calling it stack and degrade system performance?</span></span>

<span data-ttu-id="ba7f0-256">복원력은 6장, 클라우드 네이티브 *복원력에*대해 자세히 다룹니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-256">Resiliency is covered in detail Chapter 6, *Cloud-Native Resiliency*.</span></span>

<span data-ttu-id="ba7f0-257">*분산 데이터*</span><span class="sxs-lookup"><span data-stu-id="ba7f0-257">*Distributed Data*</span></span>

<span data-ttu-id="ba7f0-258">설계상 각 마이크로 서비스는 자체 데이터를 캡슐화하여 공용 인터페이스를 통해 작업을 노출합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-258">By design, each microservice encapsulates its own data, exposing operations via its public interface.</span></span> <span data-ttu-id="ba7f0-259">그렇다면 데이터를 쿼리하거나 여러 서비스에서 트랜잭션을 구현하려면 어떻게 해야 합니까?</span><span class="sxs-lookup"><span data-stu-id="ba7f0-259">If so, how do you query data or implement a transaction across multiple services?</span></span>

<span data-ttu-id="ba7f0-260">분산 데이터는 5장, *클라우드 네이티브 데이터 패턴에*대해 자세히 다룹니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-260">Distributed data is covered in detail Chapter 5, *Cloud-Native Data Patterns*.</span></span>

<span data-ttu-id="ba7f0-261">*ID*</span><span class="sxs-lookup"><span data-stu-id="ba7f0-261">*Identity*</span></span>

<span data-ttu-id="ba7f0-262">서비스에서 액세스하는 사람과 권한이 있는 권한을 어떻게 식별합니까?</span><span class="sxs-lookup"><span data-stu-id="ba7f0-262">How will your service identify who is accessing it and what permissions they have?</span></span>

<span data-ttu-id="ba7f0-263">ID는 세부 사항 장에서 다룹니다 장 8, *정체성*.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-263">Identity is covered in detail Chapter 8, *Identity*.</span></span>

## <a name="microservices"></a><span data-ttu-id="ba7f0-264">마이크로 서비스</span><span class="sxs-lookup"><span data-stu-id="ba7f0-264">Microservices</span></span>

<span data-ttu-id="ba7f0-265">클라우드 네이티브 시스템은 최신 응용 프로그램을 구성하기 위한 인기 있는 아키텍처 스타일인 마이크로 서비스를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-265">Cloud-native systems embrace microservices, a popular architectural style for constructing modern applications.</span></span>

<span data-ttu-id="ba7f0-266">공유 패브릭을 통해 상호 작용하는 작고 독립적인 서비스의 분산 된 집합으로 구축 된 마이크로 서비스는 다음과 같은 특성을 공유합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-266">Built as a distributed set of small, independent services that interact through a shared fabric, microservices share the following characteristics:</span></span>

- <span data-ttu-id="ba7f0-267">각 기능은 더 큰 도메인 컨텍스트 내에서 특정 비즈니스 기능을 구현합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-267">Each implements a specific business capability within a larger domain context.</span></span>

- <span data-ttu-id="ba7f0-268">각각은 자율적으로 개발되며 독립적으로 배포할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-268">Each is developed autonomously and can be deployed independently.</span></span>

- <span data-ttu-id="ba7f0-269">각각은 자체 데이터 스토리지 기술(SQL, NoSQL) 및 프로그래밍 플랫폼을 캡슐화하는 독립적인 것입니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-269">Each is self-contained encapsulating its own data storage technology (SQL, NoSQL) and programming platform.</span></span>

- <span data-ttu-id="ba7f0-270">각 프로세스는 자체 프로세스에서 실행되며 HTTP/HTTPS, WebSockets 또는 [AMQP와](https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol)같은 표준 통신 프로토콜을 사용하여 다른 사용자와 통신합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-270">Each runs in its own process and communicates with others using standard communication protocols such as HTTP/HTTPS, WebSockets, or [AMQP](https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol).</span></span>

- <span data-ttu-id="ba7f0-271">그들은 응용 프로그램을 형성하기 위해 함께 작성합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-271">They compose together to form an application.</span></span>

<span data-ttu-id="ba7f0-272">그림 1-4는 모놀리식 응용 프로그램 접근 방식과 마이크로 서비스 접근 방식을 대조합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-272">Figure 1-4 contrasts a monolithic application approach with a microservices approach.</span></span> <span data-ttu-id="ba7f0-273">모놀리스는 단일 프로세스에서 실행되는 계층화된 아키텍처로 구성되는 방법을 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-273">Note how the monolith is composed of a layered architecture, which executes in a single process.</span></span> <span data-ttu-id="ba7f0-274">일반적으로 관계형 데이터베이스를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-274">It typically consumes a relational database.</span></span> <span data-ttu-id="ba7f0-275">그러나 마이크로 서비스 접근 방식은 기능을 논리 및 데이터를 포함하는 독립적인 서비스로 분리합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-275">The microservice approach, however, segregates functionality into independent services that include logic and data.</span></span> <span data-ttu-id="ba7f0-276">각 마이크로 서비스는 자체 데이터 스토어를 호스팅합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-276">Each microservice hosts its own datastore.</span></span>

![모놀리식 배포와 마이크로 서비스](./media/monolithic-vs-microservices.png)

<span data-ttu-id="ba7f0-278">**그림 1-4.**</span><span class="sxs-lookup"><span data-stu-id="ba7f0-278">**Figure 1-4.**</span></span> <span data-ttu-id="ba7f0-279">모놀리식 배포와 마이크로 서비스</span><span class="sxs-lookup"><span data-stu-id="ba7f0-279">Monolithic deployment versus microservices</span></span>

<span data-ttu-id="ba7f0-280">마이크로 서비스가 이 장의 앞에서 설명한 [12단계 응용 프로그램에서](https://12factor.net/)"하나의 코드베이스, 하나의 응용 프로그램" 원칙을 승격하는 방법을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-280">Note how microservices promote the "One Codebase, One Application" principle from the [Twelve-Factor Application](https://12factor.net/), discussed earlier in the chapter.</span></span>

> <span data-ttu-id="ba7f0-281">*요소 \#1은 "자체 리포지토리에 저장된 각 마이크로 서비스에 대한 단일 코드베이스"를 지정합니다. 버전 제어를 통해 추적하면 여러 환경에 배포할 수 있습니다."*</span><span class="sxs-lookup"><span data-stu-id="ba7f0-281">*Factor \#1  specifies "A single codebase for each microservice, stored in its own repository. Tracked with version control, it can deploy to multiple environments."*</span></span>

### <a name="why-microservices"></a><span data-ttu-id="ba7f0-282">마이크로 서비스를 사용하는 이유는 무엇인가요?</span><span class="sxs-lookup"><span data-stu-id="ba7f0-282">Why microservices?</span></span>

<span data-ttu-id="ba7f0-283">마이크로 서비스는 민첩성을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-283">Microservices provide agility.</span></span>

<span data-ttu-id="ba7f0-284">이 장의 이전 부분에서는 모놀리스로 빌드된 전자 상거래 응용 프로그램을 마이크로 서비스와 비교했습니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-284">Earlier in the chapter, we compared an eCommerce application built as a monolith to that with microservices.</span></span> <span data-ttu-id="ba7f0-285">이 예제에서는 다음과 같은 몇 가지 명확한 이점을 보았습니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-285">In the example, we saw some clear benefits:</span></span>

- <span data-ttu-id="ba7f0-286">각 마이크로 서비스에는 자율적인 수명 주기가 있으며 독립적으로 진화하고 자주 배포할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-286">Each microservice has an autonomous lifecycle and can evolve independently and deploy frequently.</span></span> <span data-ttu-id="ba7f0-287">새 기능이나 업데이트를 배포하기 위해 분기별 릴리스를 기다릴 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-287">You don't have to wait for a quarterly release to deploy a new features or update.</span></span> <span data-ttu-id="ba7f0-288">복잡한 응용 프로그램의 작은 영역을 업데이트하여 전체 시스템을 중단할 위험이 적습니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-288">You can update a small area of a complex application with less risk of disrupting the entire system.</span></span>

- <span data-ttu-id="ba7f0-289">각 마이크로 서비스는 독립적으로 확장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-289">Each microservice can scale independently.</span></span> <span data-ttu-id="ba7f0-290">전체 응용 프로그램을 단일 단위로 확장하는 대신 더 많은 처리 능력이나 네트워크 대역폭이 필요한 서비스만 확장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-290">Instead of scaling the entire application as a single unit, you scale out only those services that require more processing power or network bandwidth.</span></span> <span data-ttu-id="ba7f0-291">이 세분화된 확장 방식은 시스템을 보다 잘 제어할 수 있도록 하고 모든 것이 아니라 시스템의 일부를 확장할 때 전체 비용을 절감하는 데 도움이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-291">This  fine-grained approach to scaling provides for greater control of your system and helps to reduce overall costs as you scale portions of your system, not everything.</span></span>

<span data-ttu-id="ba7f0-292">마이크로 서비스를 이해하기 위한 훌륭한 참조 가이드는 [.NET 마이크로 서비스: 컨테이너화된 .NET 응용 프로그램에 대한 아키텍처입니다.](https://docs.microsoft.com/dotnet/standard/microservices-architecture/)</span><span class="sxs-lookup"><span data-stu-id="ba7f0-292">An excellent reference guide for understanding microservices is [.NET Microservices: Architecture for Containerized .NET Applications](https://docs.microsoft.com/dotnet/standard/microservices-architecture/).</span></span> <span data-ttu-id="ba7f0-293">이 책은 마이크로 서비스 설계 및 아키텍처에 대해 심층분석합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-293">The book deep dives into microservices design and architecture.</span></span> <span data-ttu-id="ba7f0-294">Microsoft에서 무료로 다운로드할 수 있는 [전체 스택 마이크로 서비스 참조 아키텍처의](https://github.com/dotnet-architecture/eShopOnContainers) 동반자입니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-294">It's a companion for a [full-stack microservice reference architecture](https://github.com/dotnet-architecture/eShopOnContainers) available as a free download from Microsoft.</span></span>

### <a name="developing-microservices"></a><span data-ttu-id="ba7f0-295">마이크로 서비스 개발</span><span class="sxs-lookup"><span data-stu-id="ba7f0-295">Developing microservices</span></span>

<span data-ttu-id="ba7f0-296">마이크로 서비스는 모든 최신 개발 플랫폼으로 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-296">Microservices can be created with any modern development platform.</span></span>

<span data-ttu-id="ba7f0-297">Microsoft .NET 코어 플랫폼은 탁월한 선택입니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-297">The Microsoft .NET Core platform is an excellent choice.</span></span> <span data-ttu-id="ba7f0-298">무료 및 오픈 소스, 그것은 마이크로 서비스 개발을 단순화 하기 위해 많은 내장 된 기능을 가지고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-298">Free and open source, it has many built-in features to simplify microservice development.</span></span> <span data-ttu-id="ba7f0-299">.NET 코어는 크로스 플랫폼입니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-299">.NET Core is cross-platform.</span></span> <span data-ttu-id="ba7f0-300">응용 프로그램을 빌드하 고 윈도우에서 실행할 수 있습니다., macOS, 그리고 리눅스의 대부분의 맛.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-300">Applications can be built and run on Windows, macOS, and most flavors of Linux.</span></span>

<span data-ttu-id="ba7f0-301">.NET Core는 Node.js 및 기타 경쟁 플랫폼에 비해 성능이 뛰어나고 성과가 우수합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-301">.NET Core is highly performant and has scored well in comparison to Node.js and other competing platforms.</span></span> <span data-ttu-id="ba7f0-302">흥미롭게도 [TechEmpower는](https://www.techempower.com/) 많은 웹 응용 프로그램 플랫폼 및 프레임워크에서 광범위한 [성능 벤치마크](https://www.techempower.com/benchmarks/#section=data-r17&hw=ph&test=plaintext) 집합을 수행했습니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-302">Interestingly, [TechEmpower](https://www.techempower.com/) conducted an extensive set of [performance benchmarks](https://www.techempower.com/benchmarks/#section=data-r17&hw=ph&test=plaintext) across many web application platforms and frameworks.</span></span> <span data-ttu-id="ba7f0-303">.NET Core는 Node.js 및 기타 경쟁 플랫폼보다 훨씬 높은 상위 10위 안에 들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-303">.NET Core scored in the top 10 - well above Node.js and other competing platforms.</span></span>

<span data-ttu-id="ba7f0-304">.NET 코어는 마이크로소프트와 GitHub의 .NET 커뮤니티에서 관리합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-304">.NET Core is maintained by Microsoft and the .NET community on GitHub.</span></span>

## <a name="containers"></a><span data-ttu-id="ba7f0-305">컨테이너</span><span class="sxs-lookup"><span data-stu-id="ba7f0-305">Containers</span></span>

<span data-ttu-id="ba7f0-306">요즘에는 *클라우드 네이티브에*관한 대화에서 언급 된 *컨테이너라는* 용어를 듣는 것은 자연스러운 것입니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-306">Nowadays, it's natural to hear the term *container* mentioned in any conversation concerning *cloud native*.</span></span> <span data-ttu-id="ba7f0-307">이 책에서 [클라우드 네이티브 패턴의](https://www.manning.com/books/cloud-native-patterns)저자 코넬리아 데이비스는 "컨테이너는 클라우드 네이티브 소프트웨어의 훌륭한 원동력"이라고 말합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-307">In the book, [Cloud Native Patterns](https://www.manning.com/books/cloud-native-patterns), author Cornelia Davis observes that, "Containers are a great enabler of cloud-native software."</span></span> <span data-ttu-id="ba7f0-308">클라우드 네이티브 컴퓨팅 재단은 클라우드 [네이티브 트레일 맵의](https://raw.githubusercontent.com/cncf/trailmap/master/CNCF_TrailMap_latest.png) 첫 번째 단계로 마이크로 서비스 컨테이너화를 배치합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-308">The Cloud Native Computing Foundation places microservice containerization as the first step in their [Cloud-Native Trail Map](https://raw.githubusercontent.com/cncf/trailmap/master/CNCF_TrailMap_latest.png) - guidance for enterprises beginning their cloud-native journey.</span></span>

<span data-ttu-id="ba7f0-309">마이크로 서비스를 컨테이너화하는 것은 간단하고 간단합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-309">Containerizing a microservice is simple and straightforward.</span></span> <span data-ttu-id="ba7f0-310">코드, 해당 종속성 및 런타임은 [컨테이너 이미지라는](https://docs.docker.com/glossary/?term=image)바이너리로 패키징됩니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-310">The code, its dependencies, and runtime are packaged into a binary called a [container image](https://docs.docker.com/glossary/?term=image).</span></span> <span data-ttu-id="ba7f0-311">이미지는 이미지의 리포지토리 또는 라이브러리 역할을 하는 [컨테이너 레지스트리에](https://caylent.com/container-registries/)저장됩니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-311">Images are stored in a [container registry](https://caylent.com/container-registries/), which acts as a repository or library for images.</span></span> <span data-ttu-id="ba7f0-312">레지스트리는 개발 컴퓨터, 데이터 센터 또는 공용 클라우드에 위치할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-312">A registry can be located on your development computer, in your data center, or in a public cloud.</span></span> <span data-ttu-id="ba7f0-313">Docker 자체는 [Docker Hub를](https://hub.docker.com/)통해 공용 레지스트리를 유지 관리합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-313">Docker itself maintains a public registry via [Docker Hub](https://hub.docker.com/).</span></span> <span data-ttu-id="ba7f0-314">Azure 클라우드에는 컨테이너 [레지스트리를](https://azure.microsoft.com/services/container-registry/) 사용하여 컨테이너 이미지를 실행하는 클라우드 응용 프로그램에 가까운 컨테이너 이미지를 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-314">The Azure cloud features a [container registry](https://azure.microsoft.com/services/container-registry/) to store container images close to the cloud applications that will run them.</span></span>

<span data-ttu-id="ba7f0-315">필요한 경우 이미지를 실행 중인 컨테이너 인스턴스로 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-315">When needed, you transform the image into a running container instance.</span></span> <span data-ttu-id="ba7f0-316">인스턴스는 [컨테이너 런타임](https://kubernetes.io/docs/setup/production-environment/container-runtimes/) 엔진이 설치된 모든 컴퓨터에서 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-316">The instance runs on any computer that has a [container runtime](https://kubernetes.io/docs/setup/production-environment/container-runtimes/) engine installed.</span></span> <span data-ttu-id="ba7f0-317">필요에 따라 컨테이너화된 서비스의 인스턴스를 최대한 많이 가질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-317">You can have as many instances of the containerized service as needed.</span></span>

<span data-ttu-id="ba7f0-318">그림 1-5는 각각 자체 컨테이너에 있는 세 가지 서로 다른 마이크로 서비스를 보여 주며 단일 호스트에서 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-318">Figure 1-5 shows three different microservices, each in its own container, running on a single host.</span></span>

![컨테이너 호스트에서 실행되는 여러 컨테이너](./media/hosting-mulitple-containers.png)

<span data-ttu-id="ba7f0-320">**그림 1-5 .**</span><span class="sxs-lookup"><span data-stu-id="ba7f0-320">**Figure 1-5**.</span></span> <span data-ttu-id="ba7f0-321">컨테이너 호스트에서 실행되는 여러 컨테이너</span><span class="sxs-lookup"><span data-stu-id="ba7f0-321">Multiple containers running on a container host</span></span>

<span data-ttu-id="ba7f0-322">각 컨테이너가 서로 다를 수 있는 자체 종속성 및 런타임 집합을 유지하는 방법을 참고합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-322">Note how each container maintains its own set of dependencies and runtime, which can be different.</span></span> <span data-ttu-id="ba7f0-323">여기서는 동일한 호스트에서 실행되는 제품 마이크로 서비스의 다른 버전을 볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-323">Here, we see different versions of the Product microservice running on the same host.</span></span> <span data-ttu-id="ba7f0-324">각 컨테이너는 기본 호스트 운영 체제, 메모리 및 프로세서의 조각을 공유하지만 서로 격리됩니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-324">Each container shares a slice of the underlying host operating system, memory, and processor, but is isolated from one another.</span></span>

<span data-ttu-id="ba7f0-325">컨테이너 모델이 [12단계 응용 프로그램의](https://12factor.net/)"종속성" 원칙을 얼마나 잘 수용하는지 주목하십시오.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-325">Note how well the container model embraces the "Dependencies" principle from the [Twelve-Factor Application](https://12factor.net/).</span></span>

> <span data-ttu-id="ba7f0-326">*팩터 \#2는 "각 마이크로 서비스는 전체 시스템에 영향을 주지 않고 변경 내용을 수용하면서 자체 종속성을 격리하고 패키지화합니다."*</span><span class="sxs-lookup"><span data-stu-id="ba7f0-326">*Factor \#2  specifies that "Each microservice isolates and packages its own dependencies, embracing changes without impacting the entire system."*</span></span>

<span data-ttu-id="ba7f0-327">컨테이너는 Linux 및 Windows 워크로드를 모두 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-327">Containers support both Linux and Windows workloads.</span></span> <span data-ttu-id="ba7f0-328">Azure 클라우드는 공개적으로 둘 다 를 포용합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-328">The Azure cloud openly embraces both.</span></span> <span data-ttu-id="ba7f0-329">흥미롭게도, 그것은 리눅스, 윈도우 서버, 그 Azure에서 가장 인기 있는 운영 체제되고있다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-329">Interestingly, it's Linux, not Windows Server, that has become the most popular operating system in Azure.</span></span>

<span data-ttu-id="ba7f0-330">여러 컨테이너 공급 업체가 존재하는 동안 Docker는 사자의 시장 점유율을 점령했습니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-330">While several container vendors exist, Docker has captured the lion's share of the market.</span></span> <span data-ttu-id="ba7f0-331">이 회사는 소프트웨어 컨테이너 운동을 주도하고 있다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-331">The company has been driving the software container movement.</span></span> <span data-ttu-id="ba7f0-332">클라우드 네이티브 응용 프로그램을 패키징, 배포 및 실행하기 위한 사실상의 표준이 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-332">It has become the de facto standard for packaging, deploying, and running cloud-native applications.</span></span>

### <a name="why-containers"></a><span data-ttu-id="ba7f0-333">왜 컨테이너인가?</span><span class="sxs-lookup"><span data-stu-id="ba7f0-333">Why containers?</span></span>

<span data-ttu-id="ba7f0-334">컨테이너는 이식성을 제공하고 환경 전반에 걸쳐 일관성을 보장합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-334">Containers provide portability and guarantee consistency across environments.</span></span> <span data-ttu-id="ba7f0-335">모든 것을 단일 패키지로 캡슐화하면 마이크로 서비스와 해당 종속성을 기본 인프라에서 *격리할* 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-335">By encapsulating everything into a single package, you *isolate* the microservice and its dependencies from the underlying infrastructure.</span></span>

<span data-ttu-id="ba7f0-336">Docker 런타임 엔진이 있는 모든 환경에서 동일한 컨테이너를 배포할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-336">You can deploy that same container in any environment that has the Docker runtime engine.</span></span> <span data-ttu-id="ba7f0-337">또한 컨테이너화된 워크로드는 프레임워크, 소프트웨어 라이브러리 및 런타임 엔진을 통해 각 환경을 미리 구성하는 비용을 제거합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-337">Containerized workloads also eliminate the expense of pre-configuring each environment with frameworks, software libraries, and runtime engines.</span></span>

<span data-ttu-id="ba7f0-338">기본 운영 체제 및 호스트 리소스를 공유하면 컨테이너의 설치 공간이 전체 가상 시스템보다 훨씬 작습니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-338">By sharing the underlying operating system and host resources, containers have a much smaller footprint than a full virtual machine.</span></span> <span data-ttu-id="ba7f0-339">크기가 작을수록 지정된 호스트가 한 번에 실행할 수 있는 *밀도*또는 마이크로 서비스 수가 증가합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-339">The smaller size increases the *density*, or number of microservices, that a given host can run at one time.</span></span>

### <a name="container-orchestration"></a><span data-ttu-id="ba7f0-340">컨테이너 오케스트레이션</span><span class="sxs-lookup"><span data-stu-id="ba7f0-340">Container orchestration</span></span>

<span data-ttu-id="ba7f0-341">Docker와 같은 도구는 이미지를 만들고 컨테이너를 실행하는 동안 이를 관리하는 도구도 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-341">While tools such as Docker create images and run containers, you also need tools to manage them.</span></span> <span data-ttu-id="ba7f0-342">컨테이너 관리는 컨테이너 오케스트레이터라는 특수 소프트웨어 프로그램으로 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-342">Container management is done with a special software program called a container orchestrator.</span></span> <span data-ttu-id="ba7f0-343">대규모로 작동할 때 컨테이너 오케스트레이션이 필수적입니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-343">When operating at scale, container orchestration is essential.</span></span>

<span data-ttu-id="ba7f0-344">그림 1-6은 컨테이너 오케스트레이터가 제공하는 관리 작업을 보여 주었습니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-344">Figure 1-6 shows management tasks that container orchestrators provide.</span></span>

![컨테이너 오케스트레이터가 수행하는 일](./media/what-container-orchestrators-do.png)

<span data-ttu-id="ba7f0-346">**그림 1-6**.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-346">**Figure 1-6**.</span></span> <span data-ttu-id="ba7f0-347">컨테이너 오케스트레이터가 수행하는 일</span><span class="sxs-lookup"><span data-stu-id="ba7f0-347">What container orchestrators do</span></span>

<span data-ttu-id="ba7f0-348">다음 표는 일반적인 오케스트레이션 작업에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-348">The following table describes common orchestration tasks.</span></span>

|  <span data-ttu-id="ba7f0-349">작업</span><span class="sxs-lookup"><span data-stu-id="ba7f0-349">Tasks</span></span> | <span data-ttu-id="ba7f0-350">설명</span><span class="sxs-lookup"><span data-stu-id="ba7f0-350">Explanation</span></span>  |
| :-------- | :-------- |
| <span data-ttu-id="ba7f0-351">일정 계획</span><span class="sxs-lookup"><span data-stu-id="ba7f0-351">Scheduling</span></span> | <span data-ttu-id="ba7f0-352">컨테이너 인스턴스를 자동으로 프로비전합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-352">Automatically provision container instances.</span></span>|
| <span data-ttu-id="ba7f0-353">선호도/안티 친화성</span><span class="sxs-lookup"><span data-stu-id="ba7f0-353">Affinity/anti-affinity</span></span> | <span data-ttu-id="ba7f0-354">근처 또는 서로 멀리 떨어진 컨테이너를 프로비저닝하여 가용성과 성능을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-354">Provision containers nearby or far apart from each other, helping  availability and performance.</span></span> |
| <span data-ttu-id="ba7f0-355">상태 모니터링</span><span class="sxs-lookup"><span data-stu-id="ba7f0-355">Health monitoring</span></span> | <span data-ttu-id="ba7f0-356">오류를 자동으로 감지하고 수정합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-356">Automatically detect and correct failures.</span></span>|
| <span data-ttu-id="ba7f0-357">장애 조치</span><span class="sxs-lookup"><span data-stu-id="ba7f0-357">Failover</span></span> | <span data-ttu-id="ba7f0-358">실패한 인스턴스를 정상 시스템에 자동으로 다시 프로비전합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-358">Automatically reprovision failed instance to healthy machines.</span></span>|
| <span data-ttu-id="ba7f0-359">확장</span><span class="sxs-lookup"><span data-stu-id="ba7f0-359">Scaling</span></span> | <span data-ttu-id="ba7f0-360">수요를 충족하기 위해 컨테이너 인스턴스를 자동으로 추가하거나 제거합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-360">Automatically add or remove container instance to meet demand.</span></span>|
| <span data-ttu-id="ba7f0-361">네트워킹</span><span class="sxs-lookup"><span data-stu-id="ba7f0-361">Networking</span></span> | <span data-ttu-id="ba7f0-362">컨테이너 통신을 위한 네트워킹 오버레이를 관리합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-362">Manage a networking overlay for container communication.</span></span>|
| <span data-ttu-id="ba7f0-363">서비스 검색</span><span class="sxs-lookup"><span data-stu-id="ba7f0-363">Service Discovery</span></span> | <span data-ttu-id="ba7f0-364">컨테이너가 서로를 찾을 수 있도록 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-364">Enable containers to locate each other.</span></span>|
| <span data-ttu-id="ba7f0-365">롤링 업그레이드</span><span class="sxs-lookup"><span data-stu-id="ba7f0-365">Rolling Upgrades</span></span> | <span data-ttu-id="ba7f0-366">가동 중지 시간 배포가 전혀 없는 증분 업그레이드를 조정합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-366">Coordinate incremental upgrades with zero downtime deployment.</span></span> <span data-ttu-id="ba7f0-367">문제가 있는 변경 내용을 자동으로 롤백합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-367">Automatically roll back problematic changes.</span></span>|

<span data-ttu-id="ba7f0-368">오케스트레이터가 이 장의 앞에서 설명한 [12단계 응용 프로그램의](https://12factor.net/)폐기 가능성 및 동시성 원칙을 어떻게 받아들이는지 주목하십시오.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-368">Note how orchestrators embrace the disposability and concurrency principles from the [Twelve-Factor Application](https://12factor.net/), discussed earlier in the chapter.</span></span>

> <span data-ttu-id="ba7f0-369">*팩터 \#9는 "서비스 인스턴스는 일회용이어야 하며, 빠른 신생 기업은 확장성 기회를 늘리고 시스템을 올바른 상태로 두는 우아한 종료를 선호합니다. 오케스트레이터와 함께 Docker 컨테이너는 본질적으로 이 요구 사항을 충족합니다."*</span><span class="sxs-lookup"><span data-stu-id="ba7f0-369">*Factor \#9  specifies that "Service instances should be disposable, favoring fast startups to increase scalability opportunities and graceful shutdowns to leave the system in a correct state. Docker containers along with an orchestrator inherently satisfy this requirement."*</span></span>

> <span data-ttu-id="ba7f0-370">*팩터 \#8은 "사용 가능한 가장 강력한 컴퓨터에서 단일 큰 인스턴스를 확장하는 것이 아니라 많은 수의 작은 동일한 프로세스(복사본)에서 서비스가 확장되도록 지정합니다."*</span><span class="sxs-lookup"><span data-stu-id="ba7f0-370">*Factor \#8  specifies that "Services scale out across a large number of small identical processes (copies) as opposed to scaling-up a single large instance on the most powerful machine available."*</span></span>

<span data-ttu-id="ba7f0-371">여러 컨테이너 오케스트레이터가 존재하지만 [Kubernetes는](https://kubernetes.io/docs/concepts/overview/what-is-kubernetes/) 클라우드 네이티브 세계의 사실상 표준이 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-371">While several container orchestrators exist, [Kubernetes](https://kubernetes.io/docs/concepts/overview/what-is-kubernetes/) has become the de facto standard for the cloud-native world.</span></span> <span data-ttu-id="ba7f0-372">컨테이너화된 워크로드를 관리하기 위한 이식가능한 확장 가능한 오픈 소스 플랫폼입니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-372">It's a portable, extensible, open-source platform for managing containerized workloads.</span></span>

<span data-ttu-id="ba7f0-373">Kubernetes의 자체 인스턴스를 호스팅할 수 있지만 복잡할 수 있는 리소스를 프로비저닝하고 관리할 책임이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-373">You could host your own instance of Kubernetes, but then you'd be responsible for provisioning and managing its resources - which can be complex.</span></span> <span data-ttu-id="ba7f0-374">Azure 클라우드는 관리되는 서비스인 AZURE [Kubernetes 서비스(AKS)로 Kubernetes를](https://azure.microsoft.com/services/kubernetes-service/)특징으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-374">The Azure cloud features Kubernetes as a managed service, [Azure Kubernetes Service (AKS)](https://azure.microsoft.com/services/kubernetes-service/).</span></span> <span data-ttu-id="ba7f0-375">관리형 서비스를 사용하면 기능을 설치하고 유지 관리할 필요 없이 기능을 완전히 활용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-375">A managed service allows you to fully leverage its features, without having to install and maintain it.</span></span>

<span data-ttu-id="ba7f0-376">Azure Kubernetes 서비스는 클라우드 네이티브 *응용 프로그램 크기 조정*2장에서 자세히 다룹니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-376">Azure Kubernetes Services is covered in detail Chapter 2, *Scaling Cloud-Native Applications*.</span></span>

## <a name="backing-services"></a><span data-ttu-id="ba7f0-377">백업 서비스</span><span class="sxs-lookup"><span data-stu-id="ba7f0-377">Backing services</span></span>

<span data-ttu-id="ba7f0-378">클라우드 네이티브 시스템은 데이터 저장소, 메시지 브로커, 모니터링 및 ID 서비스와 같은 다양한 보조 리소스에 의존합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-378">Cloud-native systems depend upon many different ancillary resources, such as data stores, message brokers, monitoring, and identity services.</span></span> <span data-ttu-id="ba7f0-379">이러한 서비스를 [백업 서비스라고](https://12factor.net/backing-services)합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-379">These services are known as [backing services](https://12factor.net/backing-services).</span></span>

 <span data-ttu-id="ba7f0-380">그림 1-7은 클라우드 네이티브 시스템에서 사용하는 많은 일반적인 백업 서비스를 보여 주며 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-380">Figure 1-7 shows many common backing services that cloud-native systems consume.</span></span>

![일반적인 백업 서비스](./media/common-backing-services.png)

<span data-ttu-id="ba7f0-382">**그림 1-7 .**</span><span class="sxs-lookup"><span data-stu-id="ba7f0-382">**Figure 1-7**.</span></span> <span data-ttu-id="ba7f0-383">일반적인 백업 서비스</span><span class="sxs-lookup"><span data-stu-id="ba7f0-383">Common backing services</span></span>

<span data-ttu-id="ba7f0-384">백업 서비스는 장 의 앞에서 설명한 [12단계 응용 프로그램에서](https://12factor.net/)"상태 비사용" 원칙을 촉진합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-384">Backing services promote the "Statelessness" principle from the [Twelve-Factor Application](https://12factor.net/), discussed earlier in the chapter.</span></span>

><span data-ttu-id="ba7f0-385">*팩터 \#6은* "각 마이크로 서비스는 실행 중인 다른 서비스와 격리된 자체 프로세스에서 실행되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-385">*Factor \#6* specifies that, "Each microservice should execute in its own process, isolated from other running services.</span></span> <span data-ttu-id="ba7f0-386">필요한 상태를 분산 캐시 또는 데이터 저장소와 같은 백업 서비스에 외부화합니다."</span><span class="sxs-lookup"><span data-stu-id="ba7f0-386">Externalize required state to a backing service such as a distributed cache or data store."</span></span>

<span data-ttu-id="ba7f0-387">자체 백업 서비스를 호스팅할 수 있지만 이러한 리소스에 대한 라이선스, 프로비저닝 및 관리를 담당해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-387">You could host your own backing services, but then you'd be responsible for licensing, provisioning, and managing those resources.</span></span>

<span data-ttu-id="ba7f0-388">클라우드 공급자는 *다양한 관리형 백업 서비스를 제공합니다.*</span><span class="sxs-lookup"><span data-stu-id="ba7f0-388">Cloud providers offer a rich assortment of *managed backing services.*</span></span> <span data-ttu-id="ba7f0-389">서비스를 소유하는 대신 단순히 서비스를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-389">Instead of owning the service, you simply consume it.</span></span> <span data-ttu-id="ba7f0-390">공급자는 대규모로 리소스를 운영하며 성능, 보안 및 유지 관리에 대한 책임을 집니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-390">The provider operates the resource at scale and bears the responsibility for performance, security, and maintenance.</span></span> <span data-ttu-id="ba7f0-391">모니터링, 중복 성 및 가용성이 서비스에 내장되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-391">Monitoring, redundancy, and availability are built into the service.</span></span> <span data-ttu-id="ba7f0-392">공급자는 관리되는 서비스를 완벽하게 지원하여 티켓을 열고 문제를 해결합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-392">Providers fully support their managed services - open a ticket and they fix your issue.</span></span>

<span data-ttu-id="ba7f0-393">클라우드 네이티브 시스템은 클라우드 공급업체의 관리되는 백업 서비스를 선호합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-393">Cloud-native systems favor managed backing services from cloud vendors.</span></span> <span data-ttu-id="ba7f0-394">시간과 노동력의 절감은 중대합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-394">The savings in time and labor are great.</span></span> <span data-ttu-id="ba7f0-395">직접 호스팅하고 문제를 경험할 경우 운영 상의 위험이 빠르게 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-395">The operational risk of hosting your own and experiencing trouble can get expensive fast.</span></span>

<span data-ttu-id="ba7f0-396">가장 좋은 방법은 백업 서비스를 *연결된 리소스로*처리하고 외부 구성에 저장된 정보(URL 및 자격 증명)가 있는 마이크로 서비스에 동적으로 바인딩되는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-396">A best practice is to treat a backing service as an *attached resource*, dynamically bound to a microservice with information (a URL and credentials) stored in an external configuration.</span></span> <span data-ttu-id="ba7f0-397">이 지침은 장 의 앞에서 설명한 [12단계 응용 프로그램에서](https://12factor.net/)설명되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-397">This guidance is spelled out in the [Twelve-Factor Application](https://12factor.net/), discussed earlier in the chapter.</span></span>

><span data-ttu-id="ba7f0-398">*팩터 \#4는* 백업 서비스가 주소 지정 가능한 URL을 통해 노출되어야 한다고 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-398">*Factor \#4* specifies that backing services "should be exposed via an addressable URL.</span></span> <span data-ttu-id="ba7f0-399">이렇게 하면 응용 프로그램에서 리소스가 분리되어 상호 교환할 수 있습니다."</span><span class="sxs-lookup"><span data-stu-id="ba7f0-399">Doing so decouples the resource from the application, enabling it to be interchangeable."</span></span>

><span data-ttu-id="ba7f0-400">*요소 \#3은* "구성 정보가 마이크로 서비스에서 이동하고 코드 외부의 구성 관리 도구를 통해 외부화됩니다."</span><span class="sxs-lookup"><span data-stu-id="ba7f0-400">*Factor \#3* specifies that "Configuration information is moved out of the microservice and externalized through a configuration management tool outside of the code."</span></span>

<span data-ttu-id="ba7f0-401">이 패턴을 사용하면 코드 변경 없이 백업 서비스를 연결 및 분리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-401">With this pattern, a backing service can be attached and detached without code changes.</span></span> <span data-ttu-id="ba7f0-402">QA에서 스테이징 환경으로 마이크로 서비스를 승격할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-402">You might promote a microservice from QA to a staging environment.</span></span> <span data-ttu-id="ba7f0-403">스테이징에서 백업 서비스를 가리키도록 마이크로 서비스 구성을 업데이트하고 환경 변수를 통해 컨테이너에 설정을 삽입합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-403">You update the microservice configuration to point to the backing services in staging and inject the settings into your container through an environment variable.</span></span>

<span data-ttu-id="ba7f0-404">클라우드 공급업체는 API를 제공하여 독점적인 백업 서비스와 통신할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-404">Cloud vendors provide APIs for you to communicate with their proprietary backing services.</span></span> <span data-ttu-id="ba7f0-405">이러한 라이브러리는 배관 및 복잡성을 캡슐화합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-405">These libraries encapsulate the plumbing and complexity.</span></span> <span data-ttu-id="ba7f0-406">이러한 API와 직접 통신하면 코드가 백업 서비스에 밀접하게 결합됩니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-406">Communicating directly with these APIs will tightly couple your code to the backing service.</span></span> <span data-ttu-id="ba7f0-407">공급업체 API의 구현 세부 정보를 절연하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-407">It's a better practice to insulate the implementation details of the vendor API.</span></span> <span data-ttu-id="ba7f0-408">서비스 코드에 제네릭 작업을 노출하는 중개 계층 또는 중간 API를 도입합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-408">Introduce an intermediation layer, or intermediate API, exposing generic operations to your service code.</span></span> <span data-ttu-id="ba7f0-409">이 느슨한 커플링을 사용하면 한 백업 서비스를 다른 서비스로 교체하거나 기본 서비스 코드를 변경하지 않고도 코드를 다른 공용 클라우드로 이동할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-409">This loose coupling enables you to swap out one backing service for another or move your code to a different public cloud without having to make changes to the mainline service code.</span></span>

<span data-ttu-id="ba7f0-410">백업 서비스는 5장, 클라우드 *네이티브 데이터 패턴*및 4장, *클라우드 네이티브 통신 패턴에*대해 자세히 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-410">Backing services are discussed in detail Chapter 5, *Cloud-Native Data Patterns*, and Chapter 4, *Cloud-Native Communication Patterns*.</span></span>

## <a name="automation"></a><span data-ttu-id="ba7f0-411">Automation</span><span class="sxs-lookup"><span data-stu-id="ba7f0-411">Automation</span></span>

<span data-ttu-id="ba7f0-412">보시다시말처럼 클라우드 네이티브 시스템은 마이크로 서비스, 컨테이너 및 최신 시스템 설계를 수용하여 속도와 민첩성을 달성합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-412">As you've seen, cloud-native systems embrace microservices, containers, and modern system design to achieve speed and agility.</span></span> <span data-ttu-id="ba7f0-413">하지만, 그것은 이야기의 일부에 불과합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-413">But, that's only part of the story.</span></span> <span data-ttu-id="ba7f0-414">이러한 시스템이 실행되는 클라우드 환경을 프로비전하려면 어떻게 해야 합니까?</span><span class="sxs-lookup"><span data-stu-id="ba7f0-414">How do you provision the cloud environments upon which these systems run?</span></span> <span data-ttu-id="ba7f0-415">앱 기능 및 업데이트를 신속하게 배포하려면 어떻게 해야 합니까?</span><span class="sxs-lookup"><span data-stu-id="ba7f0-415">How do you rapidly deploy app features and updates?</span></span> <span data-ttu-id="ba7f0-416">전체 그림을 어떻게 마무리합니까?</span><span class="sxs-lookup"><span data-stu-id="ba7f0-416">How do you round out the full picture?</span></span>

<span data-ttu-id="ba7f0-417">널리 받아들여지는 인프라 관행을 [코드](https://docs.microsoft.com/azure/devops/learn/what-is-infrastructure-as-code)또는 IaC로 입력합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-417">Enter the widely accepted practice of [Infrastructure as Code](https://docs.microsoft.com/azure/devops/learn/what-is-infrastructure-as-code), or IaC.</span></span>

<span data-ttu-id="ba7f0-418">IaC를 사용하면 플랫폼 프로비저닝 및 애플리케이션 배포를 자동화할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-418">With IaC, you automate platform provisioning and application deployment.</span></span> <span data-ttu-id="ba7f0-419">기본적으로 DevOps 사례에 테스트 및 버전 관리와 같은 소프트웨어 엔지니어링 관행을 적용합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-419">You essentially apply software engineering practices such as testing and versioning to your DevOps practices.</span></span> <span data-ttu-id="ba7f0-420">인프라와 배포는 자동화되고 일관되며 반복 가능합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-420">Your infrastructure and deployments are automated, consistent, and repeatable.</span></span>

### <a name="automating-infrastructure"></a><span data-ttu-id="ba7f0-421">인프라 자동화</span><span class="sxs-lookup"><span data-stu-id="ba7f0-421">Automating infrastructure</span></span>

<span data-ttu-id="ba7f0-422">Azure [리소스 관리자,](https://azure.microsoft.com/documentation/articles/resource-group-overview/)Terraform 및 [Azure CLI와](https://docs.microsoft.com/cli/azure/)같은 도구를 사용하면 필요한 클라우드 인프라를 선언적으로 스크립팅할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-422">Tools like [Azure Resource Manager](https://azure.microsoft.com/documentation/articles/resource-group-overview/), Terraform, and the [Azure CLI](https://docs.microsoft.com/cli/azure/), enable you to declaratively script the cloud infrastructure you require.</span></span> <span data-ttu-id="ba7f0-423">리소스 이름, 위치, 용량 및 비밀은 매개 변수화되고 동적입니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-423">Resource names, locations, capacities, and secrets are parameterized and dynamic.</span></span> <span data-ttu-id="ba7f0-424">스크립트는 버전이 정해지고 프로젝트의 아티팩트로 소스 제어로 체크 인됩니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-424">The script is versioned and checked into source control as an artifact of your project.</span></span> <span data-ttu-id="ba7f0-425">스크립트를 호출하여 QA, 스테이징 및 프로덕션과 같은 시스템 환경 전반에 걸쳐 일관되고 반복 가능한 인프라를 프로비전합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-425">You invoke the script to provision a consistent and repeatable infrastructure across system environments, such as QA, staging, and production.</span></span>

<span data-ttu-id="ba7f0-426">후드 아래, IaC는 idempotent, 부작용 없이 동일한 스크립트를 반복해서 실행할 수 있습니다 의미.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-426">Under the hood, IaC is idempotent, meaning that you can run the same script over and over without side effects.</span></span> <span data-ttu-id="ba7f0-427">팀에서 변경해야 하는 경우 스크립트를 편집하고 다시 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-427">If the team needs to make a change, they edit and rerun the script.</span></span> <span data-ttu-id="ba7f0-428">업데이트된 리소스만 영향을 받습니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-428">Only the updated resources are affected.</span></span>

<span data-ttu-id="ba7f0-429">이 [기사에서, 코드로 인프라란 무엇인가,](https://docs.microsoft.com/azure/devops/learn/what-is-infrastructure-as-code)저자 샘 구켄하이머는 "IaC를 구현하는 팀은 신속하고 대규모로 안정적인 환경을 제공 할 수있는 방법을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-429">In the article, [What is Infrastructure as Code](https://docs.microsoft.com/azure/devops/learn/what-is-infrastructure-as-code), Author Sam Guckenheimer describes how, "Teams who implement IaC can deliver stable environments rapidly and at scale.</span></span> <span data-ttu-id="ba7f0-430">팀은 코드를 통해 원하는 환경 상태를 나타내서 환경의 수동 구성을 방지하고 일관성을 적용합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-430">Teams avoid manual configuration of environments and enforce consistency by representing the desired state of their environments via code.</span></span> <span data-ttu-id="ba7f0-431">IaC를 사용하는 인프라 배포는 반복 가능하며 구성 드리프트 또는 누락된 종속성으로 인한 런타임 문제를 방지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-431">Infrastructure deployments with IaC are repeatable and prevent runtime issues caused by configuration drift or missing dependencies.</span></span> <span data-ttu-id="ba7f0-432">DevOps 팀은 통합된 관행 및 도구 세트와 함께 애플리케이션과 지원 인프라를 신속하고 안정적으로 확장할 수 있습니다."</span><span class="sxs-lookup"><span data-stu-id="ba7f0-432">DevOps teams can work together with a unified set of practices and tools to deliver applications and their supporting infrastructure rapidly, reliably, and at scale."</span></span>

### <a name="automating-deployments"></a><span data-ttu-id="ba7f0-433">배포 자동화</span><span class="sxs-lookup"><span data-stu-id="ba7f0-433">Automating deployments</span></span>

<span data-ttu-id="ba7f0-434">앞서 설명한 [12단계 응용 프로그램은](https://12factor.net/)완성된 코드를 실행 중인 응용 프로그램으로 변환할 때 별도의 단계를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-434">The [Twelve-Factor Application](https://12factor.net/), discussed earlier, calls for separate steps when transforming completed code into a running application.</span></span>

> <span data-ttu-id="ba7f0-435">*요소 \#5는* "각 릴리스는 빌드, 릴리스 및 실행 단계 간에 엄격한 분리를 적용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-435">*Factor \#5* specifies that "Each release must enforce a strict separation across the build, release and run stages.</span></span> <span data-ttu-id="ba7f0-436">각 ID는 고유 ID로 태그가 지정되고 롤백 할 수있는 기능을 지원해야합니다."</span><span class="sxs-lookup"><span data-stu-id="ba7f0-436">Each should be tagged with a unique ID and support the ability to roll back."</span></span>

<span data-ttu-id="ba7f0-437">최신 CI/CD 시스템은 이러한 원칙을 충족하는 데 도움이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-437">Modern CI/CD systems help fulfill this principle.</span></span> <span data-ttu-id="ba7f0-438">별도의 배포 단계를 제공하고 사용자가 쉽게 사용할 수 있는 일관되고 품질 좋은 코드를 보장하는 데 도움이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-438">They provide separate deployment steps and help ensure consistent and quality code that's readily available to users.</span></span>

<span data-ttu-id="ba7f0-439">그림 1-8은 배포 프로세스 간의 구분을 보여 주며,</span><span class="sxs-lookup"><span data-stu-id="ba7f0-439">Figure 1-8 shows the separation across the deployment process.</span></span>

![CI/CD 파이프라인의 배포 단계](./media/build-release-run-pipeline.png)

<span data-ttu-id="ba7f0-441">**그림 1-8 .**</span><span class="sxs-lookup"><span data-stu-id="ba7f0-441">**Figure 1-8**.</span></span> <span data-ttu-id="ba7f0-442">CI/CD 파이프라인의 배포 단계</span><span class="sxs-lookup"><span data-stu-id="ba7f0-442">Deployment steps in a CI/CD Pipeline</span></span>

<span data-ttu-id="ba7f0-443">이전 그림에서는 작업 분리에 특별한주의를 기울이기.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-443">In the previous figure, pay special attention to separation of tasks.</span></span>

<span data-ttu-id="ba7f0-444">개발자는 코드, 실행 및 디버그의 "내부 루프"를 반복하여 개발 환경에서 기능을 구성합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-444">The developer constructs a feature in their development environment, iterating through what is called the "inner loop" of code, run, and debug.</span></span> <span data-ttu-id="ba7f0-445">완료되면 해당 코드는 GitHub, Azure DevOps 또는 BitBucket과 같은 코드 리포지토리로 *푸시됩니다.*</span><span class="sxs-lookup"><span data-stu-id="ba7f0-445">When complete, that code is *pushed* into a code repository, such as GitHub, Azure DevOps, or BitBucket.</span></span>

<span data-ttu-id="ba7f0-446">푸시는 코드를 이진 아티팩트로 변환하는 빌드 단계를 트리거합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-446">The push triggers a build stage that transforms the code into a binary artifact.</span></span> <span data-ttu-id="ba7f0-447">이 작업은 [CI(연속 통합)](https://martinfowler.com/articles/continuousIntegration.html) 파이프라인으로 구현됩니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-447">The work is implemented with a [Continuous Integration (CI)](https://martinfowler.com/articles/continuousIntegration.html) pipeline.</span></span> <span data-ttu-id="ba7f0-448">응용 프로그램을 자동으로 빌드, 테스트 및 패키지로 구성합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-448">It automatically builds, tests, and packages the application.</span></span>

<span data-ttu-id="ba7f0-449">릴리스 단계에서는 이진 아티팩트를 선택하고 외부 응용 프로그램 및 환경 구성 정보를 적용하고 변경할 수 없는 릴리스를 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-449">The release stage picks up the binary artifact, applies external application and environment configuration information, and produces an immutable release.</span></span> <span data-ttu-id="ba7f0-450">릴리스는 지정된 환경에 배포됩니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-450">The release is deployed to a specified environment.</span></span> <span data-ttu-id="ba7f0-451">이 작업은 [CD(연속 배달)](https://martinfowler.com/bliki/ContinuousDelivery.html) 파이프라인으로 구현됩니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-451">The work is implemented with a [Continuous Delivery(CD)](https://martinfowler.com/bliki/ContinuousDelivery.html) pipeline.</span></span> <span data-ttu-id="ba7f0-452">각 릴리스는 식별할 수 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-452">Each release should be identifiable.</span></span> <span data-ttu-id="ba7f0-453">"이 배포는 응용 프로그램의 릴리스 2.1.1을 실행 중"이라고 말할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-453">You can say, "This deployment is running Release 2.1.1 of the application."</span></span>

<span data-ttu-id="ba7f0-454">마지막으로 릴리스된 기능은 대상 실행 환경에서 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-454">Finally, the released feature is run in the target execution environment.</span></span> <span data-ttu-id="ba7f0-455">릴리스는 변경 사항이 새 릴리스를 만들어야 한다는 것을 의미합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-455">Releases are immutable meaning that any change must create a new release.</span></span>

<span data-ttu-id="ba7f0-456">이러한 관행을 적용함으로써 조직은 소프트웨어를 출시하는 방식을 근본적으로 발전시고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-456">Applying these practices, organizations have radically evolved how they ship software.</span></span> <span data-ttu-id="ba7f0-457">많은 사람들이 분기별 릴리스에서 주문형 업데이트로 이동했습니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-457">Many have moved from quarterly releases to on-demand updates.</span></span> <span data-ttu-id="ba7f0-458">목표는 개발 주기 초기에 문제를 해결하는 데 비용이 적게 드는 경우 문제를 해결하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-458">The goal is to catch problems early in the development cycle when they're less expensive to fix.</span></span> <span data-ttu-id="ba7f0-459">통합 간의 기간이 길수록 더 많은 비용이 드는 문제를 해결할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-459">The longer the duration between integrations, the more expensive problems become to resolve.</span></span>  <span data-ttu-id="ba7f0-460">통합 프로세스의 일관성을 통해 팀은 코드 변경을 더 자주 커밋하여 협업 및 소프트웨어 품질을 높일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-460">With consistency in the integration process, teams can commit code changes more frequently, leading to better collaboration and software quality.</span></span>

### <a name="azure-pipelines"></a><span data-ttu-id="ba7f0-461">Azure Pipelines</span><span class="sxs-lookup"><span data-stu-id="ba7f0-461">Azure Pipelines</span></span>

<span data-ttu-id="ba7f0-462">Azure 클라우드에는 그림 1-9에 표시된 [Azure DevOps](https://azure.microsoft.com/services/devops/) 제품의 일부인 새 CI/CD 서비스인 [Azure 파이프라인이](https://azure.microsoft.com/services/devops/pipelines/)포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-462">The Azure cloud includes a new CI/CD service entitled [Azure Pipelines](https://azure.microsoft.com/services/devops/pipelines/), which is part of the [Azure DevOps](https://azure.microsoft.com/services/devops/) offering shown in Figure 1-9.</span></span>

![데브옵스의 Azure 파이프라인](./media/devops-components.png)

<span data-ttu-id="ba7f0-464">**그림 1-9 .**</span><span class="sxs-lookup"><span data-stu-id="ba7f0-464">**Figure 1-9**.</span></span> <span data-ttu-id="ba7f0-465">Azure DevOps 오퍼링</span><span class="sxs-lookup"><span data-stu-id="ba7f0-465">Azure DevOps offerings</span></span>

<span data-ttu-id="ba7f0-466">Azure 파이프라인은 CI(연속 통합)와 CD(연속 배달)를 결합한 클라우드 서비스입니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-466">Azure Pipelines is a cloud service that combines continuous integration (CI) and continuous delivery (CD).</span></span> <span data-ttu-id="ba7f0-467">코드를 자동으로 테스트, 빌드 및 모든 대상에 발송할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-467">You can automatically test, build, and ship your code to any target.</span></span>

<span data-ttu-id="ba7f0-468">YAML 파일의 코드에서 파이프라인을 앱의 나머지 코드와 함께 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-468">You define your pipeline in code in a YAML file alongside the rest of the code for your app.</span></span>

- <span data-ttu-id="ba7f0-469">파이프라인은 코드로 버전이 정해지며 동일한 분기 구조를 따릅니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-469">The pipeline is versioned with your code and follows the same branching structure.</span></span>
- <span data-ttu-id="ba7f0-470">끌어오기 요청 및 분기 빌드 정책에서 코드 검토를 통해 변경 사항에 대한 유효성을 검사할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-470">You get validation of your changes through code reviews in pull requests and branch build policies.</span></span>
- <span data-ttu-id="ba7f0-471">사용하는 모든 분기는 azure-pipelines.yml 파일을 수정하여 빌드 정책을 사용자 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-471">Every branch you use can customize the build policy by modifying the azure-pipelines.yml file.</span></span>
- <span data-ttu-id="ba7f0-472">파이프라인 파일은 버전 제어에 체크 인되어 문제가 있는 경우 조사할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-472">The pipeline file is checked into version control and can be investigated if there's a problem.</span></span>

<span data-ttu-id="ba7f0-473">Azure 파이프라인 서비스는 대부분의 Git 공급자를 지원하며 Linux, macOS 또는 Windows 플랫폼에 기록된 응용 프로그램에 대한 배포 파이프라인을 생성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-473">The Azure Pipelines service supports most Git providers and can generate deployment pipelines for applications written on the Linux, macOS, or Windows platforms.</span></span> <span data-ttu-id="ba7f0-474">여기에는 Java, .NET, 자바 스크립트, 파이썬, PHP, 이동, XCode 및 C ++에 대한 지원이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="ba7f0-474">It includes support for Java, .NET, JavaScript, Python, PHP, Go, XCode, and C++.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="ba7f0-475">[이전](introduction.md)
>[다음](candidate-apps.md)</span><span class="sxs-lookup"><span data-stu-id="ba7f0-475">[Previous](introduction.md)
[Next](candidate-apps.md)</span></span>

---
title: 클라우드 네이티브 정의
description: 클라우드 네이티브 시스템의 기반을 제공하는 기본 기둥에 대해 알아보십시오.
author: robvet
ms.date: 08/20/2019
ms.openlocfilehash: 756a2565bd77fcef19a5f15579987836ff0e75a4
ms.sourcegitcommit: e3cbf26d67f7e9286c7108a2752804050762d02d
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 04/09/2020
ms.locfileid: "80989092"
---
# <a name="defining-cloud-native"></a>클라우드 네이티브 정의

[!INCLUDE [book-preview](../../../includes/book-preview.md)]

현재 하고 있는 작업을 중지하고 동료 10명에게 문자를 보입니다. 그들에게 "클라우드 네이티브"라는 용어를 정의하도록 요청합니다. 좋은 기회는 당신은 여덟 가지 답변을 얻을 수 있습니다.

클라우드 네이티브는 중요한 비즈니스 시스템 구축에 대한 사고 방식을 바꾸는 것입니다.

클라우드 네이티브 시스템은 급격한 변화, 대규모 및 복원력을 수용하도록 설계되었습니다.

클라우드 네이티브 컴퓨팅 재단은 [공식적인 정의를](https://github.com/cncf/foundation/blob/master/charter.md)제공합니다.

> *클라우드 네이티브 기술을 통해 조직은 퍼블릭, 프라이빗 및 하이브리드 클라우드와 같은 현대적이고 역동적인 환경에서 확장 가능한 애플리케이션을 구축하고 실행할 수 있습니다. 컨테이너, 서비스 메시, 마이크로 서비스, 불변 인프라 및 선언적 API는 이 접근 방식을 예로 들 수 있습니다.*

> *이러한 기술을 사용하면 복원력 있고 관리가 용이하며 관찰 가능한 느슨하게 결합된 시스템을 사용할 수 있습니다. 강력한 자동화와 결합하여 엔지니어는 최소한의 수고로 자주 예측 가능한 고영향 변경을 할 수 있습니다.*

응용 프로그램은 점점 더 많은 것을 요구하는 사용자로 점점 더 복잡해지고 있습니다. 사용자는 신속한 응답성, 혁신적인 기능 및 가동 중지 시간 제로를 기대합니다. 성능 문제, 반복되는 오류 및 빠르게 이동할 수 없는 기능은 더 이상 허용되지 않습니다. 그들은 쉽게 경쟁 업체로 이동합니다.

클라우드 네이티브는 *속도와* *민첩성에*관한 것입니다. 비즈니스 시스템은 비즈니스 역량을 지원하는 것에서 전략적 혁신의 무기로 진화하여 비즈니스 속도와 성장을 가속화하고 있습니다. 아이디어를 즉시 시장에 출시하는 것이 필수적입니다.

다음은 이러한 기술을 구현한 회사입니다. 그들이 달성한 속도, 민첩성 및 확장성에 대해 생각해 보십시오.

| 회사 | 환경 |
| :-------- | :-------- |
| [Netflix](https://www.infoq.com/news/2013/06/netflix/) | 생산에 600 개 이상의 서비스가 있습니다. 하루에 100번 배포합니다. |
| [동네 짱](https://eng.uber.com/micro-deploy/) | 생산에 저장된 1,000 개 이상의 서비스를 보유하고 있습니다. 매주 수천 개의 빌드를 배포합니다. |
| [WeChat](https://www.cs.columbia.edu/~ruigu/papers/socc18-final100.pdf) | 생산에 300 개 이상의 서비스가 있습니다. 하루에 거의 1,000번변경합니다. |

보시다시피 넷플릭스, Uber 및 WeChat은 수백 개의 독립적인 마이크로 서비스로 구성된 시스템을 노출합니다. 이 건축 양식은 시장 상황에 신속하게 대응할 수 있게 해줍니다. 라이브, 복잡한 응용 프로그램의 작은 영역을 즉시 업데이트하고 필요에 따라 해당 영역을 개별적으로 확장할 수 있습니다.

클라우드 네이티브의 속도와 민첩성은 여러 가지 요인에서 비롯됩니다. 가장 중요한 것은 클라우드 인프라입니다. 그림 1-3에 표시된 5개의 추가 기본 기둥은 클라우드 네이티브 시스템의 기반이기도 합니다.

![클라우드 네이티브 기본 기둥](./media/cloud-native-foundational-pillars.png)

**그림 1-3 .** 클라우드 네이티브 기본 기둥

각 기둥의 중요성을 더 잘 이해하기 위해 시간을 내어 봅시다.

## <a name="the-cloud"></a>구름...

클라우드 네이티브 시스템은 클라우드 서비스 모델을 최대한 활용합니다.

동적 가상화된 클라우드 환경에서 번창하도록 설계된 이러한 시스템은 [플랫폼을 PaaS(서비스)로](https://azure.microsoft.com/overview/what-is-paas/) 광범위하게 사용하여 인프라 및 관리형 서비스를 제공합니다. 기본 인프라를 자동화를 통해 몇 분 만에 프로비저닝하고 필요에 따라 크기를 조정, 확장, 이동 또는 파괴한 *일회용* 인프라로 취급합니다.

[애완 동물 대 가축의](https://medium.com/@Joachim8675309/devops-concepts-pets-vs-cattle-2380b5aab313)널리 받아들여지는 DevOps 개념을 고려하십시오. 기존 데이터 센터에서 서버는 의미 있는 이름을 부여하고 돌보는 실제 컴퓨터인 *Pets로*취급됩니다. 동일한 컴퓨터에 더 많은 리소스를 추가하여 확장합니다(확장). 서버가 아프면 다시 건강을 간호합니다. 서버를 사용할 수 없게 되면 모든 사용자가 알 수 있습니다.

*가축* 서비스 모델은 다릅니다. 각 인스턴스를 가상 컴퓨터 또는 컨테이너로 프로비전합니다. 동일하며 Service-01, Service-02 등과 같은 시스템 식별자가 할당됩니다. 더 많은 것을 만들어 확장합니다(확장). 하나를 사용할 수 없게되면 아무도 알지 못합니다.

가축 모델은 *불변의 인프라를*포용합니다. 서버는 수리 또는 수정되지 않습니다. 실패하거나 업데이트가 필요한 경우, 자동화를 통해 수행되는 새 프로비저닝이 수행됩니다.

클라우드 네이티브 시스템은 가축 서비스 모델을 수용합니다. 인프라가 실행되는 컴퓨터와 관계없이 인프라가 확장될 때 계속 실행됩니다.

Azure 클라우드 플랫폼은 자동 크기 조정, 자체 복구 및 모니터링 기능을 통해 이러한 유형의 고탄력적 인프라를 지원합니다.

## <a name="modern-design"></a>모던 한 디자인

클라우드 네이티브 앱을 어떻게 디자인하시겠습니까? 아키텍처는 어떤 모습일까요? 어떤 원칙, 패턴 및 모범 사례를 준수하시겠습니까? 어떤 인프라와 운영상의 문제가 중요할까요?

### <a name="the-twelve-factor-application"></a>12단계 응용 프로그램

클라우드 기반 응용 프로그램을 구축하기 위한 널리 사용되는 방법은 [12단계 응용 프로그램입니다.](https://12factor.net/) 개발자가 최신 클라우드 환경에 최적화된 응용 프로그램을 구성하기 위해 따르는 일련의 원칙과 사례에 대해 설명합니다. 환경 전반의 이식성과 선언적 자동화에 특별한 주의를 기울입니다.

모든 웹 기반 응용 프로그램에 적용할 수 있지만 많은 실무자는 클라우드 네이티브 앱을 빌드하기 위한 견고한 기반으로 간주합니다. 이러한 원칙을 기반으로 구축된 시스템은 신속하게 배포 및 확장하고 시장 변화에 신속하게 대응할 수 있는 기능을 추가할 수 있습니다.

다음 표에서는 12단계 방법론을 중점으로 강조합니다.

|    |  요소 | 설명  |
| :-------- | :-------- | :-------- |
| 1 | 코드 베이스 | 자체 리포지토리에 저장된 각 마이크로 서비스에 대한 단일 코드 베이스입니다. 버전 제어를 사용하여 추적하면 여러 환경(QA, 스테이징, 프로덕션)에 배포할 수 있습니다. |
| 2 | 종속성 | 각 마이크로 서비스는 전체 시스템에 영향을 주지 않고 변경 내용을 수용하면서 자체 종속성을 격리하고 패키지화합니다. |
| 3 | 구성  | 구성 정보는 마이크로 서비스에서 이동하고 코드 외부의 구성 관리 도구를 통해 외부화됩니다. 동일한 배포가 올바른 구성이 적용된 환경 간에 전파될 수 있습니다.  |
| 4 | 백업 서비스 | 보조 리소스(데이터 저장소, 캐시, 메시지 브로커)는 주소 지정 이 가능한 URL을 통해 노출되어야 합니다. 이렇게 하면 응용 프로그램에서 리소스가 분리되어 상호 교환할 수 있습니다.  |
| 5 | 빌드, 릴리스, 실행 | 각 릴리스는 빌드, 릴리스 및 실행 단계 간에 엄격한 분리를 적용해야 합니다. 각 ID는 고유 ID로 태그지정해야 하며 롤백 기능을 지원해야 합니다. 최신 CI/CD 시스템은 이러한 원칙을 충족하는 데 도움이 됩니다. |
| 6 | 프로세스 | 각 마이크로 서비스는 실행 중인 다른 서비스와 격리된 자체 프로세스에서 실행되어야 합니다. 분산 캐시 또는 데이터 저장소와 같은 백업 서비스에 필요한 상태를 외부화합니다. |
| 7 | 포트 바인딩 | 각 마이크로 서비스는 자체 포트에 노출된 인터페이스와 기능을 사용하여 자체 포함해야 합니다. 이렇게 하면 다른 마이크로 서비스와 격리됩니다. |
| 8 | 동시성 | 서비스는 사용 가능한 가장 강력한 컴퓨터에서 단일 큰 인스턴스를 확장하는 것이 아니라 많은 수의 작은 동일한 프로세스(복사본)에 걸쳐 확장됩니다. |
| 9 | 분리 가능성 | 서비스 인스턴스는 일회용이어야 하며, 빠른 신생 기업은 확장성 기회를 늘리고 시스템을 올바른 상태로 사용할 수 있도록 종료해야 합니다. 오케스트레이터와 함께 Docker 컨테이너는 본질적으로 이 요구 사항을 충족합니다. |
| 10 | 개발/프로드 패리티 | 비용이 많이 드는 바로 가기를 방지하여 응용 프로그램 수명 주기 전반에 걸쳐 환경을 최대한 유사하게 유지합니다. 여기서 컨테이너의 채택은 동일한 실행 환경을 촉진하여 크게 기여할 수 있습니다. |
| 11 | 로깅 | 마이크로 서비스에서 생성된 로그를 이벤트 스트림으로 처리합니다. 이벤트 집계자를 사용하여 처리하고 Azure Monitor 또는 Splunk와 같은 데이터 마이닝/로그 관리 도구에 데이터를 전파하고 결국 장기 보관합니다. |
| 12 | 관리자 프로세스 | 관리/관리 작업을 일회성 프로세스로 실행합니다. 작업에는 보고서에 대한 데이터 정리 및 분석 끌어당기기가 포함될 수 있습니다. 이러한 작업을 실행하는 도구는 프로덕션 환경에서 호출해야 하지만 응용 프로그램과 는 별도로 호출해야 합니다. |

책에서, [열두 요인 응용 프로그램을 넘어,](https://content.pivotal.io/blog/beyond-the-twelve-factor-app)저자 케빈 호프만 (2011 년에 작성) 원래 12 요인의 각각을 자세히 설명합니다. 또한 이 책에서는 오늘날의 최신 클라우드 응용 프로그램 디자인을 반영하는 세 가지 추가 요소를 제공합니다.

|    |  새 요소 | 설명  |
| :-------- | :-------- | :-------- |
| 13 | API 우선 | 모든 것을 서비스로 만드십시오. 코드가 프런트 엔드 클라이언트, 게이트웨이 또는 다른 서비스에서 사용된다고 가정합니다. |
| 14 | 원격 분석 | 워크스테이션에서 응용 프로그램 및 해당 동작에 대한 심층적인 가시성을 확보할 수 있습니다. 클라우드에서는 그렇지 않습니다. 디자인에 모니터링, 도메인별 및 상태/시스템 데이터의 컬렉션이 포함되어 있는지 확인합니다. |
| 15 | 인증/권한 부여  | 처음부터 ID를 구현합니다. 공용 클라우드에서 사용할 수 있는 [RBAC(역할 기반 액세스 제어)](https://docs.microsoft.com/azure/role-based-access-control/overview) 기능을 고려합니다.  |

이 장과 책 전체에 걸쳐 12+ 요인의 많은 참조 합니다.

### <a name="critical-design-considerations"></a>중요한 설계 고려 사항

12단계 방법론에서 제공하는 지침 외에도 분산 시스템을 구성할 때 결정해야 하는 몇 가지 중요한 설계 결정이 있습니다.

*통신*

프런트 엔드 클라이언트 응용 프로그램은 백업 형 핵심 서비스와 어떻게 통신할 것인가? 직접 통신을 허용하시겠습니까? 또는 유연성, 제어 및 보안을 제공하는 게이트웨이 외관을 통해 백 엔드 서비스를 추상화할 수 있습니까?

백 엔드 코어 서비스는 서로 어떻게 통신할 것인가? 커플링으로 이어지는 직접 HTTP 호출을 허용하고 성능과 민첩성에 영향을 미치도록 하시겠습니까? 또는 큐 및 토픽 기술과 분리된 메시징을 고려할 수 있습니까?

통신은 4장, 클라우드 *네이티브 커뮤니케이션 패턴에*대해 자세히 다룹니다.

*복원력*

마이크로 서비스 아키텍처는 시스템을 프로세스 내에서 네트워크 통신으로 이동합니다. 분산 환경에서 서비스 B가 서비스 A의 호출에 응답하지 않을 때 어떻게 해야 합니까? 서비스 C가 일시적으로 사용할 수 없게 되고 다른 서비스가 스택을 호출하여 시스템 성능을 저하시키면 어떻게 됩니까?

복원력은 6장, 클라우드 네이티브 *복원력에*대해 자세히 다룹니다.

*분산 데이터*

설계상 각 마이크로 서비스는 자체 데이터를 캡슐화하여 공용 인터페이스를 통해 작업을 노출합니다. 그렇다면 데이터를 쿼리하거나 여러 서비스에서 트랜잭션을 구현하려면 어떻게 해야 합니까?

분산 데이터는 5장, *클라우드 네이티브 데이터 패턴에*대해 자세히 다룹니다.

*ID*

서비스에서 액세스하는 사람과 권한이 있는 권한을 어떻게 식별합니까?

ID는 세부 사항 장에서 다룹니다 장 8, *정체성*.

## <a name="microservices"></a>마이크로 서비스

클라우드 네이티브 시스템은 최신 응용 프로그램을 구성하기 위한 인기 있는 아키텍처 스타일인 마이크로 서비스를 포함합니다.

공유 패브릭을 통해 상호 작용하는 작고 독립적인 서비스의 분산 된 집합으로 구축 된 마이크로 서비스는 다음과 같은 특성을 공유합니다.

- 각 기능은 더 큰 도메인 컨텍스트 내에서 특정 비즈니스 기능을 구현합니다.

- 각각은 자율적으로 개발되며 독립적으로 배포할 수 있습니다.

- 각각은 자체 데이터 스토리지 기술(SQL, NoSQL) 및 프로그래밍 플랫폼을 캡슐화하는 독립적인 것입니다.

- 각 프로세스는 자체 프로세스에서 실행되며 HTTP/HTTPS, WebSockets 또는 [AMQP와](https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol)같은 표준 통신 프로토콜을 사용하여 다른 사용자와 통신합니다.

- 그들은 응용 프로그램을 형성하기 위해 함께 작성합니다.

그림 1-4는 모놀리식 응용 프로그램 접근 방식과 마이크로 서비스 접근 방식을 대조합니다. 모놀리스는 단일 프로세스에서 실행되는 계층화된 아키텍처로 구성되는 방법을 확인합니다. 일반적으로 관계형 데이터베이스를 사용합니다. 그러나 마이크로 서비스 접근 방식은 기능을 논리 및 데이터를 포함하는 독립적인 서비스로 분리합니다. 각 마이크로 서비스는 자체 데이터 스토어를 호스팅합니다.

![모놀리식 배포와 마이크로 서비스](./media/monolithic-vs-microservices.png)

**그림 1-4.** 모놀리식 배포와 마이크로 서비스

마이크로 서비스가 이 장의 앞에서 설명한 [12단계 응용 프로그램에서](https://12factor.net/)"하나의 코드베이스, 하나의 응용 프로그램" 원칙을 승격하는 방법을 설명합니다.

> *요소 \#1은 "자체 리포지토리에 저장된 각 마이크로 서비스에 대한 단일 코드베이스"를 지정합니다. 버전 제어를 통해 추적하면 여러 환경에 배포할 수 있습니다."*

### <a name="why-microservices"></a>마이크로 서비스를 사용하는 이유는 무엇인가요?

마이크로 서비스는 민첩성을 제공합니다.

이 장의 이전 부분에서는 모놀리스로 빌드된 전자 상거래 응용 프로그램을 마이크로 서비스와 비교했습니다. 이 예제에서는 다음과 같은 몇 가지 명확한 이점을 보았습니다.

- 각 마이크로 서비스에는 자율적인 수명 주기가 있으며 독립적으로 진화하고 자주 배포할 수 있습니다. 새 기능이나 업데이트를 배포하기 위해 분기별 릴리스를 기다릴 필요가 없습니다. 복잡한 응용 프로그램의 작은 영역을 업데이트하여 전체 시스템을 중단할 위험이 적습니다.

- 각 마이크로 서비스는 독립적으로 확장할 수 있습니다. 전체 응용 프로그램을 단일 단위로 확장하는 대신 더 많은 처리 능력이나 네트워크 대역폭이 필요한 서비스만 확장할 수 있습니다. 이 세분화된 확장 방식은 시스템을 보다 잘 제어할 수 있도록 하고 모든 것이 아니라 시스템의 일부를 확장할 때 전체 비용을 절감하는 데 도움이 됩니다.

마이크로 서비스를 이해하기 위한 훌륭한 참조 가이드는 [.NET 마이크로 서비스: 컨테이너화된 .NET 응용 프로그램에 대한 아키텍처입니다.](https://docs.microsoft.com/dotnet/standard/microservices-architecture/) 이 책은 마이크로 서비스 설계 및 아키텍처에 대해 심층분석합니다. Microsoft에서 무료로 다운로드할 수 있는 [전체 스택 마이크로 서비스 참조 아키텍처의](https://github.com/dotnet-architecture/eShopOnContainers) 동반자입니다.

### <a name="developing-microservices"></a>마이크로 서비스 개발

마이크로 서비스는 모든 최신 개발 플랫폼으로 만들 수 있습니다.

Microsoft .NET 코어 플랫폼은 탁월한 선택입니다. 무료 및 오픈 소스, 그것은 마이크로 서비스 개발을 단순화 하기 위해 많은 내장 된 기능을 가지고 있습니다. .NET 코어는 크로스 플랫폼입니다. 응용 프로그램을 빌드하 고 윈도우에서 실행할 수 있습니다., macOS, 그리고 리눅스의 대부분의 맛.

.NET Core는 Node.js 및 기타 경쟁 플랫폼에 비해 성능이 뛰어나고 성과가 우수합니다. 흥미롭게도 [TechEmpower는](https://www.techempower.com/) 많은 웹 응용 프로그램 플랫폼 및 프레임워크에서 광범위한 [성능 벤치마크](https://www.techempower.com/benchmarks/#section=data-r17&hw=ph&test=plaintext) 집합을 수행했습니다. .NET Core는 Node.js 및 기타 경쟁 플랫폼보다 훨씬 높은 상위 10위 안에 들 수 있습니다.

.NET 코어는 마이크로소프트와 GitHub의 .NET 커뮤니티에서 관리합니다.

## <a name="containers"></a>컨테이너

요즘에는 *클라우드 네이티브에*관한 대화에서 언급 된 *컨테이너라는* 용어를 듣는 것은 자연스러운 것입니다. 이 책에서 [클라우드 네이티브 패턴의](https://www.manning.com/books/cloud-native-patterns)저자 코넬리아 데이비스는 "컨테이너는 클라우드 네이티브 소프트웨어의 훌륭한 원동력"이라고 말합니다. 클라우드 네이티브 컴퓨팅 재단은 클라우드 [네이티브 트레일 맵의](https://raw.githubusercontent.com/cncf/trailmap/master/CNCF_TrailMap_latest.png) 첫 번째 단계로 마이크로 서비스 컨테이너화를 배치합니다.

마이크로 서비스를 컨테이너화하는 것은 간단하고 간단합니다. 코드, 해당 종속성 및 런타임은 [컨테이너 이미지라는](https://docs.docker.com/glossary/?term=image)바이너리로 패키징됩니다. 이미지는 이미지의 리포지토리 또는 라이브러리 역할을 하는 [컨테이너 레지스트리에](https://caylent.com/container-registries/)저장됩니다. 레지스트리는 개발 컴퓨터, 데이터 센터 또는 공용 클라우드에 위치할 수 있습니다. Docker 자체는 [Docker Hub를](https://hub.docker.com/)통해 공용 레지스트리를 유지 관리합니다. Azure 클라우드에는 컨테이너 [레지스트리를](https://azure.microsoft.com/services/container-registry/) 사용하여 컨테이너 이미지를 실행하는 클라우드 응용 프로그램에 가까운 컨테이너 이미지를 저장합니다.

필요한 경우 이미지를 실행 중인 컨테이너 인스턴스로 변환합니다. 인스턴스는 [컨테이너 런타임](https://kubernetes.io/docs/setup/production-environment/container-runtimes/) 엔진이 설치된 모든 컴퓨터에서 실행됩니다. 필요에 따라 컨테이너화된 서비스의 인스턴스를 최대한 많이 가질 수 있습니다.

그림 1-5는 각각 자체 컨테이너에 있는 세 가지 서로 다른 마이크로 서비스를 보여 주며 단일 호스트에서 실행됩니다.

![컨테이너 호스트에서 실행되는 여러 컨테이너](./media/hosting-mulitple-containers.png)

**그림 1-5 .** 컨테이너 호스트에서 실행되는 여러 컨테이너

각 컨테이너가 서로 다를 수 있는 자체 종속성 및 런타임 집합을 유지하는 방법을 참고합니다. 여기서는 동일한 호스트에서 실행되는 제품 마이크로 서비스의 다른 버전을 볼 수 있습니다. 각 컨테이너는 기본 호스트 운영 체제, 메모리 및 프로세서의 조각을 공유하지만 서로 격리됩니다.

컨테이너 모델이 [12단계 응용 프로그램의](https://12factor.net/)"종속성" 원칙을 얼마나 잘 수용하는지 주목하십시오.

> *팩터 \#2는 "각 마이크로 서비스는 전체 시스템에 영향을 주지 않고 변경 내용을 수용하면서 자체 종속성을 격리하고 패키지화합니다."*

컨테이너는 Linux 및 Windows 워크로드를 모두 지원합니다. Azure 클라우드는 공개적으로 둘 다 를 포용합니다. 흥미롭게도, 그것은 리눅스, 윈도우 서버, 그 Azure에서 가장 인기 있는 운영 체제되고있다.

여러 컨테이너 공급 업체가 존재하는 동안 Docker는 사자의 시장 점유율을 점령했습니다. 이 회사는 소프트웨어 컨테이너 운동을 주도하고 있다. 클라우드 네이티브 응용 프로그램을 패키징, 배포 및 실행하기 위한 사실상의 표준이 되었습니다.

### <a name="why-containers"></a>왜 컨테이너인가?

컨테이너는 이식성을 제공하고 환경 전반에 걸쳐 일관성을 보장합니다. 모든 것을 단일 패키지로 캡슐화하면 마이크로 서비스와 해당 종속성을 기본 인프라에서 *격리할* 수 있습니다.

Docker 런타임 엔진이 있는 모든 환경에서 동일한 컨테이너를 배포할 수 있습니다. 또한 컨테이너화된 워크로드는 프레임워크, 소프트웨어 라이브러리 및 런타임 엔진을 통해 각 환경을 미리 구성하는 비용을 제거합니다.

기본 운영 체제 및 호스트 리소스를 공유하면 컨테이너의 설치 공간이 전체 가상 시스템보다 훨씬 작습니다. 크기가 작을수록 지정된 호스트가 한 번에 실행할 수 있는 *밀도*또는 마이크로 서비스 수가 증가합니다.

### <a name="container-orchestration"></a>컨테이너 오케스트레이션

Docker와 같은 도구는 이미지를 만들고 컨테이너를 실행하는 동안 이를 관리하는 도구도 필요합니다. 컨테이너 관리는 컨테이너 오케스트레이터라는 특수 소프트웨어 프로그램으로 수행됩니다. 대규모로 작동할 때 컨테이너 오케스트레이션이 필수적입니다.

그림 1-6은 컨테이너 오케스트레이터가 제공하는 관리 작업을 보여 주었습니다.

![컨테이너 오케스트레이터가 수행하는 일](./media/what-container-orchestrators-do.png)

**그림 1-6**. 컨테이너 오케스트레이터가 수행하는 일

다음 표는 일반적인 오케스트레이션 작업에 대해 설명합니다.

|  작업 | 설명  |
| :-------- | :-------- |
| 일정 계획 | 컨테이너 인스턴스를 자동으로 프로비전합니다.|
| 선호도/안티 친화성 | 근처 또는 서로 멀리 떨어진 컨테이너를 프로비저닝하여 가용성과 성능을 지원합니다. |
| 상태 모니터링 | 오류를 자동으로 감지하고 수정합니다.|
| 장애 조치 | 실패한 인스턴스를 정상 시스템에 자동으로 다시 프로비전합니다.|
| 확장 | 수요를 충족하기 위해 컨테이너 인스턴스를 자동으로 추가하거나 제거합니다.|
| 네트워킹 | 컨테이너 통신을 위한 네트워킹 오버레이를 관리합니다.|
| 서비스 검색 | 컨테이너가 서로를 찾을 수 있도록 설정합니다.|
| 롤링 업그레이드 | 가동 중지 시간 배포가 전혀 없는 증분 업그레이드를 조정합니다. 문제가 있는 변경 내용을 자동으로 롤백합니다.|

오케스트레이터가 이 장의 앞에서 설명한 [12단계 응용 프로그램의](https://12factor.net/)폐기 가능성 및 동시성 원칙을 어떻게 받아들이는지 주목하십시오.

> *팩터 \#9는 "서비스 인스턴스는 일회용이어야 하며, 빠른 신생 기업은 확장성 기회를 늘리고 시스템을 올바른 상태로 두는 우아한 종료를 선호합니다. 오케스트레이터와 함께 Docker 컨테이너는 본질적으로 이 요구 사항을 충족합니다."*

> *팩터 \#8은 "사용 가능한 가장 강력한 컴퓨터에서 단일 큰 인스턴스를 확장하는 것이 아니라 많은 수의 작은 동일한 프로세스(복사본)에서 서비스가 확장되도록 지정합니다."*

여러 컨테이너 오케스트레이터가 존재하지만 [Kubernetes는](https://kubernetes.io/docs/concepts/overview/what-is-kubernetes/) 클라우드 네이티브 세계의 사실상 표준이 되었습니다. 컨테이너화된 워크로드를 관리하기 위한 이식가능한 확장 가능한 오픈 소스 플랫폼입니다.

Kubernetes의 자체 인스턴스를 호스팅할 수 있지만 복잡할 수 있는 리소스를 프로비저닝하고 관리할 책임이 있습니다. Azure 클라우드는 관리되는 서비스인 AZURE [Kubernetes 서비스(AKS)로 Kubernetes를](https://azure.microsoft.com/services/kubernetes-service/)특징으로 합니다. 관리형 서비스를 사용하면 기능을 설치하고 유지 관리할 필요 없이 기능을 완전히 활용할 수 있습니다.

Azure Kubernetes 서비스는 클라우드 네이티브 *응용 프로그램 크기 조정*2장에서 자세히 다룹니다.

## <a name="backing-services"></a>백업 서비스

클라우드 네이티브 시스템은 데이터 저장소, 메시지 브로커, 모니터링 및 ID 서비스와 같은 다양한 보조 리소스에 의존합니다. 이러한 서비스를 [백업 서비스라고](https://12factor.net/backing-services)합니다.

 그림 1-7은 클라우드 네이티브 시스템에서 사용하는 많은 일반적인 백업 서비스를 보여 주며 있습니다.

![일반적인 백업 서비스](./media/common-backing-services.png)

**그림 1-7 .** 일반적인 백업 서비스

백업 서비스는 장 의 앞에서 설명한 [12단계 응용 프로그램에서](https://12factor.net/)"상태 비사용" 원칙을 촉진합니다.

>*팩터 \#6은* "각 마이크로 서비스는 실행 중인 다른 서비스와 격리된 자체 프로세스에서 실행되어야 합니다. 필요한 상태를 분산 캐시 또는 데이터 저장소와 같은 백업 서비스에 외부화합니다."

자체 백업 서비스를 호스팅할 수 있지만 이러한 리소스에 대한 라이선스, 프로비저닝 및 관리를 담당해야 합니다.

클라우드 공급자는 *다양한 관리형 백업 서비스를 제공합니다.* 서비스를 소유하는 대신 단순히 서비스를 사용합니다. 공급자는 대규모로 리소스를 운영하며 성능, 보안 및 유지 관리에 대한 책임을 집니다. 모니터링, 중복 성 및 가용성이 서비스에 내장되어 있습니다. 공급자는 관리되는 서비스를 완벽하게 지원하여 티켓을 열고 문제를 해결합니다.

클라우드 네이티브 시스템은 클라우드 공급업체의 관리되는 백업 서비스를 선호합니다. 시간과 노동력의 절감은 중대합니다. 직접 호스팅하고 문제를 경험할 경우 운영 상의 위험이 빠르게 발생할 수 있습니다.

가장 좋은 방법은 백업 서비스를 *연결된 리소스로*처리하고 외부 구성에 저장된 정보(URL 및 자격 증명)가 있는 마이크로 서비스에 동적으로 바인딩되는 것입니다. 이 지침은 장 의 앞에서 설명한 [12단계 응용 프로그램에서](https://12factor.net/)설명되어 있습니다.

>*팩터 \#4는* 백업 서비스가 주소 지정 가능한 URL을 통해 노출되어야 한다고 지정합니다. 이렇게 하면 응용 프로그램에서 리소스가 분리되어 상호 교환할 수 있습니다."

>*요소 \#3은* "구성 정보가 마이크로 서비스에서 이동하고 코드 외부의 구성 관리 도구를 통해 외부화됩니다."

이 패턴을 사용하면 코드 변경 없이 백업 서비스를 연결 및 분리할 수 있습니다. QA에서 스테이징 환경으로 마이크로 서비스를 승격할 수 있습니다. 스테이징에서 백업 서비스를 가리키도록 마이크로 서비스 구성을 업데이트하고 환경 변수를 통해 컨테이너에 설정을 삽입합니다.

클라우드 공급업체는 API를 제공하여 독점적인 백업 서비스와 통신할 수 있습니다. 이러한 라이브러리는 배관 및 복잡성을 캡슐화합니다. 이러한 API와 직접 통신하면 코드가 백업 서비스에 밀접하게 결합됩니다. 공급업체 API의 구현 세부 정보를 절연하는 것이 좋습니다. 서비스 코드에 제네릭 작업을 노출하는 중개 계층 또는 중간 API를 도입합니다. 이 느슨한 커플링을 사용하면 한 백업 서비스를 다른 서비스로 교체하거나 기본 서비스 코드를 변경하지 않고도 코드를 다른 공용 클라우드로 이동할 수 있습니다.

백업 서비스는 5장, 클라우드 *네이티브 데이터 패턴*및 4장, *클라우드 네이티브 통신 패턴에*대해 자세히 설명합니다.

## <a name="automation"></a>Automation

보시다시말처럼 클라우드 네이티브 시스템은 마이크로 서비스, 컨테이너 및 최신 시스템 설계를 수용하여 속도와 민첩성을 달성합니다. 하지만, 그것은 이야기의 일부에 불과합니다. 이러한 시스템이 실행되는 클라우드 환경을 프로비전하려면 어떻게 해야 합니까? 앱 기능 및 업데이트를 신속하게 배포하려면 어떻게 해야 합니까? 전체 그림을 어떻게 마무리합니까?

널리 받아들여지는 인프라 관행을 [코드](https://docs.microsoft.com/azure/devops/learn/what-is-infrastructure-as-code)또는 IaC로 입력합니다.

IaC를 사용하면 플랫폼 프로비저닝 및 애플리케이션 배포를 자동화할 수 있습니다. 기본적으로 DevOps 사례에 테스트 및 버전 관리와 같은 소프트웨어 엔지니어링 관행을 적용합니다. 인프라와 배포는 자동화되고 일관되며 반복 가능합니다.

### <a name="automating-infrastructure"></a>인프라 자동화

Azure [리소스 관리자,](https://azure.microsoft.com/documentation/articles/resource-group-overview/)Terraform 및 [Azure CLI와](https://docs.microsoft.com/cli/azure/)같은 도구를 사용하면 필요한 클라우드 인프라를 선언적으로 스크립팅할 수 있습니다. 리소스 이름, 위치, 용량 및 비밀은 매개 변수화되고 동적입니다. 스크립트는 버전이 정해지고 프로젝트의 아티팩트로 소스 제어로 체크 인됩니다. 스크립트를 호출하여 QA, 스테이징 및 프로덕션과 같은 시스템 환경 전반에 걸쳐 일관되고 반복 가능한 인프라를 프로비전합니다.

후드 아래, IaC는 idempotent, 부작용 없이 동일한 스크립트를 반복해서 실행할 수 있습니다 의미. 팀에서 변경해야 하는 경우 스크립트를 편집하고 다시 실행합니다. 업데이트된 리소스만 영향을 받습니다.

이 [기사에서, 코드로 인프라란 무엇인가,](https://docs.microsoft.com/azure/devops/learn/what-is-infrastructure-as-code)저자 샘 구켄하이머는 "IaC를 구현하는 팀은 신속하고 대규모로 안정적인 환경을 제공 할 수있는 방법을 설명합니다. 팀은 코드를 통해 원하는 환경 상태를 나타내서 환경의 수동 구성을 방지하고 일관성을 적용합니다. IaC를 사용하는 인프라 배포는 반복 가능하며 구성 드리프트 또는 누락된 종속성으로 인한 런타임 문제를 방지할 수 있습니다. DevOps 팀은 통합된 관행 및 도구 세트와 함께 애플리케이션과 지원 인프라를 신속하고 안정적으로 확장할 수 있습니다."

### <a name="automating-deployments"></a>배포 자동화

앞서 설명한 [12단계 응용 프로그램은](https://12factor.net/)완성된 코드를 실행 중인 응용 프로그램으로 변환할 때 별도의 단계를 호출합니다.

> *요소 \#5는* "각 릴리스는 빌드, 릴리스 및 실행 단계 간에 엄격한 분리를 적용해야 합니다. 각 ID는 고유 ID로 태그가 지정되고 롤백 할 수있는 기능을 지원해야합니다."

최신 CI/CD 시스템은 이러한 원칙을 충족하는 데 도움이 됩니다. 별도의 배포 단계를 제공하고 사용자가 쉽게 사용할 수 있는 일관되고 품질 좋은 코드를 보장하는 데 도움이 됩니다.

그림 1-8은 배포 프로세스 간의 구분을 보여 주며,

![CI/CD 파이프라인의 배포 단계](./media/build-release-run-pipeline.png)

**그림 1-8 .** CI/CD 파이프라인의 배포 단계

이전 그림에서는 작업 분리에 특별한주의를 기울이기.

개발자는 코드, 실행 및 디버그의 "내부 루프"를 반복하여 개발 환경에서 기능을 구성합니다. 완료되면 해당 코드는 GitHub, Azure DevOps 또는 BitBucket과 같은 코드 리포지토리로 *푸시됩니다.*

푸시는 코드를 이진 아티팩트로 변환하는 빌드 단계를 트리거합니다. 이 작업은 [CI(연속 통합)](https://martinfowler.com/articles/continuousIntegration.html) 파이프라인으로 구현됩니다. 응용 프로그램을 자동으로 빌드, 테스트 및 패키지로 구성합니다.

릴리스 단계에서는 이진 아티팩트를 선택하고 외부 응용 프로그램 및 환경 구성 정보를 적용하고 변경할 수 없는 릴리스를 생성합니다. 릴리스는 지정된 환경에 배포됩니다. 이 작업은 [CD(연속 배달)](https://martinfowler.com/bliki/ContinuousDelivery.html) 파이프라인으로 구현됩니다. 각 릴리스는 식별할 수 있어야 합니다. "이 배포는 응용 프로그램의 릴리스 2.1.1을 실행 중"이라고 말할 수 있습니다.

마지막으로 릴리스된 기능은 대상 실행 환경에서 실행됩니다. 릴리스는 변경 사항이 새 릴리스를 만들어야 한다는 것을 의미합니다.

이러한 관행을 적용함으로써 조직은 소프트웨어를 출시하는 방식을 근본적으로 발전시고 있습니다. 많은 사람들이 분기별 릴리스에서 주문형 업데이트로 이동했습니다. 목표는 개발 주기 초기에 문제를 해결하는 데 비용이 적게 드는 경우 문제를 해결하는 것입니다. 통합 간의 기간이 길수록 더 많은 비용이 드는 문제를 해결할 수 있습니다.  통합 프로세스의 일관성을 통해 팀은 코드 변경을 더 자주 커밋하여 협업 및 소프트웨어 품질을 높일 수 있습니다.

### <a name="azure-pipelines"></a>Azure Pipelines

Azure 클라우드에는 그림 1-9에 표시된 [Azure DevOps](https://azure.microsoft.com/services/devops/) 제품의 일부인 새 CI/CD 서비스인 [Azure 파이프라인이](https://azure.microsoft.com/services/devops/pipelines/)포함되어 있습니다.

![데브옵스의 Azure 파이프라인](./media/devops-components.png)

**그림 1-9 .** Azure DevOps 오퍼링

Azure 파이프라인은 CI(연속 통합)와 CD(연속 배달)를 결합한 클라우드 서비스입니다. 코드를 자동으로 테스트, 빌드 및 모든 대상에 발송할 수 있습니다.

YAML 파일의 코드에서 파이프라인을 앱의 나머지 코드와 함께 정의합니다.

- 파이프라인은 코드로 버전이 정해지며 동일한 분기 구조를 따릅니다.
- 끌어오기 요청 및 분기 빌드 정책에서 코드 검토를 통해 변경 사항에 대한 유효성을 검사할 수 있습니다.
- 사용하는 모든 분기는 azure-pipelines.yml 파일을 수정하여 빌드 정책을 사용자 지정할 수 있습니다.
- 파이프라인 파일은 버전 제어에 체크 인되어 문제가 있는 경우 조사할 수 있습니다.

Azure 파이프라인 서비스는 대부분의 Git 공급자를 지원하며 Linux, macOS 또는 Windows 플랫폼에 기록된 응용 프로그램에 대한 배포 파이프라인을 생성할 수 있습니다. 여기에는 Java, .NET, 자바 스크립트, 파이썬, PHP, 이동, XCode 및 C ++에 대한 지원이 포함됩니다.

>[!div class="step-by-step"]
>[이전](introduction.md)
>[다음](candidate-apps.md)

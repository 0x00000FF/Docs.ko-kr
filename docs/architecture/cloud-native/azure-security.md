---
title: 클라우드 네이티브 앱용 Azure 보안
description: Azure용 클라우드 네이티브 .NET 앱 설계 | 클라우드 네이티브 앱용 Azure 보안
ms.date: 06/30/2019
ms.openlocfilehash: 13b5ad7a883a83014913fa0a6a020610c28c524f
ms.sourcegitcommit: e3cbf26d67f7e9286c7108a2752804050762d02d
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 04/09/2020
ms.locfileid: "80989144"
---
# <a name="azure-security-for-cloud-native-apps"></a><span data-ttu-id="7e9c5-103">클라우드 네이티브 앱용 Azure 보안</span><span class="sxs-lookup"><span data-stu-id="7e9c5-103">Azure security for cloud-native apps</span></span>

[!INCLUDE [book-preview](../../../includes/book-preview.md)]

<span data-ttu-id="7e9c5-104">클라우드 네이티브 응용 프로그램은 기존 응용 프로그램보다 보안이 더 쉽고 어려울 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-104">Cloud-native applications can be both easier and more difficult to secure than traditional applications.</span></span> <span data-ttu-id="7e9c5-105">단점으로는 더 작은 응용 프로그램을 보호하고 보안 인프라를 구축하기 위해 더 많은 에너지를 투입해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-105">On the downside, you need to secure more smaller applications and dedicate more energy to build out the security infrastructure.</span></span> <span data-ttu-id="7e9c5-106">대부분의 서비스 배포에서 프로그래밍 언어와 스타일이 이기종적인 특성때문에 다양한 공급자의 보안 공지에 더 많은 주의를 기울여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-106">The heterogeneous nature of programming languages and styles in most service deployments also means you need to pay more attention to security bulletins from many different providers.</span></span>

<span data-ttu-id="7e9c5-107">반대로, 각각 자체 데이터 저장소가 있는 작은 서비스는 공격 범위를 제한합니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-107">On the flip side, smaller services, each with their own data store, limit the scope of an attack.</span></span> <span data-ttu-id="7e9c5-108">공격자가 한 시스템을 손상시키면 공격자가 모놀리식 응용 프로그램보다 다른 시스템으로 이동하는 것이 더 어려울 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-108">If an attacker compromises one system, it's probably more difficult for the attacker to make the jump to another system than it is in a monolithic application.</span></span> <span data-ttu-id="7e9c5-109">프로세스 경계는 강력한 경계입니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-109">Process boundaries are strong boundaries.</span></span> <span data-ttu-id="7e9c5-110">또한 데이터베이스 백업이 누출되면 해당 데이터베이스에 데이터 하위 집합만 포함되고 개인 데이터가 포함될 가능성이 낮기 때문에 손상이 더 제한됩니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-110">Also, if a database backup leaks, then the damage is more limited, as that database contains only a subset of data and is unlikely to contain personal data.</span></span>

## <a name="threat-modeling"></a><span data-ttu-id="7e9c5-111">위협 모델링</span><span class="sxs-lookup"><span data-stu-id="7e9c5-111">Threat modeling</span></span>

<span data-ttu-id="7e9c5-112">장점이 클라우드 네이티브 응용 프로그램의 단점보다 크더라도 동일한 전체적인 보안 사고 방식을 따라야 합니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-112">No matter if the advantages outweigh the disadvantages of cloud-native applications, the same holistic security mindset must be followed.</span></span> <span data-ttu-id="7e9c5-113">보안 및 보안 사고는 개발 및 운영 스토리의 모든 단계의 일부가 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-113">Security and secure thinking must be part of every step of the development and operations story.</span></span> <span data-ttu-id="7e9c5-114">응용 프로그램을 계획할 때 다음과 같은 질문을 합니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-114">When planning an application ask questions like:</span></span>

- <span data-ttu-id="7e9c5-115">이 데이터가 손실되는 영향은 무엇입니까?</span><span class="sxs-lookup"><span data-stu-id="7e9c5-115">What would be the impact of this data being lost?</span></span>
- <span data-ttu-id="7e9c5-116">이 서비스에 주입되는 잘못된 데이터로 인한 피해를 어떻게 제한할 수 있습니까?</span><span class="sxs-lookup"><span data-stu-id="7e9c5-116">How can we limit the damage from bad data being injected into this service?</span></span>
- <span data-ttu-id="7e9c5-117">이 데이터에 액세스할 수 있는 사람은 누구입니까?</span><span class="sxs-lookup"><span data-stu-id="7e9c5-117">Who should have access to this data?</span></span>
- <span data-ttu-id="7e9c5-118">개발 및 릴리스 프로세스와 관련된 감사 정책이 마련되어 있습니까?</span><span class="sxs-lookup"><span data-stu-id="7e9c5-118">Are there auditing policies in place around the development and release process?</span></span>

<span data-ttu-id="7e9c5-119">이러한 모든 질문은 [위협 모델링이라는](https://docs.microsoft.com/azure/security/azure-security-threat-modeling-tool)프로세스의 일부입니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-119">All these questions are part of a process called [threat modeling](https://docs.microsoft.com/azure/security/azure-security-threat-modeling-tool).</span></span> <span data-ttu-id="7e9c5-120">이 프로세스는 시스템에 어떤 위협이 있는지, 위협이 발생할 가능성 및 이로 인한 잠재적 손상에 대한 질문에 답하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-120">This process tries to answer the question of what threats there are to the system, how likely the threats are, and the potential damage from them.</span></span>

<span data-ttu-id="7e9c5-121">위협 목록이 설정되면 완화할 만한 가치가 있는지 여부를 결정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-121">Once the list of threats has been established, you need to decide whether they're worth mitigating.</span></span> <span data-ttu-id="7e9c5-122">때로는 위협이 너무 가능성과 그것에 에너지를 지출 가치가 되지 않습니다 에 대 한 계획 비용이 많이 드는.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-122">Sometimes a threat is so unlikely and expensive to plan for that it isn't worth spending energy on it.</span></span> <span data-ttu-id="7e9c5-123">예를 들어 일부 상태 수준의 행위자에서는 수백만 대의 장치에서 사용되는 프로세스의 디자인에 변경 내용을 삽입할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-123">For instance, some state level actor could inject changes into the design of a process that is used by millions of devices.</span></span> <span data-ttu-id="7e9c5-124">이제 [링 3에서](https://en.wikipedia.org/wiki/Protection_ring)특정 코드를 실행하는 대신 해당 코드는 링 0에서 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-124">Now, instead of running a certain piece of code in [Ring 3](https://en.wikipedia.org/wiki/Protection_ring), that code is run in Ring 0.</span></span> <span data-ttu-id="7e9c5-125">이렇게 하면 하이퍼바이저를 우회하고 베어 메탈 컴퓨터에서 공격 코드를 실행할 수 있으므로 해당 하드웨어에서 실행중인 모든 가상 시스템에 대한 공격을 허용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-125">This allows an exploit that can bypass the hypervisor and run the attack code on the bare metal machines, allowing attacks on all the virtual machines that are running on that hardware.</span></span>

<span data-ttu-id="7e9c5-126">변경된 프로세서는 현미경과 해당 프로세서의 실리콘 설계에 대한 고급 지식 없이는 감지하기 어렵습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-126">The altered processors are difficult to detect without a microscope and advanced knowledge of the on silicon design of that processor.</span></span> <span data-ttu-id="7e9c5-127">이 시나리오는 발생할 가능성이 낮고 완화 비용이 많이 들기 때문에 위협 모델이 악용 보호를 빌드하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-127">This scenario is unlikely to happen and expensive to mitigate, so probably no threat model would recommend building exploit protection for it.</span></span>

<span data-ttu-id="7e9c5-128">증가 공격(URL에서 대체)을 `Id` `Id=2` `Id=3` 허용하는 액세스 제어 가 깨짐또는 SQL 주입과 같은 위협은 보호 기능을 구축하는 데 더 매력적입니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-128">More likely threats, such as broken access controls permitting `Id` incrementing attacks (replacing `Id=2` with `Id=3` in the URL) or SQL injection, are more attractive to build protections against.</span></span> <span data-ttu-id="7e9c5-129">이러한 위협에 대한 완화는 회사의 평판을 얼룩지게 하는 당황스러운 보안 허점을 구축하고 방지하는 데 매우 합리적입니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-129">The mitigations for these threats are quite reasonable to build and prevent embarrassing security holes that smear the company's reputation.</span></span>

## <a name="principle-of-least-privilege"></a><span data-ttu-id="7e9c5-130">최소 권한 원칙</span><span class="sxs-lookup"><span data-stu-id="7e9c5-130">Principle of least privilege</span></span>

<span data-ttu-id="7e9c5-131">컴퓨터 보안의 창립 아이디어 중 하나는 최소 권한 원칙(POLP)입니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-131">One of the founding ideas in computer security is the Principle of Least Privilege (POLP).</span></span> <span data-ttu-id="7e9c5-132">그것은 실제로 대부분의 모든 형태의 보안에서 디지털 또는 물리적 인 기본 아이디어입니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-132">It's actually a foundational idea in most any form of security be it digital or physical.</span></span> <span data-ttu-id="7e9c5-133">즉, 모든 사용자 또는 프로세스가 작업을 실행할 수 있는 최소한의 권한을 가져야 한다는 원칙입니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-133">In short, the principle is that any user or process should have the smallest number of rights possible to execute its task.</span></span>

<span data-ttu-id="7e9c5-134">예를 들어, 은행의 점원들을 생각해 보십시오: 금고에 접근하는 것은 드문 활동입니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-134">As an example, think of the tellers at a bank: accessing the safe is an uncommon activity.</span></span> <span data-ttu-id="7e9c5-135">그래서, 평균 점원은 안전 자신을 열 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-135">So, the average teller can't open the safe themselves.</span></span> <span data-ttu-id="7e9c5-136">액세스 권한을 얻으려면 추가 보안 검사를 수행하는 은행 관리자를 통해 요청을 에스컬레이션해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-136">To gain access, they need to escalate their request through a bank manager, who performs additional security checks.</span></span>

<span data-ttu-id="7e9c5-137">컴퓨터 시스템에서 환상적인 예는 데이터베이스에 연결하는 사용자의 권리입니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-137">In a computer system, a fantastic example is the rights of a user connecting to a database.</span></span> <span data-ttu-id="7e9c5-138">대부분의 경우 데이터베이스 구조를 빌드하고 응용 프로그램을 실행하는 데 사용되는 단일 사용자 계정이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-138">In many cases, there's a single user account used to both build the database structure and run the application.</span></span> <span data-ttu-id="7e9c5-139">극단적인 경우를 제외하고 응용 프로그램을 실행하는 계정에는 스키마 정보를 업데이트할 수 있는 기능이 필요하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-139">Except in extreme cases, the account running the application doesn't need the ability to update schema information.</span></span> <span data-ttu-id="7e9c5-140">서로 다른 수준의 권한을 제공하는 여러 계정이 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-140">There should be several accounts that provide different levels of privilege.</span></span> <span data-ttu-id="7e9c5-141">응용 프로그램은 테이블의 데이터에 대한 읽기 및 쓰기 액세스 권한을 부여하는 권한 수준만 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-141">The application should only use the permission level that grants read and write access to the data in the tables.</span></span> <span data-ttu-id="7e9c5-142">이러한 종류의 보호는 데이터베이스 테이블을 삭제하거나 악의적인 트리거를 도입하려는 공격을 제거합니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-142">This kind of protection would eliminate attacks that aimed to drop database tables or introduce malicious triggers.</span></span>

<span data-ttu-id="7e9c5-143">클라우드 네이티브 응용 프로그램을 빌드하는 거의 모든 부분은 최소 권한 원칙을 기억하는 이점을 얻을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-143">Almost every part of building a cloud-native application can benefit from remembering the principle of least privilege.</span></span> <span data-ttu-id="7e9c5-144">RBAC(역할 기반 액세스 제어)에서 방화벽, 네트워크 보안 그룹, 역할 및 범위를 설정할 때 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-144">You can find it at play when setting up firewalls, network security groups, roles, and scopes in Role-based access control (RBAC).</span></span>

## <a name="penetration-testing"></a><span data-ttu-id="7e9c5-145">침투 테스트</span><span class="sxs-lookup"><span data-stu-id="7e9c5-145">Penetration testing</span></span>

<span data-ttu-id="7e9c5-146">응용 프로그램이 더 복잡해짐에 따라 공격 벡터의 수는 놀라운 속도로 증가합니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-146">As applications become more complicated the number of attack vectors increases at an alarming rate.</span></span> <span data-ttu-id="7e9c5-147">위협 모델링은 시스템을 구축하는 동일한 사람이 실행하는 경향이 있다는 점에서 결함이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-147">Threat modeling is flawed in that it tends to be executed by the same people building the system.</span></span> <span data-ttu-id="7e9c5-148">많은 개발자가 사용자 상호 작용을 구상하고 사용할 수 없는 사용자 인터페이스를 빌드하는 것과 마찬가지로 대부분의 개발자는 모든 공격 벡터를 보는 데 어려움을 겪습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-148">In the same way that many developers have trouble envisioning user interactions and then build unusable user interfaces, most developers have difficulty seeing every attack vector.</span></span> <span data-ttu-id="7e9c5-149">시스템을 구축하는 개발자가 공격 방법론에 정통하지 않고 중요한 것을 놓칠 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-149">It's also possible that the developers building the system aren't well versed in attack methodologies and miss something crucial.</span></span>

<span data-ttu-id="7e9c5-150">침투 테스트 또는 "펜 테스트"는 시스템을 공격하기 위해 외부 액터를 가져오는 것을 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-150">Penetration testing or "pen testing" involves bringing in external actors to attempt to attack the system.</span></span> <span data-ttu-id="7e9c5-151">이러한 공격자는 외부 컨설팅 회사 또는 비즈니스의 다른 부분에서 좋은 보안 지식을 가진 다른 개발자일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-151">These attackers may be an external consulting company or other developers with good security knowledge from another part of the business.</span></span> <span data-ttu-id="7e9c5-152">그들은 시스템을 전복하려고 카르테 블랑쉬를 부여하고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-152">They're given carte blanche to attempt to subvert the system.</span></span> <span data-ttu-id="7e9c5-153">패치해야 하는 광범위한 보안 허점을 자주 발견할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-153">Frequently, they'll find extensive security holes that need to be patched.</span></span> <span data-ttu-id="7e9c5-154">때로는 공격 벡터가 CEO에 대한 피싱 공격을 악용하는 것과 같이 전혀 예상치 못한 일이 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-154">Sometimes the attack vector will be something totally unexpected like exploiting a phishing attack against the CEO.</span></span>

<span data-ttu-id="7e9c5-155">Azure 자체는 지속적으로 [마이크로 소프트 내부 해커 의 팀에서](https://azure.microsoft.com/resources/videos/red-vs-blue-internal-security-penetration-testing-of-microsoft-azure/)공격을 받고있다 .</span><span class="sxs-lookup"><span data-stu-id="7e9c5-155">Azure itself is constantly undergoing attacks from a [team of hackers inside Microsoft](https://azure.microsoft.com/resources/videos/red-vs-blue-internal-security-penetration-testing-of-microsoft-azure/).</span></span> <span data-ttu-id="7e9c5-156">수년에 걸쳐, 그들은 잠재적으로 치명적인 공격 벡터 수십 을 발견 하는 첫 번째 되었습니다., 그들은 외부적으로 악용 될 수 있습니다 전에 그들을 폐쇄.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-156">Over the years, they've been the first to find dozens of potentially catastrophic attack vectors, closing them before they can be exploited externally.</span></span> <span data-ttu-id="7e9c5-157">대상을 더 유혹할수록 영원한 액터가 이를 악용하려고 시도할 가능성이 높아지고 Azure보다 더 유혹적인 몇 가지 대상이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-157">The more tempting a target, the more likely that eternal actors will attempt to exploit it and there are a few targets in the world more tempting than Azure.</span></span>

## <a name="monitoring"></a><span data-ttu-id="7e9c5-158">모니터링</span><span class="sxs-lookup"><span data-stu-id="7e9c5-158">Monitoring</span></span>

<span data-ttu-id="7e9c5-159">공격자가 응용 프로그램에 침투하려고 하면 몇 가지 경고가 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-159">Should an attacker attempt to penetrate an application, there should be some warning of it.</span></span> <span data-ttu-id="7e9c5-160">서비스에서 로그를 검사하여 공격을 자주 발견할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-160">Frequently, attacks can be spotted by examining the logs from services.</span></span> <span data-ttu-id="7e9c5-161">공격은 성공하기 전에 발견 할 수있는 이야기 흔적을 남깁니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-161">Attacks leave telltale signs that can be spotted before they succeed.</span></span> <span data-ttu-id="7e9c5-162">예를 들어 암호를 추측하려는 공격자는 로그인 시스템에 많은 요청을 합니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-162">For instance, an attacker attempting to guess a password will make many requests to a login system.</span></span> <span data-ttu-id="7e9c5-163">로그인 시스템을 모니터링하면 일반적인 액세스 패턴과 일치하지 않는 이상한 패턴을 감지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-163">Monitoring around the login system can detect weird patterns that are out of line with the typical access pattern.</span></span> <span data-ttu-id="7e9c5-164">이 모니터링은 작업 담당자에게 일종의 대책을 활성화하도록 경고할 수 있는 경고로 전환할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-164">This monitoring can be turned into an alert that can, in turn, alert an operations person to activate some sort of countermeasure.</span></span> <span data-ttu-id="7e9c5-165">고도로 성숙한 모니터링 시스템은 이러한 편차를 기반으로 조치를 취할 수도 있으며, 이러한 편차를 통해 요청을 차단하거나 응답을 제한하기 위한 규칙을 사전에 추가할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-165">A highly mature monitoring system might even take action based on these deviations proactively adding rules to block requests or throttle responses.</span></span>

## <a name="securing-the-build"></a><span data-ttu-id="7e9c5-166">빌드 보안</span><span class="sxs-lookup"><span data-stu-id="7e9c5-166">Securing the build</span></span>

<span data-ttu-id="7e9c5-167">보안이 간과되는 한 곳은 빌드 프로세스와 관련된 것입니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-167">One place where security is often overlooked is around the build process.</span></span> <span data-ttu-id="7e9c5-168">빌드가 안전하지 않은 코드 또는 체크 인 자격 증명을 검색하는 것과 같은 보안 검사를 실행해야 할 뿐만 아니라 빌드 자체는 안전해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-168">Not only should the build run security checks, such as scanning for insecure code or checked-in credentials, but the build itself should be secure.</span></span> <span data-ttu-id="7e9c5-169">빌드 서버가 손상된 경우 제품에 임의의 코드를 도입하기 위한 환상적인 벡터를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-169">If the build server is compromised, then it provides a fantastic vector for introducing arbitrary code into the product.</span></span>

<span data-ttu-id="7e9c5-170">공격자가 웹 응용 프로그램에 로그인하는 사람들의 암호를 훔치려고 한다고 가정해 보입니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-170">Imagine that an attacker is looking to steal the passwords of people signing into a web application.</span></span> <span data-ttu-id="7e9c5-171">체크 아웃된 코드를 수정하여 로그인 요청을 다른 서버에 미러하는 빌드 단계를 도입할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-171">They could introduce a build step that modifies the checked-out code to mirror any login request to another server.</span></span> <span data-ttu-id="7e9c5-172">다음에 코드가 빌드를 거치면 자동으로 업데이트됩니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-172">The next time code goes through the build, it's silently updated.</span></span> <span data-ttu-id="7e9c5-173">소스 코드 취약성 검색은 빌드 전에 실행될 때 이 것을 포착하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-173">The source code vulnerability scanning won't catch this as it runs before the build.</span></span> <span data-ttu-id="7e9c5-174">마찬가지로 빌드 단계가 빌드 서버에 있기 때문에 코드 검토에서 아무도 이를 catch하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-174">Equally, nobody will catch it in a code review because the build steps live on the build server.</span></span> <span data-ttu-id="7e9c5-175">악용된 코드는 암호를 수집할 수 있는 프로덕션으로 이동합니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-175">The exploited code will go to production where it can harvest passwords.</span></span> <span data-ttu-id="7e9c5-176">빌드 프로세스 변경에 대한 감사 로그가 없거나 감사를 모니터링하는 사람이 없을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-176">Probably there's no audit log of the build process changes, or at least nobody monitoring the audit.</span></span>

<span data-ttu-id="7e9c5-177">이는 시스템에 침입하는 데 사용할 수 있는 낮은 값의 대상을 완벽하게 예로 들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-177">This is a perfect example of a seemingly low value target that can be used to break into the system.</span></span> <span data-ttu-id="7e9c5-178">공격자가 시스템의 경계를 위반하면 원하는 곳 어디에서나 실제 피해를 줄 수 있는 수준으로 권한을 높이는 방법을 찾기 시작할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-178">Once an attacker breaches the perimeter of the system, they can start working on finding ways to elevate their permissions to the point that they can cause real harm anywhere they like.</span></span>

## <a name="building-secure-code"></a><span data-ttu-id="7e9c5-179">보안 코드 구축</span><span class="sxs-lookup"><span data-stu-id="7e9c5-179">Building secure code</span></span>

<span data-ttu-id="7e9c5-180">.NET 프레임워크는 이미 매우 안전한 프레임워크입니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-180">.NET Framework is already a quite secure framework.</span></span> <span data-ttu-id="7e9c5-181">배열의 끝을 걷는 것과 같이 관리되지 않는 코드의 일부 함정을 방지합니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-181">It avoids some of the pitfalls of unmanaged code, such as walking off the ends of arrays.</span></span> <span data-ttu-id="7e9c5-182">보안 허점이 발견되면 보안 허점을 해결하기 위한 작업이 활발히 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-182">Work is actively done to fix security holes as they're discovered.</span></span> <span data-ttu-id="7e9c5-183">심지어 [버그 현상금 프로그램은](https://www.microsoft.com/msrc/bounty) 프레임 워크에서 문제를 찾아 그들을 악용하는 대신보고 연구원을 지불합니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-183">There's even a [bug bounty program](https://www.microsoft.com/msrc/bounty) that pays researchers to find issues in the framework and report them instead of exploiting them.</span></span>

<span data-ttu-id="7e9c5-184">.NET 코드를 보다 안전하게 만드는 방법에는 여러 가지가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-184">There are many ways to make .NET code more secure.</span></span> <span data-ttu-id="7e9c5-185">.NET 문서에 [대한 보안 코딩 지침과](https://docs.microsoft.com/dotnet/standard/security/secure-coding-guidelines) 같은 지침을 따르는 것은 코드가 처음부터 안전하게 보호되도록 하는 합리적인 단계입니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-185">Following guidelines such as the [Secure coding guidelines for .NET](https://docs.microsoft.com/dotnet/standard/security/secure-coding-guidelines) article is a reasonable step to take to ensure that the code is secure from the ground up.</span></span> <span data-ttu-id="7e9c5-186">[OWASP 상위 10은](https://owasp.org/www-project-top-ten/) 보안 코드를 빌드하는 또 다른 귀중한 가이드입니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-186">The [OWASP top 10](https://owasp.org/www-project-top-ten/) is another invaluable guide to build secure code.</span></span>

<span data-ttu-id="7e9c5-187">빌드 프로세스는 프로덕션 에 들어가기 전에 소스 코드의 문제를 감지하는 검색 도구를 배치하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-187">The build process is a good place to put scanning tools to detect problems in source code before they make it into production.</span></span> <span data-ttu-id="7e9c5-188">대부분의 모든 프로젝트에는 다른 패키지에 대한 종속성이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-188">Most every project has dependencies on some other packages.</span></span> <span data-ttu-id="7e9c5-189">오래된 패키지를 검색 할 수있는 도구는 야간 빌드에서 문제를 잡을 것입니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-189">A tool that can scan for outdated packages will catch problems in a nightly build.</span></span> <span data-ttu-id="7e9c5-190">Docker 이미지를 빌드할 때도 기본 이미지에 알려진 취약점이 없는지 확인하고 확인하는 것이 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-190">Even when building Docker images, it's useful to check and make sure that the base image doesn't have known vulnerabilities.</span></span> <span data-ttu-id="7e9c5-191">확인해야 할 또 다른 점은 아무도 실수로 자격 증명을 체크 인하지 않았다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-191">Another thing to check is that nobody has accidentally checked in credentials.</span></span>

## <a name="built-in-security"></a><span data-ttu-id="7e9c5-192">기본 제공 보안</span><span class="sxs-lookup"><span data-stu-id="7e9c5-192">Built-in security</span></span>

<span data-ttu-id="7e9c5-193">Azure는 대부분의 사용자에 대한 유용성과 보안의 균형을 맞추도록 설계되었습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-193">Azure is designed to balance usability and security for the majority of users.</span></span> <span data-ttu-id="7e9c5-194">사용자마다 서로 다른 보안 요구 사항이 있으므로 클라우드 보안에 대한 접근 방식을 세밀하게 조정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-194">Different users are going to have different security requirements, so they need to fine-tune their approach to cloud security.</span></span> <span data-ttu-id="7e9c5-195">Microsoft는 [트러스트 센터에](https://azure.microsoft.com/support/trust-center/)많은 양의 보안 정보를 게시합니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-195">Microsoft publishes a great deal of security information in the [Trust Center](https://azure.microsoft.com/support/trust-center/).</span></span> <span data-ttu-id="7e9c5-196">이 리소스는 기본 제공 공격 완화 기술의 작동 방식을 이해하는 데 관심이 있는 전문가를 위한 첫 번째 중지가 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-196">This resource should be the first stop for those professionals interested in understanding how the built-in attack mitigation technologies work.</span></span>

<span data-ttu-id="7e9c5-197">Azure Portal 내에서 [Azure Advisor는](https://azure.microsoft.com/services/advisor/) 환경을 지속적으로 검색하고 권장 사항을 만드는 시스템입니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-197">Within the Azure portal, the [Azure Advisor](https://azure.microsoft.com/services/advisor/) is a system that is constantly scanning an environment and making recommendations.</span></span> <span data-ttu-id="7e9c5-198">이러한 권장 사항 중 일부는 사용자의 비용을 절감하도록 설계되었지만 다른 권장 사항은 가상 네트워크에 의해 보호되지 않고 전 세계에 저장소 컨테이너를 개방하는 것과 같이 잠재적으로 안전하지 않은 구성을 식별하도록 설계되었습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-198">Some of these recommendations are designed to save users money, but others are designed to identify potentially insecure configurations, such as having a storage container open to the world and not protected by a Virtual Network.</span></span>

## <a name="azure-network-infrastructure"></a><span data-ttu-id="7e9c5-199">Azure 네트워크 인프라</span><span class="sxs-lookup"><span data-stu-id="7e9c5-199">Azure network infrastructure</span></span>

<span data-ttu-id="7e9c5-200">온-프레미스 배포 환경에서는 네트워킹을 설정하는 데 많은 에너지가 집중됩니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-200">In an on-premises deployment environment, a great deal of energy is dedicated to setting up networking.</span></span> <span data-ttu-id="7e9c5-201">라우터, 스위치 를 설정하는 것은 복잡한 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-201">Setting up routers, switches, and the such is complicated work.</span></span> <span data-ttu-id="7e9c5-202">네트워크를 사용하면 특정 리소스가 다른 리소스와 통신하고 경우에 따라 액세스를 방지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-202">Networks allow certain resources to talk to other resources and prevent access in some cases.</span></span> <span data-ttu-id="7e9c5-203">빈번한 네트워크 규칙은 반개발 된 코드 조각이 잘못된 것을 실행하고 데이터 스와트를 삭제할 수 있는 오프 기회에 개발 환경에서 프로덕션 환경에 대한 액세스를 제한하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-203">A frequent network rule is to restrict access to the production environment from the development environment on the off chance that a half-developed piece of code runs awry and deletes a swath of data.</span></span>

<span data-ttu-id="7e9c5-204">기본적으로 대부분의 PaaS Azure 리소스에는 가장 기본적이고 허용적인 네트워킹 설정만 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-204">Out of the box, most PaaS Azure resources have only the most basic and permissive networking setup.</span></span> <span data-ttu-id="7e9c5-205">예를 들어 인터넷의 모든 사용자는 앱 서비스에 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-205">For instance, anybody on the Internet can access an app service.</span></span> <span data-ttu-id="7e9c5-206">새 SQL Server 인스턴스는 일반적으로 외부 사용자가 액세스할 수 없도록 제한되지만 Azure 자체에서 사용하는 IP 주소 범위는 허용됩니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-206">New SQL Server instances typically come restricted, so that external parties can't access them, but the IP address ranges used by Azure itself are permitted through.</span></span> <span data-ttu-id="7e9c5-207">따라서 SQL 서버가 외부 위협으로부터 보호되는 동안 공격자는 Azure의 모든 SQL 인스턴스에 대한 공격을 시작할 수 있는 Azure 브리지헤드만 설정하면 됩니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-207">So, while the SQL server is protected from external threats, an attacker only needs to set up an Azure bridgehead from where they can launch attacks against all SQL instances on Azure.</span></span>

<span data-ttu-id="7e9c5-208">다행히 대부분의 Azure 리소스를 Azure 가상 네트워크에 배치하여 보다 세분화된 액세스 제어를 허용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-208">Fortunately, most Azure resources can be placed into an Azure Virtual Network that allows finer grained access control.</span></span> <span data-ttu-id="7e9c5-209">온-프레미스 네트워크가 더 넓은 세계에서 보호되는 개인 네트워크를 설정하는 방식과 마찬가지로 가상 네트워크는 Azure 네트워크 내에 있는 개인 IP 주소의 섬입니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-209">Similar to the way that on-premises networks establish private networks that are protected from the wider world, virtual networks are islands of private IP addresses that are located within the Azure network.</span></span>

<span data-ttu-id="7e9c5-210">![그림 10-1 Azure](./media/virtual-network.png)
그림**10-1의**가상 네트워크 .</span><span class="sxs-lookup"><span data-stu-id="7e9c5-210">![Figure 10-1 A virtual network in Azure](./media/virtual-network.png)
**Figure 10-1**.</span></span> <span data-ttu-id="7e9c5-211">Azure의 가상 네트워크입니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-211">A virtual network in Azure.</span></span>

<span data-ttu-id="7e9c5-212">온-프레미스 네트워크에서 네트워크에 대한 액세스를 관리하는 방화벽을 사용하는 것과 마찬가지로 가상 네트워크 경계에 유사한 방화벽을 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-212">In the same way that on-premises networks have a firewall governing access to the network, you can establish a similar firewall at the boundary of the virtual network.</span></span> <span data-ttu-id="7e9c5-213">기본적으로 가상 네트워크의 모든 리소스는 여전히 인터넷과 통신할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-213">By default, all the resources on a virtual network can still talk to the Internet.</span></span> <span data-ttu-id="7e9c5-214">그것은 명시적 방화벽 예외의 일부 형태를 필요로 만 들어오는 연결입니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-214">It's only incoming connections that require some form of explicit firewall exception.</span></span>

<span data-ttu-id="7e9c5-215">네트워크가 설정되면 저장소 계정과 같은 내부 리소스를 가상 네트워크에 있는 리소스에 의해서만 액세스할 수 있도록 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-215">With the network established, internal resources like storage accounts can be set up to only allow for access by resources that are also on the Virtual Network.</span></span> <span data-ttu-id="7e9c5-216">이 방화벽은 해당 저장소 계정의 키가 유출되면 공격자가 유출된 키를 악용하기 위해 연결하지 못할 경우 추가 수준의 보안을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-216">This firewall provides an extra level of security, should the keys for that storage account be leaked, attackers wouldn't be able to connect to it to exploit the leaked keys.</span></span> <span data-ttu-id="7e9c5-217">이것은 최소 권한 원칙의 또 다른 예입니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-217">This is another example of the principle of least privilege.</span></span>

<span data-ttu-id="7e9c5-218">Azure Kubernetes 클러스터의 노드는 Azure에 더 많이 네이티브인 다른 리소스와 마찬가지로 가상 네트워크에 참여할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-218">The nodes in an Azure Kubernetes cluster can participate in a virtual network just like other resources that are more native to Azure.</span></span> <span data-ttu-id="7e9c5-219">이 기능을 [Azure 컨테이너 네트워킹 인터페이스라고](https://github.com/Azure/azure-container-networking/blob/master/docs/cni.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-219">This functionality is called [Azure Container Networking Interface](https://github.com/Azure/azure-container-networking/blob/master/docs/cni.md).</span></span> <span data-ttu-id="7e9c5-220">실제로 가상 시스템 및 컨테이너 이미지가 할당되는 가상 네트워크 내에 서브넷을 할당합니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-220">In effect, it allocates a subnet within the virtual network on which virtual machines and container images are allocated.</span></span>

<span data-ttu-id="7e9c5-221">최소 권한의 원칙을 설명하는 경로를 계속 따라가며 가상 네트워크 내의 모든 리소스가 다른 모든 리소스와 통신할 필요는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-221">Continuing down the path of illustrating the principle of least privilege, not every resource within a Virtual Network needs to talk to every other resource.</span></span> <span data-ttu-id="7e9c5-222">예를 들어 저장소 계정과 SQL 데이터베이스를 통해 웹 API를 제공하는 응용 프로그램에서는 데이터베이스와 저장소 계정이 서로 대화해야 할 가능성이 거의 없습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-222">For instance, in an application that provides a web API over a storage account and a SQL database, it's unlikely that the database and the storage account need to talk to one another.</span></span> <span data-ttu-id="7e9c5-223">그들 사이의 모든 데이터 공유는 웹 응용 프로그램을 통해 이동합니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-223">Any data sharing between them would go through the web application.</span></span> <span data-ttu-id="7e9c5-224">따라서 [NSG(네트워크 보안 그룹)를](https://docs.microsoft.com/azure/virtual-network/security-overview) 사용하여 두 서비스 간의 트래픽을 거부할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-224">So, a [network security group (NSG)](https://docs.microsoft.com/azure/virtual-network/security-overview) could be used to deny traffic between the two services.</span></span>

<span data-ttu-id="7e9c5-225">리소스 간의 통신을 거부하는 정책은 특히 트래픽 제한 없이 Azure를 사용하는 배경에서 오는 구현에 성가신 일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-225">A policy of denying communication between resources can be annoying to implement, especially coming from a background of using Azure without traffic restrictions.</span></span> <span data-ttu-id="7e9c5-226">다른 클라우드에서는 네트워크 보안 그룹의 개념이 훨씬 더 널리 퍼져 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-226">On some other clouds, the concept of network security groups is much more prevalent.</span></span> <span data-ttu-id="7e9c5-227">예를 들어 AWS의 기본 정책은 NSG의 규칙에 의해 활성화될 때까지 리소스가 서로 통신할 수 없다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-227">For instance, the default policy on AWS is that resources can't communicate among themselves until enabled by rules in an NSG.</span></span> <span data-ttu-id="7e9c5-228">이 개발을 느리게 하는 동안 보다 제한적인 환경은 보다 안전한 기본값을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-228">While slower to develop this, more restrictive environment provides a more secure default.</span></span> <span data-ttu-id="7e9c5-229">적절한 DevOps 방법을 사용하면 특히 [Azure 리소스 관리자 또는 Terraform을](infrastructure-as-code.md) 사용하여 사용 권한을 관리하면 규칙을 보다 쉽게 제어할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-229">Making use of proper DevOps practices, especially using [Azure Resource Manager or Terraform](infrastructure-as-code.md) to manage permissions can make controlling the rules easier.</span></span>

<span data-ttu-id="7e9c5-230">가상 네트워크는 온-프레미스 및 클라우드 리소스 간의 통신을 설정할 때도 유용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-230">Virtual Networks can also be useful when setting up communication between on-premises and cloud resources.</span></span> <span data-ttu-id="7e9c5-231">가상 사설망을 사용하여 두 네트워크를 함께 원활하게 연결할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-231">A virtual private network can be used to seamlessly attach the two networks together.</span></span> <span data-ttu-id="7e9c5-232">이렇게 하면 모든 사용자가 현장에 있는 시나리오에 대한 게이트웨이 없이 가상 네트워크를 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-232">This allows running a virtual network without any sort of gateway for scenarios where all the users are on-site.</span></span> <span data-ttu-id="7e9c5-233">이 네트워크를 설정하는 데 사용할 수 있는 여러 기술이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-233">There are a number of technologies that can be used to establish this network.</span></span> <span data-ttu-id="7e9c5-234">가장 간단한 방법은 많은 라우터와 Azure 간에 설정될 수 있는 [사이트 간 VPN을](https://docs.microsoft.com/azure/vpn-gateway/vpn-gateway-about-vpngateways?toc=%2fazure%2fvirtual-network%2ftoc.json#s2smulti) 사용하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-234">The simplest is to use a [site-to-site VPN](https://docs.microsoft.com/azure/vpn-gateway/vpn-gateway-about-vpngateways?toc=%2fazure%2fvirtual-network%2ftoc.json#s2smulti) that can be established between many routers and Azure.</span></span> <span data-ttu-id="7e9c5-235">트래픽은 다른 트래픽과 동일한 바이트당 비용으로 인터넷을 통해 암호화되고 터널로 관리됩니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-235">Traffic is encrypted and tunneled over the Internet at the same cost per byte as any other traffic.</span></span> <span data-ttu-id="7e9c5-236">더 많은 대역폭 또는 더 많은 보안이 바람직한 시나리오의 경우 Azure는 온-프레미스 네트워크와 Azure 간의 전용 회로를 사용하는 [Express Route라는](https://docs.microsoft.com/azure/vpn-gateway/vpn-gateway-about-vpngateways?toc=%2fazure%2fvirtual-network%2ftoc.json#ExpressRoute) 서비스를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-236">For scenarios where more bandwidth or more security is desirable, Azure offers a service called [Express Route](https://docs.microsoft.com/azure/vpn-gateway/vpn-gateway-about-vpngateways?toc=%2fazure%2fvirtual-network%2ftoc.json#ExpressRoute) that uses a private circuit between an on-premises network and Azure.</span></span> <span data-ttu-id="7e9c5-237">그것은 더 비용이 많이 들고 설립하기 어렵지만 더 안전합니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-237">It's more costly and difficult to establish but also more secure.</span></span>

## <a name="role-based-access-control-for-restricting-access-to-azure-resources"></a><span data-ttu-id="7e9c5-238">Azure 리소스에 대한 액세스를 제한하기 위한 역할 기반 액세스 제어</span><span class="sxs-lookup"><span data-stu-id="7e9c5-238">Role-based access control for restricting access to Azure resources</span></span>

<span data-ttu-id="7e9c5-239">RBAC는 Azure에서 실행 중인 응용 프로그램에 ID를 제공하는 시스템입니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-239">RBAC is a system that provides an identity to applications running in Azure.</span></span> <span data-ttu-id="7e9c5-240">응용 프로그램은 키 나 암호를 사용하는 대신 또는 이외에이 ID를 사용하여 리소스에 액세스 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-240">Applications can access resources using this identity instead of or in addition to using keys or passwords.</span></span>

## <a name="security-principals"></a><span data-ttu-id="7e9c5-241">보안 주체</span><span class="sxs-lookup"><span data-stu-id="7e9c5-241">Security Principals</span></span>

<span data-ttu-id="7e9c5-242">RBAC의 첫 번째 구성 요소는 보안 주체입니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-242">The first component in RBAC is a security principal.</span></span> <span data-ttu-id="7e9c5-243">보안 주체는 사용자, 그룹, 서비스 주체 또는 관리되는 ID일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-243">A security principal can be a user, group, service principal, or managed identity.</span></span>

<span data-ttu-id="7e9c5-244">![그림 10-2 보안 주체의 다른 유형](./media/rbac-security-principal.png)
**그림 10-2**.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-244">![Figure 10-2 Different types of security principals](./media/rbac-security-principal.png)
**Figure 10-2**.</span></span> <span data-ttu-id="7e9c5-245">다양한 유형의 보안 주체.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-245">Different types of security principals.</span></span>

- <span data-ttu-id="7e9c5-246">사용자 - Azure Active Directory에 계정이 있는 모든 사용자는 사용자입니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-246">User - Any user who has an account in Azure Active Directory is a user.</span></span>
- <span data-ttu-id="7e9c5-247">그룹 - Azure Active Directory의 사용자 컬렉션입니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-247">Group - A collection of users from Azure Active Directory.</span></span> <span data-ttu-id="7e9c5-248">그룹의 구성원은 사용자가 자신의 역할 과 함께 해당 그룹의 역할을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-248">As a member of a group, a user takes on the roles of that group in addition to their own.</span></span>
- <span data-ttu-id="7e9c5-249">서비스 주체 - 서비스 또는 응용 프로그램이 실행되는 보안 ID입니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-249">Service principal - A security identity under which services or applications run.</span></span>
- <span data-ttu-id="7e9c5-250">관리되는 ID - Azure에서 관리하는 Azure Active Directory ID입니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-250">Managed identity - An Azure Active Directory identity managed by Azure.</span></span> <span data-ttu-id="7e9c5-251">관리되는 ID는 일반적으로 Azure 서비스에 대한 인증을 인증하기 위한 자격 증명을 관리하는 클라우드 응용 프로그램을 개발할 때 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-251">Managed identities are typically used when developing cloud applications that manage the credentials for authenticating to Azure services.</span></span>

<span data-ttu-id="7e9c5-252">보안 주체는 대부분의 리소스에 적용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-252">The security principal can be applied to most any resource.</span></span> <span data-ttu-id="7e9c5-253">즉, Azure Kubernetes 내에서 실행 중인 컨테이너에 보안 주체를 할당하여 키 볼트에 저장된 비밀에 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-253">This means that it's possible to assign a security principal to a container running within Azure Kubernetes, allowing it to access secrets stored in Key Vault.</span></span> <span data-ttu-id="7e9c5-254">Azure Function은 Active Directory 인스턴스와 대화하여 호출 사용자에 대한 JWT의 유효성을 검사할 수 있는 권한을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-254">An Azure Function could take on a permission allowing it to talk to an Active Directory instance to validate a JWT for a calling user.</span></span> <span data-ttu-id="7e9c5-255">서비스 주체를 사용하여 서비스를 사용하도록 설정하면 역할 및 범위를 사용하여 해당 권한을 세부적으로 관리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-255">Once services are enabled with a service principal, their permissions can be managed granularly using roles and scopes.</span></span>

## <a name="roles"></a><span data-ttu-id="7e9c5-256">역할</span><span class="sxs-lookup"><span data-stu-id="7e9c5-256">Roles</span></span>

<span data-ttu-id="7e9c5-257">보안 주체는 많은 역할을 수행하거나 더 사토리얼 비유를 사용하여 많은 모자를 착용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-257">A security principal can take on many roles or, using a more sartorial analogy, wear many hats.</span></span> <span data-ttu-id="7e9c5-258">각 역할은 "Azure Service Bus 끝점에서 메시지 읽기"와 같은 일련의 사용 권한을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-258">Each role defines a series of permissions such as "Read messages from Azure Service Bus endpoint".</span></span> <span data-ttu-id="7e9c5-259">보안 주체의 유효 권한 집합은 보안 주체가 가지고 있는 모든 역할에 할당된 모든 사용 권한의 조합입니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-259">The effective permission set of a security principal is the combination of all the permissions assigned to all the roles that security principal has.</span></span> <span data-ttu-id="7e9c5-260">Azure에는 많은 수의 기본 제공 역할이 있으며 사용자는 자신의 역할을 정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-260">Azure has a large number of built-in roles and users can define their own roles.</span></span>

<span data-ttu-id="7e9c5-261">![그림 10-3 RBAC](./media/rbac-role-definition.png)
역할 정의**그림 10-3**.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-261">![Figure 10-3 RBAC role definitions](./media/rbac-role-definition.png)
**Figure 10-3**.</span></span> <span data-ttu-id="7e9c5-262">RBAC 역할 정의.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-262">RBAC role definitions.</span></span>

<span data-ttu-id="7e9c5-263">Azure에 기본 제공되는 것은 소유자, 기여자, 판독기 및 사용자 계정 관리자와 같은 여러 상위 수준 역할입니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-263">Built into Azure are also a number of high-level roles such as Owner, Contributor, Reader, and User Account Administrator.</span></span> <span data-ttu-id="7e9c5-264">소유자 역할을 사용하면 보안 주체가 모든 리소스에 액세스하고 다른 사람에게 권한을 할당할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-264">With the Owner role, a security principal can access all resources and assign permissions to others.</span></span> <span data-ttu-id="7e9c5-265">참여자는 모든 리소스에 대해 동일한 수준의 액세스 권한을 가졌지만 권한을 할당할 수는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-265">A contributor has the same level of access to all resources but they can't assign permissions.</span></span> <span data-ttu-id="7e9c5-266">독자는 기존 Azure 리소스만 볼 수 있으며 사용자 계정 관리자는 Azure 리소스에 대한 액세스를 관리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-266">A Reader can only view existing Azure resources and a User Account Administrator can manage access to Azure resources.</span></span>

<span data-ttu-id="7e9c5-267">[DNS 영역 기여자와](https://docs.microsoft.com/azure/role-based-access-control/built-in-roles#dns-zone-contributor) 같은 보다 세분화된 기본 제공 역할은 단일 서비스로 제한되는 권한을 갖습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-267">More granular built-in roles such as [DNS Zone Contributor](https://docs.microsoft.com/azure/role-based-access-control/built-in-roles#dns-zone-contributor) have rights limited to a single service.</span></span> <span data-ttu-id="7e9c5-268">보안 주체는 수에 관계없이 여러 역할을 맡을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-268">Security principals can take on any number of roles.</span></span>

## <a name="scopes"></a><span data-ttu-id="7e9c5-269">범위</span><span class="sxs-lookup"><span data-stu-id="7e9c5-269">Scopes</span></span>

<span data-ttu-id="7e9c5-270">Azure 내의 제한된 리소스 집합에 역할을 적용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-270">Roles can be applied to a restricted set of resources within Azure.</span></span> <span data-ttu-id="7e9c5-271">예를 들어 서비스 버스 큐에서 읽는 이전 예제에 범위를 적용하면 "Azure Service Bus Endpoint에서 `blah.servicebus.windows.net/queue1`메시지 읽기" 등 단일 큐로 권한을 좁힐 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-271">For instance, applying scope to the previous example of reading from a Service Bus queue, you can narrow the permission to a single queue: "Read messages from Azure Service Bus endpoint `blah.servicebus.windows.net/queue1`"</span></span>

<span data-ttu-id="7e9c5-272">범위는 단일 리소스만큼 좁거나 전체 리소스 그룹, 구독 또는 관리 그룹에 적용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-272">The scope can be as narrow as a single resource or it can be applied to an entire resource group, subscription, or even management group.</span></span>

<span data-ttu-id="7e9c5-273">보안 주체에 특정 권한이 있는지 테스트할 때 역할과 범위의 조합이 고려됩니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-273">When testing if a security principal has a certain permission, the combination of role and scope are taken into account.</span></span> <span data-ttu-id="7e9c5-274">이 조합은 강력한 권한 부여 메커니즘을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-274">This combination provides a powerful authorization mechanism.</span></span>

## <a name="deny"></a><span data-ttu-id="7e9c5-275">거부</span><span class="sxs-lookup"><span data-stu-id="7e9c5-275">Deny</span></span>

<span data-ttu-id="7e9c5-276">이전에는 RBAC에 대해 "허용" 규칙만 허용되었습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-276">Previously, only "allow" rules were permitted for RBAC.</span></span> <span data-ttu-id="7e9c5-277">이 동작으로 인해 일부 범위를 빌드하기가 복잡해졌습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-277">This behavior made some scopes complicated to build.</span></span> <span data-ttu-id="7e9c5-278">예를 들어, 잠재적으로 무한한 저장소 계정 목록에 명시적 권한을 부여하는 데 필요한 저장소 계정을 제외한 모든 저장소 계정에 대한 보안 주체 액세스를 허용합니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-278">For instance, allowing a security principal access to all storage accounts except one required granting explicit permission to a potentially endless list of storage accounts.</span></span> <span data-ttu-id="7e9c5-279">새 저장소 계정을 만들 때마다 이 계정 목록에 추가해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-279">Every time a new storage account was created, it would have to be added to this list of accounts.</span></span> <span data-ttu-id="7e9c5-280">이로 인해 관리 오버헤드가 추가되었습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-280">This added management overhead that certainly wasn't desirable.</span></span>

<span data-ttu-id="7e9c5-281">거부 규칙은 허용 규칙보다 우선합니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-281">Deny rules take precedence over allow rules.</span></span> <span data-ttu-id="7e9c5-282">이제 동일한 "하나를 제외한 모든 허용" 범위를 나타내는 두 개의 규칙 "모두 허용"과 "이 특정 범위를 거부"로 나타낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-282">Now representing the same "allow all but one" scope could be represented as two rules "allow all" and "deny this one specific one".</span></span> <span data-ttu-id="7e9c5-283">거부 규칙은 관리를 용이하게 할 뿐만 아니라 모든 사람에게 대한 액세스를 거부하여 보안을 더욱 안전하게 하는 리소스를 허용합니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-283">Deny rules not only ease management but allow for resources that are extra secure by denying access to everybody.</span></span>

## <a name="checking-access"></a><span data-ttu-id="7e9c5-284">액세스 확인</span><span class="sxs-lookup"><span data-stu-id="7e9c5-284">Checking access</span></span>

<span data-ttu-id="7e9c5-285">상상할 수 있듯이 많은 수의 역할과 범위를 보유하면 서비스 주체의 효과적인 권한을 파악하기가 매우 어려울 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-285">As you can imagine, having a large number of roles and scopes can make figuring out the effective permission of a service principal quite difficult.</span></span> <span data-ttu-id="7e9c5-286">그 위에 거부 규칙을 쌓아, 단지 복잡성을 증가하는 역할을한다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-286">Piling deny rules on top of that, only serves to increase the complexity.</span></span> <span data-ttu-id="7e9c5-287">다행히모든 서비스 주체에 대한 유효 권한을 표시할 수 있는 사용 권한 계산기가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-287">Fortunately, there's a permissions calculator that can show the effective permissions for any service principal.</span></span> <span data-ttu-id="7e9c5-288">일반적으로 그림 10-3과 같이 포털의 IAM 탭 아래에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-288">It's typically found under the IAM tab in the portal, as shown in Figure 10-3.</span></span>

<span data-ttu-id="7e9c5-289">![그림 10-4 앱 서비스에](./media/check-rbac.png)
대한 권한 계산기 그림**10-4**.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-289">![Figure 10-4 Permission calculator for an app service](./media/check-rbac.png)
**Figure 10-4**.</span></span> <span data-ttu-id="7e9c5-290">앱 서비스에 대한 권한 계산기입니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-290">Permission calculator for an app service.</span></span>

## <a name="securing-secrets"></a><span data-ttu-id="7e9c5-291">비밀 보호</span><span class="sxs-lookup"><span data-stu-id="7e9c5-291">Securing secrets</span></span>

<span data-ttu-id="7e9c5-292">암호와 인증서는 공격자의 일반적인 공격 벡터입니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-292">Passwords and certificates are a common attack vector for attackers.</span></span> <span data-ttu-id="7e9c5-293">암호 해독 하드웨어는 무차별 암호 대입 공격을 수행하여 초당 수십억 개의 암호를 추측하려고 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-293">Password-cracking hardware can do a  brute-force attack and try to guess billions of passwords per second.</span></span> <span data-ttu-id="7e9c5-294">따라서 리소스에 액세스하는 데 사용되는 암호는 다양한 문자로 강력해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-294">So it's important that the passwords that are used to access resources are strong, with a large variety of characters.</span></span> <span data-ttu-id="7e9c5-295">이러한 암호는 기억하기 거의 불가능한 암호의 종류입니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-295">These passwords are exactly the kind of passwords that are near impossible to remember.</span></span> <span data-ttu-id="7e9c5-296">다행히 Azure의 암호는 실제로 사람이 알 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-296">Fortunately, the passwords in Azure don't actually need to be known by any human.</span></span>

<span data-ttu-id="7e9c5-297">많은 보안 전문가들은 암호 관리자를 사용하여 자신의 암호를 유지하는 것이 가장 좋은 방법이라고 [제안합니다.](https://www.troyhunt.com/password-managers-dont-have-to-be-perfect-they-just-have-to-be-better-than-not-having-one/)</span><span class="sxs-lookup"><span data-stu-id="7e9c5-297">Many security [experts suggest](https://www.troyhunt.com/password-managers-dont-have-to-be-perfect-they-just-have-to-be-better-than-not-having-one/) that using a password manager to keep your own passwords is the best approach.</span></span> <span data-ttu-id="7e9c5-298">한 위치에서 암호를 중앙 집중화하지만 매우 복잡한 암호를 사용하고 각 계정에 고유하게 되도록 할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-298">While it centralizes your passwords in one location, it also allows using highly complex passwords and ensuring they're unique for each account.</span></span> <span data-ttu-id="7e9c5-299">Azure 에는 비밀에 대한 중앙 저장소와 동일한 시스템이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-299">The same system exists within Azure: a central store for secrets.</span></span>

## <a name="azure-key-vault"></a><span data-ttu-id="7e9c5-300">Azure Key Vault</span><span class="sxs-lookup"><span data-stu-id="7e9c5-300">Azure Key Vault</span></span>

<span data-ttu-id="7e9c5-301">Azure Key Vault는 데이터베이스, API 키 및 인증서와 같은 항목에 대한 암호를 저장하는 중앙 집중식 위치를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-301">Azure Key Vault provides a centralized location to store passwords for things such as databases, API keys, and certificates.</span></span> <span data-ttu-id="7e9c5-302">보안 되는 볼트에 비밀을 입력 하면 다시 표시 되지 않습니다 및 추출 하 고 그것을 볼 명령 의도적으로 복잡 한.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-302">Once a secret is entered into the Vault, it's never shown again and the commands to extract and view it are purposefully complicated.</span></span> <span data-ttu-id="7e9c5-303">금고의 정보는 소프트웨어 암호화 또는 FIPS 140-2 레벨 2 검증된 하드웨어 보안 모듈을 사용하여 보호됩니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-303">The information in the safe is protected using either software encryption or FIPS 140-2 Level 2 validated Hardware Security Modules.</span></span>

<span data-ttu-id="7e9c5-304">키 자격 증명 모음에 대한 액세스는 RBAC를 통해 제공되므로 모든 사용자가 볼트의 정보에 액세스할 수 있는 것은 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-304">Access to the key vault is provided through RBACs, meaning that not just any user can access the information in the vault.</span></span> <span data-ttu-id="7e9c5-305">웹 응용 프로그램이 Azure Key Vault에 저장된 데이터베이스 연결 문자열에 액세스하려고 한다고 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-305">Say a web application wishes to access the database connection string stored in Azure Key Vault.</span></span> <span data-ttu-id="7e9c5-306">액세스 권한을 얻으려면 응용 프로그램을 서비스 주체를 사용하여 실행해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-306">To gain access, applications need to run using a service principal.</span></span> <span data-ttu-id="7e9c5-307">이 가정 된 역할에서, 그들은 금고에서 비밀을 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-307">Under this assumed role, they can read the secrets from the safe.</span></span> <span data-ttu-id="7e9c5-308">응용 프로그램이 볼트에 대한 액세스를 추가로 제한할 수 있는 여러 가지 보안 설정이 있으므로 비밀을 업데이트할 수 있지만 읽을 수만 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-308">There are a number of different security settings that can further limit the access that an application has to the vault, so that it can't update secrets but only read them.</span></span>

<span data-ttu-id="7e9c5-309">키 자격 증명 모음에 대한 액세스를 모니터링하여 예상되는 응용 프로그램만 볼트에 액세스하고 있는지 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-309">Access to the key vault can be monitored to ensure that only the expected applications are accessing the vault.</span></span> <span data-ttu-id="7e9c5-310">로그는 Azure Monitor에 다시 통합되어 예기치 않은 조건이 발생할 때 경고를 설정하는 기능을 잠금 해제할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-310">The logs can be integrated back into Azure Monitor, unlocking the ability to set up alerts when unexpected conditions are encountered.</span></span>

## <a name="kubernetes"></a><span data-ttu-id="7e9c5-311">Kubernetes</span><span class="sxs-lookup"><span data-stu-id="7e9c5-311">Kubernetes</span></span>

<span data-ttu-id="7e9c5-312">Kubernetes 에는 작은 비밀 정보를 유지하는 유사한 서비스가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-312">Within Kubernetes, there's a similar service for maintaining small pieces of secret information.</span></span> <span data-ttu-id="7e9c5-313">Kubernetes 비밀은 일반적인 `kubectl` 실행 을 통해 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-313">Kubernetes Secrets can be set via the typical `kubectl` executable.</span></span>

<span data-ttu-id="7e9c5-314">비밀을 만드는 것은 저장할 값의 base64 버전을 찾는 것만큼 간단합니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-314">Creating a secret is as simple as finding the base64 version of the values to be stored:</span></span>

```console
echo -n 'admin' | base64
YWRtaW4=
echo -n '1f2d1e2e67df' | base64
MWYyZDFlMmU2N2Rm
```

<span data-ttu-id="7e9c5-315">그런 다음 다음 예제와 `secret.yml` 유사한 예와 같은 이름의 비밀 파일에 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-315">Then adding it to a secrets file named `secret.yml` for example that looks similar to the following example:</span></span>

```yml
apiVersion: v1
kind: Secret
metadata:
  name: mysecret
type: Opaque
data:
  username: YWRtaW4=
  password: MWYyZDFlMmU2N2Rm
```

<span data-ttu-id="7e9c5-316">마지막으로 다음 명령을 실행하여 이 파일을 Kubernetes에 로드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-316">Finally, this file can be loaded into Kubernetes by running the following command:</span></span>

```console
kubectl apply -f ./secret.yaml
```

<span data-ttu-id="7e9c5-317">그런 다음 이러한 비밀을 볼륨에 탑재하거나 환경 변수를 통해 컨테이너 프로세스에 노출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-317">These secrets can then be mounted into volumes or exposed to container processes through environment variables.</span></span> <span data-ttu-id="7e9c5-318">응용 프로그램을 빌드하는 [12단계 앱](https://12factor.net/) 접근 방식은 가장 낮은 공통 분모를 사용하여 응용 프로그램에 설정을 전송하는 것을 제안합니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-318">The [Twelve-factor app](https://12factor.net/) approach to building applications suggests using the lowest common denominator to transmit settings to an application.</span></span> <span data-ttu-id="7e9c5-319">환경 변수는 운영 체제 나 응용 프로그램에 관계없이 지원되기 때문에 가장 낮은 공통 분모입니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-319">Environment variables are the lowest common denominator, because they're supported no matter the operating system or application.</span></span>

<span data-ttu-id="7e9c5-320">기본 제공 Kubernetes 비밀을 사용하는 대안은 Kubernetes 내에서 Azure 키 볼트의 비밀에 액세스하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-320">An alternative to use the built-in Kubernetes secrets is to access the secrets in Azure Key Vault from within Kubernetes.</span></span> <span data-ttu-id="7e9c5-321">이 작업을 수행하는 가장 간단한 방법은 비밀을 로드하려는 컨테이너에 RBAC 역할을 할당하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-321">The simplest way to do this is to assign an RBAC role to the container looking to load secrets.</span></span> <span data-ttu-id="7e9c5-322">그런 다음 응용 프로그램은 Azure Key Vault API를 사용하여 비밀에 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-322">The application can then use the Azure Key Vault APIs to access the secrets.</span></span> <span data-ttu-id="7e9c5-323">그러나 이 방법을 사용 하려면 코드를 수정 해야 하며 환경 변수를 사용 하 여 패턴을 따르지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-323">However, this approach requires modifications to the code and doesn't follow the pattern of using environment variables.</span></span> <span data-ttu-id="7e9c5-324">대신 [Azure 키 볼트 인젝터를](https://mrdevops.io/introducing-azure-key-vault-to-kubernetes-931f82364354)사용하여 컨테이너에 값을 삽입할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-324">Instead, it's possible to inject values into a container through the use of the [Azure Key Vault Injector](https://mrdevops.io/introducing-azure-key-vault-to-kubernetes-931f82364354).</span></span> <span data-ttu-id="7e9c5-325">이 방법은 클러스터의 사용자가 액세스할 수 있기 때문에 Kubernetes 비밀을 직접 사용하는 것보다 더 안전합니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-325">This approach is actually more secure than using the Kubernetes secrets directly, as they can be accessed by users on the cluster.</span></span>

## <a name="encryption-in-transit-and-at-rest"></a><span data-ttu-id="7e9c5-326">전송 중 및 미사용 암호화</span><span class="sxs-lookup"><span data-stu-id="7e9c5-326">Encryption in transit and at rest</span></span>

<span data-ttu-id="7e9c5-327">데이터를 안전하게 유지하는 것은 디스크에 있든 다양한 서비스 간에 전송하든 간에 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-327">Keeping data safe is important whether it's on disk or transiting between various different services.</span></span> <span data-ttu-id="7e9c5-328">데이터가 유출되지 않도록 하는 가장 효과적인 방법은 다른 사람이 쉽게 읽을 수 없는 형식으로 암호화하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-328">The most effective way to keep data from leaking is to encrypt it into a format that can't be easily read by others.</span></span> <span data-ttu-id="7e9c5-329">Azure는 광범위한 암호화 옵션을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-329">Azure supports a wide range of encryption options.</span></span>

### <a name="in-transit"></a><span data-ttu-id="7e9c5-330">전송 중</span><span class="sxs-lookup"><span data-stu-id="7e9c5-330">In transit</span></span>

<span data-ttu-id="7e9c5-331">Azure의 네트워크에서 트래픽을 암호화하는 방법에는 여러 가지가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-331">There are several ways to encrypt traffic on the network in Azure.</span></span> <span data-ttu-id="7e9c5-332">Azure 서비스에 대한 액세스는 일반적으로 TLS(전송 계층 보안)를 사용하는 연결을 통해 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-332">The access to Azure services is typically done over connections that use Transport Layer Security (TLS).</span></span> <span data-ttu-id="7e9c5-333">예를 들어 Azure API에 대한 모든 연결에는 TLS 연결이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-333">For instance, all the connections to the Azure APIs require TLS connections.</span></span> <span data-ttu-id="7e9c5-334">마찬가지로 Azure 저장소의 끝점에 대한 연결은 TLS 암호화된 연결을 통해서만 작동하도록 제한될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-334">Equally, connections to endpoints in Azure storage can be restricted to work only over TLS encrypted connections.</span></span>

<span data-ttu-id="7e9c5-335">TLS는 복잡한 프로토콜이며 연결이 TLS를 사용하고 있다는 것을 알면 보안을 보장하기에 충분하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-335">TLS is a complicated protocol and simply knowing that the connection is using TLS isn't sufficient to ensure security.</span></span> <span data-ttu-id="7e9c5-336">예를 들어 TLS 1.0은 만성적으로 안전하지 않으며 TLS 1.1은 그다지 좋지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-336">For instance, TLS 1.0 is chronically insecure, and TLS 1.1 isn't much better.</span></span> <span data-ttu-id="7e9c5-337">TLS 버전 내에서도 연결을 해독하기 쉽게 만들 수 있는 다양한 설정이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-337">Even within the versions of TLS, there are various settings that can make the connections easier to decrypt.</span></span> <span data-ttu-id="7e9c5-338">가장 좋은 방법은 서버 연결이 최신 의 잘 구성된 프로토콜을 사용하고 있는지 확인하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-338">The best course of action is to check and see if the server connection is using up-to-date and well configured protocols.</span></span>

<span data-ttu-id="7e9c5-339">이 검사는 SSL 랩의 SSL 서버 테스트와 같은 외부 서비스에서 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-339">This check can be done by an external service such as SSL labs' SSL Server Test.</span></span> <span data-ttu-id="7e9c5-340">일반적인 Azure 끝점에 대해 실행되는 테스트(이 경우 서비스 버스 끝점은 A의 거의 완벽한 점수를 산출합니다).</span><span class="sxs-lookup"><span data-stu-id="7e9c5-340">A test run against a typical Azure endpoint, in this case a service bus endpoint, yields a near perfect score of A.</span></span>

<span data-ttu-id="7e9c5-341">Azure SQL 데이터베이스와 같은 서비스도 TLS 암호화를 사용하여 데이터를 숨김 상태로 유지합니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-341">Even services like Azure SQL databases use TLS encryption to keep data hidden.</span></span> <span data-ttu-id="7e9c5-342">TLS를 사용하여 전송 중인 데이터를 암호화하는 흥미로운 부분은 Microsoft에서도 TLS를 실행하는 컴퓨터 간의 연결을 수신할 수 없다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-342">The interesting part about encrypting the data in transit using TLS is that it isn't possible, even for Microsoft, to listen in on the connection between computers running TLS.</span></span> <span data-ttu-id="7e9c5-343">이렇게 하면 데이터가 Microsoft의 적절한 위험에 노출되거나 표준 공격자보다 더 많은 리소스를 가진 상태 행위자가 위험에 처할 수 있다고 우려하는 회사에 편안함을 제공해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-343">This should provide comfort for companies concerned that their data may be at risk from Microsoft proper or even a state actor with more resources than the standard attacker.</span></span>

<span data-ttu-id="7e9c5-344">![그림 10-5 SSL 랩보고서는 서비스 버스 엔드포인트에 대한 A점수를 보여 주다. ](./media/ssl-report.png)
 **그림 10-5**.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-344">![Figure 10-5 SSL labs report showing a score of A for a Service Bus endpoint.](./media/ssl-report.png)
**Figure 10-5**.</span></span> <span data-ttu-id="7e9c5-345">서비스 버스 끝점에 대한 A 점수를 보여 주면 SSL 랩 보고서입니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-345">SSL labs report showing a score of A for a Service Bus endpoint.</span></span>

<span data-ttu-id="7e9c5-346">이 수준의 암호화가 항상 충분하지는 않지만 Azure TLS 연결이 매우 안전하다는 확신을 불러일으킵니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-346">While this level of encryption isn't going to be sufficient for all time, it should inspire confidence that Azure TLS connections are quite secure.</span></span> <span data-ttu-id="7e9c5-347">Azure는 암호화가 개선됨에 따라 보안 표준을 계속 발전시킬 것입니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-347">Azure will continue to evolve its security standards as encryption improves.</span></span> <span data-ttu-id="7e9c5-348">보안 표준을 보고 Azure를 업데이트하는 사람이 있다는 것을 아는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-348">It's nice to know that there's somebody watching the security standards and updating Azure as they improve.</span></span>

### <a name="at-rest"></a><span data-ttu-id="7e9c5-349">미사용</span><span class="sxs-lookup"><span data-stu-id="7e9c5-349">At rest</span></span>

<span data-ttu-id="7e9c5-350">모든 응용 프로그램에서 데이터가 디스크에 있는 위치가 많이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-350">In any application, there are a number of places where data rests on disk.</span></span> <span data-ttu-id="7e9c5-351">응용 프로그램 코드 자체는 일부 저장소 메커니즘에서 로드됩니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-351">The application code itself is loaded from some storage mechanism.</span></span> <span data-ttu-id="7e9c5-352">대부분의 응용 프로그램은 SQL Server, Cosmos DB 또는 놀랍게도 가격 효율적인 테이블 저장소와 같은 일종의 데이터베이스를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-352">Most applications also use some kind of database such as SQL Server, Cosmos DB, or even the amazingly price-efficient Table Storage.</span></span> <span data-ttu-id="7e9c5-353">이러한 데이터베이스는 모두 적절한 권한이 있는 응용 프로그램 이외의 다른 사람이 데이터를 읽을 수 없도록 하기 위해 심하게 암호화된 저장소를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-353">These databases all use heavily encrypted storage to ensure that nobody other than the applications with proper permissions can read your data.</span></span> <span data-ttu-id="7e9c5-354">시스템 운영자조차도 암호화된 데이터를 읽을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-354">Even the system operators can't read data that has been encrypted.</span></span> <span data-ttu-id="7e9c5-355">따라서 고객은 비밀 정보가 비밀로 유지될 수 있다고 확신할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-355">So customers can remain confident their secret information remains secret.</span></span>

### <a name="storage"></a><span data-ttu-id="7e9c5-356">스토리지</span><span class="sxs-lookup"><span data-stu-id="7e9c5-356">Storage</span></span>

<span data-ttu-id="7e9c5-357">대부분의 Azure의 기본은 Azure 저장소 엔진입니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-357">The underpinning of much of Azure is the Azure Storage engine.</span></span> <span data-ttu-id="7e9c5-358">가상 시스템 디스크는 Azure 저장소 위에 탑재됩니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-358">Virtual machine disks are mounted on top of Azure Storage.</span></span> <span data-ttu-id="7e9c5-359">Azure Kubernetes 서비스는 Azure 저장소에서 호스팅되는 가상 컴퓨터에서 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-359">Azure Kubernetes Services run on virtual machines that, themselves, are hosted on Azure Storage.</span></span> <span data-ttu-id="7e9c5-360">Azure Functions 앱 및 Azure 컨테이너 인스턴스와 같은 서버없는 기술도 Azure 저장소의 일부인 디스크가 부족합니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-360">Even serverless technologies, such as Azure Functions Apps and Azure Container Instances, run out of disk that is part of Azure Storage.</span></span>

<span data-ttu-id="7e9c5-361">Azure Storage가 잘 암호화된 경우 대부분의 다른 모든 항목도 암호화할 수 있는 기반을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-361">If Azure Storage is well encrypted, then it provides for a foundation for most everything else to also be encrypted.</span></span> <span data-ttu-id="7e9c5-362">Azure [저장소는](https://docs.microsoft.com/azure/storage/common/storage-service-encryption) [FIPS 140-2](https://en.wikipedia.org/wiki/FIPS_140) 호환 [256비트 AES로](https://en.wikipedia.org/wiki/Advanced_Encryption_Standard)암호화됩니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-362">Azure Storage [is encrypted](https://docs.microsoft.com/azure/storage/common/storage-service-encryption) with [FIPS 140-2](https://en.wikipedia.org/wiki/FIPS_140) compliant [256-bit AES](https://en.wikipedia.org/wiki/Advanced_Encryption_Standard).</span></span> <span data-ttu-id="7e9c5-363">이것은 지난 20 년 동안 광범위한 학문적 조사의 대상이된 잘 알려진 암호화 기술입니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-363">This is a well-regarded encryption technology having been the subject of extensive academic scrutiny over the last 20 or so years.</span></span> <span data-ttu-id="7e9c5-364">현재 키에 대해 알지 못하는 사람이 AES에 의해 암호화된 데이터를 읽을 수 있는 알려진 실제 공격은 없습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-364">At present, there's no known practical attack that would allow someone without knowledge of the key to read data encrypted by AES.</span></span>

<span data-ttu-id="7e9c5-365">기본적으로 Azure 저장소를 암호화하는 데 사용되는 키는 Microsoft에서 관리합니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-365">By default, the keys used for encrypting Azure Storage are managed by Microsoft.</span></span> <span data-ttu-id="7e9c5-366">이러한 키에 대한 악의적인 액세스를 방지하기 위해 광범위한 보호 기능이 마련되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-366">There are extensive protections in place to ensure to prevent malicious access to these keys.</span></span> <span data-ttu-id="7e9c5-367">그러나 특정 암호화 요구 사항이 있는 사용자는 Azure Key Vault에서 관리되는 [자체 저장소 키를 제공할](https://docs.microsoft.com/azure/storage/common/storage-encryption-keys-powershell) 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-367">However, users with particular encryption requirements can also [provide their own storage keys](https://docs.microsoft.com/azure/storage/common/storage-encryption-keys-powershell) that are managed in Azure Key Vault.</span></span> <span data-ttu-id="7e9c5-368">이러한 키는 언제든지 해지할 수 있으며, 이를 사용하여 저장소 계정의 내용을 효과적으로 렌더링할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-368">These keys can be revoked at any time, which would effectively render the contents of the Storage account using them inaccessible.</span></span>

<span data-ttu-id="7e9c5-369">가상 머신은 암호화된 저장소를 사용하지만 Windows의 BitLocker 또는 Linux의 DM-Crypt와 같은 기술을 사용하여 다른 암호화 계층을 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-369">Virtual machines use encrypted storage, but it's possible to provide another layer of encryption by using technologies like BitLocker on Windows or DM-Crypt on Linux.</span></span> <span data-ttu-id="7e9c5-370">이러한 기술은 디스크 이미지가 저장소에서 유출되더라도 읽기가 거의 불가능하게 유지된다는 것을 의미합니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-370">These technologies mean that even if the disk image was leaked off of storage, it would remain near impossible to read it.</span></span>

### <a name="azure-sql"></a><span data-ttu-id="7e9c5-371">Azure SQL</span><span class="sxs-lookup"><span data-stu-id="7e9c5-371">Azure SQL</span></span>

<span data-ttu-id="7e9c5-372">Azure SQL에서 호스팅되는 데이터베이스는 [TDE(투명 데이터 암호화)라는](/sql/relational-databases/security/encryption/transparent-data-encryption) 기술을 사용하여 데이터가 암호화된 상태를 유지하도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-372">Databases hosted on Azure SQL use a technology called [Transparent Data Encryption (TDE)](/sql/relational-databases/security/encryption/transparent-data-encryption) to ensure data remains encrypted.</span></span> <span data-ttu-id="7e9c5-373">새로 만든 모든 SQL 데이터베이스에서 기본적으로 활성화되지만 레거시 데이터베이스에 대해 수동으로 사용하도록 설정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-373">It's enabled by default on all newly created SQL databases, but must be enabled manually for legacy databases.</span></span> <span data-ttu-id="7e9c5-374">TDE는 데이터베이스뿐만 아니라 백업 및 트랜잭션 로그의 실시간 암호화 및 암호 해독을 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-374">TDE executes real-time encryption and decryption of not just the database, but also the backups and transaction logs.</span></span>

<span data-ttu-id="7e9c5-375">암호화 매개 변수는 `master` 데이터베이스에 저장되며 시작 시 나머지 작업에 대해 메모리로 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-375">The encryption parameters are stored in the `master` database and, on startup, are read into memory for the remaining operations.</span></span> <span data-ttu-id="7e9c5-376">즉, 데이터베이스는 `master` 암호화되지 않은 상태로 유지되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-376">This means that the `master` database must remain unencrypted.</span></span> <span data-ttu-id="7e9c5-377">실제 키는 Microsoft에서 관리합니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-377">The actual key is managed by Microsoft.</span></span> <span data-ttu-id="7e9c5-378">그러나 엄격한 보안 요구 사항이 있는 사용자는 Azure Storage에 대해 수행되는 것과 거의 동일한 방식으로 Key Vault에서 자체 키를 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-378">However, users with exacting security requirements may provide their own key in Key Vault in much the same way as is done for Azure Storage.</span></span> <span data-ttu-id="7e9c5-379">키 볼트는 키 회전 및 해지와 같은 서비스를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-379">The Key Vault provides for such services as key rotation and revocation.</span></span>

<span data-ttu-id="7e9c5-380">TDS의 "투명" 부분은 암호화된 데이터베이스를 사용하는 데 필요한 클라이언트 변경 이 없다는 사실에서 비롯됩니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-380">The "Transparent" part of TDS comes from the fact that there aren't client changes needed to use an encrypted database.</span></span> <span data-ttu-id="7e9c5-381">이 방법은 좋은 보안을 제공하지만 데이터베이스 암호를 누설하는 것만으로도 사용자가 데이터를 해독할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-381">While this approach provides for good security, leaking the database password is enough for users to be able to decrypt the data.</span></span> <span data-ttu-id="7e9c5-382">데이터베이스의 개별 열이나 테이블을 암호화하는 또 다른 방법이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-382">There's another approach that encrypts individual columns or tables in a database.</span></span> <span data-ttu-id="7e9c5-383">[항상 암호화되어](https://docs.microsoft.com/azure/sql-database/sql-database-always-encrypted-azure-key-vault) 암호화된 데이터가 데이터베이스 내부의 일반 텍스트로 표시되지 않도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-383">[Always Encrypted](https://docs.microsoft.com/azure/sql-database/sql-database-always-encrypted-azure-key-vault) ensures that at no point the encrypted data appears in plain text inside the database.</span></span>

<span data-ttu-id="7e9c5-384">이 암호화 계층을 설정하려면 SQL Server 관리 Studio의 마법사를 통해 실행하여 암호화 종류를 선택하고 Key Vault에서 관련 키를 저장할 위치를 선택해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-384">Setting up this tier of encryption requires running through a wizard in SQL Server Management Studio to select the sort of encryption and where in Key Vault to store the associated keys.</span></span>

<span data-ttu-id="7e9c5-385">![그림 10-6 항상 암호화 된](./media/always-encrypted.png)
그림**10-6을**사용 하 여 암호화 될 테이블에서 열을 선택 합니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-385">![Figure 10-6 Selecting columns in a table to be encrypted using Always Encrypted](./media/always-encrypted.png)
**Figure 10-6**.</span></span> <span data-ttu-id="7e9c5-386">항상 암호화를 사용하여 암호화할 테이블의 열을 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-386">Selecting columns in a table to be encrypted using Always Encrypted.</span></span>

<span data-ttu-id="7e9c5-387">이러한 암호화된 열에서 정보를 읽는 클라이언트 응용 프로그램은 암호화된 데이터를 읽을 수 있도록 특별한 여유를 제공해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-387">Client applications that read information from these encrypted columns need to make special allowances to read encrypted data.</span></span> <span data-ttu-id="7e9c5-388">연결 문자열을 업데이트해야 `Column Encryption Setting=Enabled` 하며 키 자격 증명에서 클라이언트 자격 증명을 검색해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-388">Connection strings need to be updated with `Column Encryption Setting=Enabled` and client credentials must be retrieved from the Key Vault.</span></span> <span data-ttu-id="7e9c5-389">그런 다음 SQL Server 클라이언트에 열 암호화 키를 준비해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-389">The SQL Server client must then be primed with the column encryption keys.</span></span> <span data-ttu-id="7e9c5-390">이 작업이 완료되면 나머지 작업은 SQL Client에 대한 표준 인터페이스를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-390">Once that is done, the remaining actions use the standard interfaces to SQL Client.</span></span> <span data-ttu-id="7e9c5-391">즉, SQL 클라이언트 위에 빌드된 Dapper 및 엔터티 프레임워크와 같은 도구는 변경 없이 계속 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-391">That is, tools like Dapper and Entity Framework, which are built on top of SQL Client, will continue to work without changes.</span></span> <span data-ttu-id="7e9c5-392">항상 암호화된 모든 언어의 모든 SQL Server 드라이버에서 아직 암호화되지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-392">Always Encrypted may not yet be available for every SQL Server driver on every language.</span></span>

<span data-ttu-id="7e9c5-393">TDE와 Always Encrypted의 조합은 클라이언트별 키와 함께 사용할 수 있으며, 가장 엄격한 암호화 요구 사항도 지원됩니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-393">The combination of TDE and Always Encrypted, both of which can be used with client-specific keys, ensures that even the most exacting encryption requirements are supported.</span></span>

### <a name="cosmos-db"></a><span data-ttu-id="7e9c5-394">Cosmos DB</span><span class="sxs-lookup"><span data-stu-id="7e9c5-394">Cosmos DB</span></span>

<span data-ttu-id="7e9c5-395">코스모스 DB는 Azure에서 Microsoft에서 제공하는 최신 데이터베이스입니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-395">Cosmos DB is the newest database provided by Microsoft in Azure.</span></span> <span data-ttu-id="7e9c5-396">그것은 염두에 보안 및 암호화를 염두에 두고 처음부터 구축되었습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-396">It has been built from the ground up with security and cryptography in mind.</span></span> <span data-ttu-id="7e9c5-397">AES-256bit 암호화는 모든 Cosmos DB 데이터베이스에 대한 표준이며 비활성화할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-397">AES-256bit encryption is standard for all Cosmos DB databases and can't be disabled.</span></span> <span data-ttu-id="7e9c5-398">통신에 대한 TLS 1.2 요구 사항과 함께 전체 저장소 솔루션이 암호화됩니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-398">Coupled with the TLS 1.2 requirement for communication, the entire storage solution is encrypted.</span></span>

<span data-ttu-id="7e9c5-399">![그림 10-7 코스모스 DB](./media/cosmos-encryption.png)
그림**10-7**내의 데이터 암호화 흐름.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-399">![Figure 10-7 The flow of data encryption within Cosmos DB](./media/cosmos-encryption.png)
**Figure 10-7**.</span></span> <span data-ttu-id="7e9c5-400">코스모스 DB 내의 데이터 암호화 흐름.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-400">The flow of data encryption within Cosmos DB.</span></span>

<span data-ttu-id="7e9c5-401">Cosmos DB는 고객 암호화 키를 제공하지 않지만, PCI-DSS가 없는 상태에서 도대체 PCI-DSS를 준수할 수 있도록 팀에서 수행한 중요한 작업이 있었습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-401">While Cosmos DB doesn't provide for supplying customer encryption keys, there has been significant work done by the team to ensure it remains PCI-DSS compliant without that.</span></span> <span data-ttu-id="7e9c5-402">Cosmos DB는 Azure SQL의 항상 암호화된 암호화와 유사한 단일 열 암호화도 지원하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-402">Cosmos DB also doesn't support any sort of single column encryption similar to Azure SQL's Always Encrypted yet.</span></span>

## <a name="keeping-secure"></a><span data-ttu-id="7e9c5-403">보안 유지</span><span class="sxs-lookup"><span data-stu-id="7e9c5-403">Keeping secure</span></span>

<span data-ttu-id="7e9c5-404">Azure에는 매우 안전한 제품을 릴리스하는 데 필요한 모든 도구가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-404">Azure has all the tools necessary to release a highly secure product.</span></span> <span data-ttu-id="7e9c5-405">그러나 체인은 가장 약한 링크만큼 강력합니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-405">However, a chain is only as strong as its weakest link.</span></span> <span data-ttu-id="7e9c5-406">Azure 위에 배포된 응용 프로그램이 적절한 보안 사고 방식과 좋은 보안 감사를 통해 개발되지 않으면 체인의 약한 고리가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-406">If the applications deployed on top of Azure aren't developed with a proper security mindset and good security audits, then they become the weak link in the chain.</span></span> <span data-ttu-id="7e9c5-407">Azure에 설치된 소프트웨어가 Azure 자체만큼 안전하도록 하는 데 사용할 수 있는 많은 뛰어난 정적 분석 도구, 암호화 라이브러리 및 보안 관행이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-407">There are many great static analysis tools, encryption libraries, and security practices that can be used to ensure that the software installed on Azure is as secure as Azure itself.</span></span> <span data-ttu-id="7e9c5-408">예를 들어 [정적 분석 도구,](https://www.whitesourcesoftware.com/) [암호화 라이브러리](https://www.libressl.org/)및 보안 [사례가](https://azure.microsoft.com/resources/videos/red-vs-blue-internal-security-penetration-testing-of-microsoft-azure/)있습니다.</span><span class="sxs-lookup"><span data-stu-id="7e9c5-408">Examples include [static analysis tools](https://www.whitesourcesoftware.com/), [encryption libraries](https://www.libressl.org/), and [security practices](https://azure.microsoft.com/resources/videos/red-vs-blue-internal-security-penetration-testing-of-microsoft-azure/).</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="7e9c5-409">[이전](security.md)
>[다음](devops.md)</span><span class="sxs-lookup"><span data-stu-id="7e9c5-409">[Previous](security.md)
[Next](devops.md)</span></span>

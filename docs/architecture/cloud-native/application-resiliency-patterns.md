---
title: 애플리케이션 복원력 패턴
description: Azure 용 클라우드 네이티브 .NET 앱 설계 | 응용 프로그램 복원 력 패턴
ms.date: 06/30/2019
ms.openlocfilehash: 13811efaa88e0bd2824add1c8712b78b18d46375
ms.sourcegitcommit: 559fcfbe4871636494870a8b716bf7325df34ac5
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 10/30/2019
ms.locfileid: "73841890"
---
# <a name="application-resiliency-patterns"></a><span data-ttu-id="0487d-103">애플리케이션 복원력 패턴</span><span class="sxs-lookup"><span data-stu-id="0487d-103">Application resiliency patterns</span></span>

[!INCLUDE [book-preview](../../../includes/book-preview.md)]

<span data-ttu-id="0487d-104">첫 번째 방어 줄은 소프트웨어 사용 응용 프로그램 복원 력입니다.</span><span class="sxs-lookup"><span data-stu-id="0487d-104">The first line of defense is software-enabled application resiliency.</span></span>

<span data-ttu-id="0487d-105">사용자 고유의 복원 력 프레임 워크를 작성 하는 데 상당한 시간을 투자할 수 있지만 이러한 제품은 이미 존재 합니다.</span><span class="sxs-lookup"><span data-stu-id="0487d-105">While you could invest considerable time writing your own resiliency framework, such products already exist.</span></span> <span data-ttu-id="0487d-106">예 [를 들어, 개발자](http://www.thepollyproject.org/) 가 흐름 및 스레드로부터 안전한 방식으로 복원 력 정책을 표현할 수 있도록 하는 포괄적인 .net 복원 력 및 일시적인 오류 처리 라이브러리가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0487d-106">For example, [Polly](http://www.thepollyproject.org/) is a comprehensive .NET resilience and transient-fault-handling library that allows developers to express resiliency policies in a fluent and thread-safe manner.</span></span> <span data-ttu-id="0487d-107">완전 한 .NET Framework 또는 .NET Core를 사용 하 여 빌드된 응용 프로그램을 대상으로 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="0487d-107">Polly targets applications built with either the full .NET Framework or .NET Core.</span></span> <span data-ttu-id="0487d-108">그림 6-2은 기능 라이브러리에서 사용할 수 있는 복원 력 정책 (즉, 기능)을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="0487d-108">Figure 6-2 shows the resiliency policies (that is, functionality) available from the Polly Library.</span></span> <span data-ttu-id="0487d-109">이러한 정책은 개별적으로 적용 하거나 함께 결합할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0487d-109">These policies can be applied individually or combined together.</span></span>

![정책에 대 한 프레임 워크](./media/polly-resiliency-framework.png)

<span data-ttu-id="0487d-111">**그림 6-2**.</span><span class="sxs-lookup"><span data-stu-id="0487d-111">**Figure 6-2**.</span></span> <span data-ttu-id="0487d-112">기능 제공 복원 력 프레임 워크 기능</span><span class="sxs-lookup"><span data-stu-id="0487d-112">Polly resiliency framework features</span></span>

<span data-ttu-id="0487d-113">이전 그림에서 복원 력 정책은 외부 클라이언트나 다른 백 엔드 서비스에서 들어오는 요청 메시지에 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0487d-113">Note how in the previous figure the resiliency policies apply to request messages, whether coming from an external client or another back-end service.</span></span> <span data-ttu-id="0487d-114">목표는 일시적으로 사용할 수 없는 서비스에 대 한 요청을 보정 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="0487d-114">The goal is to compensate the request for a service that might be momentarily unavailable.</span></span> <span data-ttu-id="0487d-115">일반적으로 이러한 짧은 중단은 그림 6-3에 나와 있는 HTTP 상태 코드를 사용 하 여 매니페스트 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0487d-115">These short interruptions typically manifest themselves with the HTTP status codes shown in Figure 6-3.</span></span>

![다시 시도할 HTTP 상태 코드](./media/http-status-codes.png)

<span data-ttu-id="0487d-117">**그림 6-3**.</span><span class="sxs-lookup"><span data-stu-id="0487d-117">**Figure 6-3**.</span></span> <span data-ttu-id="0487d-118">다시 시도할 HTTP 상태 코드</span><span class="sxs-lookup"><span data-stu-id="0487d-118">HTTP status codes to retry</span></span>

<span data-ttu-id="0487d-119">질문: 403-금지 된 HTTP 상태 코드를 다시 시도 하나요?</span><span class="sxs-lookup"><span data-stu-id="0487d-119">Question: Would you retry an HTTP Status Code of 403 - Forbidden?</span></span> <span data-ttu-id="0487d-120">아니요.</span><span class="sxs-lookup"><span data-stu-id="0487d-120">No.</span></span> <span data-ttu-id="0487d-121">여기에서 시스템이 제대로 작동 하지만 요청 된 작업을 수행할 수 있는 권한이 호출자에 게 알려 줍니다.</span><span class="sxs-lookup"><span data-stu-id="0487d-121">Here, the system is functioning properly, but informing the caller that they aren't authorized to perform the requested operation.</span></span> <span data-ttu-id="0487d-122">오류로 인해 발생 하는 작업만 다시 시도해 야 합니다.</span><span class="sxs-lookup"><span data-stu-id="0487d-122">Care must be taken to retry only those operations caused by failures.</span></span>

<span data-ttu-id="0487d-123">1 장에서 권장 한 대로 클라우드 네이티브 응용 프로그램을 구성 하는 Microsoft 개발자는 .NET Core를 대상으로 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="0487d-123">As recommended in Chapter 1, Microsoft developers constructing cloud-native applications should target .NET Core.</span></span> <span data-ttu-id="0487d-124">버전 2.1에는 URL 기반 리소스와 상호 작용 하기 위한 HTTP 클라이언트 인스턴스를 만들기 위한 [Httpclientfactory](https://www.stevejgordon.co.uk/introduction-to-httpclientfactory-aspnetcore) 라이브러리가 도입 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="0487d-124">Version 2.1 introduced the [HTTPClientFactory](https://www.stevejgordon.co.uk/introduction-to-httpclientfactory-aspnetcore) library for creating HTTP Client instances for interacting with URL-based resources.</span></span> <span data-ttu-id="0487d-125">원래 HTTPClient 클래스를 대체 하는 팩터리 클래스는 향상 된 많은 기능을 지원 하며, 그 중 하나는이 기능을 사용 하는 것 [이 좋습니다.](../microservices/implement-resilient-applications/implement-http-call-retries-exponential-backoff-polly.md)</span><span class="sxs-lookup"><span data-stu-id="0487d-125">Superseding the original HTTPClient class, the factory class supports many enhanced features, one of which is [tight integration](../microservices/implement-resilient-applications/implement-http-call-retries-exponential-backoff-polly.md) with the Polly resiliency library.</span></span> <span data-ttu-id="0487d-126">이를 통해 응용 프로그램 시작 클래스에서 복원 력 정책을 쉽게 정의 하 여 부분 오류 및 연결 문제를 처리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0487d-126">With it, you can easily define resiliency policies in the application Startup class to handle partial failures and connectivity issues.</span></span>

<span data-ttu-id="0487d-127">다음으로 다시 시도 및 회로 차단기 패턴을 살펴보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="0487d-127">Next, let's expand on retry and circuit breaker patterns.</span></span>

### <a name="retry-pattern"></a><span data-ttu-id="0487d-128">재시도 패턴</span><span class="sxs-lookup"><span data-stu-id="0487d-128">Retry pattern</span></span>

<span data-ttu-id="0487d-129">분산 클라우드 기본 환경에서 서비스 및 클라우드 리소스에 대 한 호출은 일시적 (단기) 오류로 인해 실패할 수 있습니다. 일반적으로 잠시 후에 자체적으로 해결 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0487d-129">In a distributed cloud-native environment, calls to services and cloud resources can fail because of transient (short-lived) failures, which typically correct themselves after a brief period of time.</span></span> <span data-ttu-id="0487d-130">재시도 전략을 구현 하면 클라우드 네이티브 서비스에서 이러한 시나리오를 처리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0487d-130">Implementing a retry strategy helps a cloud-native service handle these scenarios.</span></span>

<span data-ttu-id="0487d-131">[다시 시도 패턴](https://docs.microsoft.com/azure/architecture/patterns/retry) 을 사용 하면 서비스에서 실패 한 요청 작업 (구성 가능)을 지 수 많은 대기 시간으로 다시 시도할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0487d-131">The [Retry pattern](https://docs.microsoft.com/azure/architecture/patterns/retry) enables a service to retry a failed request operation a (configurable) number of times with an exponentially increasing wait time.</span></span> <span data-ttu-id="0487d-132">그림 6-4에서는 다시 시도 하는 작업을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="0487d-132">Figure 6-4 shows a retry in action.</span></span>

![재시도 패턴 실행](./media/retry-pattern.png)

<span data-ttu-id="0487d-134">**그림 6-4**</span><span class="sxs-lookup"><span data-stu-id="0487d-134">**Figure 6-4**.</span></span> <span data-ttu-id="0487d-135">재시도 패턴 실행</span><span class="sxs-lookup"><span data-stu-id="0487d-135">Retry pattern in action</span></span>

<span data-ttu-id="0487d-136">위의 그림에서 재시도 패턴은 요청 작업에 대해 구현 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="0487d-136">In the previous figure, a retry pattern has been implemented for a request operation.</span></span> <span data-ttu-id="0487d-137">백오프 간격 (대기 시간)이 2 초에서 시작 하 여 실패 하기 전까지 최대 4 번의 재시도를 허용 하도록 구성 되며,이는 각 후속 시도에 대해 두 배가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0487d-137">It's configured to allow up to four retries before failing with a backoff interval (wait time) starting at two seconds, which exponentially doubles for each subsequent attempt.</span></span>

- <span data-ttu-id="0487d-138">첫 번째 호출이 실패 하 고 HTTP 상태 코드 500을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="0487d-138">The first invocation fails and returns an HTTP status code of 500.</span></span> <span data-ttu-id="0487d-139">응용 프로그램은 2 초 동안 대기한 후 호출을 다시 시도 합니다.</span><span class="sxs-lookup"><span data-stu-id="0487d-139">The application waits for two seconds and retries the call.</span></span>
- <span data-ttu-id="0487d-140">두 번째 호출도 실패 하 고 HTTP 상태 코드 500을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="0487d-140">The second invocation also fails and returns an HTTP status code of 500.</span></span> <span data-ttu-id="0487d-141">이제 응용 프로그램은 백오프 간격을 4 초로 두 배로 증가 하 고 호출을 다시 시도 합니다.</span><span class="sxs-lookup"><span data-stu-id="0487d-141">The application now doubles the backoff interval to four seconds and retries the call.</span></span>
- <span data-ttu-id="0487d-142">마지막으로 세 번째 호출은 성공 합니다.</span><span class="sxs-lookup"><span data-stu-id="0487d-142">Finally, the third call succeeds.</span></span>
- <span data-ttu-id="0487d-143">이 시나리오에서 재시도 작업은 호출을 실패 하기 전에 백오프 기간을 두 배로 하는 동시에 최대 4 번의 재시도를 시도 했습니다.</span><span class="sxs-lookup"><span data-stu-id="0487d-143">In this scenario, the retry operation would have attempted up to four retries while doubling the backoff duration before failing the call.</span></span>

<span data-ttu-id="0487d-144">서비스 시간을 자체 수정할 수 있도록 호출을 다시 시도 하기 전에 백오프 기간을 늘려야 합니다.</span><span class="sxs-lookup"><span data-stu-id="0487d-144">It's important to increase the backoff period before retrying the call to allow the service time to self-correct.</span></span> <span data-ttu-id="0487d-145">백오프을 구현 하 여 적절 한 수정 시간을 허용 하는 것이 좋습니다. 즉, 재시도 마다 마침표를 두 배로 늘립니다.</span><span class="sxs-lookup"><span data-stu-id="0487d-145">It's a best practice to implement an exponentially increasing backoff (doubling the period on each retry) to allow adequate correction time.</span></span>

## <a name="circuit-breaker-pattern"></a><span data-ttu-id="0487d-146">회로 차단기 패턴</span><span class="sxs-lookup"><span data-stu-id="0487d-146">Circuit breaker pattern</span></span>

<span data-ttu-id="0487d-147">재시도 패턴은 부분 실패에 대 한 요청을 복구 하는 데 도움이 되지만, 해결 하는 데 시간이 더 오래 걸릴 수 있는 예기치 않은 이벤트로 인해 오류가 발생할 수 있는 경우가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0487d-147">While the retry pattern can help salvage a request entangled in a partial failure, there are situations where failures can be caused by unanticipated events that will require longer periods of time to resolve.</span></span> <span data-ttu-id="0487d-148">이러한 오류의 심각도는 부분적 연결 손실에서부터 전체 서비스 오류에까지 이를 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0487d-148">These faults can range in severity from a partial loss of connectivity to the complete failure of a service.</span></span> <span data-ttu-id="0487d-149">이러한 상황에서는 응용 프로그램이 성공할 가능성이 없는 작업을 계속 해 서 다시 시도 하는 것은 무의미 합니다.</span><span class="sxs-lookup"><span data-stu-id="0487d-149">In these situations, it's pointless for an application to continually retry an operation that is unlikely to succeed.</span></span>

<span data-ttu-id="0487d-150">문제를 더 악화 하기 위해 응답성이 없는 서비스에 대 한 지속적인 재시도 작업을 실행 하면 메모리, 스레드 및 데이터베이스와 같은 리소스를 지속적으로 사용 하 여 서비스를 제한 하는 자체 서비스 거부 시나리오로 이동할 수 있습니다. 연결-동일한 리소스를 사용 하는 시스템의 관련 되지 않은 부분에서 오류가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="0487d-150">To make things worse, executing continual retry operations on a non-responsive service can move you into a self-imposed denial of service scenario where you flood your service with continual calls exhausting resources such as memory, threads and database connections, causing failure in unrelated parts of the system that use the same resources.</span></span>

<span data-ttu-id="0487d-151">이러한 경우에는 작업이 즉시 실패 하 고 성공할 가능성이 있는 경우에만 서비스를 호출 하려고 시도 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="0487d-151">In these situations, it would be preferable for the operation to fail immediately and only attempt to invoke the service if it's likely to succeed.</span></span>

<span data-ttu-id="0487d-152">[회로 차단기 패턴](https://docs.microsoft.com/azure/architecture/patterns/circuit-breaker) 은 응용 프로그램이 실패할 가능성이 있는 작업을 반복적으로 실행 하는 것을 방지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0487d-152">The [Circuit Breaker pattern](https://docs.microsoft.com/azure/architecture/patterns/circuit-breaker) can prevent an application from repeatedly trying to execute an operation that's likely to fail.</span></span> <span data-ttu-id="0487d-153">또한 주기적인 평가판 호출을 통해 응용 프로그램을 모니터링 하 여 오류가 해결 되었는지 여부를 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="0487d-153">It also monitors the application with a periodic trial call to determine whether the fault has resolved.</span></span> <span data-ttu-id="0487d-154">그림 6-5은 작동 중인 회로 차단기 패턴을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="0487d-154">Figure 6-5 shows the Circuit Breaker pattern in action.</span></span>

![작동 중인 회로 차단기 패턴](./media/circuit-breaker-pattern.png)

<span data-ttu-id="0487d-156">**그림 6-5**</span><span class="sxs-lookup"><span data-stu-id="0487d-156">**Figure 6-5**.</span></span> <span data-ttu-id="0487d-157">작동 중인 회로 차단기 패턴</span><span class="sxs-lookup"><span data-stu-id="0487d-157">Circuit breaker pattern in action</span></span>

<span data-ttu-id="0487d-158">위의 그림에서 회로 차단기 패턴은 원래 재시도 패턴에 추가 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="0487d-158">In the previous figure, a Circuit Breaker pattern has been added to the original retry pattern.</span></span> <span data-ttu-id="0487d-159">실패 한 요청 10 개가 지나면 회로 차단기가 열리고 더 이상 서비스에 대 한 호출을 허용 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0487d-159">Note how after 10 failed requests, the circuit breakers opens and no longer allows calls to the service.</span></span> <span data-ttu-id="0487d-160">CheckCircuit 값 (30 초)은 라이브러리에서 한 요청이 서비스를 진행 하도록 허용 하는 빈도를 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="0487d-160">The CheckCircuit value, set at 30 seconds, specifies how often the library allows one request to proceed to the service.</span></span> <span data-ttu-id="0487d-161">해당 호출이 성공 하면 회로가 닫히고 서비스는 다시 트래픽에 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0487d-161">If that call succeeds, the circuit closes and the service is once again available to traffic.</span></span>

<span data-ttu-id="0487d-162">회로 차단기 패턴의 의도는 재시도 패턴과 *다르다는* 점에 유의 하세요.</span><span class="sxs-lookup"><span data-stu-id="0487d-162">Keep in mind that the intent of the Circuit Breaker pattern is *different* than that of the Retry pattern.</span></span> <span data-ttu-id="0487d-163">재시도 패턴을 사용 하면 응용 프로그램이 성공 하다 고 가정 하에 작업을 다시 시도할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0487d-163">The Retry pattern enables an application to retry an operation in the expectation that it will succeed.</span></span> <span data-ttu-id="0487d-164">회로 차단기 패턴은 응용 프로그램이 실패할 가능성이 있는 작업을 수행할 수 없도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="0487d-164">The Circuit Breaker pattern prevents an application from doing an operation that is likely to fail.</span></span> <span data-ttu-id="0487d-165">응용 프로그램은 회로 차단기를 통해 작업을 호출 하기 위해 재시도 패턴을 사용 하 여 이러한 두 가지 패턴을 *결합* 하는 경우가 많습니다.</span><span class="sxs-lookup"><span data-stu-id="0487d-165">Often, an application will *combine* these two patterns by using the Retry pattern to invoke an operation through a circuit breaker.</span></span> <span data-ttu-id="0487d-166">그러나 다시 시도 논리는 회로 차단기에서 반환 된 모든 예외에 대 한 중요 한 것 이며 회로 차단기에서 일시적인 오류가 아닌 것으로 표시 되는 경우 재시도 횟수를 중단 합니다.</span><span class="sxs-lookup"><span data-stu-id="0487d-166">However, the retry logic should be sensitive to any exceptions returned by the circuit breaker and abandon retry attempts if the circuit breaker indicates that a fault isn't transient.</span></span>

<span data-ttu-id="0487d-167">응용 프로그램 복원 력을 통해 문제가 있는 요청 된 작업을 처리 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="0487d-167">Application resiliency is a must for handling problematic requested operations.</span></span> <span data-ttu-id="0487d-168">그러나이는 스토리의 절반에 불과합니다.</span><span class="sxs-lookup"><span data-stu-id="0487d-168">But, it's only half of the story.</span></span> <span data-ttu-id="0487d-169">다음으로, Azure 클라우드에서 사용할 수 있는 복원 력 기능을 다룹니다.</span><span class="sxs-lookup"><span data-stu-id="0487d-169">Next, we cover resiliency features available in the Azure cloud.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="0487d-170">[이전](resiliency.md)
>[다음](infrastructure-resiliency-azure.md)</span><span class="sxs-lookup"><span data-stu-id="0487d-170">[Previous](resiliency.md)
[Next](infrastructure-resiliency-azure.md)</span></span>

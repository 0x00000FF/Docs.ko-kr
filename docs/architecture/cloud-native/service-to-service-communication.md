---
title: 서비스 간 통신
description: 백 엔드 클라우드 네이티브 마이크로 서비스가 다른 백 엔드 마이크로 서비스와 통신하는 방법을 알아봅니다.
author: robvet
ms.date: 09/09/2019
ms.openlocfilehash: a5124b8b83f62ff17b1230ead63db26e0c1f2a5b
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/14/2020
ms.locfileid: "79401762"
---
# <a name="service-to-service-communication"></a>서비스 간 통신

[!INCLUDE [book-preview](../../../includes/book-preview.md)]

프런트 엔드 클라이언트에서 이동, 우리는 지금 서로 통신 백 엔드 마이크로 서비스를 해결.

클라우드 네이티브 응용 프로그램을 구성할 때 백 엔드 서비스가 서로 통신하는 방식에 민감해야 합니다. 이상적으로는 서비스 간 통신이 적을수록 좋습니다. 그러나 백 엔드 서비스가 작업을 완료하기 위해 서로 의존하는 경우가 많기 때문에 회피가 항상 가능한 것은 아닙니다.

서비스 간 통신을 구현하기 위해 널리 사용되는 몇 가지 접근 방식이 있습니다. *통신 상호 작용의 유형에* 따라 가장 적합한 접근 방식이 결정되는 경우가 많습니다.

다음 상호 작용 유형을 고려하십시오.

- *쿼리* - 호출 마이크로 서비스가 "이봐, 지정된 고객 ID에 대한 구매자 정보를 제공"과 같은 호출 마이크로 서비스에서 응답이 필요한 경우.

- *명령* - 호출 마이크로 서비스가 작업을 실행하기 위해 다른 마이크로 서비스가 필요하지만 "이봐, 그냥이 순서를 발송"과 같은 응답을 필요로하지 않는 경우.

- *이벤트* – 게시자라고 하는 마이크로 서비스가 상태가 변경되었거나 작업이 발생한 이벤트를 발생시면 관심 있는 구독자라고 하는 다른 마이크로 서비스는 이벤트에 적절하게 대응할 수 있습니다. 게시자와 구독자는 서로를 인식하지 못합니다.

마이크로 서비스 시스템은 일반적으로 서비스 간 상호 작용이 필요한 작업을 실행하는 경우 이러한 상호 작용 유형의 조합을 사용합니다. 각각을 자세히 살펴보고 이를 구현하는 방법을 살펴보겠습니다.

## <a name="queries"></a>쿼리

한 마이크로 서비스가 다른 마이크로 서비스를 *쿼리해야* 하는 경우가 많으며 작업을 완료하기 위해 즉각적인 응답이 필요할 수 있습니다. 장바구니 마이크로 서비스는 장바구니에 품목을 추가하기 위해 제품 정보와 가격이 필요할 수 있습니다. 쿼리 작업을 구현하기 위한 여러 가지 방법이 있습니다.

### <a name="requestresponse-messaging"></a>요청/응답 메시징

이 시나리오를 구현하기 위한 한 가지 옵션은 그림 4-8에 표시된 쿼리해야 하는 마이크로 서비스에 직접 HTTP 요청을 하기 위해 백 엔드 마이크로 서비스를 호출하는 것입니다.

![직접 HTTP 통신](./media/direct-http-communication.png)

**그림 4-8**. 직접 HTTP 통신

마이크로 서비스 간의 직접 HTTP 호출은 비교적 간단하지만 이 방법을 최소화하려면 주의해야 합니다. 시작하려면 이러한 호출은 항상 *동기적이며* 결과가 반환되거나 요청 시간이 시간 단축될 때까지 작업을 차단합니다. 한때 독립적이고 독립적인 서비스가었으며, 독립적으로 진화하고 자주 배포할 수 있었던 것은 이제 서로 결합됩니다. 마이크로 서비스 간의 결합이 증가함에 따라 아키텍처상의 이점이 줄어듭니다.

다른 마이크로 서비스에 대한 단일 직접 HTTP 호출을 하는 드문 요청을 실행하는 것은 일부 시스템에서 허용될 수 있습니다. 그러나 여러 마이크로 서비스에 직접 HTTP 호출을 호출하는 대용량 호출은 권장되지 않습니다. 대기 시간이 증가하고 시스템의 성능, 확장성 및 가용성에 부정적인 영향을 미칠 수 있습니다. 더 나쁜 것은 긴 일련의 직접 HTTP 통신은 그림 4-9에 표시된 동기 마이크로 서비스 호출의 깊고 복잡한 체인으로 이어질 수 있습니다.

![HTTP 쿼리 연결](./media/chaining-http-queries.png)

**그림 4-9**. HTTP 쿼리 연결

당신은 확실히 이전 이미지에 표시된 디자인의 위험을 상상할 수 있습니다. 3단계가 실패하면 어떻게 됩니까? \# 또는 \#8 단계가 실패? 어떻게 회복합니까? 기본 서비스가 \#사용 중이기 때문에 6단계가 느리면 어떻게 해야 합니까? 어떻게 계속하시겠습니까? 모든 것이 올바르게 작동하더라도 이 호출이 발생하는 대기 시간을 생각하면 각 단계의 대기 시간의 합계입니다.

이전 이미지의 큰 커플링은 서비스가 최적으로 모델링되지 않았음을 시사합니다. 팀이 자신의 디자인을 다시 검토하는 것이 좋을 것입니다.

### <a name="materialized-view-pattern"></a>구체화된 뷰 패턴

마이크로 서비스 커플링을 제거하는 데 가장 인기 있는 옵션은 [구체화된 뷰 패턴입니다.](https://docs.microsoft.com/azure/architecture/patterns/materialized-view) 이 패턴을 사용하면 마이크로 서비스는 다른 서비스에서 소유한 데이터의 로컬, 정규화되지 않은 복사본을 저장합니다. 제품 카탈로그 및 가격 책정 마이크로 서비스를 쿼리하는 장바구니 마이크로 서비스 대신 해당 데이터의 로컬 복사본을 유지 관리합니다. 이 패턴은 불필요한 결합을 제거하고 안정성과 응답 시간을 향상시킵니다. 전체 작업은 단일 프로세스 내에서 실행됩니다. 이 패턴 및 기타 데이터 관련 사항5장에서 살펴보겠습니다.

### <a name="service-aggregator-pattern"></a>서비스 애그리게이터 패턴

마이크로 서비스 간 마이크로 서비스 커플링을 제거하는 또 다른 옵션은 그림 4-10에 자주색으로 표시된 [애그리게이터 마이크로 서비스입니다.](https://devblogs.microsoft.com/cesardelatorre/designing-and-implementing-api-gateways-with-ocelot-in-a-microservices-and-container-based-architecture/)

![애그리게이터 서비스](./media/aggregator-service.png)

**그림 4-10** 애그리게이터 마이크로 서비스

패턴은 여러 백 엔드 마이크로 서비스를 호출하는 작업을 격리하여 논리를 특수 마이크로 서비스로 중앙 집중화합니다.  이전 그림의 보라색 체크 아웃 집계 마이크로 서비스는 체크 아웃 작업에 대한 워크플로를 오케스트레이션합니다. 여기에는 순서대로 여러 백 엔드 마이크로 서비스에 대한 호출이 포함됩니다. 워크플로의 데이터가 집계되어 호출자에게 반환됩니다. 집계 마이크로 서비스는 여전히 직접 HTTP 호출을 구현하지만 백 엔드 마이크로 서비스 간의 직접 종속성을 줄입니다.

### <a name="requestreply-pattern"></a>요청/회신 패턴

동기 HTTP 메시지를 분리하기 위한 또 다른 방법은 대기 통신을 사용하는 [요청-회신 패턴입니다.](https://www.enterpriseintegrationpatterns.com/patterns/messaging/RequestReply.html) 큐를 사용하는 통신은 항상 생산자가 메시지를 보내고 소비자가 수신하는 단방향 채널입니다. 이 패턴을 사용하면 그림 4-11에 표시된 요청 큐와 응답 큐가 모두 구현됩니다.

![요청-회신 패턴](./media/request-reply-pattern.png)

**그림 4-11** 요청-회신 패턴

여기서 메시지 생산자는 고유한 상관 관계 ID를 포함하는 쿼리 기반 메시지를 만들고 요청 큐에 배치합니다. 소비 서비스는 메시지를 큐에 넣고, 메시지를 처리하고, 동일한 상관 관계 ID를 사용하여 응답 큐에 응답을 배치합니다. 생산자 서비스는 메시지를 큐에 삭제하고 상관 관계 ID와 일치시키고 처리를 계속합니다. 다음 섹션에서는 대기열을 자세히 다룹니다.

## <a name="commands"></a>명령

통신 상호 작용의 또 다른 유형은 *명령입니다.* 마이크로 서비스는 작업을 수행하기 위해 다른 마이크로 서비스가 필요할 수 있습니다. 주문 마이크로 서비스는 승인된 주문에 대한 발송물을 만들기 위해 배송 마이크로 서비스가 필요할 수 있습니다. 그림 4-12에서 생산자라고 하는 한 마이크로 서비스는 다른 마이크로 서비스인 소비자에게 메시지를 보내서 작업을 수행하도록 명령합니다.

![큐와의 명령 상호 작용](./media/command-interaction-with-queue.png)

**그림 4-12**. 큐와의 명령 상호 작용

대부분의 경우 생산자는 응답이 필요하지 않으며 메시지를 *발생시키고 잊어버릴* 수 있습니다. 회신이 필요한 경우 소비자는 다른 채널의 생산자에게 별도의 메시지를 다시 보냅니다. 명령 메시지는 메시지 큐를 사용 하 고 비동기적으로 전송 하는 것이 좋습니다. 경량 메시지 브로커에 의해 지원됩니다. 이전 다이어그램에서는 큐가 두 서비스를 분리하고 분리하는 방법을 기록합니다.

메시지 큐는 생산자와 소비자가 메시지를 전달하는 중간 구조입니다. 큐는 비동기의 지점 간 메시징 패턴을 구현합니다. 생산자는 명령을 보내야 하는 위치를 알고 적절하게 라우팅합니다. 큐는 채널에서 읽는 소비자 인스턴스 중 하나에서 메시지를 처리합니다. 이 시나리오에서는 생산자 또는 소비자 서비스 다른 영향을 주지 않고 확장할 수 있습니다. 또한 기술은 각 측면에서 서로 다를 수 있으므로 [Golang](https://golang.org) 마이크로 서비스를 호출하는 Java 마이크로 서비스가 있을 수 있습니다.

1장에서는 *지원 서비스에*대해 설명했습니다. 백업 서비스는 클라우드 네이티브 시스템이 의존하는 보조 리소스입니다. 메시지 큐가 서비스를 백업하고 있습니다. Azure 클라우드는 클라우드 네이티브 시스템에서 명령 메시징을 구현하는 데 사용할 수 있는 두 가지 유형의 메시지 큐(Azure 저장소 큐 및 Azure Service Bus Queues)를 지원합니다.

### <a name="azure-storage-queues"></a>Azure Storage 큐

Azure 저장소 큐는 Azure 저장소 계정에서 빠르고 저렴하며 백업되는 간단한 큐에 있는 인프라를 제공합니다.

[Azure 저장소 큐에는](https://docs.microsoft.com/azure/storage/queues/storage-queues-introduction) 안정적이고 지속적인 메시징이 있는 REST 기반 큐 메커니즘이 있습니다. 최소한의 기능 집합을 제공하지만 저렴하고 수백만 개의 메시지를 저장합니다. 용량은 최대 500TB입니다. 단일 메시지의 크기는 최대 64KB입니다.

HTTP 또는 HTTPS를 사용하여 인증된 호출을 통해 전 세계 어디서나 메시지에 액세스할 수 있습니다. 저장소 큐는 많은 수의 동시 클라이언트로 확장하여 트래픽 스파이크를 처리할 수 있습니다.

즉, 서비스에는 제한이 있습니다.

- 메시지 순서는 보장되지 않습니다.

- 메시지는 자동으로 제거되기 전에 7일 동안만 지속될 수 있습니다.

- 상태 관리, 중복 검색 또는 트랜잭션에 대한 지원을 사용할 수 없습니다.

그림 4-13은 Azure 저장소 큐의 계층 구조를 보여 주며 있습니다.

![스토리지 큐 계층 구조](./media/storage-queue-hierarchy.png)

**그림 4-13**. 스토리지 큐 계층 구조

이전 그림에서는 저장소 큐가 기본 Azure Storage 계정에 메시지를 저장하는 방법을 기록합니다.

개발자의 경우 Microsoft는 저장소 큐 처리를 위해 여러 클라이언트 및 서버 측 라이브러리를 제공합니다. 대부분의 주요 플랫폼은 .NET, 자바, 자바 스크립트, 루비, 파이썬 및 이동을 포함하여 지원됩니다. 개발자는 이러한 라이브러리와 직접 통신해서는 안 됩니다. 이렇게 하면 마이크로 서비스 코드를 Azure 저장소 큐 서비스에 밀접하게 결합합니다. API의 구현 세부 정보를 절연하는 것이 좋습니다. 일반 작업을 노출하고 콘크리트 라이브러리를 캡슐화하는 중간 API인 중간 API를 소개합니다. 이 느슨한 커플링을 사용하면 메인 라인 서비스 코드를 변경하지 않고도 하나의 대기열 서비스를 다른 큐잉 서비스로 교체 할 수 있습니다.

Azure 저장소 큐는 클라우드 네이티브 응용 프로그램에서 명령 메시징을 구현하는 경제적인 옵션입니다. 특히 큐 크기가 80GB를 초과하거나 간단한 기능 집합이 허용되는 경우. 메시지 저장에 대해서만 비용을 지불합니다. 정해진 시간당 요금은 없습니다.

### <a name="azure-service-bus-queues"></a>Azure Service Bus Queues

보다 복잡한 메시징 요구 사항을 보려면 Azure Service Bus 큐를 고려하십시오.

강력한 메시지 인프라 위에 있는 [Azure Service Bus는](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-messaging-overview) *중개된 메시징 모델을*지원합니다. 메시지는 소비자가 수신할 때까지 브로커(큐)에 안정적으로 저장됩니다. 큐는 메시지가 큐에 추가된 순서를 고려하여 FIFO(선/First-Out) 메시지 배달을 보장합니다.

메시지 크기는 최대 256KB까지 훨씬 클 수 있습니다. 메시지는 무제한 기간 동안 큐에 유지됩니다. Service Bus는 HTTP 기반 호출뿐만 아니라 [AMPQ 프로토콜에](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-amqp-overview)대한 전체 지원을 제공합니다. AMPQ는 이진 프로토콜과 높은 수준의 안정성을 지원하는 공급업체 전반에 걸쳐 개방형 표준입니다.

Service Bus는 [트랜잭션 지원](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-transactions) 및 중복 [검색 기능을](https://docs.microsoft.com/azure/service-bus-messaging/duplicate-detection)비롯한 다양한 기능 집합을 제공합니다. 큐는 메시지당 "한 번 배달"을 보장합니다. 이미 전송된 메시지는 자동으로 삭제됩니다. 생산자가 의심스러운 경우 동일한 메시지를 다시 보낼 수 있으며 Service Bus는 하나의 복사본만 처리되도록 보장합니다. 중복 검색을 통해 추가 인프라 배관을 구축할 필요가 없습니다.

두 개의 엔터프라이즈 기능이 분할 및 세션입니다. 기존의 Service Bus 큐는 단일 메시지 브로커에 의해 처리되고 단일 메시지 저장소에 저장됩니다. 그러나 [서비스 버스 분할은](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-partitioning) 여러 메시지 브로커 및 메시지 저장소에 큐를 분산시입니다. 전체 처리량은 더 이상 단일 메시지 브로커 또는 메시징 저장소의 성능에 의해 제한되지 않습니다. 메시징 저장소의 일시적인 중단으로 인해 분할된 큐를 사용할 수 없게 됩니다.

[서비스 버스 세션은](https://codingcanvas.com/azure-service-bus-sessions/) 그룹 관련 메시지에 대한 방법을 제공합니다. 메시지를 함께 처리하고 작업이 끝날 때 완료되어야 하는 워크플로 시나리오를 상상해 보십시오. 이점을 활용하려면 큐에 대해 세션을 명시적으로 활성화해야 하며 각 관련 메시지에는 동일한 세션 ID가 포함되어야 합니다.

그러나 몇 가지 중요한 주의 사항이 있습니다: 서비스 버스 큐 크기는 80GB로 제한되어 있으며 이는 저장소 큐에서 사용할 수 있는 것보다 훨씬 작습니다. 또한 서비스 버스 큐에는 기본 비용과 작업당 요금이 부과됩니다.

그림 4-14는 서비스 버스 큐의 고급 아키텍처를 간략하게 설명합니다.

![Service Bus 큐](./media/service-bus-queue.png)

**그림 4-14**. Service Bus 큐

이전 그림에서는 점 간 관계를 기록합니다. 동일한 공급자의 두 인스턴스가 메시지를 단일 Service Bus 큐에 큐에 넣습니다. 각 메시지는 오른쪽에 있는 세 개의 소비자 인스턴스 중 하나에서만 사용됩니다. 다음으로, 서로 다른 소비자가 모두 동일한 메시지에 관심이 있을 수 있는 메시징을 구현하는 방법에 대해 설명합니다.

## <a name="events"></a>이벤트

메시지 큐잉은 생산자가 비동기적으로 소비자에게 메시지를 보낼 수 있는 통신을 구현하는 효과적인 방법입니다. 그러나 *많은 다른 소비자가* 동일한 메시지에 관심이 있을 때 어떻게 됩니까? 각 소비자에 대한 전용 메시지 큐는 확장이 잘 되지 않아 관리하기가 어려워집니다.

이 시나리오를 해결 하려면 세 번째 유형의 메시지 상호 작용, *이벤트로*이동 합니다. 한 마이크로 서비스는 작업이 발생했음을 알 수 있습니다. 다른 마이크로 서비스(관심이 있는 경우)는 작업 또는 이벤트에 반응합니다.

이벤트는 두 단계로 이루어집니다. 지정된 상태 변경의 경우 마이크로 서비스는 메시지를 브로커에 게시하여 다른 관심 있는 마이크로 서비스에서 사용할 수 있도록 합니다. 관심 있는 마이크로 서비스는 메시지 브로커에서 이벤트를 구독하여 알림을 받게 됩니다. [게시/구독](https://docs.microsoft.com/azure/architecture/patterns/publisher-subscriber) 패턴을 사용하여 [이벤트 기반 통신을](https://docs.microsoft.com/dotnet/standard/microservices-architecture/multi-container-microservice-net-applications/integration-event-based-microservice-communications)구현합니다.

그림 4-15는 두 개의 다른 마이크로 서비스가 구독하는 이벤트를 게시하는 장바구니 마이크로 서비스를 보여 주며, 이에 따라 이벤트를 구독합니다.

![이벤트 기반 메시징](./media/event-driven-messaging.png)

**그림 4-15**. 이벤트 기반 메시징

통신 채널 중간에 있는 *이벤트 버스* 구성 요소를 기록합니다. 메시지 브로커를 캡슐화하고 기본 응용 프로그램에서 분리하는 사용자 지정 클래스입니다. 주문 및 재고 마이크로 서비스는 서로에 대한 지식없이 이벤트를 독립적으로 운영하거나 장바구니 마이크로 서비스를 운영합니다. 등록된 이벤트가 이벤트 버스에 게시되면 그 에 따라 작동합니다.

이벤트와 함께, 우리는 *주제에*대기 기술에서 이동 . [토픽은](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions) 큐와 유사하지만 일대다 메시징 패턴을 지원합니다. 하나의 마이크로 서비스가 메시지를 게시합니다. 여러 구독 마이크로 서비스는 해당 메시지를 수신하고 조치를 취하도록 선택할 수 있습니다. 그림 4-16은 토픽 아키텍처를 나타낸다.

![주제 아키텍처](./media/topic-architecture.png)

**그림 4-16**. 주제 아키텍처

이전 그림에서 게시자는 토픽에 메시지를 보냅니다. 결국 구독자는 구독에서 메시지를 받습니다. 중간에 주제는 진한 파란색 상자에 표시된 *일련의 규칙에*따라 구독으로 메시지를 전달합니다. 규칙은 특정 메시지를 구독으로 전달하는 필터 역할을 합니다. 여기서는 "CreateOrder" 이벤트가 구독 \#1및 구독 \#3으로 전송되지만 \#구독 2에는 전송되지 않습니다. "주문 완료" 이벤트가 구독 \#2 및 \#구독 3으로 전송됩니다.

Azure 클라우드는 두 가지 주제 서비스를 지원합니다: Azure 서비스 버스 토픽 및 Azure EventGrid.

### <a name="azure-service-bus-topics"></a>Azure Service Bus Topics

Azure Service Bus 큐의 동일한 강력한 중개 메시지 모델 위에 있는 [Azure Service Bus 항목입니다.](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions) 토픽은 여러 독립 게시자로부터 메시지를 수신하고 최대 2,000명의 구독자에게 메시지를 보낼 수 있습니다. 시스템을 중지하거나 토픽을 다시 만들지 않고도 런타임에 구독을 동적으로 추가하거나 제거할 수 있습니다.

Azure Service Bus 큐의 여러 고급 기능은 [중복 검색](https://docs.microsoft.com/azure/service-bus-messaging/duplicate-detection) 및 트랜잭션 [지원을](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-transactions)비롯한 토픽에도 사용할 수 있습니다. 기본적으로 Service Bus 항목은 단일 메시지 브로커에 의해 처리되고 단일 메시지 저장소에 저장됩니다. 그러나 [Service Bus 분할은](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-partitioning) 많은 메시지 브로커 및 메시지 저장소에 배포하여 토픽을 확장합니다.

[예약된 메시지 배달은](https://docs.microsoft.com/azure/service-bus-messaging/message-sequencing) 처리에 특정 시간이 있는 메시지에 태그를 붙입니다. 메시지는 해당 시간 전에 토픽에 나타나지 않습니다. [메시지 지연을](https://docs.microsoft.com/azure/service-bus-messaging/message-deferral) 사용하면 나중에 메시지 검색을 연기할 수 있습니다. 둘 다 일반적으로 작업이 특정 순서로 처리되는 워크플로 처리 시나리오에서 사용됩니다. 이전 작업이 완료될 때까지 수신된 메시지 처리를 연기할 수 있습니다.

Service Bus 주제는 클라우드 네이티브 시스템에서 게시/구독 통신을 활성화하기 위한 강력하고 입증된 기술입니다.

### <a name="azure-event-grid"></a>Azure Event Grid

Azure Service Bus는 전체 엔터프라이즈 기능 집합을 갖춘 전투 테스트를 거친 메시징 브로커이지만 [Azure Event Grid는](https://docs.microsoft.com/azure/event-grid/overview) 블록의 새로운 사용자입니다.

언뜻 보기에 이벤트 그리드는 다른 주제 기반 메시징 시스템처럼 보일 수 있습니다. 그러나 여러 면에서 다릅니다. 이벤트 기반 워크로드에 중점을 두고 실시간 이벤트 처리, 심층 적인 Azure 통합 및 개방형 플랫폼(서버리스 인프라)을 지원합니다. 최신 클라우드 네이티브 및 서버리스 애플리케이션을 위해 설계되었습니다.

중앙 집중식 *이벤트 백플레인*또는 파이프로서 Event Grid는 Azure 리소스 내부 및 자체 서비스에서 발생한 이벤트에 반응합니다.

이벤트 알림은 이벤트 그리드 토픽에 게시되며, 이 주제는 각 이벤트를 구독으로 라우팅합니다. 구독자는 구독에 매핑하고 이벤트를 사용합니다. 서비스 버스와 마찬가지로 Event Grid는 구독이 수신하려는 이벤트에 대한 규칙을 설정하는 *필터링된 구독자 모델을* 지원합니다. Event Grid는 빠른 처리량을 제공하여 초당 1,000만 개의 이벤트를 보장하여 Azure Service Bus가 생성할 수 있는 것보다 훨씬 더 많은 실시간 배달을 가능하게 합니다.

Event Grid의 가장 좋은 점은 Azure 인프라의 패브릭에 대한 심층적인 통합입니다. Cosmos DB와 같은 Azure 리소스는 사용자 지정 코드 없이 다른 관심 있는 Azure 리소스에 직접 기본 제공 이벤트를 게시할 수 있습니다. Event Grid는 Azure 구독, 리소스 그룹 또는 서비스에서 이벤트를 게시할 수 있으므로 개발자는 클라우드 리소스의 수명 주기를 세밀하게 제어할 수 있습니다. 그러나 이벤트 그리드는 Azure로 제한되지 않습니다. 응용 프로그램 또는 타사 서비스에서 게시된 사용자 지정 HTTP 이벤트를 사용하고 이벤트를 외부 구독자에게 라우팅할 수 있는 개방형 플랫폼입니다.

Azure 리소스에서 네이티브 이벤트를 게시하고 구독할 때 코딩이 필요하지 않습니다. 간단한 구성을 사용하면 토픽 및 구독에 대한 기본 제공 배관을 활용하는 다른 Azure 리소스의 이벤트를 통합할 수 있습니다. 그림 4-17은 이벤트 그리드의 해부학을 보여줍니다.

![이벤트 그리드 해부학](./media/event-grid-anatomy.png)

**그림 4-17**. 이벤트 그리드 해부학

EventGrid와 서비스 버스의 주요 차이점은 기본 *메시지 교환 패턴입니다.*

Service Bus는 다운스트림 구독자가 새 메시지에 대한 토픽 구독을 적극적으로 폴링을 하는 이전 스타일의 *끌어오기 모델을* 구현합니다. 거꾸로, 이 방법은 가입자가 메시지를 처리하는 속도를 완전히 제어 할 수 있습니다. 지정된 시간에 처리할 메시지의 시기와 수를 제어합니다. 읽지 않은 메시지는 처리될 때까지 구독에 남아 있습니다. 중요한 단점은 이벤트가 생성된 시간과 처리를 위해 해당 메시지를 구독자에게 가져오는 폴링 작업 사이의 대기 시간입니다. 또한 다음 이벤트에 대한 상수 폴링의 오버헤드는 리소스와 비용을 소비합니다.

그러나 EventGrid는 다릅니다. 이벤트가 수신된 대로 EventHandlers로 전송되는 *푸시 모델을* 구현하여 거의 실시간으로 이벤트 배달을 제공합니다. 또한 폴링과 마찬가지로 이벤트가 계속 소비되지 않는 경우에만 서비스가 트리거되기 때문에 비용이 절감됩니다. 즉, 이벤트 처리기는 들어오는 부하를 처리하고 과부하되지 않도록 자신을 보호하기 위해 제한 메커니즘을 제공해야 합니다. Azure Functions 및 논리 앱과 같은 이러한 이벤트를 사용하는 많은 Azure 서비스는 증가된 부하를 처리하는 자동 자동 크기 조정 기능을 제공합니다.  

이벤트 그리드는 완전히 관리되는 서버리스 클라우드 서비스입니다. 트래픽을 기반으로 동적으로 확장되며 사전 구매용량이 아닌 실제 사용량에 대해서만 요금이 청구됩니다. 매월 처음 100,000개의 작업은 무료입니다. 99.99%의 가용성을 갖춘 EventGrid는 24시간 내에 이벤트 배달을 보장하며, 실패한 배달을 위한 기본 제공 재시도 기능을 통해 이벤트를 제공합니다. 배달되지 않은 메시지는 해결을 위해 "배달 못한 편지" 큐로 이동할 수 있습니다.  Azure Service Bus와 달리 이벤트 그리드는 빠른 성능을 위해 조정되며 정렬된 메시징, 트랜잭션 및 세션과 같은 기능을 지원하지 않습니다.

### <a name="streaming-messages-in-the-azure-cloud"></a>Azure 클라우드에서 메시지 스트리밍

Azure Service Bus 및 이벤트 그리드는 새 문서와 같은 개별 이벤트가 Cosmos DB에 삽입된 경우와 같은 단일 이벤트를 노출하는 응용 프로그램에 대한 훌륭한 지원을 제공합니다. 그러나 클라우드 네이티브 시스템이 *관련 이벤트 스트림을*처리해야 하는 경우 어떻게 해야 합니까? [이벤트 스트림은](https://docs.microsoft.com/archive/msdn-magazine/2015/february/microsoft-azure-the-rise-of-event-stream-oriented-systems) 더 복잡합니다. 일반적으로 시간 순차적이고 상호 관련되며 그룹으로 처리되어야 합니다.

[Azure Event Hub는](https://azure.microsoft.com/services/event-hubs/) 이벤트를 수집, 변환 및 저장하는 데이터 스트리밍 플랫폼 및 이벤트 수집 서비스입니다. 원격 분석 컨텍스트에서 내보낸 연속 이벤트 알림과 같은 스트리밍 데이터를 캡처하도록 미세 조정됩니다. 이 서비스는 확장성이 뛰어나며 [초당 수백만 개의 이벤트를](https://docs.microsoft.com/azure/event-hubs/event-hubs-about)저장하고 처리할 수 있습니다. 그림 4-18에 표시된 이 파이프라인은 이벤트 파이프라인의 정문으로, 이벤트 소비에서 인제스트 스트림을 분리합니다.

![Azure Event Hub](./media/azure-event-hub.png)

**그림 4-18**. Azure Event Hub

이벤트 허브는 짧은 대기 시간 및 구성 가능한 시간 보존을 지원합니다. 큐 및 토픽과 달리 이벤트 허브는 소비자가 읽은 후 이벤트 데이터를 유지합니다. 이 기능을 사용하면 내부 및 외부의 다른 데이터 분석 서비스에서 추가 분석을 위해 데이터를 재생할 수 있습니다. 이벤트 허브에 저장된 이벤트는 기본적으로 1일이지만 구성 가능한 보존 기간이 만료된 경우에만 삭제됩니다.

이벤트 허브는 HTTPS 및 AMQP를 포함한 일반적인 이벤트 게시 프로토콜을 지원합니다. 또한 카프카 1.0을 지원합니다. [기존 Kafka 응용 프로그램은 큰 Kafka 클러스터를](https://docs.microsoft.com/azure/event-hubs/event-hubs-for-kafka-ecosystem-overview) 관리하는 대안을 제공하는 Kafka 프로토콜을 사용하여 이벤트 허브와 통신할 수 있습니다. 많은 오픈 소스 클라우드 네이티브 시스템은 Kafka를 수용합니다.

Event Hubs는 각 소비자가 메시지 스트림의 특정 하위 집합 또는 파티션만 읽는 [분할된 소비자 모델을](https://docs.microsoft.com/azure/event-hubs/event-hubs-features) 통해 메시지 스트리밍을 구현합니다. 이 패턴에서는 이벤트 처리를 위해 매우 폭넓은 수평 확장이 가능하며, 큐와 항목에서는 사용할 수 없는 기타 스트림 중심 기능이 제공됩니다. 파티션은 Event Hub에서 보유하는 순서가 지정된 이벤트 시퀀스입니다. 최신 이벤트가 도착하면 이 시퀀스의 끝에 추가됩니다.그림 4-19는 이벤트 허브에서 분할을 보여줍니다.

![이벤트 허브 분할](./media/event-hub-partitioning.png)

**그림 4-19**. 이벤트 허브 분할

각 소비자 그룹은 동일한 리소스에서 읽는 대신 메시지 스트림의 하위 집합 또는 파티션을 읽습니다.

많은 수의 이벤트를 스트리밍해야 하는 클라우드 네이티브 응용 프로그램의 경우 Azure Event Hub는 강력하고 경제적인 솔루션이 될 수 있습니다.

>[!div class="step-by-step"]
>[이전](front-end-communication.md)
>[다음](rest-grpc.md)

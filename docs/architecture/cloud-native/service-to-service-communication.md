---
title: 서비스 간 통신
description: 백 엔드 클라우드 네이티브 마이크로 서비스가 다른 백 엔드 마이크로 서비스와 통신하는 방법을 알아봅니다.
author: robvet
ms.date: 09/09/2019
ms.openlocfilehash: 926be3c2eb4513c89ebcd1f31dceb7d58639dc6f
ms.sourcegitcommit: 79b0dd8bfc63f33a02137121dd23475887ecefda
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 04/01/2020
ms.locfileid: "80523556"
---
# <a name="service-to-service-communication"></a><span data-ttu-id="22e74-103">서비스 간 통신</span><span class="sxs-lookup"><span data-stu-id="22e74-103">Service-to-service communication</span></span>

[!INCLUDE [book-preview](../../../includes/book-preview.md)]

<span data-ttu-id="22e74-104">프런트 엔드 클라이언트에서 이동, 우리는 지금 서로 통신 백 엔드 마이크로 서비스를 해결.</span><span class="sxs-lookup"><span data-stu-id="22e74-104">Moving from the front-end client, we now address back-end microservices communicate with each other.</span></span>

<span data-ttu-id="22e74-105">클라우드 네이티브 응용 프로그램을 구성할 때 백 엔드 서비스가 서로 통신하는 방식에 민감해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-105">When constructing a cloud-native application, you'll want to be sensitive to how back-end services communicate with each other.</span></span> <span data-ttu-id="22e74-106">이상적으로는 서비스 간 통신이 적을수록 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-106">Ideally, the less inter-service communication, the better.</span></span> <span data-ttu-id="22e74-107">그러나 백 엔드 서비스가 작업을 완료하기 위해 서로 의존하는 경우가 많기 때문에 회피가 항상 가능한 것은 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-107">However, avoidance isn't always possible as back-end services often rely on one another to complete an operation.</span></span>

<span data-ttu-id="22e74-108">서비스 간 통신을 구현하기 위해 널리 사용되는 몇 가지 접근 방식이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-108">There are several widely accepted approaches to implementing cross-service communication.</span></span> <span data-ttu-id="22e74-109">*통신 상호 작용의 유형에* 따라 가장 적합한 접근 방식이 결정되는 경우가 많습니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-109">The *type of communication interaction* will often determine the best approach.</span></span>

<span data-ttu-id="22e74-110">다음 상호 작용 유형을 고려하십시오.</span><span class="sxs-lookup"><span data-stu-id="22e74-110">Consider the following interaction types:</span></span>

- <span data-ttu-id="22e74-111">*쿼리* - 호출 마이크로 서비스가 "이봐, 지정된 고객 ID에 대한 구매자 정보를 제공"과 같은 호출 마이크로 서비스에서 응답이 필요한 경우.</span><span class="sxs-lookup"><span data-stu-id="22e74-111">*Query* – when a calling microservice requires a response from a called microservice, such as, "Hey, give me the buyer information for a given customer Id."</span></span>

- <span data-ttu-id="22e74-112">*명령* - 호출 마이크로 서비스가 작업을 실행하기 위해 다른 마이크로 서비스가 필요하지만 "이봐, 그냥이 순서를 발송"과 같은 응답을 필요로하지 않는 경우.</span><span class="sxs-lookup"><span data-stu-id="22e74-112">*Command* – when the calling microservice needs another microservice to execute an action but doesn't require a response, such as, "Hey, just ship this order."</span></span>

- <span data-ttu-id="22e74-113">*이벤트* – 게시자라고 하는 마이크로 서비스가 상태가 변경되었거나 작업이 발생한 이벤트를 발생시면</span><span class="sxs-lookup"><span data-stu-id="22e74-113">*Event* – when a microservice, called the publisher, raises an event that state has changed or an action has occurred.</span></span> <span data-ttu-id="22e74-114">관심 있는 구독자라고 하는 다른 마이크로 서비스는 이벤트에 적절하게 대응할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-114">Other microservices, called subscribers, who are interested, can react to the event appropriately.</span></span> <span data-ttu-id="22e74-115">게시자와 구독자는 서로를 인식하지 못합니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-115">The publisher and the subscribers aren't aware of each other.</span></span>

<span data-ttu-id="22e74-116">마이크로 서비스 시스템은 일반적으로 서비스 간 상호 작용이 필요한 작업을 실행하는 경우 이러한 상호 작용 유형의 조합을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-116">Microservice systems typically use a combination of these interaction types when executing operations that require cross-service interaction.</span></span> <span data-ttu-id="22e74-117">각각을 자세히 살펴보고 이를 구현하는 방법을 살펴보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-117">Let's take a close look at each and how you might implement them.</span></span>

## <a name="queries"></a><span data-ttu-id="22e74-118">쿼리</span><span class="sxs-lookup"><span data-stu-id="22e74-118">Queries</span></span>

<span data-ttu-id="22e74-119">한 마이크로 서비스가 다른 마이크로 서비스를 *쿼리해야* 하는 경우가 많으며 작업을 완료하기 위해 즉각적인 응답이 필요할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-119">Many times, one microservice might need to *query* another, requiring an immediate response to complete an operation.</span></span> <span data-ttu-id="22e74-120">장바구니 마이크로 서비스는 장바구니에 품목을 추가하기 위해 제품 정보와 가격이 필요할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-120">A shopping basket microservice may need product information and a price to add an item to its basket.</span></span> <span data-ttu-id="22e74-121">쿼리 작업을 구현하기 위한 여러 가지 방법이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-121">There are a number of approaches for implementing query operations.</span></span>

### <a name="requestresponse-messaging"></a><span data-ttu-id="22e74-122">요청/응답 메시징</span><span class="sxs-lookup"><span data-stu-id="22e74-122">Request/Response Messaging</span></span>

<span data-ttu-id="22e74-123">이 시나리오를 구현하기 위한 한 가지 옵션은 그림 4-8에 표시된 쿼리해야 하는 마이크로 서비스에 직접 HTTP 요청을 하기 위해 백 엔드 마이크로 서비스를 호출하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-123">One option for implementing this scenario is for the calling back-end microservice to make direct HTTP requests to the microservices it needs to query, shown in Figure 4-8.</span></span>

![직접 HTTP 통신](./media/direct-http-communication.png)

<span data-ttu-id="22e74-125">**그림 4-8**.</span><span class="sxs-lookup"><span data-stu-id="22e74-125">**Figure 4-8**.</span></span> <span data-ttu-id="22e74-126">직접 HTTP 통신</span><span class="sxs-lookup"><span data-stu-id="22e74-126">Direct HTTP communication</span></span>

<span data-ttu-id="22e74-127">마이크로 서비스 간의 직접 HTTP 호출은 비교적 간단하지만 이 방법을 최소화하려면 주의해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-127">While direct HTTP calls between microservices are relatively simple to implement, care should be taken to minimize this practice.</span></span> <span data-ttu-id="22e74-128">시작하려면 이러한 호출은 항상 *동기적이며* 결과가 반환되거나 요청 시간이 시간 단축될 때까지 작업을 차단합니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-128">To start, these calls are always *synchronous* and will block the operation until a result is returned or the request times outs.</span></span> <span data-ttu-id="22e74-129">한때 독립적이고 독립적인 서비스가었으며, 독립적으로 진화하고 자주 배포할 수 있었던 것은 이제 서로 결합됩니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-129">What were once self-contained, independent services, able to evolve independently and deploy frequently, now become coupled to each other.</span></span> <span data-ttu-id="22e74-130">마이크로 서비스 간의 결합이 증가함에 따라 아키텍처상의 이점이 줄어듭니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-130">As coupling among microservices increase, their architectural benefits diminish.</span></span>

<span data-ttu-id="22e74-131">다른 마이크로 서비스에 대한 단일 직접 HTTP 호출을 하는 드문 요청을 실행하는 것은 일부 시스템에서 허용될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-131">Executing an infrequent request that makes a single direct HTTP call to another microservice might be acceptable for some systems.</span></span> <span data-ttu-id="22e74-132">그러나 여러 마이크로 서비스에 직접 HTTP 호출을 호출하는 대용량 호출은 권장되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-132">However, high-volume calls that invoke direct HTTP calls to multiple microservices aren't advisable.</span></span> <span data-ttu-id="22e74-133">대기 시간이 증가하고 시스템의 성능, 확장성 및 가용성에 부정적인 영향을 미칠 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-133">They can increase latency and negatively impact the performance, scalability, and availability of your system.</span></span> <span data-ttu-id="22e74-134">더 나쁜 것은 긴 일련의 직접 HTTP 통신은 그림 4-9에 표시된 동기 마이크로 서비스 호출의 깊고 복잡한 체인으로 이어질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-134">Even worse, a long series of direct HTTP communication can lead to deep and complex chains of synchronous microservices calls, shown in Figure 4-9:</span></span>

![HTTP 쿼리 연결](./media/chaining-http-queries.png)

<span data-ttu-id="22e74-136">**그림 4-9**.</span><span class="sxs-lookup"><span data-stu-id="22e74-136">**Figure 4-9**.</span></span> <span data-ttu-id="22e74-137">HTTP 쿼리 연결</span><span class="sxs-lookup"><span data-stu-id="22e74-137">Chaining HTTP queries</span></span>

<span data-ttu-id="22e74-138">당신은 확실히 이전 이미지에 표시된 디자인의 위험을 상상할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-138">You can certainly imagine the risk in the design shown in the previous image.</span></span> <span data-ttu-id="22e74-139">3단계가 실패하면 어떻게 됩니까? \#</span><span class="sxs-lookup"><span data-stu-id="22e74-139">What happens if Step \#3 fails?</span></span> <span data-ttu-id="22e74-140">또는 \#8 단계가 실패?</span><span class="sxs-lookup"><span data-stu-id="22e74-140">Or Step \#8 fails?</span></span> <span data-ttu-id="22e74-141">어떻게 회복합니까?</span><span class="sxs-lookup"><span data-stu-id="22e74-141">How do you recover?</span></span> <span data-ttu-id="22e74-142">기본 서비스가 \#사용 중이기 때문에 6단계가 느리면 어떻게 해야 합니까?</span><span class="sxs-lookup"><span data-stu-id="22e74-142">What if Step \#6 is slow because the underlying service is busy?</span></span> <span data-ttu-id="22e74-143">어떻게 계속하시겠습니까?</span><span class="sxs-lookup"><span data-stu-id="22e74-143">How do you continue?</span></span> <span data-ttu-id="22e74-144">모든 것이 올바르게 작동하더라도 이 호출이 발생하는 대기 시간을 생각하면 각 단계의 대기 시간의 합계입니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-144">Even if all works correctly, think of the latency this call would incur, which is the sum of the latency of each step.</span></span>

<span data-ttu-id="22e74-145">이전 이미지의 큰 커플링은 서비스가 최적으로 모델링되지 않았음을 시사합니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-145">The large degree of coupling in the previous image suggests the services weren't optimally modeled.</span></span> <span data-ttu-id="22e74-146">팀이 자신의 디자인을 다시 검토하는 것이 좋을 것입니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-146">It would behoove the team to revisit their design.</span></span>

### <a name="materialized-view-pattern"></a><span data-ttu-id="22e74-147">구체화된 뷰 패턴</span><span class="sxs-lookup"><span data-stu-id="22e74-147">Materialized View pattern</span></span>

<span data-ttu-id="22e74-148">마이크로 서비스 커플링을 제거하는 데 가장 인기 있는 옵션은 [구체화된 뷰 패턴입니다.](https://docs.microsoft.com/azure/architecture/patterns/materialized-view)</span><span class="sxs-lookup"><span data-stu-id="22e74-148">A popular option for removing microservice coupling is the [Materialized View pattern](https://docs.microsoft.com/azure/architecture/patterns/materialized-view).</span></span> <span data-ttu-id="22e74-149">이 패턴을 사용하면 마이크로 서비스는 다른 서비스에서 소유한 데이터의 로컬, 정규화되지 않은 복사본을 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-149">With this pattern, a microservice stores its own local, denormalized copy of data that's owned by other services.</span></span> <span data-ttu-id="22e74-150">제품 카탈로그 및 가격 책정 마이크로 서비스를 쿼리하는 장바구니 마이크로 서비스 대신 해당 데이터의 로컬 복사본을 유지 관리합니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-150">Instead of the Shopping Basket microservice querying the Product Catalog and Pricing microservices, it maintains its own local copy of that data.</span></span> <span data-ttu-id="22e74-151">이 패턴은 불필요한 결합을 제거하고 안정성과 응답 시간을 향상시킵니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-151">This pattern eliminates unnecessary coupling and improves reliability and response time.</span></span> <span data-ttu-id="22e74-152">전체 작업은 단일 프로세스 내에서 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-152">The entire operation executes inside a single process.</span></span> <span data-ttu-id="22e74-153">이 패턴 및 기타 데이터 관련 사항5장에서 살펴보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-153">We explore this pattern and other data concerns in Chapter 5.</span></span>

### <a name="service-aggregator-pattern"></a><span data-ttu-id="22e74-154">서비스 애그리게이터 패턴</span><span class="sxs-lookup"><span data-stu-id="22e74-154">Service Aggregator Pattern</span></span>

<span data-ttu-id="22e74-155">마이크로 서비스 간 마이크로 서비스 커플링을 제거하는 또 다른 옵션은 그림 4-10에 자주색으로 표시된 [애그리게이터 마이크로 서비스입니다.](https://devblogs.microsoft.com/cesardelatorre/designing-and-implementing-api-gateways-with-ocelot-in-a-microservices-and-container-based-architecture/)</span><span class="sxs-lookup"><span data-stu-id="22e74-155">Another option for eliminating microservice-to-microservice coupling is an [Aggregator microservice](https://devblogs.microsoft.com/cesardelatorre/designing-and-implementing-api-gateways-with-ocelot-in-a-microservices-and-container-based-architecture/), shown in purple in Figure 4-10.</span></span>

![애그리게이터 서비스](./media/aggregator-service.png)

<span data-ttu-id="22e74-157">**그림 4-10**</span><span class="sxs-lookup"><span data-stu-id="22e74-157">**Figure 4-10**.</span></span> <span data-ttu-id="22e74-158">애그리게이터 마이크로 서비스</span><span class="sxs-lookup"><span data-stu-id="22e74-158">Aggregator microservice</span></span>

<span data-ttu-id="22e74-159">패턴은 여러 백 엔드 마이크로 서비스를 호출하는 작업을 격리하여 논리를 특수 마이크로 서비스로 중앙 집중화합니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-159">The pattern isolates an operation that makes calls to multiple back-end microservices, centralizing its logic into a specialized microservice.</span></span>  <span data-ttu-id="22e74-160">이전 그림의 보라색 체크 아웃 집계 마이크로 서비스는 체크 아웃 작업에 대한 워크플로를 오케스트레이션합니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-160">The purple checkout aggregator microservice in the previous figure orchestrates the workflow for the Checkout operation.</span></span> <span data-ttu-id="22e74-161">여기에는 순서대로 여러 백 엔드 마이크로 서비스에 대한 호출이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-161">It includes calls to several back-end microservices in a sequenced order.</span></span> <span data-ttu-id="22e74-162">워크플로의 데이터가 집계되어 호출자에게 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-162">Data from the workflow is aggregated and returned to the caller.</span></span> <span data-ttu-id="22e74-163">집계 마이크로 서비스는 여전히 직접 HTTP 호출을 구현하지만 백 엔드 마이크로 서비스 간의 직접 종속성을 줄입니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-163">While it still implements direct HTTP calls, the aggregator microservice reduces direct dependencies among back-end microservices.</span></span>

### <a name="requestreply-pattern"></a><span data-ttu-id="22e74-164">요청/회신 패턴</span><span class="sxs-lookup"><span data-stu-id="22e74-164">Request/Reply Pattern</span></span>

<span data-ttu-id="22e74-165">동기 HTTP 메시지를 분리하기 위한 또 다른 방법은 대기 통신을 사용하는 [요청-회신 패턴입니다.](https://www.enterpriseintegrationpatterns.com/patterns/messaging/RequestReply.html)</span><span class="sxs-lookup"><span data-stu-id="22e74-165">Another approach for decoupling synchronous HTTP messages is a [Request-Reply Pattern](https://www.enterpriseintegrationpatterns.com/patterns/messaging/RequestReply.html), which uses queuing communication.</span></span> <span data-ttu-id="22e74-166">큐를 사용하는 통신은 항상 생산자가 메시지를 보내고 소비자가 수신하는 단방향 채널입니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-166">Communication using a queue is always a one-way channel, with a producer sending the message and consumer receiving it.</span></span> <span data-ttu-id="22e74-167">이 패턴을 사용하면 그림 4-11에 표시된 요청 큐와 응답 큐가 모두 구현됩니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-167">With this pattern, both a request queue and response queue are implemented, shown in Figure 4-11.</span></span>

![요청-회신 패턴](./media/request-reply-pattern.png)

<span data-ttu-id="22e74-169">**그림 4-11**</span><span class="sxs-lookup"><span data-stu-id="22e74-169">**Figure 4-11**.</span></span> <span data-ttu-id="22e74-170">요청-회신 패턴</span><span class="sxs-lookup"><span data-stu-id="22e74-170">Request-reply pattern</span></span>

<span data-ttu-id="22e74-171">여기서 메시지 생산자는 고유한 상관 관계 ID를 포함하는 쿼리 기반 메시지를 만들고 요청 큐에 배치합니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-171">Here, the message producer creates a query-based message that contains a unique correlation ID and places it into a request queue.</span></span> <span data-ttu-id="22e74-172">소비 서비스는 메시지를 큐에 넣고, 메시지를 처리하고, 동일한 상관 관계 ID를 사용하여 응답 큐에 응답을 배치합니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-172">The consuming service dequeues the messages, processes it and places the response into the response queue with the same correlation ID.</span></span> <span data-ttu-id="22e74-173">생산자 서비스는 메시지를 큐에 삭제하고 상관 관계 ID와 일치시키고 처리를 계속합니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-173">The producer service dequeues the message, matches it with the correlation ID and continues processing.</span></span> <span data-ttu-id="22e74-174">다음 섹션에서는 대기열을 자세히 다룹니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-174">We cover queues in detail in the next section.</span></span>

## <a name="commands"></a><span data-ttu-id="22e74-175">명령</span><span class="sxs-lookup"><span data-stu-id="22e74-175">Commands</span></span>

<span data-ttu-id="22e74-176">통신 상호 작용의 또 다른 유형은 *명령입니다.*</span><span class="sxs-lookup"><span data-stu-id="22e74-176">Another type of communication interaction is a *command*.</span></span> <span data-ttu-id="22e74-177">마이크로 서비스는 작업을 수행하기 위해 다른 마이크로 서비스가 필요할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-177">A microservice may need another microservice to perform an action.</span></span> <span data-ttu-id="22e74-178">주문 마이크로 서비스는 승인된 주문에 대한 발송물을 만들기 위해 배송 마이크로 서비스가 필요할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-178">The Ordering microservice may need the Shipping microservice to create a shipment for an approved order.</span></span> <span data-ttu-id="22e74-179">그림 4-12에서 생산자라고 하는 한 마이크로 서비스는 다른 마이크로 서비스인 소비자에게 메시지를 보내서 작업을 수행하도록 명령합니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-179">In Figure 4-12, one microservice, called a Producer, sends a message to another microservice, the Consumer, commanding it to do something.</span></span>

![큐와의 명령 상호 작용](./media/command-interaction-with-queue.png)

<span data-ttu-id="22e74-181">**그림 4-12**.</span><span class="sxs-lookup"><span data-stu-id="22e74-181">**Figure 4-12**.</span></span> <span data-ttu-id="22e74-182">큐와의 명령 상호 작용</span><span class="sxs-lookup"><span data-stu-id="22e74-182">Command interaction with a queue</span></span>

<span data-ttu-id="22e74-183">대부분의 경우 생산자는 응답이 필요하지 않으며 메시지를 *발생시키고 잊어버릴* 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-183">Most often, the Producer doesn't require a response and can *fire-and-forget* the message.</span></span> <span data-ttu-id="22e74-184">회신이 필요한 경우 소비자는 다른 채널의 생산자에게 별도의 메시지를 다시 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-184">If a reply is needed, the Consumer sends a separate message back to Producer on another channel.</span></span> <span data-ttu-id="22e74-185">명령 메시지는 메시지 큐를 사용 하 고 비동기적으로 전송 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-185">A command message is best sent asynchronously with a message queue.</span></span> <span data-ttu-id="22e74-186">경량 메시지 브로커에 의해 지원됩니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-186">supported by a lightweight message broker.</span></span> <span data-ttu-id="22e74-187">이전 다이어그램에서는 큐가 두 서비스를 분리하고 분리하는 방법을 기록합니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-187">In the previous diagram, note how a queue separates and decouples both services.</span></span>

<span data-ttu-id="22e74-188">메시지 큐는 생산자와 소비자가 메시지를 전달하는 중간 구조입니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-188">A message queue is an intermediary construct through which a producer and consumer pass a message.</span></span> <span data-ttu-id="22e74-189">큐는 비동기의 지점 간 메시징 패턴을 구현합니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-189">Queues implement an asynchronous, point-to-point messaging pattern.</span></span> <span data-ttu-id="22e74-190">생산자는 명령을 보내야 하는 위치를 알고 적절하게 라우팅합니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-190">The Producer knows where a command needs to be sent and routes appropriately.</span></span> <span data-ttu-id="22e74-191">큐는 채널에서 읽는 소비자 인스턴스 중 하나에서 메시지를 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-191">The queue guarantees that a message is processed by exactly one of the consumer instances that are reading from the channel.</span></span> <span data-ttu-id="22e74-192">이 시나리오에서는 생산자 또는 소비자 서비스 다른 영향을 주지 않고 확장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-192">In this scenario, either the producer or consumer service can scale out without affecting the other.</span></span> <span data-ttu-id="22e74-193">또한 기술은 각 측면에서 서로 다를 수 있으므로 [Golang](https://golang.org) 마이크로 서비스를 호출하는 Java 마이크로 서비스가 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-193">As well, technologies can be disparate on each side, meaning that we might have a Java microservice calling a [Golang](https://golang.org) microservice.</span></span>

<span data-ttu-id="22e74-194">1장에서는 *지원 서비스에*대해 설명했습니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-194">In chapter 1, we talked about *backing services*.</span></span> <span data-ttu-id="22e74-195">백업 서비스는 클라우드 네이티브 시스템이 의존하는 보조 리소스입니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-195">Backing services are ancillary resources upon which cloud-native systems depend.</span></span> <span data-ttu-id="22e74-196">메시지 큐가 서비스를 백업하고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-196">Message queues are backing services.</span></span> <span data-ttu-id="22e74-197">Azure 클라우드는 클라우드 네이티브 시스템에서 명령 메시징을 구현하는 데 사용할 수 있는 두 가지 유형의 메시지 큐(Azure 저장소 큐 및 Azure Service Bus Queues)를 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-197">The Azure cloud supports two types of message queues that your cloud-native systems can consume to implement command messaging: Azure Storage Queues and Azure Service Bus Queues.</span></span>

### <a name="azure-storage-queues"></a><span data-ttu-id="22e74-198">Azure Storage 큐</span><span class="sxs-lookup"><span data-stu-id="22e74-198">Azure Storage Queues</span></span>

<span data-ttu-id="22e74-199">Azure 저장소 큐는 Azure 저장소 계정에서 빠르고 저렴하며 백업되는 간단한 큐에 있는 인프라를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-199">Azure storage queues offer a simple queueing infrastructure that is fast, affordable, and backed by Azure storage accounts.</span></span>

<span data-ttu-id="22e74-200">[Azure 저장소 큐에는](https://docs.microsoft.com/azure/storage/queues/storage-queues-introduction) 안정적이고 지속적인 메시징이 있는 REST 기반 큐 메커니즘이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-200">[Azure Storage Queues](https://docs.microsoft.com/azure/storage/queues/storage-queues-introduction) feature a REST-based queuing mechanism with reliable and persistent messaging.</span></span> <span data-ttu-id="22e74-201">최소한의 기능 집합을 제공하지만 저렴하고 수백만 개의 메시지를 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-201">They provide a minimal feature set, but are inexpensive and store millions of messages.</span></span> <span data-ttu-id="22e74-202">용량은 최대 500TB입니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-202">Their capacity ranges up to 500 TB.</span></span> <span data-ttu-id="22e74-203">단일 메시지의 크기는 최대 64KB입니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-203">A single message can be up to 64 KB in size.</span></span>

<span data-ttu-id="22e74-204">HTTP 또는 HTTPS를 사용하여 인증된 호출을 통해 전 세계 어디서나 메시지에 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-204">You can access messages from anywhere in the world via authenticated calls using HTTP or HTTPS.</span></span> <span data-ttu-id="22e74-205">저장소 큐는 많은 수의 동시 클라이언트로 확장하여 트래픽 스파이크를 처리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-205">Storage queues can scale out to large numbers of concurrent clients to handle traffic spikes.</span></span>

<span data-ttu-id="22e74-206">즉, 서비스에는 제한이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-206">That said, there are limitations with the service:</span></span>

- <span data-ttu-id="22e74-207">메시지 순서는 보장되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-207">Message order isn't guaranteed.</span></span>

- <span data-ttu-id="22e74-208">메시지는 자동으로 제거되기 전에 7일 동안만 지속될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-208">A message can only persist for seven days before it's automatically removed.</span></span>

- <span data-ttu-id="22e74-209">상태 관리, 중복 검색 또는 트랜잭션에 대한 지원을 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-209">Support for state management, duplicate detection, or transactions isn't available.</span></span>

<span data-ttu-id="22e74-210">그림 4-13은 Azure 저장소 큐의 계층 구조를 보여 주며 있습니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-210">Figure 4-13 shows the hierarchy of an Azure Storage Queue.</span></span>

![스토리지 큐 계층 구조](./media/storage-queue-hierarchy.png)

<span data-ttu-id="22e74-212">**그림 4-13**.</span><span class="sxs-lookup"><span data-stu-id="22e74-212">**Figure 4-13**.</span></span> <span data-ttu-id="22e74-213">스토리지 큐 계층 구조</span><span class="sxs-lookup"><span data-stu-id="22e74-213">Storage queue hierarchy</span></span>

<span data-ttu-id="22e74-214">이전 그림에서는 저장소 큐가 기본 Azure Storage 계정에 메시지를 저장하는 방법을 기록합니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-214">In the previous figure, note how storage queues store their messages in the underlying Azure Storage account.</span></span>

<span data-ttu-id="22e74-215">개발자의 경우 Microsoft는 저장소 큐 처리를 위해 여러 클라이언트 및 서버 측 라이브러리를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-215">For developers, Microsoft provides several client and server-side libraries for Storage queue processing.</span></span> <span data-ttu-id="22e74-216">대부분의 주요 플랫폼은 .NET, 자바, 자바 스크립트, 루비, 파이썬 및 이동을 포함하여 지원됩니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-216">Most major platforms are supported including .NET, Java, JavaScript, Ruby, Python, and Go.</span></span> <span data-ttu-id="22e74-217">개발자는 이러한 라이브러리와 직접 통신해서는 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-217">Developers should never communicate directly with these libraries.</span></span> <span data-ttu-id="22e74-218">이렇게 하면 마이크로 서비스 코드를 Azure 저장소 큐 서비스에 밀접하게 결합합니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-218">Doing so will tightly couple your microservice code to the Azure Storage Queue service.</span></span> <span data-ttu-id="22e74-219">API의 구현 세부 정보를 절연하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-219">It's a better practice to insulate the implementation details of the API.</span></span> <span data-ttu-id="22e74-220">일반 작업을 노출하고 콘크리트 라이브러리를 캡슐화하는 중간 API인 중간 API를 소개합니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-220">Introduce an intermediation layer, or intermediate API, that exposes generic operations and encapsulates the concrete library.</span></span> <span data-ttu-id="22e74-221">이 느슨한 커플링을 사용하면 메인 라인 서비스 코드를 변경하지 않고도 하나의 대기열 서비스를 다른 큐잉 서비스로 교체 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-221">This loose coupling enables you to swap out one queuing service for another without having to make changes to the mainline service code.</span></span>

<span data-ttu-id="22e74-222">Azure 저장소 큐는 클라우드 네이티브 응용 프로그램에서 명령 메시징을 구현하는 경제적인 옵션입니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-222">Azure Storage queues are an economical option to implement command messaging in your cloud-native applications.</span></span> <span data-ttu-id="22e74-223">특히 큐 크기가 80GB를 초과하거나 간단한 기능 집합이 허용되는 경우.</span><span class="sxs-lookup"><span data-stu-id="22e74-223">Especially when a queue size will exceed 80 GB, or a simple feature set is acceptable.</span></span> <span data-ttu-id="22e74-224">메시지 저장에 대해서만 비용을 지불합니다. 정해진 시간당 요금은 없습니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-224">You only pay for the storage of the messages; there are no fixed hourly charges.</span></span>

### <a name="azure-service-bus-queues"></a><span data-ttu-id="22e74-225">Azure Service Bus Queues</span><span class="sxs-lookup"><span data-stu-id="22e74-225">Azure Service Bus Queues</span></span>

<span data-ttu-id="22e74-226">보다 복잡한 메시징 요구 사항을 보려면 Azure Service Bus 큐를 고려하십시오.</span><span class="sxs-lookup"><span data-stu-id="22e74-226">For more complex messaging requirements, consider Azure Service Bus queues.</span></span>

<span data-ttu-id="22e74-227">강력한 메시지 인프라 위에 있는 [Azure Service Bus는](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-messaging-overview) *중개된 메시징 모델을*지원합니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-227">Sitting atop a robust message infrastructure, [Azure Service Bus](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-messaging-overview) supports a *brokered messaging model*.</span></span> <span data-ttu-id="22e74-228">메시지는 소비자가 수신할 때까지 브로커(큐)에 안정적으로 저장됩니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-228">Messages are reliably stored in a broker (the queue) until received by the consumer.</span></span> <span data-ttu-id="22e74-229">큐는 메시지가 큐에 추가된 순서를 고려하여 FIFO(선/First-Out) 메시지 배달을 보장합니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-229">The queue guarantees First-In/First-Out (FIFO) message delivery, respecting the order in which messages were added to the queue.</span></span>

<span data-ttu-id="22e74-230">메시지 크기는 최대 256KB까지 훨씬 클 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-230">The size of a message can be much larger, up to 256 KB.</span></span> <span data-ttu-id="22e74-231">메시지는 무제한 기간 동안 큐에 유지됩니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-231">Messages are persisted in the queue for an unlimited period of time.</span></span> <span data-ttu-id="22e74-232">Service Bus는 HTTP 기반 호출뿐만 아니라 [AMPQ 프로토콜에](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-amqp-overview)대한 전체 지원을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-232">Service Bus supports not only HTTP-based calls, but also provides full support for the [AMPQ protocol](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-amqp-overview).</span></span> <span data-ttu-id="22e74-233">AMPQ는 이진 프로토콜과 높은 수준의 안정성을 지원하는 공급업체 전반에 걸쳐 개방형 표준입니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-233">AMPQ is an open-standard across vendors that supports a binary protocol and higher degrees of reliability.</span></span>

<span data-ttu-id="22e74-234">Service Bus는 [트랜잭션 지원](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-transactions) 및 중복 [검색 기능을](https://docs.microsoft.com/azure/service-bus-messaging/duplicate-detection)비롯한 다양한 기능 집합을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-234">Service Bus provides a rich set of features, including [transaction support](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-transactions) and a [duplicate detection feature](https://docs.microsoft.com/azure/service-bus-messaging/duplicate-detection).</span></span> <span data-ttu-id="22e74-235">큐는 메시지당 "한 번 배달"을 보장합니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-235">The queue guarantees "at most once delivery" per message.</span></span> <span data-ttu-id="22e74-236">이미 전송된 메시지는 자동으로 삭제됩니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-236">It automatically discards a message that has already been sent.</span></span> <span data-ttu-id="22e74-237">생산자가 의심스러운 경우 동일한 메시지를 다시 보낼 수 있으며 Service Bus는 하나의 복사본만 처리되도록 보장합니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-237">If a producer is in doubt, it can resend the same message, and Service Bus guarantees that only one copy will be processed.</span></span> <span data-ttu-id="22e74-238">중복 검색을 통해 추가 인프라 배관을 구축할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-238">Duplicate detection frees you from  having to build additional infrastructure plumbing.</span></span>

<span data-ttu-id="22e74-239">두 개의 엔터프라이즈 기능이 분할 및 세션입니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-239">Two more enterprise features are partitioning and sessions.</span></span> <span data-ttu-id="22e74-240">기존의 Service Bus 큐는 단일 메시지 브로커에 의해 처리되고 단일 메시지 저장소에 저장됩니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-240">A conventional Service Bus queue is handled by a single message broker and stored in a single message store.</span></span> <span data-ttu-id="22e74-241">그러나 [서비스 버스 분할은](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-partitioning) 여러 메시지 브로커 및 메시지 저장소에 큐를 분산시입니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-241">But, [Service Bus Partitioning](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-partitioning) spreads the queue across multiple message brokers and message stores.</span></span> <span data-ttu-id="22e74-242">전체 처리량은 더 이상 단일 메시지 브로커 또는 메시징 저장소의 성능에 의해 제한되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-242">The overall throughput is no longer limited by the performance of a single message broker or messaging store.</span></span> <span data-ttu-id="22e74-243">메시징 저장소의 일시적인 중단으로 인해 분할된 큐를 사용할 수 없게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-243">A temporary outage of a messaging store doesn't render a partitioned queue unavailable.</span></span>

<span data-ttu-id="22e74-244">[서비스 버스 세션은](https://codingcanvas.com/azure-service-bus-sessions/) 그룹 관련 메시지에 대한 방법을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-244">[Service Bus Sessions](https://codingcanvas.com/azure-service-bus-sessions/) provide a way to group-related messages.</span></span> <span data-ttu-id="22e74-245">메시지를 함께 처리하고 작업이 끝날 때 완료되어야 하는 워크플로 시나리오를 상상해 보십시오.</span><span class="sxs-lookup"><span data-stu-id="22e74-245">Imagine a workflow scenario where messages must be processed together and the operation completed at the end.</span></span> <span data-ttu-id="22e74-246">이점을 활용하려면 큐에 대해 세션을 명시적으로 활성화해야 하며 각 관련 메시지에는 동일한 세션 ID가 포함되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-246">To take advantage, sessions must be explicitly enabled for the queue and each related messaged must contain the same session ID.</span></span>

<span data-ttu-id="22e74-247">그러나 몇 가지 중요한 주의 사항이 있습니다: 서비스 버스 큐 크기는 80GB로 제한되어 있으며 이는 저장소 큐에서 사용할 수 있는 것보다 훨씬 작습니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-247">However, there are some important caveats: Service Bus queues size is limited to 80 GB, which is much smaller than what's available from store queues.</span></span> <span data-ttu-id="22e74-248">또한 서비스 버스 큐에는 기본 비용과 작업당 요금이 부과됩니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-248">Additionally, Service Bus queues incur a base cost and charge per operation.</span></span>

<span data-ttu-id="22e74-249">그림 4-14는 서비스 버스 큐의 고급 아키텍처를 간략하게 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-249">Figure 4-14 outlines the high-level architecture of a Service Bus queue.</span></span>

![Service Bus 큐](./media/service-bus-queue.png)

<span data-ttu-id="22e74-251">**그림 4-14**.</span><span class="sxs-lookup"><span data-stu-id="22e74-251">**Figure 4-14**.</span></span> <span data-ttu-id="22e74-252">Service Bus 큐</span><span class="sxs-lookup"><span data-stu-id="22e74-252">Service Bus queue</span></span>

<span data-ttu-id="22e74-253">이전 그림에서는 점 간 관계를 기록합니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-253">In the previous figure, note the point-to-point relationship.</span></span> <span data-ttu-id="22e74-254">동일한 공급자의 두 인스턴스가 메시지를 단일 Service Bus 큐에 큐에 넣습니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-254">Two instances of the same provider are enqueuing messages into a single Service Bus queue.</span></span> <span data-ttu-id="22e74-255">각 메시지는 오른쪽에 있는 세 개의 소비자 인스턴스 중 하나에서만 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-255">Each message is consumed by only one of three consumer instances on the right.</span></span> <span data-ttu-id="22e74-256">다음으로, 서로 다른 소비자가 모두 동일한 메시지에 관심이 있을 수 있는 메시징을 구현하는 방법에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-256">Next, we discuss how to implement messaging where different consumers may all be interested the same message.</span></span>

## <a name="events"></a><span data-ttu-id="22e74-257">이벤트</span><span class="sxs-lookup"><span data-stu-id="22e74-257">Events</span></span>

<span data-ttu-id="22e74-258">메시지 큐잉은 생산자가 비동기적으로 소비자에게 메시지를 보낼 수 있는 통신을 구현하는 효과적인 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-258">Message queuing is an effective way to implement communication where a producer can asynchronously send a consumer a message.</span></span> <span data-ttu-id="22e74-259">그러나 *많은 다른 소비자가* 동일한 메시지에 관심이 있을 때 어떻게 됩니까?</span><span class="sxs-lookup"><span data-stu-id="22e74-259">However, what happens when *many different consumers* are interested in the same message?</span></span> <span data-ttu-id="22e74-260">각 소비자에 대한 전용 메시지 큐는 확장이 잘 되지 않아 관리하기가 어려워집니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-260">A dedicated message queue for each consumer wouldn't scale well and would become difficult to manage.</span></span>

<span data-ttu-id="22e74-261">이 시나리오를 해결 하려면 세 번째 유형의 메시지 상호 작용, *이벤트로*이동 합니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-261">To address this scenario, we move to the third type of message interaction, the *event*.</span></span> <span data-ttu-id="22e74-262">한 마이크로 서비스는 작업이 발생했음을 알 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-262">One microservice announces that an action had occurred.</span></span> <span data-ttu-id="22e74-263">다른 마이크로 서비스(관심이 있는 경우)는 작업 또는 이벤트에 반응합니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-263">Other microservices, if interested, react to the action, or event.</span></span>

<span data-ttu-id="22e74-264">이벤트는 두 단계로 이루어집니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-264">Eventing is a two-step process.</span></span> <span data-ttu-id="22e74-265">지정된 상태 변경의 경우 마이크로 서비스는 메시지를 브로커에 게시하여 다른 관심 있는 마이크로 서비스에서 사용할 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-265">For a given state change, a microservice publishes an event to a message broker, making it available to any other interested microservice.</span></span> <span data-ttu-id="22e74-266">관심 있는 마이크로 서비스는 메시지 브로커에서 이벤트를 구독하여 알림을 받게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-266">The interested microservice is notified by subscribing to the event in the message broker.</span></span> <span data-ttu-id="22e74-267">[게시/구독](https://docs.microsoft.com/azure/architecture/patterns/publisher-subscriber) 패턴을 사용하여 [이벤트 기반 통신을](https://docs.microsoft.com/dotnet/standard/microservices-architecture/multi-container-microservice-net-applications/integration-event-based-microservice-communications)구현합니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-267">You use the [Publish/Subscribe](https://docs.microsoft.com/azure/architecture/patterns/publisher-subscriber) pattern to implement [event-based communication](https://docs.microsoft.com/dotnet/standard/microservices-architecture/multi-container-microservice-net-applications/integration-event-based-microservice-communications).</span></span>

<span data-ttu-id="22e74-268">그림 4-15는 두 개의 다른 마이크로 서비스가 구독하는 이벤트를 게시하는 장바구니 마이크로 서비스를 보여 주며, 이에 따라 이벤트를 구독합니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-268">Figure 4-15 shows a shopping basket microservice publishing an event with two other microservices subscribing to it.</span></span>

![이벤트 기반 메시징](./media/event-driven-messaging.png)

<span data-ttu-id="22e74-270">**그림 4-15**.</span><span class="sxs-lookup"><span data-stu-id="22e74-270">**Figure 4-15**.</span></span> <span data-ttu-id="22e74-271">이벤트 기반 메시징</span><span class="sxs-lookup"><span data-stu-id="22e74-271">Event-Driven messaging</span></span>

<span data-ttu-id="22e74-272">통신 채널 중간에 있는 *이벤트 버스* 구성 요소를 기록합니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-272">Note the *event bus* component that sits in the middle of the communication channel.</span></span> <span data-ttu-id="22e74-273">메시지 브로커를 캡슐화하고 기본 응용 프로그램에서 분리하는 사용자 지정 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-273">It's a custom class that encapsulates the message broker and decouples it from the underlying application.</span></span> <span data-ttu-id="22e74-274">주문 및 재고 마이크로 서비스는 서로에 대한 지식없이 이벤트를 독립적으로 운영하거나 장바구니 마이크로 서비스를 운영합니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-274">The ordering and inventory microservices independently operate the event with no knowledge of each other, nor the shopping basket microservice.</span></span> <span data-ttu-id="22e74-275">등록된 이벤트가 이벤트 버스에 게시되면 그 에 따라 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-275">When the registered event is published to the event bus, they act upon it.</span></span>

<span data-ttu-id="22e74-276">이벤트와 함께, 우리는 *주제에*대기 기술에서 이동 .</span><span class="sxs-lookup"><span data-stu-id="22e74-276">With eventing, we move from queuing technology to *topics*.</span></span> <span data-ttu-id="22e74-277">[토픽은](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions) 큐와 유사하지만 일대다 메시징 패턴을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-277">A [topic](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions) is similar to a queue, but supports a one-to-many messaging pattern.</span></span> <span data-ttu-id="22e74-278">하나의 마이크로 서비스가 메시지를 게시합니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-278">One microservice publishes a message.</span></span> <span data-ttu-id="22e74-279">여러 구독 마이크로 서비스는 해당 메시지를 수신하고 조치를 취하도록 선택할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-279">Multiple subscribing microservices can choose to receive and act upon that message.</span></span> <span data-ttu-id="22e74-280">그림 4-16은 토픽 아키텍처를 나타낸다.</span><span class="sxs-lookup"><span data-stu-id="22e74-280">Figure 4-16 shows a topic architecture.</span></span>

![주제 아키텍처](./media/topic-architecture.png)

<span data-ttu-id="22e74-282">**그림 4-16**.</span><span class="sxs-lookup"><span data-stu-id="22e74-282">**Figure 4-16**.</span></span> <span data-ttu-id="22e74-283">주제 아키텍처</span><span class="sxs-lookup"><span data-stu-id="22e74-283">Topic architecture</span></span>

<span data-ttu-id="22e74-284">이전 그림에서 게시자는 토픽에 메시지를 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-284">In the previous figure, publishers send messages to the topic.</span></span> <span data-ttu-id="22e74-285">결국 구독자는 구독에서 메시지를 받습니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-285">At the end, subscribers receive messages from subscriptions.</span></span> <span data-ttu-id="22e74-286">중간에 주제는 진한 파란색 상자에 표시된 *일련의 규칙에*따라 구독으로 메시지를 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-286">In the middle, the topic forwards messages to subscriptions based on a set of *rules*, shown in dark blue boxes.</span></span> <span data-ttu-id="22e74-287">규칙은 특정 메시지를 구독으로 전달하는 필터 역할을 합니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-287">Rules act as a filter that forward specific messages to a subscription.</span></span> <span data-ttu-id="22e74-288">여기서는 "CreateOrder" 이벤트가 구독 \#1및 구독 \#3으로 전송되지만 \#구독 2에는 전송되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-288">Here, a "CreateOrder" event would be sent to Subscription \#1 and Subscription \#3, but not to Subscription \#2.</span></span> <span data-ttu-id="22e74-289">"주문 완료" 이벤트가 구독 \#2 및 \#구독 3으로 전송됩니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-289">An "OrderCompleted" event would be sent to Subscription \#2 and Subscription \#3.</span></span>

<span data-ttu-id="22e74-290">Azure 클라우드는 두 가지 주제 서비스를 지원합니다: Azure 서비스 버스 토픽 및 Azure EventGrid.</span><span class="sxs-lookup"><span data-stu-id="22e74-290">The Azure cloud supports two different topic services: Azure Service Bus Topics and Azure EventGrid.</span></span>

### <a name="azure-service-bus-topics"></a><span data-ttu-id="22e74-291">Azure Service Bus Topics</span><span class="sxs-lookup"><span data-stu-id="22e74-291">Azure Service Bus Topics</span></span>

<span data-ttu-id="22e74-292">Azure Service Bus 큐의 동일한 강력한 중개 메시지 모델 위에 있는 [Azure Service Bus 항목입니다.](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions)</span><span class="sxs-lookup"><span data-stu-id="22e74-292">Sitting on top of the same robust brokered message model of Azure Service Bus queues are [Azure Service Bus Topics](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions).</span></span> <span data-ttu-id="22e74-293">토픽은 여러 독립 게시자로부터 메시지를 수신하고 최대 2,000명의 구독자에게 메시지를 보낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-293">A topic can receive messages from multiple independent publishers and send messages to up to 2,000 subscribers.</span></span> <span data-ttu-id="22e74-294">시스템을 중지하거나 토픽을 다시 만들지 않고도 런타임에 구독을 동적으로 추가하거나 제거할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-294">Subscriptions can be dynamically added or removed at runtime without stopping the system or recreating the topic.</span></span>

<span data-ttu-id="22e74-295">Azure Service Bus 큐의 여러 고급 기능은 [중복 검색](https://docs.microsoft.com/azure/service-bus-messaging/duplicate-detection) 및 트랜잭션 [지원을](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-transactions)비롯한 토픽에도 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-295">Many advanced features from Azure Service Bus queues are also available for topics, including [Duplicate Detection](https://docs.microsoft.com/azure/service-bus-messaging/duplicate-detection) and [Transaction support](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-transactions).</span></span> <span data-ttu-id="22e74-296">기본적으로 Service Bus 항목은 단일 메시지 브로커에 의해 처리되고 단일 메시지 저장소에 저장됩니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-296">By default, Service Bus topics are handled by a single message broker and stored in a single message store.</span></span> <span data-ttu-id="22e74-297">그러나 [Service Bus 분할은](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-partitioning) 많은 메시지 브로커 및 메시지 저장소에 배포하여 토픽을 확장합니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-297">But, [Service Bus Partitioning](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-partitioning) scales a topic by spreading it across many message brokers and message stores.</span></span>

<span data-ttu-id="22e74-298">[예약된 메시지 배달은](https://docs.microsoft.com/azure/service-bus-messaging/message-sequencing) 처리에 특정 시간이 있는 메시지에 태그를 붙입니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-298">[Scheduled Message Delivery](https://docs.microsoft.com/azure/service-bus-messaging/message-sequencing) tags a message with a specific time for processing.</span></span> <span data-ttu-id="22e74-299">메시지는 해당 시간 전에 토픽에 나타나지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-299">The message won't appear in the topic before that time.</span></span> <span data-ttu-id="22e74-300">[메시지 지연을](https://docs.microsoft.com/azure/service-bus-messaging/message-deferral) 사용하면 나중에 메시지 검색을 연기할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-300">[Message Deferral](https://docs.microsoft.com/azure/service-bus-messaging/message-deferral) enables you to defer a retrieval of a message to a later time.</span></span> <span data-ttu-id="22e74-301">둘 다 일반적으로 작업이 특정 순서로 처리되는 워크플로 처리 시나리오에서 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-301">Both are commonly used in workflow processing scenarios where operations are processed in a particular order.</span></span> <span data-ttu-id="22e74-302">이전 작업이 완료될 때까지 수신된 메시지 처리를 연기할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-302">You can postpone processing of received messages until prior work has been completed.</span></span>

<span data-ttu-id="22e74-303">Service Bus 주제는 클라우드 네이티브 시스템에서 게시/구독 통신을 활성화하기 위한 강력하고 입증된 기술입니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-303">Service Bus topics are a robust and proven technology for enabling publish/subscribe communication in your cloud-native systems.</span></span>

### <a name="azure-event-grid"></a><span data-ttu-id="22e74-304">Azure Event Grid</span><span class="sxs-lookup"><span data-stu-id="22e74-304">Azure Event Grid</span></span>

<span data-ttu-id="22e74-305">Azure Service Bus는 전체 엔터프라이즈 기능 집합을 갖춘 전투 테스트를 거친 메시징 브로커이지만 [Azure Event Grid는](https://docs.microsoft.com/azure/event-grid/overview) 블록의 새로운 사용자입니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-305">While Azure Service Bus is a battle-tested messaging broker with a full set of enterprise features, [Azure Event Grid](https://docs.microsoft.com/azure/event-grid/overview) is the new kid on the block.</span></span>

<span data-ttu-id="22e74-306">언뜻 보기에 이벤트 그리드는 다른 주제 기반 메시징 시스템처럼 보일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-306">At first glance, Event Grid may look like just another topic-based messaging system.</span></span> <span data-ttu-id="22e74-307">그러나 여러 면에서 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-307">However, it's different in many ways.</span></span> <span data-ttu-id="22e74-308">이벤트 기반 워크로드에 중점을 두고 실시간 이벤트 처리, 심층 적인 Azure 통합 및 개방형 플랫폼(서버리스 인프라)을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-308">Focused on event-driven workloads, it enables real-time event processing, deep Azure integration, and an open-platform - all on serverless infrastructure.</span></span> <span data-ttu-id="22e74-309">최신 클라우드 네이티브 및 서버리스 애플리케이션을 위해 설계되었습니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-309">It's designed for contemporary cloud-native and serverless applications</span></span>

<span data-ttu-id="22e74-310">중앙 집중식 *이벤트 백플레인*또는 파이프로서 Event Grid는 Azure 리소스 내부 및 자체 서비스에서 발생한 이벤트에 반응합니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-310">As a centralized *eventing backplane*, or pipe, Event Grid reacts to events inside Azure resources and from your own services.</span></span>

<span data-ttu-id="22e74-311">이벤트 알림은 이벤트 그리드 토픽에 게시되며, 이 주제는 각 이벤트를 구독으로 라우팅합니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-311">Event notifications are published to an Event Grid Topic, which, in turn, routes each event to a subscription.</span></span> <span data-ttu-id="22e74-312">구독자는 구독에 매핑하고 이벤트를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-312">Subscribers map to subscriptions and consume the events.</span></span> <span data-ttu-id="22e74-313">서비스 버스와 마찬가지로 Event Grid는 구독이 수신하려는 이벤트에 대한 규칙을 설정하는 *필터링된 구독자 모델을* 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-313">Like Service Bus, Event Grid supports a *filtered subscriber model* where a subscription sets rule for the events it wishes to receive.</span></span> <span data-ttu-id="22e74-314">Event Grid는 빠른 처리량을 제공하여 초당 1,000만 개의 이벤트를 보장하여 Azure Service Bus가 생성할 수 있는 것보다 훨씬 더 많은 실시간 배달을 가능하게 합니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-314">Event Grid provides fast throughput with a guarantee of 10 million events per second enabling near real-time delivery - far more than what Azure Service Bus can generate.</span></span>

<span data-ttu-id="22e74-315">Event Grid의 가장 좋은 점은 Azure 인프라의 패브릭에 대한 심층적인 통합입니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-315">A sweet spot for Event Grid is its deep integration into the fabric of Azure infrastructure.</span></span> <span data-ttu-id="22e74-316">Cosmos DB와 같은 Azure 리소스는 사용자 지정 코드 없이 다른 관심 있는 Azure 리소스에 직접 기본 제공 이벤트를 게시할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-316">An Azure resource, such as Cosmos DB, can publish built-in events directly to other interested Azure resources - without the need for custom code.</span></span> <span data-ttu-id="22e74-317">Event Grid는 Azure 구독, 리소스 그룹 또는 서비스에서 이벤트를 게시할 수 있으므로 개발자는 클라우드 리소스의 수명 주기를 세밀하게 제어할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-317">Event Grid can publish events from an Azure Subscription, Resource Group, or Service, giving developers fine-grained control over the lifecycle of cloud resources.</span></span> <span data-ttu-id="22e74-318">그러나 이벤트 그리드는 Azure로 제한되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-318">However, Event Grid isn't limited to Azure.</span></span> <span data-ttu-id="22e74-319">응용 프로그램 또는 타사 서비스에서 게시된 사용자 지정 HTTP 이벤트를 사용하고 이벤트를 외부 구독자에게 라우팅할 수 있는 개방형 플랫폼입니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-319">It's an open platform that can consume custom HTTP events published from applications or third-party services and route events to external subscribers.</span></span>

<span data-ttu-id="22e74-320">Azure 리소스에서 네이티브 이벤트를 게시하고 구독할 때 코딩이 필요하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-320">When publishing and subscribing to native events from Azure resources, no coding is required.</span></span> <span data-ttu-id="22e74-321">간단한 구성을 사용하면 토픽 및 구독에 대한 기본 제공 배관을 활용하는 다른 Azure 리소스의 이벤트를 통합할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-321">With simple configuration, you can integrate events from one Azure resource to another leveraging built-in plumbing for Topics and Subscriptions.</span></span> <span data-ttu-id="22e74-322">그림 4-17은 이벤트 그리드의 해부학을 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-322">Figure 4-17 shows the anatomy of Event Grid.</span></span>

![이벤트 그리드 해부학](./media/event-grid-anatomy.png)

<span data-ttu-id="22e74-324">**그림 4-17**.</span><span class="sxs-lookup"><span data-stu-id="22e74-324">**Figure 4-17**.</span></span> <span data-ttu-id="22e74-325">이벤트 그리드 해부학</span><span class="sxs-lookup"><span data-stu-id="22e74-325">Event Grid anatomy</span></span>

<span data-ttu-id="22e74-326">EventGrid와 서비스 버스의 주요 차이점은 기본 *메시지 교환 패턴입니다.*</span><span class="sxs-lookup"><span data-stu-id="22e74-326">A major difference between EventGrid and Service Bus is the underlying *message exchange pattern*.</span></span>

<span data-ttu-id="22e74-327">Service Bus는 다운스트림 구독자가 새 메시지에 대한 토픽 구독을 적극적으로 폴링을 하는 이전 스타일의 *끌어오기 모델을* 구현합니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-327">Service Bus implements an older style *pull model* in which the downstream subscriber actively polls the topic subscription for new messages.</span></span> <span data-ttu-id="22e74-328">거꾸로, 이 방법은 가입자가 메시지를 처리하는 속도를 완전히 제어 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-328">On the upside, this approach gives the subscriber full control of the pace at which it processes messages.</span></span> <span data-ttu-id="22e74-329">지정된 시간에 처리할 메시지의 시기와 수를 제어합니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-329">It controls when and how many messages to process at any given time.</span></span> <span data-ttu-id="22e74-330">읽지 않은 메시지는 처리될 때까지 구독에 남아 있습니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-330">Unread messages remain in the subscription until processed.</span></span> <span data-ttu-id="22e74-331">중요한 단점은 이벤트가 생성된 시간과 처리를 위해 해당 메시지를 구독자에게 가져오는 폴링 작업 사이의 대기 시간입니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-331">A significant shortcoming is the latency between the time the event is generated and the polling operation that pulls that message to the subscriber for processing.</span></span> <span data-ttu-id="22e74-332">또한 다음 이벤트에 대한 상수 폴링의 오버헤드는 리소스와 비용을 소비합니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-332">Also, the overhead of constant polling for the next event consumes resources and money.</span></span>

<span data-ttu-id="22e74-333">그러나 EventGrid는 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-333">EventGrid, however, is different.</span></span> <span data-ttu-id="22e74-334">이벤트가 수신된 대로 EventHandlers로 전송되는 *푸시 모델을* 구현하여 거의 실시간으로 이벤트 배달을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-334">It implements a *push model* in which events are sent to the EventHandlers as received, giving near real-time event delivery.</span></span> <span data-ttu-id="22e74-335">또한 폴링과 마찬가지로 이벤트가 계속 소비되지 않는 경우에만 서비스가 트리거되기 때문에 비용이 절감됩니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-335">It also reduces cost as the service is triggered only when it's needed to consume an event – not continually as with polling.</span></span> <span data-ttu-id="22e74-336">즉, 이벤트 처리기는 들어오는 부하를 처리하고 과부하되지 않도록 자신을 보호하기 위해 제한 메커니즘을 제공해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-336">That said, an event handler must handle the incoming load and provide throttling mechanisms to protect itself from becoming overwhelmed.</span></span> <span data-ttu-id="22e74-337">Azure Functions 및 논리 앱과 같은 이러한 이벤트를 사용하는 많은 Azure 서비스는 증가된 부하를 처리하는 자동 자동 크기 조정 기능을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-337">Many Azure services that consume these events, such as Azure Functions and Logic Apps provide automatic autoscaling capabilities to handle increased loads.</span></span>  

<span data-ttu-id="22e74-338">이벤트 그리드는 완전히 관리되는 서버리스 클라우드 서비스입니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-338">Event Grid is a fully managed serverless cloud service.</span></span> <span data-ttu-id="22e74-339">트래픽을 기반으로 동적으로 확장되며 사전 구매용량이 아닌 실제 사용량에 대해서만 요금이 청구됩니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-339">It dynamically scales based on your traffic and charges you only for your actual usage, not pre-purchased capacity.</span></span> <span data-ttu-id="22e74-340">매월 처음 100,000개의 작업은 무료입니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-340">The first 100,000 operations per month are free – operations being defined as event ingress (incoming event notifications), subscription delivery attempts, management calls, and filtering by subject.</span></span> <span data-ttu-id="22e74-341">99.99%의 가용성을 갖춘 EventGrid는 24시간 내에 이벤트 배달을 보장하며, 실패한 배달을 위한 기본 제공 재시도 기능을 통해 이벤트를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-341">With 99.99% availability, EventGrid guarantees the delivery of an event within a 24-hour period, with built-in retry functionality for unsuccessful delivery.</span></span> <span data-ttu-id="22e74-342">배달되지 않은 메시지는 해결을 위해 "배달 못한 편지" 큐로 이동할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-342">Undelivered messages can be moved to a "dead-letter" queue for resolution.</span></span>  <span data-ttu-id="22e74-343">Azure Service Bus와 달리 이벤트 그리드는 빠른 성능을 위해 조정되며 정렬된 메시징, 트랜잭션 및 세션과 같은 기능을 지원하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-343">Unlike Azure Service Bus, Event Grid is tuned for fast performance and doesn't support features like ordered messaging, transactions, and sessions.</span></span>

### <a name="streaming-messages-in-the-azure-cloud"></a><span data-ttu-id="22e74-344">Azure 클라우드에서 메시지 스트리밍</span><span class="sxs-lookup"><span data-stu-id="22e74-344">Streaming messages in the Azure cloud</span></span>

<span data-ttu-id="22e74-345">Azure Service Bus 및 이벤트 그리드는 새 문서와 같은 개별 이벤트가 Cosmos DB에 삽입된 경우와 같은 단일 이벤트를 노출하는 응용 프로그램에 대한 훌륭한 지원을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-345">Azure Service Bus and Event Grid provide great support for applications that expose single, discrete events like a new document has been inserted into a Cosmos DB.</span></span> <span data-ttu-id="22e74-346">그러나 클라우드 네이티브 시스템이 *관련 이벤트 스트림을*처리해야 하는 경우 어떻게 해야 합니까?</span><span class="sxs-lookup"><span data-stu-id="22e74-346">But, what if your cloud-native system needs to process a *stream of related events*?</span></span> <span data-ttu-id="22e74-347">[이벤트 스트림은](https://docs.microsoft.com/archive/msdn-magazine/2015/february/microsoft-azure-the-rise-of-event-stream-oriented-systems) 더 복잡합니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-347">[Event streams](https://docs.microsoft.com/archive/msdn-magazine/2015/february/microsoft-azure-the-rise-of-event-stream-oriented-systems) are more complex.</span></span> <span data-ttu-id="22e74-348">일반적으로 시간 순차적이고 상호 관련되며 그룹으로 처리되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-348">They're typically time-ordered, interrelated, and must be processed as a group.</span></span>

<span data-ttu-id="22e74-349">[Azure Event Hub는](https://azure.microsoft.com/services/event-hubs/) 이벤트를 수집, 변환 및 저장하는 데이터 스트리밍 플랫폼 및 이벤트 수집 서비스입니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-349">[Azure Event Hub](https://azure.microsoft.com/services/event-hubs/) is a data streaming platform and event ingestion service that collects, transforms, and stores events.</span></span> <span data-ttu-id="22e74-350">원격 분석 컨텍스트에서 내보낸 연속 이벤트 알림과 같은 스트리밍 데이터를 캡처하도록 미세 조정됩니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-350">It's fine-tuned to capture streaming data, such as continuous event notifications emitted from a telemetry context.</span></span> <span data-ttu-id="22e74-351">이 서비스는 확장성이 뛰어나며 [초당 수백만 개의 이벤트를](https://docs.microsoft.com/azure/event-hubs/event-hubs-about)저장하고 처리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-351">The service is highly scalable and can store and [process millions of events per second](https://docs.microsoft.com/azure/event-hubs/event-hubs-about).</span></span> <span data-ttu-id="22e74-352">그림 4-18에 표시된 이 파이프라인은 이벤트 파이프라인의 정문으로, 이벤트 소비에서 인제스트 스트림을 분리합니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-352">Shown in Figure 4-18, it's often a front door for an event pipeline, decoupling ingest stream from event consumption.</span></span>

![Azure Event Hub](./media/azure-event-hub.png)

<span data-ttu-id="22e74-354">**그림 4-18**.</span><span class="sxs-lookup"><span data-stu-id="22e74-354">**Figure 4-18**.</span></span> <span data-ttu-id="22e74-355">Azure Event Hub</span><span class="sxs-lookup"><span data-stu-id="22e74-355">Azure Event Hub</span></span>

<span data-ttu-id="22e74-356">이벤트 허브는 짧은 대기 시간 및 구성 가능한 시간 보존을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-356">Event Hub supports low latency and configurable time retention.</span></span> <span data-ttu-id="22e74-357">큐 및 토픽과 달리 이벤트 허브는 소비자가 읽은 후 이벤트 데이터를 유지합니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-357">Unlike queues and topics, Event Hubs keep event data after it's been read by a consumer.</span></span> <span data-ttu-id="22e74-358">이 기능을 사용하면 내부 및 외부의 다른 데이터 분석 서비스에서 추가 분석을 위해 데이터를 재생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-358">This feature enables other data analytic services, both internal and external, to replay the data for further analysis.</span></span> <span data-ttu-id="22e74-359">이벤트 허브에 저장된 이벤트는 기본적으로 1일이지만 구성 가능한 보존 기간이 만료된 경우에만 삭제됩니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-359">Events stored in event hub are only deleted upon expiration of the retention period, which is one day by default, but configurable.</span></span>

<span data-ttu-id="22e74-360">이벤트 허브는 HTTPS 및 AMQP를 포함한 일반적인 이벤트 게시 프로토콜을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-360">Event Hub supports common event publishing protocols including HTTPS and AMQP.</span></span> <span data-ttu-id="22e74-361">또한 카프카 1.0을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-361">It also supports Kafka 1.0.</span></span> <span data-ttu-id="22e74-362">[기존 Kafka 응용 프로그램은 큰 Kafka 클러스터를](https://docs.microsoft.com/azure/event-hubs/event-hubs-for-kafka-ecosystem-overview) 관리하는 대안을 제공하는 Kafka 프로토콜을 사용하여 이벤트 허브와 통신할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-362">[Existing Kafka applications can communicate with Event Hub](https://docs.microsoft.com/azure/event-hubs/event-hubs-for-kafka-ecosystem-overview) using the Kafka protocol providing an alternative to managing large Kafka clusters.</span></span> <span data-ttu-id="22e74-363">많은 오픈 소스 클라우드 네이티브 시스템은 Kafka를 수용합니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-363">Many open-source cloud-native systems embrace Kafka.</span></span>

<span data-ttu-id="22e74-364">Event Hubs는 각 소비자가 메시지 스트림의 특정 하위 집합 또는 파티션만 읽는 [분할된 소비자 모델을](https://docs.microsoft.com/azure/event-hubs/event-hubs-features) 통해 메시지 스트리밍을 구현합니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-364">Event Hubs implements message streaming through a [partitioned consumer model](https://docs.microsoft.com/azure/event-hubs/event-hubs-features) in which each consumer only reads a specific subset, or partition, of the message stream.</span></span> <span data-ttu-id="22e74-365">이 패턴에서는 이벤트 처리를 위해 매우 폭넓은 수평 확장이 가능하며, 큐와 항목에서는 사용할 수 없는 기타 스트림 중심 기능이 제공됩니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-365">This pattern enables tremendous horizontal scale for event processing and provides other stream-focused features that are unavailable in queues and topics.</span></span> <span data-ttu-id="22e74-366">파티션은 Event Hub에서 보유하는 순서가 지정된 이벤트 시퀀스입니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-366">A partition is an ordered sequence of events that is held in an event hub.</span></span> <span data-ttu-id="22e74-367">최신 이벤트가 도착하면 이 시퀀스의 끝에 추가됩니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-367">As newer events arrive, they're added to the end of this sequence.</span></span><span data-ttu-id="22e74-368">그림 4-19는 이벤트 허브에서 분할을 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-368"> Figure 4-19 shows partitioning in an Event Hub.</span></span>

![이벤트 허브 분할](./media/event-hub-partitioning.png)

<span data-ttu-id="22e74-370">**그림 4-19**.</span><span class="sxs-lookup"><span data-stu-id="22e74-370">**Figure 4-19**.</span></span> <span data-ttu-id="22e74-371">이벤트 허브 분할</span><span class="sxs-lookup"><span data-stu-id="22e74-371">Event Hub partitioning</span></span>

<span data-ttu-id="22e74-372">각 소비자 그룹은 동일한 리소스에서 읽는 대신 메시지 스트림의 하위 집합 또는 파티션을 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-372">Instead of reading from the same resource, each consumer group reads across a subset, or partition, of the message stream.</span></span>

<span data-ttu-id="22e74-373">많은 수의 이벤트를 스트리밍해야 하는 클라우드 네이티브 응용 프로그램의 경우 Azure Event Hub는 강력하고 경제적인 솔루션이 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="22e74-373">For cloud-native applications that must stream large numbers of events, Azure Event Hub can be a robust and affordable solution.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="22e74-374">[이전](front-end-communication.md)
>[다음](grpc.md)</span><span class="sxs-lookup"><span data-stu-id="22e74-374">[Previous](front-end-communication.md)
[Next](grpc.md)</span></span>

---
title: Protobuf 메시지-WCF 개발자를 위한 gRPC
description: Protobuf 메시지가 IDL에 정의 되 고에서 C#생성 되는 방법에 대해 알아봅니다.
ms.date: 09/09/2019
ms.openlocfilehash: 4d543fe88c21999cd820a0bb98073d58a229913a
ms.sourcegitcommit: f348c84443380a1959294cdf12babcb804cfa987
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 11/12/2019
ms.locfileid: "73967430"
---
# <a name="protobuf-messages"></a><span data-ttu-id="a8e84-103">Protobuf 메시지</span><span class="sxs-lookup"><span data-stu-id="a8e84-103">Protobuf messages</span></span>

<span data-ttu-id="a8e84-104">이 섹션에서는 `.proto` 파일에서 Protobuf 메시지를 선언 하는 방법에 대해 설명 하 고, 필드 번호 및 형식의 기본적인 개념을 C# 설명 하 고, `protoc` 컴파일러에 의해 생성 된 코드를 살펴봅니다.</span><span class="sxs-lookup"><span data-stu-id="a8e84-104">This section covers how to declare Protobuf messages in `.proto` files, explains the fundamental concepts of field numbers and types, and looks at the C# code that is generated by the `protoc` compiler.</span></span> <span data-ttu-id="a8e84-105">이 장의 나머지 부분에서는 Protobuf에서 다양 한 유형의 데이터가 표시 되는 방식에 대해 자세히 살펴봅니다.</span><span class="sxs-lookup"><span data-stu-id="a8e84-105">The rest of the chapter will look in more detail at how different types of data are represented in Protobuf.</span></span>

## <a name="declaring-a-message"></a><span data-ttu-id="a8e84-106">메시지 선언</span><span class="sxs-lookup"><span data-stu-id="a8e84-106">Declaring a message</span></span>

<span data-ttu-id="a8e84-107">WCF에서 주식 시장 거래 응용 프로그램에 대 한 `Stock` 클래스는 다음 예제와 같이 정의 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a8e84-107">In WCF, a `Stock` class for a stock market trading application might be defined like the following example:</span></span>

```csharp
namespace TraderSys
{
    [DataContract]
    public class Stock
    {
        [DataMember]
        public int Id { get; set;}
        [DataMember]
        public string Symbol { get; set;}
        [DataMember]
        public string DisplayName { get; set;}
        [DataMember]
        public int MarketId { get; set; }
    }
}
```

<span data-ttu-id="a8e84-108">Protobuf에서 동일한 클래스를 구현 하려면 `.proto` 파일에 선언 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a8e84-108">To implement the equivalent class in Protobuf, it must be declared in the `.proto` file.</span></span> <span data-ttu-id="a8e84-109">그러면 `protoc` 컴파일러는 빌드 프로세스의 일부로 .NET 클래스를 생성 합니다.</span><span class="sxs-lookup"><span data-stu-id="a8e84-109">The `protoc` compiler will then generate the .NET class as part of the build process.</span></span>

```protobuf
syntax "proto3";

option csharp_namespace = "TraderSys";

message Stock {

    int32 id = 1;
    string symbol = 2;
    string display_name = 3;
    int32 market_id = 4;

}  
```

<span data-ttu-id="a8e84-110">첫 번째 줄은 사용 중인 구문 버전을 선언 합니다.</span><span class="sxs-lookup"><span data-stu-id="a8e84-110">The first line declares the syntax version being used.</span></span> <span data-ttu-id="a8e84-111">이 언어 버전 3은 2016에서 출시 되었으며 gRPC 서비스에 권장 되는 버전입니다.</span><span class="sxs-lookup"><span data-stu-id="a8e84-111">Version 3 of the language was released in 2016 and is the recommended version for gRPC services.</span></span>

<span data-ttu-id="a8e84-112">`option csharp_namespace` 줄에서는 생성 C# 된 형식에 사용할 네임 스페이스를 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="a8e84-112">The `option csharp_namespace` line specifies the namespace to be used for the generated C# types.</span></span> <span data-ttu-id="a8e84-113">이 옵션은 `.proto` 파일이 다른 언어로 컴파일될 때 무시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="a8e84-113">This option will be ignored when the `.proto` file is compiled for other languages.</span></span> <span data-ttu-id="a8e84-114">Protobuf 파일은 여러 언어에 대 한 언어별 옵션을 포함 하는 것이 일반적입니다.</span><span class="sxs-lookup"><span data-stu-id="a8e84-114">It is common for Protobuf files to contain language-specific options for several languages.</span></span>

<span data-ttu-id="a8e84-115">`Stock` 메시지 정의는 각각 유형, 이름 및 필드 번호가 있는 4 개의 필드를 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="a8e84-115">The `Stock` message definition specifies four fields, each with a type, a name, and a field number.</span></span>

## <a name="field-numbers"></a><span data-ttu-id="a8e84-116">필드 번호</span><span class="sxs-lookup"><span data-stu-id="a8e84-116">Field numbers</span></span>

<span data-ttu-id="a8e84-117">필드 번호는 Protobuf의 중요 한 부분입니다.</span><span class="sxs-lookup"><span data-stu-id="a8e84-117">Field numbers are an important part of Protobuf.</span></span> <span data-ttu-id="a8e84-118">이진 인코딩 데이터의 필드를 식별 하는 데 사용 됩니다. 즉, 버전에서 서비스 버전으로 변경할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="a8e84-118">They're used to identify fields in the binary encoded data, which means they can't change from version to version of your service.</span></span> <span data-ttu-id="a8e84-119">이러한 이점은 이전 버전과 앞으로의 호환성이 가능 하다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="a8e84-119">The advantage is that backward and forward compatibility is possible.</span></span> <span data-ttu-id="a8e84-120">클라이언트와 서비스는 누락 값이 처리 되는 경우에는 알 수 없는 필드 번호만 무시 합니다.</span><span class="sxs-lookup"><span data-stu-id="a8e84-120">Clients and services will simply ignore field numbers they don't know about, as long as the possibility of missing values is handled.</span></span>

<span data-ttu-id="a8e84-121">이진 형식에서 필드 번호는 형식 식별자와 결합 됩니다.</span><span class="sxs-lookup"><span data-stu-id="a8e84-121">In the binary format, the field number is combined with a type identifier.</span></span> <span data-ttu-id="a8e84-122">1에서 15 사이의 필드 번호는 해당 형식을 단일 바이트로 인코딩할 수 있습니다. 16에서 2047 사이의 숫자는 2 바이트를 차지 합니다.</span><span class="sxs-lookup"><span data-stu-id="a8e84-122">Field numbers from 1 to 15 can be encoded with their type as a single byte; numbers from 16 to 2047 take 2 bytes.</span></span> <span data-ttu-id="a8e84-123">어떤 이유로 든 메시지에서 필드가 2047 개를 초과 해야 하는 경우 더 높은 수준으로 이동할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a8e84-123">You can go higher if you need more than 2047 fields on a message for any reason.</span></span> <span data-ttu-id="a8e84-124">필드 번호 1에서 15 까지의 단일 바이트 식별자가 더 나은 성능을 제공 하므로 가장 기본적인 자주 사용 되는 필드에 사용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a8e84-124">The single byte identifiers for field numbers 1 to 15 offer better performance, so you should use them for the most basic, frequently used fields.</span></span>

## <a name="types"></a><span data-ttu-id="a8e84-125">형식</span><span class="sxs-lookup"><span data-stu-id="a8e84-125">Types</span></span>

<span data-ttu-id="a8e84-126">형식 선언은 Protobuf의 네이티브 스칼라 데이터 형식을 사용 하며, [다음 섹션](protobuf-data-types.md)에서 자세히 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="a8e84-126">The type declarations are using Protobuf's native scalar data types, which are discussed in more detail in [the next section](protobuf-data-types.md).</span></span> <span data-ttu-id="a8e84-127">이 장의 나머지 부분에서는 Protobuf의 기본 제공 형식에 대해 설명 하 고 일반적인 .NET 형식과의 관계를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="a8e84-127">The rest of this chapter will cover Protobuf's built-in types and show how they relate to common .NET types.</span></span>

> [!NOTE]
> <span data-ttu-id="a8e84-128">Protobuf는 기본적으로 `decimal` 형식을 지원 하지 않으므로 double이 대신 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="a8e84-128">Protobuf doesn't natively support a `decimal` type, so double is used instead.</span></span> <span data-ttu-id="a8e84-129">전체 자릿수가 전체 자릿수가 필요한 응용 프로그램의 경우이 챕터의 다음 부분에 있는 [10 진수에 대 한 섹션](protobuf-data-types.md#decimals) 을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="a8e84-129">For applications that require full decimal precision, refer to the [section on Decimals](protobuf-data-types.md#decimals) in the next part of this chapter.</span></span>

## <a name="the-generated-code"></a><span data-ttu-id="a8e84-130">생성된 코드</span><span class="sxs-lookup"><span data-stu-id="a8e84-130">The generated code</span></span>

<span data-ttu-id="a8e84-131">응용 프로그램을 빌드할 때 Protobuf는 각 메시지에 대 한 클래스를 만들어 네이티브 형식을 형식에 C# 매핑합니다.</span><span class="sxs-lookup"><span data-stu-id="a8e84-131">When you build your application, Protobuf creates classes for each of your messages, mapping its native types to C# types.</span></span> <span data-ttu-id="a8e84-132">생성 된 `Stock` 형식에는 다음 서명이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a8e84-132">The generated `Stock` type would have the following signature:</span></span>

```csharp
public class Stock
{
    public int Id { get; set; }
    public string Symbol { get; set; }
    public string DisplayName { get; set; }
    public int MarketId { get; set; }
}
```

<span data-ttu-id="a8e84-133">각 클래스는 이진 통신 형식으로 serialize 및 deserialize 하는 데 필요한 모든 코드를 포함 하기 때문에 생성 되는 실제 코드는 이보다 훨씬 더 복잡 합니다.</span><span class="sxs-lookup"><span data-stu-id="a8e84-133">The actual code that is generated is far more complicated than this, because each class contains all the code necessary to serialize and deserialize itself to the binary wire format.</span></span>

### <a name="property-names"></a><span data-ttu-id="a8e84-134">속성 이름</span><span class="sxs-lookup"><span data-stu-id="a8e84-134">Property names</span></span>

<span data-ttu-id="a8e84-135">Protobuf 컴파일러는 `.proto` 파일에 `snake_case` 되었지만 속성 이름에 `PascalCase` 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="a8e84-135">Note that the Protobuf compiler applied `PascalCase` to the property names although they were `snake_case` in the `.proto` file.</span></span> <span data-ttu-id="a8e84-136">[Protobuf 스타일 가이드](https://developers.google.com/protocol-buffers/docs/style) 는 다른 플랫폼에 대 한 코드 생성이 해당 규칙에 대해 예상 되는 대/소문자를 생성 하도록 메시지 정의에 `snake_case`를 사용 하는 것을 권장 합니다.</span><span class="sxs-lookup"><span data-stu-id="a8e84-136">The [Protobuf style guide](https://developers.google.com/protocol-buffers/docs/style) recommends using `snake_case` in your message definitions so that the code generation for other platforms produces the expected case for their conventions.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="a8e84-137">[이전](protocol-buffers.md)
>[다음](protobuf-data-types.md)</span><span class="sxs-lookup"><span data-stu-id="a8e84-137">[Previous](protocol-buffers.md)
[Next](protobuf-data-types.md)</span></span>

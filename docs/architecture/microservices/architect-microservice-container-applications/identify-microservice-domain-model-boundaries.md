---
title: 각 마이크로 서비스의 도메인 모델 경계 식별
description: 대규모 애플리케이션을 마이크로 서비스로 파티셔닝하여 사운드 아키텍처를 달성하는 데 필요한 핵심을 탐색합니다.
ms.date: 09/20/2018
ms.openlocfilehash: aa903e13b20be1084fad60e6fb7bbb1c61403deb
ms.sourcegitcommit: f20dd18dbcf2275513281f5d9ad7ece6a62644b4
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 07/30/2019
ms.locfileid: "68673090"
---
# <a name="identify-domain-model-boundaries-for-each-microservice"></a><span data-ttu-id="9adcf-103">각 마이크로 서비스의 도메인 모델 경계 식별</span><span class="sxs-lookup"><span data-stu-id="9adcf-103">Identify domain-model boundaries for each microservice</span></span>

<span data-ttu-id="9adcf-104">가능하면 마이크로 서비스가 작아야 하지만 각 마이크로 서비스에 대한 모델 경계 및 크기를 식별할 때 세분화하여 분리하지 않는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="9adcf-104">The goal when identifying model boundaries and size for each microservice isn't to get to the most granular separation possible, although you should tend toward small microservices if possible.</span></span> <span data-ttu-id="9adcf-105">대신, 도메인 지식에 의해 설명된 가장 적합한 분리로 이동하는 것이 목적입니다.</span><span class="sxs-lookup"><span data-stu-id="9adcf-105">Instead, your goal should be to get to the most meaningful separation guided by your domain knowledge.</span></span> <span data-ttu-id="9adcf-106">중요한 점은 크기가 아닌 비즈니스 용량입니다.</span><span class="sxs-lookup"><span data-stu-id="9adcf-106">The emphasis isn't on the size, but instead on business capabilities.</span></span> <span data-ttu-id="9adcf-107">또한 많은 수의 종속성을 기반으로 애플리케이션의 특정 부분에 필요한 응집력이 있는 경우 단일 마이크로 서비스가 필요하다는 것을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="9adcf-107">In addition, if there's clear cohesion needed for a certain area of the application based on a high number of dependencies, that indicates the need for a single microservice, too.</span></span> <span data-ttu-id="9adcf-108">응집력은 마이크로 서비스를 분리하거나 그룹화하는 방법을 식별하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="9adcf-108">Cohesion is a way to identify how to break apart or group together microservices.</span></span> <span data-ttu-id="9adcf-109">궁극적으로 도메인에 대한 더 많은 지식을 확보하는 동안 마이크로 서비스의 크기를 반복적으로 활용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9adcf-109">Ultimately, while you gain more knowledge about the domain, you should adapt the size of your microservice, iteratively.</span></span> <span data-ttu-id="9adcf-110">적절한 크기를 찾는 것은 원샷 프로세스가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="9adcf-110">Finding the right size isn't a one-shot process.</span></span>

<span data-ttu-id="9adcf-111">마이크로 서비스의 선구자이며 [마이크로 서비스 빌드](https://samnewman.io/books/building_microservices/)라는 책의 저자인 [Sam Newman](https://samnewman.io/)은 앞서 소개한 대로 BC(경계가 지정된 컨텍스트) 패턴(도메인 기반 디자인의 일부)에 따라 마이크로 서비스를 디자인해야 한다고 강조합니다.</span><span class="sxs-lookup"><span data-stu-id="9adcf-111">[Sam Newman](https://samnewman.io/), a recognized promoter of microservices and author of the book [Building Microservices](https://samnewman.io/books/building_microservices/), highlights that you should design your microservices based on the Bounded Context (BC) pattern (part of domain-driven design), as introduced earlier.</span></span> <span data-ttu-id="9adcf-112">경우에 따라 BC는 몇 가지 물리적 서비스로 구성되지만 그 반대의 경우는 불가능합니다.</span><span class="sxs-lookup"><span data-stu-id="9adcf-112">Sometimes, a BC could be composed of several physical services, but not vice versa.</span></span>

<span data-ttu-id="9adcf-113">특정 도메인 엔터티를 사용하는 도메인 모델은 특정 BC 또는 마이크로 서비스 내에서 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="9adcf-113">A domain model with specific domain entities applies within a concrete BC or microservice.</span></span> <span data-ttu-id="9adcf-114">BC는 도메인 모델의 적용 가능성을 제한하고 개발자 팀 멤버에게 화합되어야 하는 기능 및 독립적으로 개발할 수 있는 기능에 대한 명확하고 공유된 이해를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="9adcf-114">A BC delimits the applicability of a domain model and gives developer team members a clear and shared understanding of what must be cohesive and what can be developed independently.</span></span> <span data-ttu-id="9adcf-115">마이크로 서비스에 대한 동일한 목표입니다.</span><span class="sxs-lookup"><span data-stu-id="9adcf-115">These are the same goals for microservices.</span></span>

<span data-ttu-id="9adcf-116">디자인을 선택했다고 알려주는 또 다른 도구는 [Conway's law](https://en.wikipedia.org/wiki/Conway%27s_law)입니다. 여기서는 애플리케이션이 생성한 조직의 사회적 경계를 반영합니다.</span><span class="sxs-lookup"><span data-stu-id="9adcf-116">Another tool that informs your design choice is [Conway's law](https://en.wikipedia.org/wiki/Conway%27s_law), which states that an application will reflect the social boundaries of the organization that produced it.</span></span> <span data-ttu-id="9adcf-117">그러나 때로는 반대가 맞습니다. 회사의 조직은 소프트웨어로 구성됩니다.</span><span class="sxs-lookup"><span data-stu-id="9adcf-117">But sometimes the opposite is true -the company's organization is formed by the software.</span></span> <span data-ttu-id="9adcf-118">회사를 구성하려는 방식으로 Conway's law를 되돌리고 경계를 빌드해야 할 수도 있습니다. 그러면 비즈니스 프로세스 컨설팅으로 기울어집니다.</span><span class="sxs-lookup"><span data-stu-id="9adcf-118">You might need to reverse Conway's law and build the boundaries the way you want the company to be organized, leaning toward business process consulting.</span></span>

<span data-ttu-id="9adcf-119">바인딩된 컨텍스트를 식별하려면 [컨텍스트 매핑 패턴](https://www.infoq.com/articles/ddd-contextmapping)이라는 DDD 패턴을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9adcf-119">To identify bounded contexts, you can use a DDD pattern called the [Context Mapping pattern](https://www.infoq.com/articles/ddd-contextmapping).</span></span> <span data-ttu-id="9adcf-120">컨텍스트 매핑을 사용하여 애플리케이션 및 해당 경계에서 다양한 컨텍스트를 식별합니다.</span><span class="sxs-lookup"><span data-stu-id="9adcf-120">With Context Mapping, you identify the various contexts in the application and their boundaries.</span></span> <span data-ttu-id="9adcf-121">예를 들어 일반적으로 작은 하위 시스템에 다른 컨텍스트 및 경계가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9adcf-121">It's common to have a different context and boundary for each small subsystem, for instance.</span></span> <span data-ttu-id="9adcf-122">컨텍스트 맵은 도메인 간의 해당 경계를 정의하고 명시적으로 지정하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="9adcf-122">The Context Map is a way to define and make explicit those boundaries between domains.</span></span> <span data-ttu-id="9adcf-123">BC는 자율적이며 도메인 엔터티와 같은 단일 도메인의 세부 정보를 포함하며 다른 BC와의 통합 계약을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="9adcf-123">A BC is autonomous and includes the details of a single domain -details like the domain entities- and defines integration contracts with other BCs.</span></span> <span data-ttu-id="9adcf-124">마이크로 서비스의 정의와 비슷하게 자율적이며 특정 도메인 기능을 구현하고 인터페이스를 제공해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9adcf-124">This is similar to the definition of a microservice: it's autonomous, it implements certain domain capability, and it must provide interfaces.</span></span> <span data-ttu-id="9adcf-125">따라서 컨텍스트 매핑 및 바인딩된 컨텍스트 패턴은 마이크로 서비스의 도메인 모델 경계를 식별하기 위한 좋은 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="9adcf-125">This is why Context Mapping and the Bounded Context pattern are good approaches for identifying the domain model boundaries of your microservices.</span></span>

<span data-ttu-id="9adcf-126">대규모 애플리케이션을 디자인할 때 도메인 모델을 조각화할 수 있는 방법이 표시됩니다. 예를 들어 카탈로그 도메인의 도메인 전문가는 배송 도메인 전문가와 달리 카탈로그 및 인벤토리 도메인에서 엔터티 이름을 다르게 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="9adcf-126">When designing a large application, you'll see how its domain model can be fragmented - a domain expert from the catalog domain will name entities differently in the catalog and inventory domains than a shipping domain expert, for instance.</span></span> <span data-ttu-id="9adcf-127">또는 고객에 대한 불완전한 데이터가 필요한 주문 도메인 전문가와 달리 고객에 대한 모든 세부 정보를 저장하려는 CRM 전문가를 다룰 때 사용자 도메인 엔터티는 특성의 크기와 수가 다를 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9adcf-127">Or the user domain entity might be different in size and number of attributes when dealing with a CRM expert who wants to store every detail about the customer than for an ordering domain expert who just needs partial data about the customer.</span></span> <span data-ttu-id="9adcf-128">대규모 애플리케이션과 관련된 모든 도메인에서 모든 도메인 용어를 명확히 구분하는 것은 어렵습니다.</span><span class="sxs-lookup"><span data-stu-id="9adcf-128">It's very hard to disambiguate all domain terms across all the domains related to a large application.</span></span> <span data-ttu-id="9adcf-129">하지만 가장 중요한 점은 용어를 통합하려고 해서는 안 된다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="9adcf-129">But the most important thing is that you shouldn't try to unify the terms.</span></span> <span data-ttu-id="9adcf-130">대신 각 도메인에서 제공하는 차이점과 다양성을 수용하세요.</span><span class="sxs-lookup"><span data-stu-id="9adcf-130">Instead, accept the differences and richness provided by each domain.</span></span> <span data-ttu-id="9adcf-131">전체 애플리케이션에 통합 데이터베이스를 보유하는 경우 통합 어휘를 사용하는 것은 이상하고 여러 도메인 전문가도 옳다고 여기지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9adcf-131">If you try to have a unified database for the whole application, attempts at a unified vocabulary will be awkward and won't sound right to any of the multiple domain experts.</span></span> <span data-ttu-id="9adcf-132">따라서 BC(마이크로 서비스로 구현됨)는 다른 도메인을 사용하여 특정 도메인 용어를 사용할 수 있는 위치 및 시스템을 나누고 추가 BC를 만들어야 하는 위치를 명시할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9adcf-132">Therefore, BCs (implemented as microservices) will help you to clarify where you can use certain domain terms and where you'll need to split the system and create additional BCs with different domains.</span></span>

<span data-ttu-id="9adcf-133">도메인 모델 간에 강력한 관계가 거의 없고 일반적인 애플리케이션 작업을 수행할 때 일반적으로 여러 도메인 모델에서 정보를 병합할 필요가 없는 경우, 각 BC와 도메인 모델의 올바른 경계와 크기를 알 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9adcf-133">You'll know that you got the right boundaries and sizes of each BC and domain model if you have few strong relationships between domain models, and you do not usually need to merge information from multiple domain models when performing typical application operations.</span></span>

<span data-ttu-id="9adcf-134">아마도 각 마이크로 서비스의 도메인 모델 크기에 대한 질문에 최상의 답변은 다음과 같습니다. 가능한 한 격리된 자율적인 BC가 있어야만 다른 컨텍스트로 전환하지 않고도 작업할 수 있습니다(다른 마이크로 서비스의 모델).</span><span class="sxs-lookup"><span data-stu-id="9adcf-134">Perhaps the best answer to the question of how large a domain model for each microservice should be is the following: it should have an autonomous BC, as isolated as possible, that enables you to work without having to constantly switch to other contexts (other microservice's models).</span></span> <span data-ttu-id="9adcf-135">그림 4-10에서 애플리케이션에서 식별된 도메인 각각에 대한 특정 요구 사항에 따라 고유한 모델이 있는 마이크로 서비스(여러 BC)의 수 및 해당 엔터티를 정의할 수 있는 방법을 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9adcf-135">In Figure 4-10, you can see how multiple microservices (multiple BCs) each has their own model and how their entities can be defined, depending on the specific requirements for each of the identified domains in your application.</span></span>

![바인딩된 컨텍스트에 따라 동일한 엔터티가 "사용자", "구매자", "지급인" 및 "고객"으로 표시하는 여러 모델 경계(바인딩된 컨텍스트)의 엔터티](./media/image10.png)

<span data-ttu-id="9adcf-137">**그림 4-10**</span><span class="sxs-lookup"><span data-stu-id="9adcf-137">**Figure 4-10**.</span></span> <span data-ttu-id="9adcf-138">엔터티 및 마이크로 서비스 모델 경계 식별</span><span class="sxs-lookup"><span data-stu-id="9adcf-138">Identifying entities and microservice model boundaries</span></span>

<span data-ttu-id="9adcf-139">그림 4-10은 온라인 회의 관리 시스템과 관련된 샘플 시나리오를 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="9adcf-139">Figure 4-10 illustrates a sample scenario related to an online conference management system.</span></span> <span data-ttu-id="9adcf-140">도메인 전문가가 정의한 도메인에 따라 마이크로 서비스로 구현할 수 있는 몇 가지 BC를 식별했습니다.</span><span class="sxs-lookup"><span data-stu-id="9adcf-140">You've identified several BCs that could be implemented as microservices, based on domains that domain experts defined for you.</span></span> <span data-ttu-id="9adcf-141">볼 수 있듯이 결제 마이크로 서비스의 결제와 같은 단일 마이크로 서비스 모델에만 있는 엔터티가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9adcf-141">As you can see, there are entities that are present just in a single microservice model, like Payments in the Payment microservice.</span></span> <span data-ttu-id="9adcf-142">구현하기 쉽습니다.</span><span class="sxs-lookup"><span data-stu-id="9adcf-142">Those will be easy to implement.</span></span>

<span data-ttu-id="9adcf-143">그러나 다른 셰이프가 있지만 여러 마이크로 서비스의 여러 도메인 모델에서 동일한 ID를 공유하는 엔터티가 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9adcf-143">However, you might also have entities that have a different shape but share the same identity across the multiple domain models from the multiple microservices.</span></span> <span data-ttu-id="9adcf-144">예를 들어 사용자 엔터티는 회의 관리 마이크로 서비스에서 식별됩니다.</span><span class="sxs-lookup"><span data-stu-id="9adcf-144">For example, the User entity is identified in the Conferences Management microservice.</span></span> <span data-ttu-id="9adcf-145">동일한 ID를 사용하는 동일한 사용자는 주문 마이크로 서비스의 구매자이거나 결재 마이크로 서비스의 결재자이고 고객 서비스 마이크로 서비스의 고객이라고도 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9adcf-145">That same user, with the same identity, is the one named Buyers in the Ordering microservice, or the one named Payer in the Payment microservice, and even the one named Customer in the Customer Service microservice.</span></span> <span data-ttu-id="9adcf-146">이로 인해 각 도메인 전문가가 사용하는 [유비쿼터스 언어](https://martinfowler.com/bliki/UbiquitousLanguage.html)에 따라 사용자에게는 다양한 특성을 가진 다른 관점이 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9adcf-146">This is because, depending on the [ubiquitous language](https://martinfowler.com/bliki/UbiquitousLanguage.html) that each domain expert is using, a user might have a different perspective even with different attributes.</span></span> <span data-ttu-id="9adcf-147">회의 관리라는 마이크로 서비스 모델의 사용자 엔터티에는 대부분의 개인 데이터 특성이 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9adcf-147">The user entity in the microservice model named Conferences Management might have most of its personal data attributes.</span></span> <span data-ttu-id="9adcf-148">그러나 결재 마이크로 서비스의 결재자 셰이프나 고객 서비스 마이크로 서비스의 고객 셰이프인 동일한 사용자에게는 동일한 특성 목록이 필요하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9adcf-148">However, that same user in the shape of Payer in the microservice Payment or in the shape of Customer in the microservice Customer Service might not need the same list of attributes.</span></span>

<span data-ttu-id="9adcf-149">그림 4-11에 유사한 방법이 나와있습니다.</span><span class="sxs-lookup"><span data-stu-id="9adcf-149">A similar approach is illustrated in Figure 4-11.</span></span>

![바인딩된 컨텍스트 간에 기존 데이터 모델을 분해할 때 각 바운딩된 컨텍스트에서 서로 다른 특성을 가진 동일한 ID(구매자도 사용자임)를 공유하는 여러 엔터티를 가질 수 있습니다.](./media/image11.png)

<span data-ttu-id="9adcf-151">**그림 4-11**</span><span class="sxs-lookup"><span data-stu-id="9adcf-151">**Figure 4-11**.</span></span> <span data-ttu-id="9adcf-152">일반적인 데이터 모델을 여러 도메인 모델로 분해</span><span class="sxs-lookup"><span data-stu-id="9adcf-152">Decomposing traditional data models into multiple domain models</span></span>

<span data-ttu-id="9adcf-153">사용자가 실제로 구매자일 때 사용자에 대한 대체 특성 및 세부 정보를 사용하여 사용자 엔터티로 회의 관리 마이크로 서비스 모델에 존재하고 가격 책정 마이크로 서비스의 구매자 형식으로 존재하는 방법을 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9adcf-153">You can see how the user is present in the Conferences Management microservice model as the User entity and is also present in the form of the Buyer entity in the Pricing microservice, with alternate attributes or details about the user when it's actually a buyer.</span></span> <span data-ttu-id="9adcf-154">각 마이크로 서비스 또는 BC에는 해결할 문제 또는 컨텍스트에 따라 사용자 엔터티와 관련된 모든 데이터가 아닌 일부가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="9adcf-154">Each microservice or BC might not need all the data related to a User entity, just part of it, depending on the problem to solve or the context.</span></span> <span data-ttu-id="9adcf-155">예를 들어 가격 책정 마이크로 서비스 모델에서 사용자의 주소나 이름이 필요하지 않고 ID(ID) 및 상태만이 필요합니다. 이는 구매자 당 좌석의 가격을 책정할 때 할인에 영향을 줍니다.</span><span class="sxs-lookup"><span data-stu-id="9adcf-155">For instance, in the Pricing microservice model, you do not need the address or the name of the user, just the ID (as identity) and Status, which will have an impact on discounts when pricing the seats per buyer.</span></span>

<span data-ttu-id="9adcf-156">사용자 엔터티는 각 도메인 모델에서 동일한 이름과 다른 특성을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="9adcf-156">The Seat entity has the same name but different attributes in each domain model.</span></span> <span data-ttu-id="9adcf-157">그러나 사용자와 구매자에서 발생하는 대로 사용자는 동일한 ID를 기반으로 ID를 공유합니다.</span><span class="sxs-lookup"><span data-stu-id="9adcf-157">However, Seat shares identity based on the same ID, as happens with User and Buyer.</span></span>

<span data-ttu-id="9adcf-158">기본적으로 해당 사용자의 ID를 모두 공유하는 여러 서비스(도메인)에 있는 사용자의 공유 개념이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9adcf-158">Basically, there's a shared concept of a user that exists in multiple services (domains), which all share the identity of that user.</span></span> <span data-ttu-id="9adcf-159">하지만 각각의 도메인 모델에는 사용자 엔터티에 대한 추가 세부 정보가 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9adcf-159">But in each domain model there might be additional or different details about the user entity.</span></span> <span data-ttu-id="9adcf-160">따라서 도메인(마이크로 서비스) 간에 사용자 엔터티를 매핑하는 방법이 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9adcf-160">Therefore, there needs to be a way to map a user entity from one domain (microservice) to another.</span></span>

<span data-ttu-id="9adcf-161">도메인 간에 동일한 특성 수를 가진 동일한 사용자 엔터티를 공유하지 않는 몇 가지 이점이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9adcf-161">There are several benefits to not sharing the same user entity with the same number of attributes across domains.</span></span> <span data-ttu-id="9adcf-162">이점 중 하나는 마이크로 서비스 모델에는 필요하지 않은 데이터가 없도록 중복을 줄이는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="9adcf-162">One benefit is to reduce duplication, so that microservice models do not have any data that they do not need.</span></span> <span data-ttu-id="9adcf-163">또 다른 이점은 해당 형식의 데이터에 대한 업데이트 및 쿼리가 해당 마이크로 서비스에 의해서만 발생하도록 특정 형식의 엔터티 당 데이터를 소유하는 마스터 마이크로 서비스가 있는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="9adcf-163">Another benefit is having a master microservice that owns a certain type of data per entity so that updates and queries for that type of data are driven only by that microservice.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="9adcf-164">[이전](distributed-data-management.md)
>[다음](direct-client-to-microservice-communication-versus-the-api-gateway-pattern.md)</span><span class="sxs-lookup"><span data-stu-id="9adcf-164">[Previous](distributed-data-management.md)
[Next](direct-client-to-microservice-communication-versus-the-api-gateway-pattern.md)</span></span>

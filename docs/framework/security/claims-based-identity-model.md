---
title: 클레임 기반 ID 모델
ms.date: 03/30/2017
ms.assetid: 4a96a9af-d980-43be-bf91-341a23401431
author: BrucePerlerMS
ms.openlocfilehash: b7cafa727251c28b79615a37adce4effe6885392
ms.sourcegitcommit: 9b1ac36b6c80176fd4e20eb5bfcbd9d56c3264cf
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 06/28/2019
ms.locfileid: "67422403"
---
# <a name="claims-based-identity-model"></a><span data-ttu-id="bd43a-102">클레임 기반 ID 모델</span><span class="sxs-lookup"><span data-stu-id="bd43a-102">Claims-Based Identity Model</span></span>
<span data-ttu-id="bd43a-103">클레임 인식 응용 프로그램을 작성할 때 사용자 ID가 클레임 집합으로 응용 프로그램에 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="bd43a-103">When you build claims-aware applications, the user identity is represented in your application as a set of claims.</span></span> <span data-ttu-id="bd43a-104">클레임이 하나는 사용자의 이름, 다른 전자 메일 주소를 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bd43a-104">One claim could be the user’s name, another might be an email address.</span></span> <span data-ttu-id="bd43a-105">외부 ID 시스템은 수신하는 ID 데이터가 신뢰할 수 있는 출처에서 제공되는 암호화 보증과 함께 각각의 요청을 작성한 사용자에 대해 파악하기 위해 필요한 모든 사항을 응용 프로그램에 제공하도록 구성됩니다.</span><span class="sxs-lookup"><span data-stu-id="bd43a-105">The idea is that an external identity system is configured to give your application everything it needs to know about the user with each request she makes, along with cryptographic assurance that the identity data you receive comes from a trusted source.</span></span>  
  
 <span data-ttu-id="bd43a-106">이 모델에서는 Single Sign-On을 더욱 쉽게 달성할 수 있으며, 응용 프로그램이 더 이상 다음과 같은 작업을 수행할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="bd43a-106">Under this model, single sign-on is much easier to achieve, and your application is no longer responsible for the following:</span></span>  
  
- <span data-ttu-id="bd43a-107">사용자 인증</span><span class="sxs-lookup"><span data-stu-id="bd43a-107">Authenticating users.</span></span>  
  
- <span data-ttu-id="bd43a-108">사용자 계정 및 암호 저장</span><span class="sxs-lookup"><span data-stu-id="bd43a-108">Storing user accounts and passwords.</span></span>  
  
- <span data-ttu-id="bd43a-109">사용자 ID 세부 정보를 조회하기 위해 엔터프라이즈 디렉터리 호출</span><span class="sxs-lookup"><span data-stu-id="bd43a-109">Calling to enterprise directories to look up user identity details.</span></span>  
  
- <span data-ttu-id="bd43a-110">다른 플랫폼 또는 회사의 ID 시스템과 통합</span><span class="sxs-lookup"><span data-stu-id="bd43a-110">Integrating with identity systems from other platforms or companies.</span></span>  
  
 <span data-ttu-id="bd43a-111">이 모델에서는 응용 프로그램이 사용자를 인증한 시스템에서 제공하는 클레임을 기반으로 ID 관련 결정을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="bd43a-111">Under this model, your application makes identity-related decisions based on claims supplied by the system that authenticated your user.</span></span> <span data-ttu-id="bd43a-112">이는 사용자의 이름을 사용한 단순 응용 프로그램 개인 설정부터 사용자에게 응용 프로그램에서 더욱 중요한 기능 및 리소스에 대한 액세스 권한 부여까지 모든 작업이 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bd43a-112">This could be anything from simple application personalization with the user’s first name, to authorizing the user to access higher valued features and resources in your application.</span></span>  
  
 <span data-ttu-id="bd43a-113">이 항목에서는 다음 내용에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="bd43a-113">This topic provides the following information:</span></span>  
  
- [<span data-ttu-id="bd43a-114">클레임 기반 ID 소개</span><span class="sxs-lookup"><span data-stu-id="bd43a-114">Introduction to Claims-Based Identity</span></span>](../../../docs/framework/security/claims-based-identity-model.md#BKMK_1)  
  
- [<span data-ttu-id="bd43a-115">클레임 기반 ID 모델에 대한 기본 시나리오</span><span class="sxs-lookup"><span data-stu-id="bd43a-115">Basic Scenario for a Claims-Based Identity Model</span></span>](../../../docs/framework/security/claims-based-identity-model.md#BKMK_2)  
  
<a name="BKMK_1"></a>   
## <a name="introduction-to-claims-based-identity"></a><span data-ttu-id="bd43a-116">클레임 기반 ID 소개</span><span class="sxs-lookup"><span data-stu-id="bd43a-116">Introduction to Claims-Based Identity</span></span>  
 <span data-ttu-id="bd43a-117">다음 용어와 개념은 ID에 대한 새로운 아키텍처를 이해하는 데 도움을 줍니다.</span><span class="sxs-lookup"><span data-stu-id="bd43a-117">The following terminology and concepts can help you understand this new architecture for identity.</span></span>  
  
### <a name="identity"></a><span data-ttu-id="bd43a-118">클레임</span><span class="sxs-lookup"><span data-stu-id="bd43a-118">Identity</span></span>  
 <span data-ttu-id="bd43a-119">WIF(Windows Identity Foundation)의 프로그래밍 모델을 설명하기 위해 보안을 유지할 시스템에서 사용자 또는 기타 일부 엔터티의 속성 집합을 나타내는 데 용어 “ID”를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="bd43a-119">For the purposes of describing the programming model in Windows Identity Foundation (WIF), we will use the term "identity" to represent a set of attributes that describe a user or some other entity in a system that you want to secure.</span></span>  
  
### <a name="claim"></a><span data-ttu-id="bd43a-120">클레임</span><span class="sxs-lookup"><span data-stu-id="bd43a-120">Claim</span></span>  
 <span data-ttu-id="bd43a-121">클레임 이름, 전자 메일 주소, 나이, Sales 역할의 멤버 자격 id 정보 부분으로 생각할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bd43a-121">Think of a claim as a piece of identity information such as name, email address, age, membership in the Sales role.</span></span> <span data-ttu-id="bd43a-122">응용 프로그램에서 수신하는 클레임 수가 많을수록 사용자에 대해 더 많이 파악할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bd43a-122">The more claims your application receives, the more you’ll know about your user.</span></span> <span data-ttu-id="bd43a-123">왜 이를 일반적으로 기업 디렉터리를 설명하는 데 사용되는 “특성”이 아닌 “클레임”이라고 하는지 궁금하실 것입니다.</span><span class="sxs-lookup"><span data-stu-id="bd43a-123">You may be wondering why these are called "claims," rather than "attributes," as is commonly used in describing enterprise directories.</span></span> <span data-ttu-id="bd43a-124">이유는 전달 방법과 관련이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bd43a-124">The reason has to do with the delivery method.</span></span> <span data-ttu-id="bd43a-125">이 모델에서는 응용 프로그램이 디렉터리에서 사용자 속성을 조회하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="bd43a-125">In this model, your application doesn’t look up user attributes in a directory.</span></span> <span data-ttu-id="bd43a-126">대신 사용자가 응용 프로그램에 클레임을 전달하고 응용 프로그램이 이를 검사합니다.</span><span class="sxs-lookup"><span data-stu-id="bd43a-126">Instead, the user delivers claims to your application, and your application examines them.</span></span> <span data-ttu-id="bd43a-127">각 클레임은 발급자에 의해 생성되므로 발급자를 신뢰하는 만큼만 클레임을 신뢰하게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bd43a-127">Each claim is made by an issuer, and you trust the claim only as much as you trust the issuer.</span></span> <span data-ttu-id="bd43a-128">예를 들어, 사용자가 직접 생성한 클레임보다 회사의 도메인 컨트롤러에서 생성된 클레임을 더 신뢰합니다.</span><span class="sxs-lookup"><span data-stu-id="bd43a-128">For example, you trust a claim made by your company’s domain controller more than you trust a claim made by the user herself.</span></span> <span data-ttu-id="bd43a-129">WIF는 클레임을 발급한 사람을 확인할 수 있는 <xref:System.Security.Claims.Claim> 속성이 있는 <xref:System.Security.Claims.Claim.Issuer%2A> 유형으로 클레임을 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="bd43a-129">WIF represents claims with a <xref:System.Security.Claims.Claim> type, which has an <xref:System.Security.Claims.Claim.Issuer%2A> property that allows you to find out who issued the claim.</span></span>  
  
### <a name="security-token"></a><span data-ttu-id="bd43a-130">보안 토큰</span><span class="sxs-lookup"><span data-stu-id="bd43a-130">Security Token</span></span>  
 <span data-ttu-id="bd43a-131">사용자는 요청과 함께 응용 프로그램에 클레임 집합을 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="bd43a-131">The user delivers a set of claims to your application along with a request.</span></span> <span data-ttu-id="bd43a-132">웹 서비스에서는 이러한 클레임이 SOAP 봉투의 보안 헤더로 전달됩니다.</span><span class="sxs-lookup"><span data-stu-id="bd43a-132">In a Web service, these claims are carried in the security header of the SOAP envelope.</span></span> <span data-ttu-id="bd43a-133">브라우저 기반 웹 응용 프로그램에서는 클레임이 사용자의 브라우저로부터 HTTP POST를 통해 도착하고 세션에 필요한 경우 나중에 쿠키에 캐시될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bd43a-133">In a browser-based Web application, the claims arrive through an HTTP POST from the user’s browser, and may later be cached in a cookie if a session is desired.</span></span> <span data-ttu-id="bd43a-134">클레임의 도착 방식에 관계없이 보안 토큰이 제공되는 위치에서 직렬화해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="bd43a-134">Regardless of how these claims arrive, they must be serialized, which is where security tokens come in.</span></span> <span data-ttu-id="bd43a-135">보안 토큰은 발급 기관에서 디지털로 서명한 클레임의 직렬화된 집합입니다.</span><span class="sxs-lookup"><span data-stu-id="bd43a-135">A security token is a serialized set of claims that is digitally signed by the issuing authority.</span></span> <span data-ttu-id="bd43a-136">서명이 중요합니다. 서명은 사용자가 여러 클레임을 구성하고 보냈음을 보증합니다.</span><span class="sxs-lookup"><span data-stu-id="bd43a-136">The signature is important: it gives you assurance that the user didn’t just make up a bunch of claims and send them to you.</span></span> <span data-ttu-id="bd43a-137">암호화가 필요 없거나 이를 원하지 않는 낮은 수중의 보안 상태에서 서명되지 않은 토큰을 사용할 수 있지만 이러한 시나리오는 이 항목에 설명되어 있지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="bd43a-137">In low security situations where cryptography isn’t necessary or desired, you can use unsigned tokens, but that scenario is not described in this topic.</span></span>  
  
 <span data-ttu-id="bd43a-138">WIF의 주요 기능 중 하나는 보안 토큰을 읽고 만드는 기능입니다.</span><span class="sxs-lookup"><span data-stu-id="bd43a-138">One of the core features in WIF is the ability to create and read security tokens.</span></span> <span data-ttu-id="bd43a-139">WIF와 .NET Framework가 모든 암호화 작업을 처리하고 읽을 수 있는 클레임 집합과 함께 응용 프로그램을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="bd43a-139">WIF and the .NET Framework handle all of the cryptographic work, and present your application with a set of claims that you can read.</span></span>  
  
### <a name="issuing-authority"></a><span data-ttu-id="bd43a-140">발급 기관</span><span class="sxs-lookup"><span data-stu-id="bd43a-140">Issuing Authority</span></span>  
 <span data-ttu-id="bd43a-141">Kerberos 티켓을 발급하는 도메인 컨트롤러에서 X.509 인증서를 발급하는 인증 기관까지 여러 가지 유형의 발급 기관이 있지만, 이 항목에 설명된 특정 유형의 기관에서는 클레임을 포함하는 보안 토큰을 발급합니다.</span><span class="sxs-lookup"><span data-stu-id="bd43a-141">There are lots of different types of issuing authorities, from domain controllers that issue Kerberos tickets, to certification authorities that issue X.509 certificates, but the specific type of authority discussed in this topic issues security tokens that contain claims.</span></span> <span data-ttu-id="bd43a-142">이 발급 기관은 보안 토큰을 발급하는 방법을 알고 있는 웹 응용 프로그램 또는 웹 서비스입니다.</span><span class="sxs-lookup"><span data-stu-id="bd43a-142">This issuing authority is a Web application or Web service that knows how to issue security tokens.</span></span> <span data-ttu-id="bd43a-143">요청을 만드는 대상 신뢰 당사자와 사용자에게 적절한 클레임을 발급할 수 있도록 충분한 지식이 있어야 하며 클레임을 조회하고 사용자를 인증하기 위해 사용자 저장소와 상호 작용해야 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bd43a-143">It must have enough knowledge to be able to issue the proper claims given the target relying party and the user making the request, and might be responsible for interacting with user stores to look up claims and authenticate the users themselves.</span></span>  
  
 <span data-ttu-id="bd43a-144">어떤 발급 기관을 선택하든 ID 솔루션에서 중심적인 역할을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="bd43a-144">Whatever issuing authority you choose, it plays a central role in your identity solution.</span></span> <span data-ttu-id="bd43a-145">클레임을 신뢰하여 응용 프로그램에서 인증을 고려하는 경우 해당 기관에 책임을 전달하고 대신 사용자를 인증하도록 요청합니다.</span><span class="sxs-lookup"><span data-stu-id="bd43a-145">When you factor authentication out of your application by relying on claims, you’re passing responsibility to that authority and asking it to authenticate users on your behalf.</span></span>  
  
### <a name="security-token-service-sts"></a><span data-ttu-id="bd43a-146">STS(보안 토큰 서비스)</span><span class="sxs-lookup"><span data-stu-id="bd43a-146">Security Token Service (STS)</span></span>  
 <span data-ttu-id="bd43a-147">STS(보안 토큰 서비스)는 WS-Trust 및 WS-Federation 프로토콜에 따라 보안 토큰을 작성, 서명 및 발급하는 서비스 구성 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="bd43a-147">A security token service (STS) is the service component that builds, signs, and issues security tokens according to the WS-Trust and WS-Federation protocols.</span></span> <span data-ttu-id="bd43a-148">이 프로토콜의 구현을 위해 수행해야 할 많은 작업이 있지만 WIF가 이러한 작업을 모두 수행하므로, 프로토콜에 대한 전문 지식이 없어도 누구나 쉽게 STS를 가져오고 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bd43a-148">There’s a lot of work that goes into implementing these protocols, but WIF does all of this work for you, making it feasible for someone who isn’t an expert in the protocols to get an STS up and running with very little effort.</span></span> <span data-ttu-id="bd43a-149">[AD FS(Active Directory® Federation Services) 2.0](https://go.microsoft.com/fwlink/?LinkID=247516)과 같이 미리 빌드된 STS 또는 [Microsoft Azure ACS(Access Control Service)](https://go.microsoft.com/fwlink/?LinkID=247517)와 같은 클라우드 STS를 사용하거나 사용자 지정 토큰을 발급하거나 사용자 지정 인증 또는 권한 부여를 제공하려는 경우 WIF를 사용하여 고유한 사용자 지정 STS를 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bd43a-149">You can use a pre-built STS such as [Active Directory® Federation Services (AD FS) 2.0](https://go.microsoft.com/fwlink/?LinkID=247516), a cloud STS such as a [Windows Azure Access Control Service (ACS)](https://go.microsoft.com/fwlink/?LinkID=247517), or, if you want to issue custom tokens or provide custom authentication or authorization, you can build your own custom STS using WIF.</span></span> <span data-ttu-id="bd43a-150">WIF를 사용하면 쉽게 자체 STS를 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bd43a-150">WIF makes it easy to build your own STS.</span></span>  
  
### <a name="relying-party-application"></a><span data-ttu-id="bd43a-151">타사 응용 프로그램 신뢰</span><span class="sxs-lookup"><span data-stu-id="bd43a-151">Relying Party Application</span></span>  
 <span data-ttu-id="bd43a-152">클레임을 신뢰하는 응용 프로그램을 빌드할 때 RP(신뢰 당사자) 응용 프로그램을 빌드합니다.</span><span class="sxs-lookup"><span data-stu-id="bd43a-152">When you build an application that relies on claims, you are building a relying party (RP) application.</span></span> <span data-ttu-id="bd43a-153">RP의 동의어로는, “클레임 인식 애플리케이션” 및 “클레임 기반 애플리케이션”이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bd43a-153">Synonyms for an RP include "claims-aware application" and "claims-based application".</span></span> <span data-ttu-id="bd43a-154">웹 응용 프로그램과 웹 서비스가 모두 RP일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bd43a-154">Web applications and Web services can both be RPs.</span></span> <span data-ttu-id="bd43a-155">RP 응용 프로그램은 STS에서 발급한 토큰을 사용하고 토큰에서 클레임을 추출하여 ID 관련 작업에 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="bd43a-155">A RP application consumes the tokens issued by a STS and extracts the claims from tokens to use them for identity related tasks.</span></span> <span data-ttu-id="bd43a-156">WIF는 RP 응용 프로그램을 작성하는 데 도움을 주는 기능을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="bd43a-156">WIF offers functionalities to help you build RP applications.</span></span>  
  
### <a name="standards"></a><span data-ttu-id="bd43a-157">표준</span><span class="sxs-lookup"><span data-stu-id="bd43a-157">Standards</span></span>  
 <span data-ttu-id="bd43a-158">모두 상호 운용 가능한 상태로 만들기 위해 이전 시나리오에서 여러 WS-\* 표준이 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="bd43a-158">In order to make all of this interoperable, several WS-\* standards are used in the previous scenario.</span></span> <span data-ttu-id="bd43a-159">WS-MetadataExchange를 사용하여 정책이 검색되고 WS-Policy 사양에 따라 정책이 구조화됩니다.</span><span class="sxs-lookup"><span data-stu-id="bd43a-159">Policy is retrieved using WS-MetadataExchange, and the policy itself is structured according to the WS-Policy specification.</span></span> <span data-ttu-id="bd43a-160">STS가 보안 토큰을 요청하고 수신하는 방법을 설명하는 WS-Trust 사양을 구현하는 엔드포인트를 노출합니다.</span><span class="sxs-lookup"><span data-stu-id="bd43a-160">The STS exposes endpoints that implement the WS-Trust specification, which describes how to request and receive security tokens.</span></span> <span data-ttu-id="bd43a-161">오늘날 대부분의 sts가 사용 하 여 SAML Security Assertion Markup Language () 서식이 지정 된 토큰을 발급 합니다.</span><span class="sxs-lookup"><span data-stu-id="bd43a-161">Most STSs today issue tokens formatted with Security Assertion Markup Language (SAML).</span></span> <span data-ttu-id="bd43a-162">SAML은 상호 운용 가능한 방식으로 클레임을 나타내는 데 사용할 수 있는 업계에서 통용되는 XML 용어입니다.</span><span class="sxs-lookup"><span data-stu-id="bd43a-162">SAML is an industry-recognized XML vocabulary that can be used to represent claims in an interoperable way.</span></span> <span data-ttu-id="bd43a-163">또는 다중 플랫폼 상황에서 이를 통해 완전히 다른 플랫폼에서 STS와 통신하고 플랫폼에 관계없이 모든 응용 프로그램에서 Single Sign-On을 달성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bd43a-163">Or, in a multi-platform situation, this allows you to communicate with an STS on an entirely different platform and achieve single sign-on across all of your applications, regardless of platform.</span></span>  
  
### <a name="browser-based-applications"></a><span data-ttu-id="bd43a-164">브라우저 기반 응용 프로그램</span><span class="sxs-lookup"><span data-stu-id="bd43a-164">Browser-Based Applications</span></span>  
 <span data-ttu-id="bd43a-165">스마트 클라이언트만 클레임 기반 ID 모델을 사용할 수 있는 것이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="bd43a-165">Smart clients aren’t the only ones who can use the claims-based identity model.</span></span> <span data-ttu-id="bd43a-166">브라우저 기반 응용 프로그램(수동 클라이언트라고도 함)에서도 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bd43a-166">Browser-based applications (also referred to as passive clients) can use it as well.</span></span> <span data-ttu-id="bd43a-167">다음 시나리오는 이러한 작동 방식을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="bd43a-167">The following scenario describes how this works.</span></span>  
  
 <span data-ttu-id="bd43a-168">먼저, 사용자가 클레임 인식 웹 응용 프로그램(신뢰 당사자 응용 프로그램)에서 브라우저를 가리킵니다.</span><span class="sxs-lookup"><span data-stu-id="bd43a-168">First, the user points a browser at a claims-aware Web application (the relying party application).</span></span> <span data-ttu-id="bd43a-169">사용자를 인증할 수 있도록 웹 응용 프로그램이 브라우저를 STS로 리디렉션합니다.</span><span class="sxs-lookup"><span data-stu-id="bd43a-169">The Web application redirects the browser to the STS so the user can be authenticated.</span></span> <span data-ttu-id="bd43a-170">STS는 들어오는 요청을 읽고, 표준 HTTP 메커니즘을 사용하여 사용자를 인증한 후 SAML 토큰을 만드는 단순 웹 응용 프로그램에서 호스팅되며, 브라우저에서 SAML 토큰을 RP에 다시 보내는 HTTP POST가 시작되도록 하는 JavaScript 코드의 일부로 회신합니다.</span><span class="sxs-lookup"><span data-stu-id="bd43a-170">The STS is hosted in a simple web application that reads the incoming request, authenticates the user using standard HTTP mechanisms, and then creates a SAML token and replies with a piece of JavaScript code that causes the browser to initiate an HTTP POST that sends the SAML token back to the RP.</span></span> <span data-ttu-id="bd43a-171">이 POST의 본문에는 RP가 요청한 클레임이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="bd43a-171">The body of this POST contains the claims that the RP requested.</span></span> <span data-ttu-id="bd43a-172">이때 일반적으로 요청할 때마다 사용자를 리디렉션할 필요가 없도록 RP가 클레임을 쿠키에 패키지합니다.</span><span class="sxs-lookup"><span data-stu-id="bd43a-172">At this point, it is common for the RP to package the claims into a cookie so that the user doesn’t have to be redirected for each request.</span></span>  
  
<a name="BKMK_2"></a>   
## <a name="basic-scenario-for-a-claims-based-identity-model"></a><span data-ttu-id="bd43a-173">클레임 기반 ID 모델에 대한 기본 시나리오</span><span class="sxs-lookup"><span data-stu-id="bd43a-173">Basic Scenario for a Claims-Based Identity Model</span></span>  
 <span data-ttu-id="bd43a-174">다음은 클레임 기반 시스템의 예입니다.</span><span class="sxs-lookup"><span data-stu-id="bd43a-174">The following is an example of a claims-based system.</span></span>  
  
 <span data-ttu-id="bd43a-175">![신뢰 파트너 인증 흐름](../../../docs/framework/security/media/conc-relying-partner-processc.png "conc_relying_partner_processc")</span><span class="sxs-lookup"><span data-stu-id="bd43a-175">![Relying Partner Authentication Flow](../../../docs/framework/security/media/conc-relying-partner-processc.png "conc_relying_partner_processc")</span></span>  
  
 <span data-ttu-id="bd43a-176">이 다이어그램은 사이트를 사용할 웹 브라우저의 인증 및 클라이언트에 WIF를 사용하도록 구성된 웹 사이트(신뢰 당사자 응용 프로그램, RP)를 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="bd43a-176">This diagram shows a Web site (the relying party application, RP) that has been configured to use WIF for authentication and a client, a web browser, that wants to use that site.</span></span>  
  
1. <span data-ttu-id="bd43a-177">페이지를 요청 하는 인증 되지 않은 사용자가 브라우저 identity 공급자 (IdP) 페이지로 리디렉션됩니다.</span><span class="sxs-lookup"><span data-stu-id="bd43a-177">When an unauthenticated user requests a page, their browser is redirected to the identity provider (IdP) pages.</span></span>  
  
2. <span data-ttu-id="bd43a-178">IdP에 필요한 사용자 사용자 이름/암호 또는 Kerberos 인증과 같은 자격 증명을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="bd43a-178">The IdP requires the user to present their credentials, such as username/password or Kerberos authentication.</span></span>  
  
3. <span data-ttu-id="bd43a-179">IdP 문제는 토큰이 브라우저에 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bd43a-179">The IdP issues a token back to that is returned to the browser.</span></span>  
  
4. <span data-ttu-id="bd43a-180">이제 브라우저가 원래 요청된 페이지로 다시 리디렉션되며, 이 페이지에서 WIF가 토큰이 페이지 전반의 요구 사항을 만족하는지 판별합니다.</span><span class="sxs-lookup"><span data-stu-id="bd43a-180">The browser is now redirected back to the originally requested page where WIF determines if the token satisfies the requirements to access the page.</span></span> <span data-ttu-id="bd43a-181">이 경우 한 번만 인증하면 되도록 세션을 설정하기 위해 쿠키가 발급되고, 응용 프로그램에 제어가 전달됩니다.</span><span class="sxs-lookup"><span data-stu-id="bd43a-181">If so a cookie is issued to establish a session so the authentication only needs to occur once, and control is passed to the application.</span></span>

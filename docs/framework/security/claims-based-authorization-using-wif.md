---
title: WIF를 사용하여 클레임 기반 권한 부여
ms.date: 03/30/2017
ms.assetid: e24000a3-8fd8-4c0e-bdf0-39882cc0f6d8
author: BrucePerlerMS
ms.openlocfilehash: c13ea5c9f2f62c9c01139741d06de35dd2ff4be1
ms.sourcegitcommit: 213292dfbb0c37d83f62709959ff55c50af5560d
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 09/25/2018
ms.locfileid: "47088115"
---
# <a name="claims-based-authorization-using-wif"></a><span data-ttu-id="8840b-102">WIF를 사용하여 클레임 기반 권한 부여</span><span class="sxs-lookup"><span data-stu-id="8840b-102">Claims Based Authorization Using WIF</span></span>
<span data-ttu-id="8840b-103">신뢰 당사자 응용 프로그램에서 권한 부여에 따라 인증된 ID가 액세스할 수 있도록 허용되는 리소스 및 이러한 리소스에서 수행할 수 있도록 허용되는 작업이 결정됩니다.</span><span class="sxs-lookup"><span data-stu-id="8840b-103">In a relying party application, authorization determines what resources an authenticated identity is allowed to access and what operations it is allowed to perform on those resources.</span></span> <span data-ttu-id="8840b-104">권한 부여가 부적절하거나 취약한 상태인 경우 정보가 노출되거나 데이터가 변조될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8840b-104">Improper or weak authorization leads to information disclosure and data tampering.</span></span> <span data-ttu-id="8840b-105">이 항목에서는 ACS(Windows Azure Access Control Service)와 같은 STS(보안 토큰 서비스) 및 WIF(Windows Identity Foundation)를 사용하여 클레임 인식 ASP.NET 웹 응용 프로그램과 서비스에 대한 권한 부여를 구현하기 위해 사용할 수 있는 방법에 대해 간략하게 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="8840b-105">This topic outlines the available approaches to implementing authorization for claims-aware ASP.NET web applications and services using Windows Identity Foundation (WIF) and a Security Token Service (STS), for example, the Windows Azure Access Control Service (ACS).</span></span>  
  
## <a name="overview"></a><span data-ttu-id="8840b-106">개요</span><span class="sxs-lookup"><span data-stu-id="8840b-106">Overview</span></span>  
 <span data-ttu-id="8840b-107">.NET Framework는 첫 번째 버전부터 권한 부여를 구현하는 유연한 메커니즘을 제공해 왔습니다.</span><span class="sxs-lookup"><span data-stu-id="8840b-107">Since its first version, the .NET Framework has offered a flexible mechanism for implementing authorization.</span></span> <span data-ttu-id="8840b-108">이 메커니즘은 **IPrincipal** 및 **IIdentity**와 같은 두 가지 간단한 인터페이스를 기반으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="8840b-108">This mechanism is based on two simple interfaces—**IPrincipal** and **IIdentity**.</span></span> <span data-ttu-id="8840b-109">**IIdentity**의 구체적인 구현은 인증된 사용자를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="8840b-109">Concrete implementations of **IIdentity** represent an authenticated user.</span></span> <span data-ttu-id="8840b-110">예를 들어 **WindowsIdentity** 구현은 Active Directory에 의해 인증된 사용자를 나타내고, **GenericIdentity**는 사용자 지정 인증 프로세스를 통해 ID가 확인된 사용자를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="8840b-110">For example, the **WindowsIdentity** implementation represents a user who is authenticated by Active Directory, and **GenericIdentity** represents a user whose identity is verified via a custom authentication process.</span></span> <span data-ttu-id="8840b-111">**IPrincipal**의 구체적인 구현은 역할 저장소에 따라 역할을 사용하여 권한을 확인하는 데 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="8840b-111">Concrete implementations of **IPrincipal** help to check permissions using roles depending on the role store.</span></span> <span data-ttu-id="8840b-112">예를 들어 **WindowsPrincipal**은 Active Directory 그룹의 멤버에 대한 **WindowsIdentity**를 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="8840b-112">For example, **WindowsPrincipal** checks **WindowsIdentity** for membership in Active Directory groups.</span></span> <span data-ttu-id="8840b-113">**IPrincipal** 인터페이스에서 **IsInRole** 메서드를 호출하면 이러한 확인이 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="8840b-113">This check is performed by calling the **IsInRole** method on the **IPrincipal** interface.</span></span> <span data-ttu-id="8840b-114">역할을 기반으로 액세스 권한을 확인하는 것을 RBAC(역할 기반 Access Control)라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="8840b-114">Checking access based on roles is called Role-Based Access Control (RBAC).</span></span> <span data-ttu-id="8840b-115">자세한 내용은 [역할 기반 액세스 제어](../../../docs/framework/security/claims-based-authorization-using-wif.md#BKMK_1)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="8840b-115">For more information, see [Role-Based Access Control](../../../docs/framework/security/claims-based-authorization-using-wif.md#BKMK_1).</span></span>  <span data-ttu-id="8840b-116">클레임을 사용하여 친숙한 역할 기반 권한 부여 메커니즘을 지원하기 위해 역할에 대한 정보를 전달할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8840b-116">Claims can be used to carry information about roles to support familiar, role-based authorization mechanisms.</span></span>  
  
 <span data-ttu-id="8840b-117">또한 클레임을 사용하여 역할보다 훨씬 복잡한 권한 부여 결정을 수행할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8840b-117">Claims can also be used to enable more complicated authorization decisions beyond roles.</span></span> <span data-ttu-id="8840b-118">클레임은 연령, 우편 번호, 신발 크기 등 사용자에 대한 거의 모든 정보를 기반으로 할 수 있습니다. 임의의 클레임을 기반으로 하는 액세스 제어 메커니즘을 클레임 기반 권한 부여라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="8840b-118">Claims can be based on virtually any information about the user - age, zip code, shoe size, etc. An access control mechanism that is based on arbitrary claims is called claims-based authorization.</span></span> <span data-ttu-id="8840b-119">자세한 내용은 [클레임 기반 권한 부여](../../../docs/framework/security/claims-based-authorization-using-wif.md#BKMK_2)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="8840b-119">For more information, see [Claims-based Authorization](../../../docs/framework/security/claims-based-authorization-using-wif.md#BKMK_2).</span></span>  
  
<a name="BKMK_1"></a>   
## <a name="role-based-access-control"></a><span data-ttu-id="8840b-120">역할 기반 Access Control</span><span class="sxs-lookup"><span data-stu-id="8840b-120">Role-Based Access Control</span></span>  
 <span data-ttu-id="8840b-121">RBAC는 사용자 역할에 따라 응용 프로그램에서 사용자 권한을 관리하고 적용하는 권한 부여 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="8840b-121">RBAC is an authorization approach in which user permissions are managed and enforced by an application based on user roles.</span></span> <span data-ttu-id="8840b-122">사용자에게 작업을 수행하는 데 필요한 역할이 있는 경우 액세스 권한이 부여되고, 그렇지 않으면 액세스가 거부됩니다.</span><span class="sxs-lookup"><span data-stu-id="8840b-122">If a user has a role that is required to perform an action, the access is granted; otherwise, access is denied.</span></span>  
  
### <a name="iprincipalisinrole-method"></a><span data-ttu-id="8840b-123">IPrincipal.IsInRole 메서드</span><span class="sxs-lookup"><span data-stu-id="8840b-123">IPrincipal.IsInRole Method</span></span>  
 <span data-ttu-id="8840b-124">클레임 인식 응용 프로그램에서 RBAC 방식을 구현하려면 비-클레임 인식 응용 프로그램에서와 마찬가지로 **IPrinicpal** 인터페이스에서 **IsInRole()** 메서드를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="8840b-124">To implement the RBAC approach in claims-aware applications, use the **IsInRole()** method in the **IPrinicpal** interface, just as you would in non-claims-aware applications.</span></span> <span data-ttu-id="8840b-125">다음과 같은 여러 가지 방법으로 **IsInRole()** 메서드를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8840b-125">There are several ways of using the **IsInRole()** method:</span></span>  
  
-   <span data-ttu-id="8840b-126">**IPrincipal.IsInRole(“Administrator”)** 의 명시적 호출</span><span class="sxs-lookup"><span data-stu-id="8840b-126">Explicitly calling on **IPrincipal.IsInRole("Administrator")**.</span></span> <span data-ttu-id="8840b-127">이 방법에서는 결과가 부울입니다.</span><span class="sxs-lookup"><span data-stu-id="8840b-127">In this approach, the outcome is a Boolean.</span></span> <span data-ttu-id="8840b-128">이는 조건문에서 사용되며,</span><span class="sxs-lookup"><span data-stu-id="8840b-128">Use it in your conditional statements.</span></span> <span data-ttu-id="8840b-129">코드에서 임의의 위치에 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8840b-129">It can be used arbitrarily any place in your code.</span></span>  
  
-   <span data-ttu-id="8840b-130">보안 요청 **PrincipalPermission.Demand()** 사용</span><span class="sxs-lookup"><span data-stu-id="8840b-130">Using the security demand **PrincipalPermission.Demand()**.</span></span> <span data-ttu-id="8840b-131">이 방법에서는 요청이 충족되지 않는 경우 결과가 예외입니다.</span><span class="sxs-lookup"><span data-stu-id="8840b-131">In this approach, the outcome is an exception in case the demand is not satisfied.</span></span> <span data-ttu-id="8840b-132">이는 예외 처리 전략에 맞아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8840b-132">This should fit your exception handling strategy.</span></span> <span data-ttu-id="8840b-133">부울 반환과 비교했을 때 예외가 발생하면 성능적인 측면에서 비용이 훨씬 많이 듭니다.</span><span class="sxs-lookup"><span data-stu-id="8840b-133">Throwing exceptions is much more expensive from a performance perspective compared to returning Boolean.</span></span> <span data-ttu-id="8840b-134">이는 코드에서 임의의 위치에 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8840b-134">This can be used any place in your code.</span></span>  
  
-   <span data-ttu-id="8840b-135">선언적 특성 **[PrincipalPermission(SecurityAction.Demand, Role = “Administrator”)]** 사용</span><span class="sxs-lookup"><span data-stu-id="8840b-135">Using the declarative attributes **[PrincipalPermission(SecurityAction.Demand, Role = "Administrator")]**.</span></span> <span data-ttu-id="8840b-136">이 방법은 메서드를 데코레이팅하는 데 사용되므로 선언적이라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="8840b-136">This approach is called declarative, because it is used to decorate methods.</span></span> <span data-ttu-id="8840b-137">메서드 구현 내의 코드 블록에는 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="8840b-137">It cannot be used in code blocks inside the method’s implementations.</span></span> <span data-ttu-id="8840b-138">요청이 충족되지 않는 경우 결과가 예외입니다.</span><span class="sxs-lookup"><span data-stu-id="8840b-138">The outcome is an exception in case the demand is not satisfied.</span></span> <span data-ttu-id="8840b-139">예외 처리 전략에 맞는지 확인해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8840b-139">You should make sure that it fits your exception-handling strategy.</span></span>  
  
-   <span data-ttu-id="8840b-140">**web.config**의 **\<authorization>** 섹션을 사용하여 URL 권한 부여 사용 이 방법은 URL 수준에서 권한 부여를 관리하는 경우 적합합니다.</span><span class="sxs-lookup"><span data-stu-id="8840b-140">Using URL authorization, using the **\<authorization>** section in **web.config**. This approach is suitable when you are managing authorization on a URL level.</span></span> <span data-ttu-id="8840b-141">이는 앞서 언급한 것 중에서 가장 정교하지 않은 수준입니다.</span><span class="sxs-lookup"><span data-stu-id="8840b-141">This is the most coarse level among those previously mentioned.</span></span> <span data-ttu-id="8840b-142">이 방법의 장점은 구성 파일에서 내용이 변경되므로 변경 내용을 활용하기 위해 코드를 컴파일하지 않는다는 점입니다.</span><span class="sxs-lookup"><span data-stu-id="8840b-142">The advantage of this approach is that changes are made in the configuration file, which means that the code should not be compiled to take advantage of the change.</span></span>  
  
### <a name="expressing-roles-as-claims"></a><span data-ttu-id="8840b-143">역할을 클레임으로 표시</span><span class="sxs-lookup"><span data-stu-id="8840b-143">Expressing Roles as Claims</span></span>  
 <span data-ttu-id="8840b-144">**IsInRole()** 메서드가 호출되면 현재 사용자에게 해당 역할이 있는지 확인하는 검사가 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="8840b-144">When the **IsInRole()** method is called, there is a check made to see if the current user has that role.</span></span> <span data-ttu-id="8840b-145">클레임 인식 응용 프로그램에서는 역할이 토큰에서 사용할 수 있는 역할 클레임 형식으로 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="8840b-145">In claims-aware applications, the role is expressed by a role claim type that should be available in the token.</span></span> <span data-ttu-id="8840b-146">역할 클레임 형식은 다음 URI를 사용하여 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="8840b-146">The role claim type is expressed using the following URI:</span></span>  
  
 http://schemas.microsoft.com/ws/2008/06/identity/claims/role  
  
 <span data-ttu-id="8840b-147">여러 가지 방법으로 역할 클레임 형식을 사용하여 토큰을 보강할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8840b-147">There are several ways to enrich a token with a role claim type:</span></span>  
  
-   <span data-ttu-id="8840b-148">**토큰 발급 중**.</span><span class="sxs-lookup"><span data-stu-id="8840b-148">**During token issuance**.</span></span> <span data-ttu-id="8840b-149">사용자가 인증되면 Microsoft Azure ACS(Access Control Service)와 같은 페더레이션 공급자 또는 ID 공급자 STS에 의해 역할 클레임이 발급될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8840b-149">When a user is authenticated the role claim can be issued by the identity provider STS or by a federation provider such as the Windows Azure Access Control Service (ACS).</span></span>  
  
-   <span data-ttu-id="8840b-150">**ClaimsAuthenticationManager를 사용하여 임의의 클레임을 클레임 역할 형식으로 변형**</span><span class="sxs-lookup"><span data-stu-id="8840b-150">**Transforming arbitrary claims into of claims role type using ClaimsAuthenticationManager**.</span></span> <span data-ttu-id="8840b-151">ClaimsAuthenticationManager는 WIF의 일부로 제공되는 구성 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="8840b-151">The ClaimsAuthenticationManager is a component that ships as part of WIF.</span></span> <span data-ttu-id="8840b-152">이는 토큰을 검사하고 클레임을 추가, 변경 또는 제거하여 해당 토큰을 변형하면서 응용 프로그램을 시작할 때 요청을 가로챌 수 있도록 허용합니다.</span><span class="sxs-lookup"><span data-stu-id="8840b-152">It allows requests to be intercepted when they launch an application, inspecting tokens and transforming them by adding, changing, or removing claims.</span></span> <span data-ttu-id="8840b-153">클레임을 변환 하기 위해 ClaimsAuthenticationManager를 사용 하는 방법에 대 한 자세한 내용은 참조 하세요. [방법: 구현 RBAC 역할 기반 액세스 제어 ()는 클레임 인식 ASP.NET 응용 프로그램 사용 하 여 WIF 및 ACS에서](https://go.microsoft.com/fwlink/?LinkID=247445)합니다.</span><span class="sxs-lookup"><span data-stu-id="8840b-153">For more information about how to use ClaimsAuthenticationManager for transforming claims, see [How To: Implement Role Based Access Control (RBAC) in a Claims Aware ASP.NET Application Using WIF and ACS](https://go.microsoft.com/fwlink/?LinkID=247445).</span></span>  
  
-   <span data-ttu-id="8840b-154">**samlSecurityTokenRequirement 구성 섹션을 사용하여 임의의 클레임을 역할 형식으로 매핑** - 구성만 사용하여 클레임 변형을 완료하며 코딩이 필요하지 않은 선언적 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="8840b-154">**Mapping arbitrary claims to a role type using the samlSecurityTokenRequirement configuration section**—A declarative approach where the claims transformation is done using only the configuration and no coding is required.</span></span>  
  
<a name="BKMK_2"></a>   
## <a name="claims-based-authorization"></a><span data-ttu-id="8840b-155">클레임 기반 권한 부여</span><span class="sxs-lookup"><span data-stu-id="8840b-155">Claims-based Authorization</span></span>  
 <span data-ttu-id="8840b-156">클레임 기반 권한 부여는 액세스를 허용하거나 거부하는 권한 부여 결정이 클레임에서 결정을 내리는 데 사용할 수 있는 데이터를 사용하는 임의의 논리를 기반으로 수행되는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="8840b-156">Claims-based authorization is an approach where the authorization decision to grant or deny access is based on arbitrary logic that uses data available in claims to make the decision.</span></span> <span data-ttu-id="8840b-157">RBAC의 경우 사용되는 유일한 클레임은 역할 형식 클레임이라는 점에 유의하십시오.</span><span class="sxs-lookup"><span data-stu-id="8840b-157">Recall that in the case of RBAC, the only claim used was role type claim.</span></span> <span data-ttu-id="8840b-158">사용자가 특정 역할에 속하는지 여부를 확인하기 위해 역할 형식 클레임이 사용되었습니다.</span><span class="sxs-lookup"><span data-stu-id="8840b-158">A role type claim was used to check if the user belongs to specific role or not.</span></span> <span data-ttu-id="8840b-159">클레임 기반 권한 부여 방법을 사용하여 권한 부여 결정을 내리는 과정을 설명하기 위해 다음 단계를 고려하십시오.</span><span class="sxs-lookup"><span data-stu-id="8840b-159">To illustrate the process of making the authorization decisions using claims-based authorization approach, consider the following steps:</span></span>  
  
1.  <span data-ttu-id="8840b-160">응용 프로그램에서 사용자가 인증을 받아야 하는 요청을 수신합니다.</span><span class="sxs-lookup"><span data-stu-id="8840b-160">The application receives a request that requires the user is authenticated.</span></span>  
  
2.  <span data-ttu-id="8840b-161">WIF가 사용자를 ID 공급자로 리디렉션하고, 인증되면 응용 프로그램 요청에 대한 클레임이 있는 사용자를 나타내는 연결된 보안 토큰과 함께 해당 요청이 생성됩니다.</span><span class="sxs-lookup"><span data-stu-id="8840b-161">WIF redirects the user to their identity provider, after they are authenticated the application request is made with an associated security token representing the user containing claims about them.</span></span> <span data-ttu-id="8840b-162">WIF가 이러한 클레임을 사용자를 나타내는 보안 주체와 연결합니다.</span><span class="sxs-lookup"><span data-stu-id="8840b-162">WIF associates those claims with the principal that represents the user.</span></span>  
  
3.  <span data-ttu-id="8840b-163">응용 프로그램이 의사 결정 논리 메커니즘에 클레임을 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="8840b-163">The application passes the claims to the decision logic mechanism.</span></span> <span data-ttu-id="8840b-164">이는 메모리 내 코드, 웹 서비스에 대한 호출, 데이터베이스에 대한 쿼리, 정교한 규칙 엔진 또는 ClaimsAuthorizationManager를 사용하는 방식일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8840b-164">It can be in-memory code, a call to a web service, a query to a database, a sophisticated rules engine, or using the ClaimsAuthorizationManager.</span></span>  
  
4.  <span data-ttu-id="8840b-165">의사 결정 메커니즘이 클레임에 따라 결과를 계산합니다.</span><span class="sxs-lookup"><span data-stu-id="8840b-165">The decision mechanism calculates the outcome based on the claims.</span></span>  
  
5.  <span data-ttu-id="8840b-166">결과가 true이면 액세스가 허용되고 false인 경우에는 거부됩니다.</span><span class="sxs-lookup"><span data-stu-id="8840b-166">Access is granted if the outcome is true and denied if it is false.</span></span> <span data-ttu-id="8840b-167">예를 들어, 규칙은 사용자가 21세 이상이고 워싱턴 주에 거주하는 것일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8840b-167">For example, the rule might be that the user is of age 21 or above and lives in Washington State.</span></span>  
  
 <span data-ttu-id="8840b-168"><xref:System.Security.Claims.ClaimsAuthorizationManager>는 응용 프로그램에서 클레임 기반 권한 부여를 위한 의사 결정 논리를 표면화하는 데 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="8840b-168"><xref:System.Security.Claims.ClaimsAuthorizationManager> is useful for externalizing the decision logic for  claims-based authorization in your applications.</span></span> <span data-ttu-id="8840b-169">ClaimsAuthorizationManager는 .NET 4.5의 일부로 제공되는 WIF 구성 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="8840b-169">ClaimsAuthorizationManager is a WIF component that ships as part of .NET 4.5.</span></span> <span data-ttu-id="8840b-170">ClaimsAuthorizationManager를 사용하면 들어오는 요청을 가로채고 들어오는 클레임에 따라 권한 부여 결정을 수행하도록 선택 항목의 논리를 구현할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8840b-170">ClaimsAuthorizationManager allows you to intercept incoming requests and implement any logic of your choice to make authorization decisions based on the incoming claims.</span></span> <span data-ttu-id="8840b-171">이는 권한 부여 논리를 변경해야 하는 경우 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="8840b-171">This becomes important when authorization logic needs to be changed.</span></span> <span data-ttu-id="8840b-172">이러한 경우 ClaimsAuthorizationManager를 사용해도 응용 프로그램의 무결성에 영향을 미치지 않으므로, 변경으로 인해 응용 프로그램에 오류가 발생할 가능성이 줄어듭니다.</span><span class="sxs-lookup"><span data-stu-id="8840b-172">In that case, using ClaimsAuthorizationManager will not affect the application’s integrity, thereby reducing the likelihood of an application error as a result of the change.</span></span> <span data-ttu-id="8840b-173">ClaimsAuthorizationManager를 사용하여 클레임 기반 액세스 제어를 구현하는 방법에 대한 자세한 내용은 [방법: WIF 및 ACS를 사용하여 클레임 인식 ASP.NET 응용 프로그램에서 클레임 권한 부여 구현](https://go.microsoft.com/fwlink/?LinkID=247446)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="8840b-173">To learn more about how to use ClaimsAuthorizationManager to implement claims-based access control, see [How To: Implement Claims Authorization in a Claims Aware ASP.NET Application Using WIF and ACS](https://go.microsoft.com/fwlink/?LinkID=247446).</span></span>

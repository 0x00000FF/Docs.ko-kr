---
title: SQL Server의 스냅숏 격리
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: 43ae5dd3-50f5-43a8-8d01-e37a61664176
ms.openlocfilehash: c06ecd8626b148c4f2143efdfa1e143d6ab3d6bc
ms.sourcegitcommit: 5b6d778ebb269ee6684fb57ad69a8c28b06235b9
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 04/08/2019
ms.locfileid: "59215939"
---
# <a name="snapshot-isolation-in-sql-server"></a><span data-ttu-id="8f7e5-102">SQL Server의 스냅숏 격리</span><span class="sxs-lookup"><span data-stu-id="8f7e5-102">Snapshot Isolation in SQL Server</span></span>
<span data-ttu-id="8f7e5-103">스냅숏 격리를 통해 OLTP 응용 프로그램의 동시성이 향상됩니다.</span><span class="sxs-lookup"><span data-stu-id="8f7e5-103">Snapshot isolation enhances concurrency for OLTP applications.</span></span>  
  
## <a name="understanding-snapshot-isolation-and-row-versioning"></a><span data-ttu-id="8f7e5-104">스냅샷 격리 및 행 버전 관리 이해</span><span class="sxs-lookup"><span data-stu-id="8f7e5-104">Understanding Snapshot Isolation and Row Versioning</span></span>  
 <span data-ttu-id="8f7e5-105">각 트랜잭션에 대해 업데이트 된 행 버전에 유지 됩니다 스냅숏 격리 활성화 되 면 **tempdb**합니다.</span><span class="sxs-lookup"><span data-stu-id="8f7e5-105">Once snapshot isolation is enabled, updated row versions for each transaction are maintained in **tempdb**.</span></span> <span data-ttu-id="8f7e5-106">고유한 트랜잭션 시퀀스 번호가 각 트랜잭션을 식별하며 행 버전에 대해 이러한 고유 번호가 기록됩니다.</span><span class="sxs-lookup"><span data-stu-id="8f7e5-106">A unique transaction sequence number identifies each transaction, and these unique numbers are recorded for each row version.</span></span> <span data-ttu-id="8f7e5-107">트랜잭션은 트랜잭션 시퀀스 번호 이전의 시퀀스 번호를 가진 최근 행 버전에서 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="8f7e5-107">The transaction works with the most recent row versions having a sequence number before the sequence number of the transaction.</span></span> <span data-ttu-id="8f7e5-108">트랜잭션이 시작된 이후에 만들어진 새로운 행 버전은 트랜잭션에서 무시됩니다.</span><span class="sxs-lookup"><span data-stu-id="8f7e5-108">Newer row versions created after the transaction has begun are ignored by the transaction.</span></span>  
  
 <span data-ttu-id="8f7e5-109">"스냅샷"이라는 용어는 트랜잭션의 모든 쿼리가 트랜잭션이 시작되는 시점에서 데이터베이스 상태에 따라 데이터베이스의 동일한 버전 또는 스냅샷을 표시하는 것을 의미합니다.</span><span class="sxs-lookup"><span data-stu-id="8f7e5-109">The term "snapshot" reflects the fact that all queries in the transaction see the same version, or snapshot, of the database, based on the state of the database at the moment in time when the transaction begins.</span></span> <span data-ttu-id="8f7e5-110">스냅샷 트랜잭션의 기본 데이터 행이나 데이터 페이지에서는 잠금이 인식되지 않습니다. 따라서 이전에 완료되지 않은 트랜잭션에 의해 차단되지 않고 다른 트랜잭션을 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8f7e5-110">No locks are acquired on the underlying data rows or data pages in a snapshot transaction, which permits other transactions to execute without being blocked by a prior uncompleted transaction.</span></span> <span data-ttu-id="8f7e5-111">일반적으로 트랜잭션은 SQL Server의 기본 READ COMMITTED 격리 수준 아래에 있으므로 데이터를 수정하는 트랜잭션이 데이터를 읽는 트랜잭션을 차단하지 않으며 데이터를 읽는 트랜잭션이 데이터를 쓰는 트랜잭션을 차단하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="8f7e5-111">Transactions that modify data do not block transactions that read data, and transactions that read data do not block transactions that write data, as they normally would under the default READ COMMITTED isolation level in SQL Server.</span></span> <span data-ttu-id="8f7e5-112">또한 이러한 비블로킹 동작이 복잡한 트랜잭션의 교착 상태 가능성을 크게 줄여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="8f7e5-112">This non-blocking behavior also significantly reduces the likelihood of deadlocks for complex transactions.</span></span>  
  
 <span data-ttu-id="8f7e5-113">스냅샷 격리에서는 낙관적 동시성 모델을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="8f7e5-113">Snapshot isolation uses an optimistic concurrency model.</span></span> <span data-ttu-id="8f7e5-114">스냅샷 트랜잭션에서 트랜잭션이 시작된 이후에 변경된 데이터에 대한 수정 내용을 커밋하려는 경우 트랜잭션이 롤백되고 오류가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="8f7e5-114">If a snapshot transaction attempts to commit modifications to data that has changed since the transaction began, the transaction will roll back and an error will be raised.</span></span> <span data-ttu-id="8f7e5-115">이러한 문제를 방지하려면 수정할 데이터에 액세스하는 SELECT 문에 대해 UPDLOCK 힌트를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="8f7e5-115">You can avoid this by using UPDLOCK hints for SELECT statements that access data to be modified.</span></span> <span data-ttu-id="8f7e5-116">자세한 내용은 SQL Server 온라인 설명서의 "Locking Hints"를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="8f7e5-116">See "Locking Hints" in SQL Server Books Online for more information.</span></span>  
  
 <span data-ttu-id="8f7e5-117">트랜잭션에서 사용되기 전에 ALLOW_SNAPSHOT_ISOLATION ON 데이터베이스 옵션을 설정하여 스냅샷 격리를 활성화해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8f7e5-117">Snapshot isolation must be enabled by setting the ALLOW_SNAPSHOT_ISOLATION ON database option before it is used in transactions.</span></span> <span data-ttu-id="8f7e5-118">이렇게 하면 임시 데이터베이스에 행 버전을 저장 하기 위한 메커니즘을 활성화 (**tempdb**).</span><span class="sxs-lookup"><span data-stu-id="8f7e5-118">This activates the mechanism for storing row versions in the temporary database (**tempdb**).</span></span> <span data-ttu-id="8f7e5-119">Transact-SQL ALTER DATABASE 문과 함께 사용하는 각 데이터베이스에서 스냅샷 격리를 활성화해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8f7e5-119">You must enable snapshot isolation in each database that uses it with the Transact-SQL ALTER DATABASE statement.</span></span> <span data-ttu-id="8f7e5-120">이 경우 스냅샷 격리는 구성을 필요로 하지 않는 READ COMMITTED, REPEATABLE READ, SERIALIZABLE 및 READ UNCOMMITTED와 같은 일반적인 격리 수준과 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="8f7e5-120">In this respect, snapshot isolation differs from the traditional isolation levels of READ COMMITTED, REPEATABLE READ, SERIALIZABLE, and READ UNCOMMITTED, which require no configuration.</span></span> <span data-ttu-id="8f7e5-121">다음 문은 스냅샷 격리를 활성화하고 기본 READ COMMITTED 동작을 SNAPSHOT으로 대체합니다.</span><span class="sxs-lookup"><span data-stu-id="8f7e5-121">The following statements activate snapshot isolation and replace the default READ COMMITTED behavior with SNAPSHOT:</span></span>  
  
```sql  
ALTER DATABASE MyDatabase  
SET ALLOW_SNAPSHOT_ISOLATION ON  
  
ALTER DATABASE MyDatabase  
SET READ_COMMITTED_SNAPSHOT ON  
```  
  
 <span data-ttu-id="8f7e5-122">READ_COMMITTED_SNAPSHOT ON 옵션을 설정하면 기본 READ COMMITTED 격리 수준에서 버전 관리되는 행에 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8f7e5-122">Setting the READ_COMMITTED_SNAPSHOT ON option allows access to versioned rows under the default READ COMMITTED isolation level.</span></span> <span data-ttu-id="8f7e5-123">READ_COMMITTED_SNAPSHOT 옵션이 OFF로 설정된 경우 버전 관리되는 행에 액세스하려면 세션마다 스냅샷 격리 수준을 명시적으로 설정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8f7e5-123">If the READ_COMMITTED_SNAPSHOT option is set to OFF, you must explicitly set the Snapshot isolation level for each session in order to access versioned rows.</span></span>  
  
## <a name="managing-concurrency-with-isolation-levels"></a><span data-ttu-id="8f7e5-124">격리 수준을 사용하여 동시성 관리</span><span class="sxs-lookup"><span data-stu-id="8f7e5-124">Managing Concurrency with Isolation Levels</span></span>  
 <span data-ttu-id="8f7e5-125">Transact-SQL 문이 실행되는 격리 수준은 해당 문의 잠금 및 행 버전 관리 동작을 결정합니다.</span><span class="sxs-lookup"><span data-stu-id="8f7e5-125">The isolation level under which a Transact-SQL statement executes determines its locking and row versioning behavior.</span></span> <span data-ttu-id="8f7e5-126">격리 수준은 연결 전체 범위에 적용되므로 SET TRANSACTION ISOLATION LEVEL 문을 사용하여 연결에 대해 격리 수준이 설정되고 나면 연결이 닫히거나 다른 격리 수준이 설정될 때까지 적용된 상태가 유지됩니다.</span><span class="sxs-lookup"><span data-stu-id="8f7e5-126">An isolation level has connection-wide scope, and once set for a connection with the SET TRANSACTION ISOLATION LEVEL statement, it remains in effect until the connection is closed or another isolation level is set.</span></span> <span data-ttu-id="8f7e5-127">연결이 닫히고 풀로 반환되면 마지막 SET TRANSACTION ISOLATION LEVEL 문의 격리 수준이 유지됩니다.</span><span class="sxs-lookup"><span data-stu-id="8f7e5-127">When a connection is closed and returned to the pool, the isolation level from the last SET TRANSACTION ISOLATION LEVEL statement is retained.</span></span> <span data-ttu-id="8f7e5-128">풀링된 연결을 다시 사용하는 후속 연결은 연결이 풀링된 시점에 유효 상태였던 격리 수준을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="8f7e5-128">Subsequent connections reusing a pooled connection use the isolation level that was in effect at the time the connection is pooled.</span></span>  
  
 <span data-ttu-id="8f7e5-129">연결 내에서 실행된 개별 쿼리에는 단일 문이나 트랜잭션의 격리를 수정하는 잠금 힌트가 포함될 수 있지만 연결의 격리 수준에는 영향을 미치지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="8f7e5-129">Individual queries issued within a connection can contain lock hints that modify the isolation for a single statement or transaction but do not affect the isolation level of the connection.</span></span> <span data-ttu-id="8f7e5-130">저장 프로시저 또는 함수에 설정된 격리 수준이나 잠금 힌트는 이러한 저장 프로시저나 함수를 호출하는 연결의 격리 수준을 변경하지 않으며 저장 프로시저 또는 함수 호출 기간에만 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="8f7e5-130">Isolation levels or lock hints set in stored procedures or functions do not change the isolation level of the connection that calls them and are in effect only for the duration of the stored procedure or function call.</span></span>  
  
 <span data-ttu-id="8f7e5-131">이전 버전의 SQL Server에서는 SQL-92 표준에 정의된 네 가지 격리 수준이 지원되었습니다.</span><span class="sxs-lookup"><span data-stu-id="8f7e5-131">Four isolation levels defined in the SQL-92 standard were supported in early versions of SQL Server:</span></span>  
  
-   <span data-ttu-id="8f7e5-132">READ UNCOMMITTED는 다른 트랜잭션에 의한 잠금을 무시하기 때문에 가장 제한이 적은 격리 수준입니다.</span><span class="sxs-lookup"><span data-stu-id="8f7e5-132">READ UNCOMMITTED is the least restrictive isolation level because it ignores locks placed by other transactions.</span></span> <span data-ttu-id="8f7e5-133">READ UNCOMMITTED에서 실행되는 트랜잭션은 다른 트랜잭션에서 커밋하지 않은 수정된 데이터 값을 읽을 수 있습니다. 이를 "더티" 읽기라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="8f7e5-133">Transactions executing under READ UNCOMMITTED can read modified data values that have not yet been committed by other transactions; these are called "dirty" reads.</span></span>  
  
-   <span data-ttu-id="8f7e5-134">READ COMMITTED는 SQL Server의 기본 격리 수준입니다.</span><span class="sxs-lookup"><span data-stu-id="8f7e5-134">READ COMMITTED is the default isolation level for SQL Server.</span></span> <span data-ttu-id="8f7e5-135">이 격리 수준은 문에서 다른 트랜잭션에 의해 수정되었지만 아직 커밋되지 않은 데이터 값을 읽을 수 없도록 지정하여 더티 읽기를 방지합니다.</span><span class="sxs-lookup"><span data-stu-id="8f7e5-135">It prevents dirty reads by specifying that statements cannot read data values that have been modified but not yet committed by other transactions.</span></span> <span data-ttu-id="8f7e5-136">다른 트랜잭션에서 현재 트랜잭션 내에 있는 개별 문이 실행되는 사이에 데이터를 계속해서 수정하거나 삽입 또는 삭제할 수 있기 때문에 결과적으로 반복되지 않은 읽기 또는 "팬텀" 데이터가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="8f7e5-136">Other transactions can still modify, insert, or delete data between executions of individual statements within the current transaction, resulting in non-repeatable reads, or "phantom" data.</span></span>  
  
-   <span data-ttu-id="8f7e5-137">REPEATABLE READ는 READ COMMITTED보다 좀 더 제한적인 격리 수준입니다.</span><span class="sxs-lookup"><span data-stu-id="8f7e5-137">REPEATABLE READ is a more restrictive isolation level than READ COMMITTED.</span></span> <span data-ttu-id="8f7e5-138">이 수준은 READ COMMITTED를 포함할 뿐만 아니라 현재 트랜잭션이 커밋될 때까지 현재 트랜잭션에서 읽은 데이터를 다른 트랜잭션에서 수정하거나 삭제할 수 없도록 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="8f7e5-138">It encompasses READ COMMITTED and additionally specifies that no other transactions can modify or delete data that has been read by the current transaction until the current transaction commits.</span></span> <span data-ttu-id="8f7e5-139">읽은 데이터에 대한 공유 잠금이 각 문이 끝날 때 해제되지 않고 트랜잭션 기간 동안 유지되기 때문에 동시성이 READ COMMITTED의 경우보다 낮습니다.</span><span class="sxs-lookup"><span data-stu-id="8f7e5-139">Concurrency is lower than for READ COMMITTED because shared locks on read data are held for the duration of the transaction instead of being released at the end of each statement.</span></span>  
  
-   <span data-ttu-id="8f7e5-140">SERIALIZABLE은 전체 키를 잠그고 트랜잭션이 완료될 때까지 잠금을 유지하기 때문에 가장 제한적인 격리 수준입니다.</span><span class="sxs-lookup"><span data-stu-id="8f7e5-140">SERIALIZABLE is the most restrictive isolation level, because it locks entire ranges of keys and holds the locks until the transaction is complete.</span></span> <span data-ttu-id="8f7e5-141">이 격리 수준은 REPEATABLE READ를 포함하며 트랜잭션이 완료될 때까지 다른 트랜잭션이 해당 트랜잭션에서 읽은 범위 내에 새 행을 삽입할 수 없도록 하는 제한을 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="8f7e5-141">It encompasses REPEATABLE READ and adds the restriction that other transactions cannot insert new rows into ranges that have been read by the transaction until the transaction is complete.</span></span>  
  
 <span data-ttu-id="8f7e5-142">자세한 내용은 참조는 [트랜잭션 잠금 및 행 버전 관리 지침](/sql/relational-databases/sql-server-transaction-locking-and-row-versioning-guide)합니다.</span><span class="sxs-lookup"><span data-stu-id="8f7e5-142">For more information, refer to the [Transaction Locking and Row Versioning Guide](/sql/relational-databases/sql-server-transaction-locking-and-row-versioning-guide).</span></span>  
  
### <a name="snapshot-isolation-level-extensions"></a><span data-ttu-id="8f7e5-143">스냅샷 격리 수준 확장명</span><span class="sxs-lookup"><span data-stu-id="8f7e5-143">Snapshot Isolation Level Extensions</span></span>  
 <span data-ttu-id="8f7e5-144">SQL Server에서는 SNAPSHOT 격리 수준을 도입하고 READ COMMITTED를 추가로 구현함으로써 SQL-92 격리 수준이 확장되었습니다.</span><span class="sxs-lookup"><span data-stu-id="8f7e5-144">SQL Server introduced extensions to the SQL-92 isolation levels with the introduction of the SNAPSHOT isolation level and an additional implementation of READ COMMITTED.</span></span> <span data-ttu-id="8f7e5-145">READ_COMMITTED_SNAPSHOT 격리 수준은 모든 트랜잭션에 대해 READ COMMITTED를 투명하게 대체할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8f7e5-145">The READ_COMMITTED_SNAPSHOT isolation level can transparently replace READ COMMITTED for all transactions.</span></span>  
  
-   <span data-ttu-id="8f7e5-146">SNAPSHOT 격리는 트랜잭션 내에서 읽은 데이터에 다른 동시 트랜잭션에서 발생한 변경 내용이 반영되지 않도록 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="8f7e5-146">SNAPSHOT isolation specifies that data read within a transaction will never reflect changes made by other simultaneous transactions.</span></span> <span data-ttu-id="8f7e5-147">트랜잭션은 트랜잭션이 시작될 때 존재하는 데이터 행 버전을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="8f7e5-147">The transaction uses the data row versions that exist when the transaction begins.</span></span> <span data-ttu-id="8f7e5-148">데이터를 읽을 때 데이터가 잠기지 않으므로 SNAPSHOT 트랜잭션이 다른 트랜잭션의 데이터 쓰기 동작을 차단하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="8f7e5-148">No locks are placed on the data when it is read, so SNAPSHOT transactions do not block other transactions from writing data.</span></span> <span data-ttu-id="8f7e5-149">데이터를 쓰는 트랜잭션은 스냅샷 트랜잭션의 데이터 읽기 동작을 차단하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="8f7e5-149">Transactions that write data do not block snapshot transactions from reading data.</span></span> <span data-ttu-id="8f7e5-150">스냅샷 격리를 사용하려면 ALLOW_SNAPSHOT_ISOLATION 데이터베이스 옵션을 설정하여 스냅샷 격리를 활성화해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8f7e5-150">You need to enable snapshot isolation by setting the ALLOW_SNAPSHOT_ISOLATION database option in order to use it.</span></span>  
  
-   <span data-ttu-id="8f7e5-151">READ_COMMITTED_SNAPSHOT 데이터베이스 옵션은 데이터베이스에서 스냅샷 격리를 활성화한 경우 기본 READ COMMITTED 격리 수준의 동작을 결정합니다.</span><span class="sxs-lookup"><span data-stu-id="8f7e5-151">The READ_COMMITTED_SNAPSHOT database option determines the behavior of the default READ COMMITTED isolation level when snapshot isolation is enabled in a database.</span></span> <span data-ttu-id="8f7e5-152">READ_COMMITTED_SNAPSHOT ON을 명시적으로 지정하지 않은 경우 READ COMMITTED가 모든 암시적 트랜잭션에 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="8f7e5-152">If you do not explicitly specify READ_COMMITTED_SNAPSHOT ON, READ COMMITTED is applied to all implicit transactions.</span></span> <span data-ttu-id="8f7e5-153">따라서 READ_COMMITTED_SNAPSHOT OFF(기본값)를 설정할 때와 똑같이 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="8f7e5-153">This produces the same behavior as setting READ_COMMITTED_SNAPSHOT OFF (the default).</span></span> <span data-ttu-id="8f7e5-154">READ_COMMITTED_SNAPSHOT OFF가 적용되는 경우 데이터베이스 엔진에서 공유 잠금을 사용하여 기본 격리 수준을 적용합니다.</span><span class="sxs-lookup"><span data-stu-id="8f7e5-154">When READ_COMMITTED_SNAPSHOT OFF is in effect, the Database Engine uses shared locks to enforce the default isolation level.</span></span> <span data-ttu-id="8f7e5-155">READ_COMMITTED_SNAPSHOT 데이터베이스 옵션을 ON으로 설정하면 데이터베이스 엔진에서 잠금을 사용하는 대신에 행 버전 관리 및 스냅샷 격리를 기본값으로 사용하여 데이터를 보호합니다.</span><span class="sxs-lookup"><span data-stu-id="8f7e5-155">If you set the READ_COMMITTED_SNAPSHOT database option to ON, the database engine uses row versioning and snapshot isolation as the default, instead of using locks to protect the data.</span></span>  
  
## <a name="how-snapshot-isolation-and-row-versioning-work"></a><span data-ttu-id="8f7e5-156">스냅샷 격리 및 행 버전 관리의 작동 방법</span><span class="sxs-lookup"><span data-stu-id="8f7e5-156">How Snapshot Isolation and Row Versioning Work</span></span>  
 <span data-ttu-id="8f7e5-157">SQL Server 데이터베이스 엔진의 원래 행의 복사본을 저장 SNAPSHOT 격리 수준을 사용 하는 경우 행이 업데이트 될 때마다 **tempdb**를 행에 트랜잭션 시퀀스 번호를 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="8f7e5-157">When the SNAPSHOT isolation level is enabled, each time a row is updated, the SQL Server Database Engine stores a copy of the original row in **tempdb**, and adds a transaction sequence number to the row.</span></span> <span data-ttu-id="8f7e5-158">발생하는 이벤트 시퀀스는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="8f7e5-158">The following is the sequence of events that occurs:</span></span>  
  
-   <span data-ttu-id="8f7e5-159">새 트랜잭션이 시작되고 트랜잭션 시퀀스 번호가 할당됩니다.</span><span class="sxs-lookup"><span data-stu-id="8f7e5-159">A new transaction is initiated, and it is assigned a transaction sequence number.</span></span>  
  
-   <span data-ttu-id="8f7e5-160">데이터베이스 엔진이 트랜잭션 내에서 행을 읽고에서 행 버전을 검색 **tempdb** 시퀀스 번호에 근접 한 트랜잭션 시퀀스 번호 보다 낮으면서 가장 합니다.</span><span class="sxs-lookup"><span data-stu-id="8f7e5-160">The Database Engine reads a row within the transaction and retrieves the row version from **tempdb** whose sequence number is closest to, and lower than, the transaction sequence number.</span></span>  
  
-   <span data-ttu-id="8f7e5-161">데이터베이스 엔진에서 스냅샷 트랜잭션이 시작되었을 때 커밋되지 않은 활성 트랜잭션의 트랜잭션 시퀀스 번호 목록에 트랜잭션 시퀀스 번호가 들어 있지 않은지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="8f7e5-161">The Database Engine checks to see if the transaction sequence number is not in the list of transaction sequence numbers of the uncommitted transactions active when the snapshot transaction started.</span></span>  
  
-   <span data-ttu-id="8f7e5-162">트랜잭션이에서 행의 버전을 읽습니다 **tempdb** 트랜잭션 시작 당시의 합니다.</span><span class="sxs-lookup"><span data-stu-id="8f7e5-162">The transaction reads the version of the row from **tempdb** that was current as of the start of the transaction.</span></span> <span data-ttu-id="8f7e5-163">트랜잭션이 시작된 후 삽입된 새 행은 해당 시퀀스 번호 값이 트랜잭션 시퀀스 번호 값보다 높으므로 표시되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="8f7e5-163">It will not see new rows inserted after the transaction was started because those sequence number values will be higher than the value of the transaction sequence number.</span></span>  
  
-   <span data-ttu-id="8f7e5-164">현재 트랜잭션에서 행 버전이 있을 것 때문에 트랜잭션이 시작 된 후 삭제 된 행이 나타납니다 **tempdb** 낮은 시퀀스 번호 값입니다.</span><span class="sxs-lookup"><span data-stu-id="8f7e5-164">The current transaction will see rows that were deleted after the transaction began, because there will be a row version in **tempdb** with a lower sequence number value.</span></span>  
  
 <span data-ttu-id="8f7e5-165">스냅샷 격리의 결과로 트랜잭션에서 기본 테이블에 잠금을 고려하거나 배치하지 않고 트랜잭션을 시작할 때 존재했던 그대로 모든 데이터를 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="8f7e5-165">The net effect of snapshot isolation is that the transaction sees all of the data as it existed at the start of the transaction, without honoring or placing any locks on the underlying tables.</span></span> <span data-ttu-id="8f7e5-166">따라서 경합이 있는 상황에서는 성능이 향상될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8f7e5-166">This can result in performance improvements in situations where there is contention.</span></span>  
  
 <span data-ttu-id="8f7e5-167">스냅샷 트랜잭션은 다른 트랜잭션에서 행이 업데이트되는 것을 방지하는 잠금을 유지하면서 항상 낙관적 동시성 제어를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="8f7e5-167">A snapshot transaction always uses optimistic concurrency control, withholding any locks that would prevent other transactions from updating rows.</span></span> <span data-ttu-id="8f7e5-168">스냅샷 트랜잭션에서 트랜잭션이 시작된 후 변경된 행에 대한 업데이트를 커밋하려고 하면 트랜잭션이 롤백되고 오류가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="8f7e5-168">If a snapshot transaction attempts to commit an update to a row that was changed after the transaction began, the transaction is rolled back, and an error is raised.</span></span>  
  
## <a name="working-with-snapshot-isolation-in-adonet"></a><span data-ttu-id="8f7e5-169">ADO.NET에서 스냅샷 격리 사용</span><span class="sxs-lookup"><span data-stu-id="8f7e5-169">Working with Snapshot Isolation in ADO.NET</span></span>  
 <span data-ttu-id="8f7e5-170">스냅샷 격리는 ADO.NET에서 <xref:System.Data.SqlClient.SqlTransaction> 클래스를 통해 지원됩니다.</span><span class="sxs-lookup"><span data-stu-id="8f7e5-170">Snapshot isolation is supported in ADO.NET by the <xref:System.Data.SqlClient.SqlTransaction> class.</span></span> <span data-ttu-id="8f7e5-171">데이터베이스에 스냅숏 격리 설정 하지만 READ_COMMITTED_SNAPSHOT ON에 대 한 구성 되지 않은 경우 시작 해야 합니다는 <xref:System.Data.SqlClient.SqlTransaction> 를 사용 하 여는 **IsolationLevel.Snapshot** 호출 하는 경우에 열거형 값의 <xref:System.Data.SqlClient.SqlConnection.BeginTransaction%2A> 메서드입니다.</span><span class="sxs-lookup"><span data-stu-id="8f7e5-171">If a database has been enabled for snapshot isolation but is not configured for READ_COMMITTED_SNAPSHOT ON, you must initiate a <xref:System.Data.SqlClient.SqlTransaction> using the **IsolationLevel.Snapshot** enumeration value when calling the <xref:System.Data.SqlClient.SqlConnection.BeginTransaction%2A> method.</span></span> <span data-ttu-id="8f7e5-172">이 코드 조각에서는 연결을 열려 있는 <xref:System.Data.SqlClient.SqlConnection> 개체로 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="8f7e5-172">This code fragment assumes that connection is an open <xref:System.Data.SqlClient.SqlConnection> object.</span></span>  
  
```vb  
Dim sqlTran As SqlTransaction = _  
  connection.BeginTransaction(IsolationLevel.Snapshot)  
```  
  
```csharp  
SqlTransaction sqlTran =   
  connection.BeginTransaction(IsolationLevel.Snapshot);  
```  
  
### <a name="example"></a><span data-ttu-id="8f7e5-173">예제</span><span class="sxs-lookup"><span data-stu-id="8f7e5-173">Example</span></span>  
 <span data-ttu-id="8f7e5-174">다음 예제에서는 잠겨 있는 데이터에 대한 액세스를 시도하여 다른 격리 수준이 작동하는 방법을 보여 줍니다. 이 예제는 프로덕션 코드에는 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="8f7e5-174">The following example demonstrates how the different isolation levels behave by attempting to access locked data, and it is not intended to be used in production code.</span></span>  
  
 <span data-ttu-id="8f7e5-175">코드에 연결 합니다 **AdventureWorks** 라는 테이블을 만들고 샘플 데이터베이스에 SQL Server **TestSnapshot** 데이터의 한 행을 삽입 합니다.</span><span class="sxs-lookup"><span data-stu-id="8f7e5-175">The code connects to the **AdventureWorks** sample database in SQL Server and creates a table named **TestSnapshot** and inserts one row of data.</span></span> <span data-ttu-id="8f7e5-176">이 코드에서는 ALTER DATABASE Transact-SQL 문을 사용하여 데이터베이스에 스냅샷 격리 기능을 설정하지만 READ_COMMITTED_SNAPSHOT 옵션을 설정하지 않으므로 기본 READ COMMITTED 격리 수준 동작이 그대로 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="8f7e5-176">The code uses the ALTER DATABASE Transact-SQL statement to turn on snapshot isolation for the database, but it does not set the READ_COMMITTED_SNAPSHOT option, leaving the default READ COMMITTED isolation-level behavior in effect.</span></span> <span data-ttu-id="8f7e5-177">그런 다음 이 코드에서는 다음 작업을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="8f7e5-177">The code then performs the following actions:</span></span>  
  
-   <span data-ttu-id="8f7e5-178">sqlTransaction1을 시작하지만 완료하지는 않습니다. 이 트랜잭션은 SERIALIZABLE 격리 수준을 사용하여 업데이트 트랜잭션을 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="8f7e5-178">It begins, but does not complete, sqlTransaction1, which uses the SERIALIZABLE isolation level to start an update transaction.</span></span> <span data-ttu-id="8f7e5-179">이렇게 하면 테이블이 잠깁니다.</span><span class="sxs-lookup"><span data-stu-id="8f7e5-179">This has the effect of locking the table.</span></span>  
  
-   <span data-ttu-id="8f7e5-180">두 번째 연결이 열리고의 데이터를 읽을 SNAPSHOT 격리 수준을 사용 하 여 두 번째 트랜잭션을 시작 합니다 **TestSnapshot** 테이블입니다.</span><span class="sxs-lookup"><span data-stu-id="8f7e5-180">It opens a second connection and initiates a second transaction using the SNAPSHOT isolation level to read the data in the **TestSnapshot** table.</span></span> <span data-ttu-id="8f7e5-181">스냅샷 격리가 활성화되므로 이 트랜잭션에서 sqlTransaction1이 시작되기 전에 존재하는 데이터를 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8f7e5-181">Because snapshot isolation is enabled, this transaction can read the data that existed before sqlTransaction1 started.</span></span>  
  
-   <span data-ttu-id="8f7e5-182">세 번째 연결을 열고 READ COMMITTED 격리 수준을 사용하여 트랜잭션을 시작함으로써 테이블의 데이터를 읽으려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="8f7e5-182">It opens a third connection and initiates a transaction using the READ COMMITTED isolation level to attempt to read the data in the table.</span></span> <span data-ttu-id="8f7e5-183">이 경우 첫 번째 트랜잭션에서 테이블에 있는 잠금을 통과하여 읽을 수 없기 때문에 코드에서 데이터를 읽을 수 없으며 제한 시간이 초과됩니다. REPEATABLE READ 및 SERIALIZABLE 격리 수준에서도 첫 번째 트랜잭션에 있는 잠금을 통과하여 읽을 수 없으므로 이러한 격리 수준이 사용되는 경우 동일한 결과가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="8f7e5-183">In this case, the code cannot read the data because it cannot read past the locks placed on the table in the first transaction and times out. The same result would occur if the REPEATABLE READ and SERIALIZABLE isolation levels were used because these isolation levels also cannot read past the locks placed in the first transaction.</span></span>  
  
-   <span data-ttu-id="8f7e5-184">네 번째 연결을 열고 READ UNCOMMITTED 격리 수준을 사용하여 트랜잭션을 시작합니다. 이 격리 수준은 sqlTransaction1에서 커밋되지 않은 값의 더티 읽기를 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="8f7e5-184">It opens a fourth connection and initiates a transaction using the READ UNCOMMITTED isolation level, which performs a dirty read of the uncommitted value in sqlTransaction1.</span></span> <span data-ttu-id="8f7e5-185">첫 번째 트랜잭션이 커밋되지 않는 경우 이 값은 데이터베이스에 실제로 존재하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="8f7e5-185">This value may never actually exist in the database if the first transaction is not committed.</span></span>  
  
-   <span data-ttu-id="8f7e5-186">첫 번째 트랜잭션을 롤백하고 고 삭제 하 여 정리 합니다 **TestSnapshot** 테이블과 해제 스냅샷 격리를 **AdventureWorks** 데이터베이스입니다.</span><span class="sxs-lookup"><span data-stu-id="8f7e5-186">It rolls back the first transaction and cleans up by deleting the **TestSnapshot** table and turning off snapshot isolation for the **AdventureWorks** database.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8f7e5-187">다음 예제에서는 연결 풀링을 해제한 상태에서 동일한 연결 문자열을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="8f7e5-187">The following examples use the same connection string with connection pooling turned off.</span></span> <span data-ttu-id="8f7e5-188">연결이 풀링된 경우, 연결의 격리 수준을 재설정하더라도 서버에서는 격리 수준이 재설정되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="8f7e5-188">If a connection is pooled, resetting its isolation level does not reset the isolation level at the server.</span></span> <span data-ttu-id="8f7e5-189">따라서 풀링된 동일한 내부 연결을 사용하는 후속 연결은 풀링된 연결의 격리 수준으로 설정된 각각의 격리 수준에서 시작됩니다.</span><span class="sxs-lookup"><span data-stu-id="8f7e5-189">As a result, subsequent connections that use the same pooled inner connection start with their isolation levels set to that of the pooled connection.</span></span> <span data-ttu-id="8f7e5-190">연결 풀링을 해제하는 대신 각 연결에 대해 명시적으로 격리 수준을 설정할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8f7e5-190">An alternative to turning off connection pooling is to set the isolation level explicitly for each connection.</span></span>  
  
 [!code-csharp[DataWorks SnapshotIsolation.Demo#1](../../../../../samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks SnapshotIsolation.Demo/CS/source.cs#1)]
 [!code-vb[DataWorks SnapshotIsolation.Demo#1](../../../../../samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks SnapshotIsolation.Demo/VB/source.vb#1)]  
  
### <a name="example"></a><span data-ttu-id="8f7e5-191">예제</span><span class="sxs-lookup"><span data-stu-id="8f7e5-191">Example</span></span>  
 <span data-ttu-id="8f7e5-192">다음 예제에서는 데이터가 수정될 때 나타나는 스냅샷 격리의 동작을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="8f7e5-192">The following example demonstrates the behavior of snapshot isolation when data is being modified.</span></span> <span data-ttu-id="8f7e5-193">이 코드에서는 다음 작업을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="8f7e5-193">The code performs the following actions:</span></span>  
  
-   <span data-ttu-id="8f7e5-194">에 연결 합니다 **AdventureWorks** 샘플 데이터베이스 및 하면 스냅숏 격리 합니다.</span><span class="sxs-lookup"><span data-stu-id="8f7e5-194">Connects to the **AdventureWorks** sample database and enables SNAPSHOT isolation.</span></span>  
  
-   <span data-ttu-id="8f7e5-195">라는 테이블을 만듭니다 **TestSnapshotUpdate** 세 개의 샘플 데이터 행을 삽입 합니다.</span><span class="sxs-lookup"><span data-stu-id="8f7e5-195">Creates a table named **TestSnapshotUpdate** and inserts three rows of sample data.</span></span>  
  
-   <span data-ttu-id="8f7e5-196">SNAPSHOT 격리를 사용하여 sqlTransaction1을 시작하지만 완료하지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="8f7e5-196">Begins, but does not complete, sqlTransaction1 using SNAPSHOT isolation.</span></span> <span data-ttu-id="8f7e5-197">트랜잭션에서 데이터 행 세 개가 선택됩니다.</span><span class="sxs-lookup"><span data-stu-id="8f7e5-197">Three rows of data are selected in the transaction.</span></span>  
  
-   <span data-ttu-id="8f7e5-198">두 번째를 만듭니다 **SqlConnection** 하 **AdventureWorks** sqlTransaction1에서 선택한 행 중 하나에 값을 업데이트 하는 READ COMMITTED 격리 수준을 사용 하 여 두 번째 트랜잭션을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="8f7e5-198">Creates a second **SqlConnection** to **AdventureWorks** and creates a second transaction using the READ COMMITTED isolation level that updates a value in one of the rows selected in sqlTransaction1.</span></span>  
  
-   <span data-ttu-id="8f7e5-199">sqlTransaction2를 커밋합니다.</span><span class="sxs-lookup"><span data-stu-id="8f7e5-199">Commits sqlTransaction2.</span></span>  
  
-   <span data-ttu-id="8f7e5-200">sqlTransaction1로 돌아가서 sqlTransaction1이 커밋된 동일한 행에 대한 업데이트를 시도합니다.</span><span class="sxs-lookup"><span data-stu-id="8f7e5-200">Returns to sqlTransaction1 and attempts to update the same row that sqlTransaction1 already committed.</span></span> <span data-ttu-id="8f7e5-201">오류 3960이 발생하고 sqlTransaction1이 자동으로 롤백됩니다.</span><span class="sxs-lookup"><span data-stu-id="8f7e5-201">Error 3960 is raised, and sqlTransaction1 is rolled back automatically.</span></span> <span data-ttu-id="8f7e5-202">합니다 **SqlException.Number** 하 고 **SqlException.Message** 콘솔 창에 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="8f7e5-202">The **SqlException.Number** and **SqlException.Message** are displayed in the Console window.</span></span>  
  
-   <span data-ttu-id="8f7e5-203">스냅숏 격리를 해제 하려면 정리 코드를 실행 **AdventureWorks** 하 고 삭제 합니다 **TestSnapshotUpdate** 테이블.</span><span class="sxs-lookup"><span data-stu-id="8f7e5-203">Executes clean-up code to turn off snapshot isolation in **AdventureWorks** and delete the **TestSnapshotUpdate** table.</span></span>  
  
 [!code-csharp[DataWorks SnapshotIsolation.DemoUpdate#1](../../../../../samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks SnapshotIsolation.DemoUpdate/CS/source.cs#1)]
 [!code-vb[DataWorks SnapshotIsolation.DemoUpdate#1](../../../../../samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks SnapshotIsolation.DemoUpdate/VB/source.vb#1)]  
  
### <a name="using-lock-hints-with-snapshot-isolation"></a><span data-ttu-id="8f7e5-204">스냅샷 격리와 함께 잠금 힌트 사용</span><span class="sxs-lookup"><span data-stu-id="8f7e5-204">Using Lock Hints with Snapshot Isolation</span></span>  
 <span data-ttu-id="8f7e5-205">앞의 예제에서는 첫 번째 트랜잭션에서 데이터를 선택한 후 첫 번째 트랜잭션이 완료되기 전에 두 번째 트랜잭션에서 데이터를 업데이트하므로 첫 번째 트랜잭션에서 동일한 행을 업데이트하려고 할 때 업데이트 충돌이 발생하게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="8f7e5-205">In the previous example, the first transaction selects data, and a second transaction updates the data before the first transaction is able to complete, causing an update conflict when the first transaction tries to update the same row.</span></span> <span data-ttu-id="8f7e5-206">트랜잭션을 시작할 때 잠금 힌트를 제공하면 장기 실행 스냅샷 트랜잭션에서 업데이트 충돌을 줄일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8f7e5-206">You can reduce the chance of update conflicts in long-running snapshot transactions by supplying lock hints at the beginning of the transaction.</span></span> <span data-ttu-id="8f7e5-207">다음 SELECT 문에서는 UDPLOCK 힌트를 사용하여 선택한 행을 잠급니다.</span><span class="sxs-lookup"><span data-stu-id="8f7e5-207">The following SELECT statement uses the UPDLOCK hint to lock the selected rows:</span></span>  
  
```sql  
SELECT * FROM TestSnapshotUpdate WITH (UPDLOCK)   
  WHERE PriKey BETWEEN 1 AND 3  
```  
  
 <span data-ttu-id="8f7e5-208">UPDLOCK 잠금 힌트를 사용하면 첫 번째 트랜잭션이 완료되기 전에 행에 대한 업데이트 시도가 차단됩니다.</span><span class="sxs-lookup"><span data-stu-id="8f7e5-208">Using the UPDLOCK lock hint blocks any rows attempting to update the rows before the first transaction completes.</span></span> <span data-ttu-id="8f7e5-209">따라서 선택한 행이 트랜잭션에서 나중에 업데이트되는 경우에도 충돌이 발생하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="8f7e5-209">This guarantees that the selected rows have no conflicts when they are updated later in the transaction.</span></span> <span data-ttu-id="8f7e5-210">SQL Server 온라인 설명서의 "Locking Hints"를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="8f7e5-210">See "Locking Hints" in SQL Server Books Online.</span></span>  
  
 <span data-ttu-id="8f7e5-211">응용 프로그램에서 충돌이 자주 발생하는 경우 스냅샷 격리는 적합한 방법이 될 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="8f7e5-211">If your application has many conflicts, snapshot isolation may not be the best choice.</span></span> <span data-ttu-id="8f7e5-212">힌트는 꼭 필요한 경우에만 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8f7e5-212">Hints should only be used when really needed.</span></span> <span data-ttu-id="8f7e5-213">작동 시 잠금 힌트를 계속해서 사용하도록 응용 프로그램을 디자인해서는 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="8f7e5-213">Your application should not be designed so that it constantly relies on lock hints for its operation.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="8f7e5-214">참고자료</span><span class="sxs-lookup"><span data-stu-id="8f7e5-214">See also</span></span>

- [<span data-ttu-id="8f7e5-215">SQL Server 및 ADO.NET</span><span class="sxs-lookup"><span data-stu-id="8f7e5-215">SQL Server and ADO.NET</span></span>](../../../../../docs/framework/data/adonet/sql/index.md)
- [<span data-ttu-id="8f7e5-216">ADO.NET 관리되는 공급자 및 데이터 집합 개발자 센터</span><span class="sxs-lookup"><span data-stu-id="8f7e5-216">ADO.NET Managed Providers and DataSet Developer Center</span></span>](https://go.microsoft.com/fwlink/?LinkId=217917)
- [<span data-ttu-id="8f7e5-217">트랜잭션 잠금 및 행 버전 관리 지침</span><span class="sxs-lookup"><span data-stu-id="8f7e5-217">Transaction Locking and Row Versioning Guide</span></span>](/sql/relational-databases/sql-server-transaction-locking-and-row-versioning-guide)

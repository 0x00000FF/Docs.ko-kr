---
title: SQL Server에서 권한 부여 및 권한
ms.date: 03/30/2017
ms.assetid: d340405c-91f4-4837-a3cc-a238ee89888a
ms.openlocfilehash: bdf5112e3f0e2cada4885b0b66adf248f0ffe808
ms.sourcegitcommit: f513a91160b3fec289dd06646d0d6f81f8fcf910
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 09/18/2018
ms.locfileid: "46007328"
---
# <a name="authorization-and-permissions-in-sql-server"></a><span data-ttu-id="b90e0-102">SQL Server에서 권한 부여 및 권한</span><span class="sxs-lookup"><span data-stu-id="b90e0-102">Authorization and Permissions in SQL Server</span></span>
<span data-ttu-id="b90e0-103">데이터베이스 개체를 만들 때는 사용자가 해당 개체에 액세스할 수 있도록 권한을 명시적으로 부여해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b90e0-103">When you create database objects, you must explicitly grant permissions to make them accessible to users.</span></span> <span data-ttu-id="b90e0-104">모든 보안 개체에는 권한 문을 통해 보안 주체에게 부여할 수 있는 권한이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b90e0-104">Every securable object has permissions that can be granted to a principal using permission statements.</span></span>  
  
## <a name="the-principle-of-least-privilege"></a><span data-ttu-id="b90e0-105">최소 권한의 원칙</span><span class="sxs-lookup"><span data-stu-id="b90e0-105">The Principle of Least Privilege</span></span>  
 <span data-ttu-id="b90e0-106">LUA(최소 권한 사용자 계정) 방식을 사용하여 응용 프로그램을 개발하는 것은 보안 위협에 대처하는 심층적인 방어 전략을 구현하는 데 있어 매우 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="b90e0-106">Developing an application using a least-privileged user account (LUA) approach is an important part of a defensive, in-depth strategy for countering security threats.</span></span> <span data-ttu-id="b90e0-107">LUA 방식을 사용할 경우 사용자는 최소 권한의 원칙에 따라야 하며, 항상 제한된 사용자 계정으로 로그온해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b90e0-107">The LUA approach ensures that users follow the principle of least privilege and always log on with limited user accounts.</span></span> <span data-ttu-id="b90e0-108">관리 작업은 고정 서버 역할을 통해 분산되며 `sysadmin` 고정 서버 역할의 사용은 엄격하게 제한됩니다.</span><span class="sxs-lookup"><span data-stu-id="b90e0-108">Administrative tasks are broken out using fixed server roles, and the use of the `sysadmin` fixed server role is severely restricted.</span></span>  
  
 <span data-ttu-id="b90e0-109">데이터베이스 사용자에게 권한을 부여할 때는 항상 최소 권한의 원칙에 따라</span><span class="sxs-lookup"><span data-stu-id="b90e0-109">Always follow the principle of least privilege when granting permissions to database users.</span></span> <span data-ttu-id="b90e0-110">지정된 작업을 수행하는 데 필요한 최소한의 권한을 사용자 또는 역할에 부여해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b90e0-110">Grant the minimum permissions necessary to a user or role to accomplish a given task.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="b90e0-111">LUA 방식을 사용하여 응용 프로그램을 개발하고 테스트하면 개발 프로세스가 더 복잡해집니다.</span><span class="sxs-lookup"><span data-stu-id="b90e0-111">Developing and testing an application using the LUA approach adds a degree of difficulty to the development process.</span></span> <span data-ttu-id="b90e0-112">시스템 관리자나 데이터베이스 소유자로 로그온하면 LUA 계정을 사용할 때보다 개체를 만들고 코드를 작성하는 것이 훨씬 쉽습니다.</span><span class="sxs-lookup"><span data-stu-id="b90e0-112">It is easier to create objects and write code while logged on as a system administrator or database owner than it is using a LUA account.</span></span> <span data-ttu-id="b90e0-113">그러나 높은 수준의 권한을 가진 계정을 사용하여 응용 프로그램을 개발하면 최소 권한을 가진 사용자가 높은 수준의 권한이 필요한 응용 프로그램을 실행하려고 할 때 기능이 제한되기 때문에 이로 인해 문제가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b90e0-113">However, developing applications using a highly privileged account can obfuscate the impact of reduced functionality when least privileged users attempt to run an application that requires elevated permissions in order to function correctly.</span></span> <span data-ttu-id="b90e0-114">사용할 수 없는 기능을 사용할 수 있도록 사용자에게 권한을 과도하게 부여하면 응용 프로그램이 공격에 쉽게 노출될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b90e0-114">Granting excessive permissions to users in order to reacquire lost functionality can leave your application vulnerable to attack.</span></span> <span data-ttu-id="b90e0-115">LUA 계정으로 로그온하여 응용 프로그램을 디자인, 개발 및 테스트하면 보안을 보다 체계적으로 계획하여 예기치 않은 문제를 방지할 수 있을 뿐만 아니라 임시 방편으로 높은 권한을 부여하는 위험을 제거할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b90e0-115">Designing, developing and testing your application logged on with a LUA account enforces a disciplined approach to security planning that eliminates unpleasant surprises and the temptation to grant elevated privileges as a quick fix.</span></span> <span data-ttu-id="b90e0-116">Windows 인증을 사용하여 배포하도록 응용 프로그램을 개발하는 경우에도 SQL Server 로그인을 사용하여 테스트할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b90e0-116">You can use a SQL Server login for testing even if your application is intended to deploy using Windows authentication.</span></span>  
  
## <a name="role-based-permissions"></a><span data-ttu-id="b90e0-117">역할 기반 권한</span><span class="sxs-lookup"><span data-stu-id="b90e0-117">Role-Based Permissions</span></span>  
 <span data-ttu-id="b90e0-118">사용자가 아닌 역할에 권한을 부여하면 더 간편하게 보안을 관리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b90e0-118">Granting permissions to roles rather than to users simplifies security administration.</span></span> <span data-ttu-id="b90e0-119">역할에 할당한 권한 집합은 해당 역할의 모든 멤버에게 상속됩니다.</span><span class="sxs-lookup"><span data-stu-id="b90e0-119">Permission sets that are assigned to roles are inherited by all members of the role.</span></span> <span data-ttu-id="b90e0-120">개별 사용자에 대해 별도의 권한 집합을 다시 만드는 것보다는 역할에 사용자를 추가하거나 역할에서 사용자를 제거하는 것이 쉽습니다.</span><span class="sxs-lookup"><span data-stu-id="b90e0-120">It is easier to add or remove users from a role than it is to recreate separate permission sets for individual users.</span></span> <span data-ttu-id="b90e0-121">역할은 중첩될 수 있지만 너무 많이 중첩하면 성능이 저하될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b90e0-121">Roles can be nested; however, too many levels of nesting can degrade performance.</span></span> <span data-ttu-id="b90e0-122">고정 데이터베이스 역할에 사용자를 추가하여 권한 할당 작업을 간소화할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b90e0-122">You can also add users to fixed database roles to simplify assigning permissions.</span></span>  
  
 <span data-ttu-id="b90e0-123">스키마 수준에서 권한을 부여할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b90e0-123">You can grant permissions at the schema level.</span></span> <span data-ttu-id="b90e0-124">이렇게 하면 스키마에 새로 만드는 모든 개체에 대한 권한이 자동으로 사용자에게 상속되기 때문에 새 개체를 만들 때마다 권한을 부여하지 않아도 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b90e0-124">Users automatically inherit permissions on all new objects created in the schema; you do not need to grant permissions as new objects are created.</span></span>  
  
## <a name="permissions-through-procedural-code"></a><span data-ttu-id="b90e0-125">프로시저 코드를 통한 권한 부여</span><span class="sxs-lookup"><span data-stu-id="b90e0-125">Permissions Through Procedural Code</span></span>  
 <span data-ttu-id="b90e0-126">저장 프로시저 및 사용자 정의 함수와 같은 모듈을 통해 데이터 액세스를 캡슐화하면 응용 프로그램의 보안을 강화할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b90e0-126">Encapsulating data access through modules such as stored procedures and user-defined functions provides an additional layer of protection around your application.</span></span> <span data-ttu-id="b90e0-127">예를 들어 저장 프로시저나 함수에 대한 권한만 부여하고 테이블과 같은 기본 개체에 대한 권한은 거부하여 사용자가 데이터베이스 개체와 직접 상호 작용하지 못하게 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b90e0-127">You can prevent users from directly interacting with database objects by granting permissions only to stored procedures or functions while denying permissions to underlying objects such as tables.</span></span> <span data-ttu-id="b90e0-128">SQL Server에서는 소유권 체인을 통해 이러한 설정을 구현할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b90e0-128">SQL Server achieves this by ownership chaining.</span></span>  
  
## <a name="permission-statements"></a><span data-ttu-id="b90e0-129">권한 문</span><span class="sxs-lookup"><span data-stu-id="b90e0-129">Permission Statements</span></span>  
 <span data-ttu-id="b90e0-130">다음 표에서는 세 가지 Transact-SQL 권한 문에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="b90e0-130">The three Transact-SQL permission statements are described in the following table.</span></span>  
  
|<span data-ttu-id="b90e0-131">권한 문</span><span class="sxs-lookup"><span data-stu-id="b90e0-131">Permission Statement</span></span>|<span data-ttu-id="b90e0-132">설명</span><span class="sxs-lookup"><span data-stu-id="b90e0-132">Description</span></span>|  
|--------------------------|-----------------|  
|<span data-ttu-id="b90e0-133">GRANT</span><span class="sxs-lookup"><span data-stu-id="b90e0-133">GRANT</span></span>|<span data-ttu-id="b90e0-134">권한을 부여합니다.</span><span class="sxs-lookup"><span data-stu-id="b90e0-134">Grants a permission.</span></span>|  
|<span data-ttu-id="b90e0-135">REVOKE</span><span class="sxs-lookup"><span data-stu-id="b90e0-135">REVOKE</span></span>|<span data-ttu-id="b90e0-136">권한을 취소합니다.</span><span class="sxs-lookup"><span data-stu-id="b90e0-136">Revokes a permission.</span></span> <span data-ttu-id="b90e0-137">이것은 새 개체의 기본 상태입니다.</span><span class="sxs-lookup"><span data-stu-id="b90e0-137">This is the default state of a new object.</span></span> <span data-ttu-id="b90e0-138">사용자나 역할에 대해 취소한 권한은 해당 보안 주체가 할당된 다른 그룹이나 역할로부터 여전히 상속될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b90e0-138">A permission revoked from a user or role can still be inherited from other groups or roles to which the principal is assigned.</span></span>|  
|<span data-ttu-id="b90e0-139">DENY</span><span class="sxs-lookup"><span data-stu-id="b90e0-139">DENY</span></span>|<span data-ttu-id="b90e0-140">DENY는 권한을 상속할 수 없도록 취소합니다.</span><span class="sxs-lookup"><span data-stu-id="b90e0-140">DENY revokes a permission so that it cannot be inherited.</span></span> <span data-ttu-id="b90e0-141">DENY는 다른 모든 권한보다 우선적으로 적용됩니다. 단, 개체 소유자 또는 `sysadmin`의 멤버에는 DENY가 적용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="b90e0-141">DENY takes precedence over all permissions, except DENY does not apply to object owners or members of `sysadmin`.</span></span> <span data-ttu-id="b90e0-142">`public` 역할에서 개체에 대한 권한을 DENY로 설정하면 해당 권한은 개체 소유자와 `sysadmin` 멤버를 제외한 모든 사용자와 역할에 대해 거부됩니다.</span><span class="sxs-lookup"><span data-stu-id="b90e0-142">If you DENY permissions on an object to the `public` role it is denied to all users and roles except for object owners and `sysadmin` members.</span></span>|  
  
-   <span data-ttu-id="b90e0-143">GRANT 문을 사용하면 그룹 또는 역할에 권한을 할당할 수 있으며 데이터베이스 사용자는 이 그룹 또는 역할에서 권한을 상속할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b90e0-143">The GRANT statement can assign permissions to a group or role that can be inherited by database users.</span></span> <span data-ttu-id="b90e0-144">그러나 DENY 문은 다른 모든 권한 문보다 우선적으로 적용되므로</span><span class="sxs-lookup"><span data-stu-id="b90e0-144">However, the DENY statement takes precedence over all other permission statements.</span></span> <span data-ttu-id="b90e0-145">권한이 거부된 사용자는 다른 역할에서 해당 권한을 상속할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="b90e0-145">Therefore, a user who has been denied a permission cannot inherit it from another role.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b90e0-146">`sysadmin` 고정 서버 역할의 멤버 및 개체 소유자의 권한은 거부할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="b90e0-146">Members of the `sysadmin` fixed server role and object owners cannot be denied permissions.</span></span>  
  
## <a name="ownership-chains"></a><span data-ttu-id="b90e0-147">소유권 체인</span><span class="sxs-lookup"><span data-stu-id="b90e0-147">Ownership Chains</span></span>  
 <span data-ttu-id="b90e0-148">SQL Server에서는 권한이 부여된 보안 주체만 개체에 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b90e0-148">SQL Server ensures that only principals that have been granted permission can access objects.</span></span> <span data-ttu-id="b90e0-149">여러 데이터베이스 개체가 서로 액세스하는 시퀀스를 체인이라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="b90e0-149">When multiple database objects access each other, the sequence is known as a chain.</span></span> <span data-ttu-id="b90e0-150">개체 체인의 링크에서 이동할 때 SQL Server는 각 개체를 개별적으로 액세스할 때와는 다른 방법으로 권한을 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="b90e0-150">When SQL Server is traversing the links in the chain, it evaluates permissions differently than it would if it were accessing each item separately.</span></span> <span data-ttu-id="b90e0-151">체인을 통해 개체에 액세스할 경우 SQL Server는 먼저 개체의 소유자와 해당 개체를 호출한 소유자(체인의 이전 링크)를 비교합니다.</span><span class="sxs-lookup"><span data-stu-id="b90e0-151">When an object is accessed through a chain, SQL Server first compares the object's owner to the owner of the calling object (the previous link in the chain).</span></span> <span data-ttu-id="b90e0-152">두 개체의 소유자가 같으면 참조되는 개체의 권한을 확인하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="b90e0-152">If both objects have the same owner, permissions on the referenced object are not checked.</span></span> <span data-ttu-id="b90e0-153">그러나 개체가 소유자가 서로 다른 또 하나의 개체에 액세스할 때마다 소유권 체인은 끊어지고 SQL Server는 호출자의 보안 컨텍스트를 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="b90e0-153">Whenever an object accesses another object that has a different owner, the ownership chain is broken and SQL Server must check the caller's security context.</span></span>  
  
## <a name="procedural-code-and-ownership-chaining"></a><span data-ttu-id="b90e0-154">프로시저 코드 및 소유권 체인</span><span class="sxs-lookup"><span data-stu-id="b90e0-154">Procedural Code and Ownership Chaining</span></span>  
 <span data-ttu-id="b90e0-155">사용자가 테이블에서 데이터를 선택하는 저장 프로시저에 대한 실행 권한을 가지고 있다고 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="b90e0-155">Suppose that a user is granted execute permissions on a stored procedure that selects data from a table.</span></span> <span data-ttu-id="b90e0-156">이 저장 프로시저와 테이블의 소유자가 동일하면 사용자에게 테이블에 대한 별도의 권한을 부여할 필요가 없으며 해당 사용자의 권한을 거부할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b90e0-156">If the stored procedure and the table have the same owner, the user doesn't need to be granted any permissions on the table and can even be denied permissions.</span></span> <span data-ttu-id="b90e0-157">그러나 저장 프로시저와 테이블의 소유자가 서로 다르면 SQL Server는 데이터에 대한 액세스를 허용하기 전에 테이블에 대한 사용자의 권한을 확인해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b90e0-157">However, if the stored procedure and the table have different owners, SQL Server must check the user's permissions on the table before allowing access to the data.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b90e0-158">소유권 체인은 동적 SQL 문에는 적용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="b90e0-158">Ownership chaining does not apply in the case of dynamic SQL statements.</span></span> <span data-ttu-id="b90e0-159">SQL 문을 실행하는 프로시저를 호출하려면 호출자에게 기본 테이블에 대한 권한을 부여해야 하기 때문에 결과적으로 응용 프로그램이 SQL 삽입 공격에 노출될 위험이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b90e0-159">To call a procedure that executes an SQL statement, the caller must be granted permissions on the underlying tables, leaving your application vulnerable to SQL Injection attack.</span></span> <span data-ttu-id="b90e0-160">SQL Server에서는 가장 및 인증서를 사용한 모듈 서명과 같은 새로운 메커니즘을 제공하므로 기본 테이블에 대한 권한을 부여하지 않아도 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b90e0-160">SQL Server provides new mechanisms, such as impersonation and signing modules with certificates, that do not require granting permissions on the underlying tables.</span></span> <span data-ttu-id="b90e0-161">이러한 기능은 CLR 저장 프로시저에 대해서도 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b90e0-161">These can also be used with CLR stored procedures.</span></span>  
  
## <a name="external-resources"></a><span data-ttu-id="b90e0-162">외부 리소스</span><span class="sxs-lookup"><span data-stu-id="b90e0-162">External Resources</span></span>  
 <span data-ttu-id="b90e0-163">자세한 내용은 다음 리소스를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="b90e0-163">For more information, see the following resources.</span></span>  
  
|<span data-ttu-id="b90e0-164">리소스</span><span class="sxs-lookup"><span data-stu-id="b90e0-164">Resource</span></span>|<span data-ttu-id="b90e0-165">설명</span><span class="sxs-lookup"><span data-stu-id="b90e0-165">Description</span></span>|  
|--------------|-----------------|  
|[<span data-ttu-id="b90e0-166">권한</span><span class="sxs-lookup"><span data-stu-id="b90e0-166">Permissions</span></span>](/sql/relational-databases/security/permissions-database-engine)|<span data-ttu-id="b90e0-167">권한 계층 구조, 카탈로그 뷰, 고정 서버 역할 및 데이터베이스 역할의 권한에 대해 설명하는 항목을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="b90e0-167">Contains topics describing permissions hierarchy, catalog views, and permissions of fixed server and database roles.</span></span>|
  
## <a name="see-also"></a><span data-ttu-id="b90e0-168">참고 항목</span><span class="sxs-lookup"><span data-stu-id="b90e0-168">See Also</span></span>  
 [<span data-ttu-id="b90e0-169">ADO.NET 응용 프로그램 보안</span><span class="sxs-lookup"><span data-stu-id="b90e0-169">Securing ADO.NET Applications</span></span>](../../../../../docs/framework/data/adonet/securing-ado-net-applications.md)  
 [<span data-ttu-id="b90e0-170">SQL Server의 응용 프로그램 보안 시나리오</span><span class="sxs-lookup"><span data-stu-id="b90e0-170">Application Security Scenarios in SQL Server</span></span>](../../../../../docs/framework/data/adonet/sql/application-security-scenarios-in-sql-server.md)  
 [<span data-ttu-id="b90e0-171">SQL Server에서 인증</span><span class="sxs-lookup"><span data-stu-id="b90e0-171">Authentication in SQL Server</span></span>](../../../../../docs/framework/data/adonet/sql/authentication-in-sql-server.md)  
 [<span data-ttu-id="b90e0-172">SQL Server의 서버 및 데이터베이스 역할</span><span class="sxs-lookup"><span data-stu-id="b90e0-172">Server and Database Roles in SQL Server</span></span>](../../../../../docs/framework/data/adonet/sql/server-and-database-roles-in-sql-server.md)  
 [<span data-ttu-id="b90e0-173">SQL Server에서 소유권 및 사용자 스키마 분리</span><span class="sxs-lookup"><span data-stu-id="b90e0-173">Ownership and User-Schema Separation in SQL Server</span></span>](../../../../../docs/framework/data/adonet/sql/ownership-and-user-schema-separation-in-sql-server.md)  
 [<span data-ttu-id="b90e0-174">ADO.NET 관리되는 공급자 및 데이터 집합 개발자 센터</span><span class="sxs-lookup"><span data-stu-id="b90e0-174">ADO.NET Managed Providers and DataSet Developer Center</span></span>](https://go.microsoft.com/fwlink/?LinkId=217917)

---
title: 데이터 세트 콘텐츠 병합
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: e5e9309a-3ebb-4a9c-9d78-21c4e2bafc5b
ms.openlocfilehash: 38d716552c4a52e01ef803ce197e4d588ed562c3
ms.sourcegitcommit: 6eac9a01ff5d70c6d18460324c016a3612c5e268
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 09/15/2018
ms.locfileid: "45658797"
---
# <a name="merging-dataset-contents"></a><span data-ttu-id="a3d84-102">데이터 세트 콘텐츠 병합</span><span class="sxs-lookup"><span data-stu-id="a3d84-102">Merging DataSet Contents</span></span>
<span data-ttu-id="a3d84-103"><xref:System.Data.DataSet.Merge%2A> 메서드를 사용하여 <xref:System.Data.DataSet>, <xref:System.Data.DataTable> 또는 <xref:System.Data.DataRow> 배열의 내용을 기존 `DataSet`으로 병합할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a3d84-103">You can use the <xref:System.Data.DataSet.Merge%2A> method to merge the contents of a <xref:System.Data.DataSet>, <xref:System.Data.DataTable>, or <xref:System.Data.DataRow> array into an existing `DataSet`.</span></span> <span data-ttu-id="a3d84-104">새 데이터가 기존 `DataSet`으로 병합되는 방법은 몇 가지 요소 및 옵션에 따라 달라집니다.</span><span class="sxs-lookup"><span data-stu-id="a3d84-104">Several factors and options affect how new data is merged into an existing `DataSet`.</span></span>  
  
## <a name="primary-keys"></a><span data-ttu-id="a3d84-105">기본 키</span><span class="sxs-lookup"><span data-stu-id="a3d84-105">Primary Keys</span></span>  
 <span data-ttu-id="a3d84-106">병합을 통해 새 데이터와 스키마를 받는 테이블에 기본 키가 있는 경우 들어오는 데이터의 새 행은 들어오는 데이터의 행과 동일한 <xref:System.Data.DataRowVersion.Original> 기본 키 값을 가진 기존 행이 있는지 비교됩니다.</span><span class="sxs-lookup"><span data-stu-id="a3d84-106">If the table receiving new data and schema from a merge has a primary key, new rows from the incoming data are matched with existing rows that have the same <xref:System.Data.DataRowVersion.Original> primary key values as those in the incoming data.</span></span> <span data-ttu-id="a3d84-107">들어오는 스키마의 열이 기존 스키마의 열과 일치하면 기존 행의 데이터가 수정됩니다.</span><span class="sxs-lookup"><span data-stu-id="a3d84-107">If the columns from the incoming schema match those of the existing schema, the data in the existing rows is modified.</span></span> <span data-ttu-id="a3d84-108">기존 스키마와 일치하지 않는 열은 <xref:System.Data.Common.DataAdapter.MissingSchemaAction%2A> 매개 변수에 따라 무시되거나 추가됩니다.</span><span class="sxs-lookup"><span data-stu-id="a3d84-108">Columns that do not match the existing schema are either ignored or added based on the <xref:System.Data.Common.DataAdapter.MissingSchemaAction%2A> parameter.</span></span> <span data-ttu-id="a3d84-109">기존 행과 일치하지 않는 기본 키 값을 가진 새 행은 기존 테이블에 추가됩니다.</span><span class="sxs-lookup"><span data-stu-id="a3d84-109">New rows with primary key values that do not match any existing rows are appended to the existing table.</span></span>  
  
 <span data-ttu-id="a3d84-110">들어오는 행 또는 기존 행의 상태가 <xref:System.Data.DataRowState.Added>이면 <xref:System.Data.DataRowVersion.Current> 행 버전이 없으므로 해당 기본 키 값은 `Added` 행의 `Original` 기본 키 값을 사용하여 비교됩니다.</span><span class="sxs-lookup"><span data-stu-id="a3d84-110">If incoming or existing rows have a row state of <xref:System.Data.DataRowState.Added>, their primary key values are matched using the <xref:System.Data.DataRowVersion.Current> primary key value of the `Added` row because no `Original` row version exists.</span></span>  
  
 <span data-ttu-id="a3d84-111">들어오는 테이블과 기존 테이블에 이름은 같지만 데이터 형식이 다른 열이 있으면 예외가 throw되고 <xref:System.Data.DataSet.MergeFailed>의 `DataSet` 이벤트가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="a3d84-111">If an incoming table and an existing table contain a column with the same name but different data types, an exception is thrown and the <xref:System.Data.DataSet.MergeFailed> event of the `DataSet` is raised.</span></span> <span data-ttu-id="a3d84-112">들어오는 테이블과 기존 테이블에 모두 키가 정의되어 있지만 각 열의 기본 키가 서로 다르면 예외가 throw되고 `MergeFailed`의 `DataSet` 이벤트가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="a3d84-112">If an incoming table and an existing table both have defined keys, but the primary keys are for different columns, an exception is thrown and the `MergeFailed` event of the `DataSet` is raised.</span></span>  
  
 <span data-ttu-id="a3d84-113">병합을 통해 새 데이터를 받는 테이블에 기본 키가 없으면 들어오는 데이터의 새 행이 테이블의 기존 행과 일치할 수는 없고, 대신 기존 테이블에 추가됩니다.</span><span class="sxs-lookup"><span data-stu-id="a3d84-113">If the table receiving new data from a merge does not have a primary key, new rows from the incoming data cannot be matched to existing rows in the table and are instead appended to the existing table.</span></span>  
  
## <a name="table-names-and-namespaces"></a><span data-ttu-id="a3d84-114">테이블 이름 및 네임스페이스</span><span class="sxs-lookup"><span data-stu-id="a3d84-114">Table Names and Namespaces</span></span>  
 <span data-ttu-id="a3d84-115"><xref:System.Data.DataTable> 개체에는 선택적으로 <xref:System.Data.DataTable.Namespace%2A> 속성 값을 할당할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a3d84-115"><xref:System.Data.DataTable> objects can optionally be assigned a <xref:System.Data.DataTable.Namespace%2A> property value.</span></span> <span data-ttu-id="a3d84-116"><xref:System.Data.DataTable.Namespace%2A> 값이 할당된 경우 <xref:System.Data.DataSet>에는 <xref:System.Data.DataTable> 값이 같은 여러 <xref:System.Data.DataTable.TableName%2A> 개체가 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a3d84-116">When <xref:System.Data.DataTable.Namespace%2A> values are assigned, a <xref:System.Data.DataSet> can contain multiple <xref:System.Data.DataTable> objects with the same <xref:System.Data.DataTable.TableName%2A> value.</span></span> <span data-ttu-id="a3d84-117">병합 작업 도중 <xref:System.Data.DataTable.TableName%2A> 및 <xref:System.Data.DataTable.Namespace%2A>를 사용하여 병합의 대상을 식별합니다.</span><span class="sxs-lookup"><span data-stu-id="a3d84-117">During merge operations, both <xref:System.Data.DataTable.TableName%2A> and <xref:System.Data.DataTable.Namespace%2A> are used to identify the target of a merge.</span></span> <span data-ttu-id="a3d84-118"><xref:System.Data.DataTable.Namespace%2A>가 할당되지 않은 경우에는 <xref:System.Data.DataTable.TableName%2A>만 사용하여 병합의 대상을 식별합니다.</span><span class="sxs-lookup"><span data-stu-id="a3d84-118">If no <xref:System.Data.DataTable.Namespace%2A> has been assigned, only the <xref:System.Data.DataTable.TableName%2A> is used to identify the target of a merge.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a3d84-119">이는 .NET Framework의 버전 2.0에서 변경된 동작입니다.</span><span class="sxs-lookup"><span data-stu-id="a3d84-119">This behavior changed in version 2.0 of the .NET Framework.</span></span> <span data-ttu-id="a3d84-120">버전 1.1에서는 네임스페이스가 지원되었지만 병합 작업 도중 무시되었습니다.</span><span class="sxs-lookup"><span data-stu-id="a3d84-120">In version 1.1, namespaces were supported but were ignored during merge operations.</span></span> <span data-ttu-id="a3d84-121">이러한 이유로 <xref:System.Data.DataSet> 속성 값을 사용하는 <xref:System.Data.DataTable.Namespace%2A>은 실행 중인 .NET Framework의 버전에 따라 다르게 동작합니다.</span><span class="sxs-lookup"><span data-stu-id="a3d84-121">For this reason, a <xref:System.Data.DataSet> that uses <xref:System.Data.DataTable.Namespace%2A> property values will have different behaviors depending on which version of the .NET Framework you are running.</span></span> <span data-ttu-id="a3d84-122">예를 들어 `DataSets` 속성 값은 같지만 `DataTables` 속성 값이 다른 <xref:System.Data.DataTable.TableName%2A>가 있는 두 개의 <xref:System.Data.DataTable.Namespace%2A>가 있다고 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="a3d84-122">For example, suppose you have two `DataSets` containing `DataTables` with the same <xref:System.Data.DataTable.TableName%2A> property values but different <xref:System.Data.DataTable.Namespace%2A> property values.</span></span> <span data-ttu-id="a3d84-123">.NET Framework의 버전 1.1에서는 두 <xref:System.Data.DataTable.Namespace%2A> 개체를 병합할 때 서로 다른 <xref:System.Data.DataSet> 이름은 무시됩니다.</span><span class="sxs-lookup"><span data-stu-id="a3d84-123">In version 1.1 of the .NET Framework, the different <xref:System.Data.DataTable.Namespace%2A> names will be ignored when merging the two <xref:System.Data.DataSet> objects.</span></span> <span data-ttu-id="a3d84-124">하지만 버전 2.0부터는 병합할 경우 두 개의 새로운 `DataTables`가 대상 <xref:System.Data.DataSet>에 생성됩니다.</span><span class="sxs-lookup"><span data-stu-id="a3d84-124">However, starting with version 2.0, merging causes two new `DataTables` to be created in the target <xref:System.Data.DataSet>.</span></span> <span data-ttu-id="a3d84-125">원래의 `DataTables`는 병합의 영향을 받지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="a3d84-125">The original `DataTables` will be unaffected by the merge.</span></span>  
  
## <a name="preservechanges"></a><span data-ttu-id="a3d84-126">PreserveChanges</span><span class="sxs-lookup"><span data-stu-id="a3d84-126">PreserveChanges</span></span>  
 <span data-ttu-id="a3d84-127">`DataSet`, `DataTable` 또는 `DataRow` 배열을 `Merge` 메서드로 전달할 때는 기존 `DataSet`의 변경 내용을 유지할 것인지 여부와 들어오는 데이터에서 발견되는 새 스키마 요소를 처리하는 방법을 지정하는 선택적 매개 변수를 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a3d84-127">When you pass a `DataSet`, `DataTable`, or `DataRow` array to the `Merge` method, you can include optional parameters that specify whether or not to preserve changes in the existing `DataSet`, and how to handle new schema elements found in the incoming data.</span></span> <span data-ttu-id="a3d84-128">들어오는 데이터 다음에 나오는 이러한 매개 변수 중 첫 번째는 부울 플래그인 <xref:System.Data.LoadOption.PreserveChanges>이며, 이 플래그는 기존 `DataSet`의 변경 내용을 유지할지 여부를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="a3d84-128">The first of these parameters after the incoming data is a Boolean flag, <xref:System.Data.LoadOption.PreserveChanges>, which specifies whether or not to preserve the changes in the existing `DataSet`.</span></span> <span data-ttu-id="a3d84-129">`PreserveChanges` 플래그가 `true`로 설정되어 있으면 들어오는 값은 기존 행의 `Current` 행 버전에 있는 기존 값을 덮어쓰지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="a3d84-129">If the `PreserveChanges` flag is set to `true`, incoming values do not overwrite existing values in the `Current` row version of the existing row.</span></span> <span data-ttu-id="a3d84-130">`PreserveChanges` 플래그가 `false`로 설정되어 있으면 들어오는 값은 기존 행의 `Current` 행 버전에 있는 기존 값을 덮어씁니다.</span><span class="sxs-lookup"><span data-stu-id="a3d84-130">If the `PreserveChanges` flag is set to `false`, incoming values do overwrite the existing values in the `Current` row version of the existing row.</span></span> <span data-ttu-id="a3d84-131">`PreserveChanges` 플래그를 지정하지 않으면 `false`가 기본값으로 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="a3d84-131">If the `PreserveChanges` flag is not specified, it is set to `false` by default.</span></span> <span data-ttu-id="a3d84-132">행 버전에 대 한 자세한 내용은 참조 하세요. [행 상태 및 행 버전](../../../../../docs/framework/data/adonet/dataset-datatable-dataview/row-states-and-row-versions.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="a3d84-132">For more information about row versions, see [Row States and Row Versions](../../../../../docs/framework/data/adonet/dataset-datatable-dataview/row-states-and-row-versions.md).</span></span>  
  
 <span data-ttu-id="a3d84-133">`PreserveChanges`가 `true`이면 기존 행의 데이터는 기존 행의 <xref:System.Data.DataRowVersion.Current> 행 버전에 유지되지만 기존 행의 <xref:System.Data.DataRowVersion.Original> 행 버전에 있는 데이터는 들어오는 행의 `Original` 행 버전에 있는 데이터로 덮어쓰여집니다.</span><span class="sxs-lookup"><span data-stu-id="a3d84-133">When `PreserveChanges` is `true`, the data from the existing row is maintained in the <xref:System.Data.DataRowVersion.Current> row version of the existing row, while the data from the <xref:System.Data.DataRowVersion.Original> row version of the existing row is overwritten with the data from the `Original` row version of the incoming row.</span></span> <span data-ttu-id="a3d84-134">기존 행의 <xref:System.Data.DataRow.RowState%2A>는 <xref:System.Data.DataRowState.Modified>로 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="a3d84-134">The <xref:System.Data.DataRow.RowState%2A> of the existing row is set to <xref:System.Data.DataRowState.Modified>.</span></span> <span data-ttu-id="a3d84-135">다음과 같은 예외가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a3d84-135">The following exceptions apply:</span></span>  
  
-   <span data-ttu-id="a3d84-136">기존 행의 `RowState`가 `Deleted`인 경우 이 `RowState`는 `Deleted`로 유지되며 `Modified`로 설정되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="a3d84-136">If the existing row has a `RowState` of `Deleted`, this `RowState` remains `Deleted` and is not set to `Modified`.</span></span> <span data-ttu-id="a3d84-137">이 경우, 들어오는 행의 데이터는 기존 행의 `Original` 행 버전에 계속 저장되어 기존 행의 `Original` 행 버전을 덮어씁니다. 단, 들어오는 행의 `RowState`가 `Added`인 경우는 예외입니다.</span><span class="sxs-lookup"><span data-stu-id="a3d84-137">In this case, the data from the incoming row will still be stored in the `Original` row version of the existing row, overwriting the `Original` row version of the existing row (unless the incoming row has a `RowState` of `Added`).</span></span>  
  
-   <span data-ttu-id="a3d84-138">들어오는 행의 `RowState`가 `Added`이면 들어오는 행에 `Original` 행 버전이 없으므로 기존 행의 `Original` 행 버전 데이터가 들어오는 행의 데이터로 덮어쓰여지지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="a3d84-138">If the incoming row has a `RowState` of `Added`, the data from the `Original` row version of the existing row will not be overwritten with data from the incoming row, because the incoming row does not have an `Original` row version.</span></span>  
  
 <span data-ttu-id="a3d84-139">`PreserveChanges`가 `false`이면 기존 행의 `Current` 및 `Original` 행 버전이 들어오는 행의 데이터로 덮어쓰여지며 기존 행의 `RowState`는 들어오는 행의 `RowState`로 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="a3d84-139">When `PreserveChanges` is `false`, both the `Current` and `Original` row versions in the existing row are overwritten with the data from the incoming row, and the `RowState` of the existing row is set to the `RowState` of the incoming row.</span></span> <span data-ttu-id="a3d84-140">다음과 같은 예외가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a3d84-140">The following exceptions apply:</span></span>  
  
-   <span data-ttu-id="a3d84-141">들어오는 행의 `RowState`가 `Unchanged`이고 기존 행의 `RowState`가 `Modified`, `Deleted` 또는 `Added`이면 기존 행의 `RowState`가 `Modified`로 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="a3d84-141">If the incoming row has a `RowState` of `Unchanged` and the existing row has a `RowState` of `Modified`, `Deleted`, or `Added`, the `RowState` of the existing row is set to `Modified`.</span></span>  
  
-   <span data-ttu-id="a3d84-142">들어오는 행의 `RowState`가 `Added`이고 기존 행의 `RowState`가 `Unchanged`, `Modified` 또는 `Deleted`이면 기존 행의 `RowState`가 `Modified`로 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="a3d84-142">If the incoming row has a `RowState` of `Added`, and the existing row has a `RowState` of `Unchanged`, `Modified`, or `Deleted`, the `RowState` of the existing row is set to `Modified`.</span></span> <span data-ttu-id="a3d84-143">또한, 들어오는 행에 `Original` 행 버전이 없으므로 기존 행의 `Original` 행 버전 데이터는 들어오는 행의 데이터로 덮어쓰여지지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="a3d84-143">Also, the data from the `Original` row version of the existing row is not overwritten with data from the incoming row, because the incoming row does not have an `Original` row version.</span></span>  
  
## <a name="missingschemaaction"></a><span data-ttu-id="a3d84-144">MissingSchemaAction</span><span class="sxs-lookup"><span data-stu-id="a3d84-144">MissingSchemaAction</span></span>  
 <span data-ttu-id="a3d84-145"><xref:System.Data.MissingSchemaAction> 메서드의 선택적 `Merge` 매개 변수를 사용하면 기존 `Merge`에 포함되어 있지 않은 들어오는 데이터의 스키마 요소를 `DataSet`에서 어떻게 처리할지 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a3d84-145">You can use the optional <xref:System.Data.MissingSchemaAction> parameter of the `Merge` method to specify how `Merge` will handle schema elements in the incoming data that are not part of the existing `DataSet`.</span></span>  
  
 <span data-ttu-id="a3d84-146">다음 표에서는 `MissingSchemaAction`의 옵션을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="a3d84-146">The following table describes the options for `MissingSchemaAction`.</span></span>  
  
|<span data-ttu-id="a3d84-147">MissingSchemaAction 옵션</span><span class="sxs-lookup"><span data-stu-id="a3d84-147">MissingSchemaAction option</span></span>|<span data-ttu-id="a3d84-148">설명</span><span class="sxs-lookup"><span data-stu-id="a3d84-148">Description</span></span>|  
|--------------------------------|-----------------|  
|<xref:System.Data.MissingSchemaAction.Add>|<span data-ttu-id="a3d84-149">`DataSet`에 새 스키마 정보를 추가한 다음 새 열을 들어오는 값으로 채웁니다.</span><span class="sxs-lookup"><span data-stu-id="a3d84-149">Add the new schema information to the `DataSet` and populate the new columns with the incoming values.</span></span> <span data-ttu-id="a3d84-150">이 값이 기본값입니다.</span><span class="sxs-lookup"><span data-stu-id="a3d84-150">This is the default.</span></span>|  
|<xref:System.Data.MissingSchemaAction.AddWithKey>|<span data-ttu-id="a3d84-151">`DataSet`에 새 스키마와 기본 키 정보를 추가한 다음 새 열을 들어오는 값으로 채웁니다.</span><span class="sxs-lookup"><span data-stu-id="a3d84-151">Add the new schema and primary key information to the `DataSet` and populate the new columns with the incoming values.</span></span>|  
|<xref:System.Data.MissingSchemaAction.Error>|<span data-ttu-id="a3d84-152">일치하지 않는 스키마 정보가 발견되면 예외가 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="a3d84-152">Throw an exception if mismatched schema information is encountered.</span></span>|  
|<xref:System.Data.MissingSchemaAction.Ignore>|<span data-ttu-id="a3d84-153">새 스키마 정보를 무시합니다.</span><span class="sxs-lookup"><span data-stu-id="a3d84-153">Ignore the new schema information.</span></span>|  
  
## <a name="constraints"></a><span data-ttu-id="a3d84-154">제약 조건</span><span class="sxs-lookup"><span data-stu-id="a3d84-154">Constraints</span></span>  
 <span data-ttu-id="a3d84-155">`Merge` 메서드를 사용하면 새 데이터가 기존 `DataSet`에 모두 추가되기 전까지 제약 조건이 검사되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="a3d84-155">With the `Merge` method, constraints are not checked until all new data has been added to the existing `DataSet`.</span></span> <span data-ttu-id="a3d84-156">데이터가 추가되고 나면 `DataSet`의 현재 값에 제약 조건이 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="a3d84-156">Once the data has been added, constraints are enforced on the current values in the `DataSet`.</span></span> <span data-ttu-id="a3d84-157">제약 조건 위반으로 인해 throw되는 모든 예외를 처리하도록 코드를 작성해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a3d84-157">You must ensure that your code handles any exceptions that might be thrown due to constraint violations.</span></span>  
  
 <span data-ttu-id="a3d84-158">`DataSet`의 기존 행이 기본 키 값이 1인 `Unchanged` 행인 경우를 살펴보세요.</span><span class="sxs-lookup"><span data-stu-id="a3d84-158">Consider a case where an existing row in a `DataSet` is an `Unchanged` row with a primary key value of 1.</span></span> <span data-ttu-id="a3d84-159">`Modified` 기본 키 값이 2이고 `Original` 기본 키 값이 1인 `Current` 들어오는 행에 대해 병합 작업을 수행할 경우 `Original` 기본 키 값이 다르기 때문에 기존 행과 들어오는 행은 일치하지 않는 것으로 간주됩니다.</span><span class="sxs-lookup"><span data-stu-id="a3d84-159">During a merge operation with a `Modified` incoming row with an `Original` primary key value of 2 and a `Current` primary key value of 1, the existing row and the incoming row are not considered matching because the `Original` primary key values differ.</span></span> <span data-ttu-id="a3d84-160">그러나 병합을 완료하고 제약 조건을 검사하면 `Current` 기본 키 값이 기본 키 열의 UNIQUE 제약 조건을 위반하므로 예외가 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="a3d84-160">However, when the merge is completed and constraints are checked, an exception will be thrown because the `Current` primary key values violate the unique constraint for the primary key column.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a3d84-161">ID 열과 같은 자동 증분 열이 있는 데이터베이스 테이블에 행이 삽입되는 경우에는 삽입을 통해 반환되는 ID 열 값이 `DataSet`의 값과 일치하지 않을 수 있으므로 반환되는 행이 병합되는 대신 추가됩니다.</span><span class="sxs-lookup"><span data-stu-id="a3d84-161">When rows are inserted into a database table containing an auto incrementing column such as an identity column, the identity column value returned by the insert may not match the value in the `DataSet`, causing the returned rows to be appended instead of merged.</span></span> <span data-ttu-id="a3d84-162">자세한 내용은 [Retrieving Identity or Autonumber 값](../../../../../docs/framework/data/adonet/retrieving-identity-or-autonumber-values.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="a3d84-162">For more information, see [Retrieving Identity or Autonumber Values](../../../../../docs/framework/data/adonet/retrieving-identity-or-autonumber-values.md).</span></span>  
  
 <span data-ttu-id="a3d84-163">다음 코드 예제에서는 스키마가 서로 다른 두 개의 `DataSet` 개체를 들어오는 두 `DataSet` 개체의 스키마가 결합된 하나의 `DataSet`으로 병합합니다.</span><span class="sxs-lookup"><span data-stu-id="a3d84-163">The following code example merges two `DataSet` objects with differents schemas into one `DataSet` with the combined schemas of the two incoming `DataSet` objects.</span></span>  
  
 [!code-csharp[DataWorks DataSet.Merge#1](../../../../../samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataSet.Merge/CS/source.cs#1)]
 [!code-vb[DataWorks DataSet.Merge#1](../../../../../samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataSet.Merge/VB/source.vb#1)]  
  
 <span data-ttu-id="a3d84-164">다음 코드 예제에서는 업데이트 사항이 있는 기존 `DataSet`을 사용하여 해당 업데이트를 `DataAdapter`로 전달하여 데이터 소스에서 처리되도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="a3d84-164">The following code example takes an existing `DataSet` with updates and passes those updates to a `DataAdapter` to be processed at the data source.</span></span> <span data-ttu-id="a3d84-165">그러면 결과가 원래 `DataSet`에 병합됩니다.</span><span class="sxs-lookup"><span data-stu-id="a3d84-165">The results are then merged into the original `DataSet`.</span></span> <span data-ttu-id="a3d84-166">오류를 발생시킨 변경 내용이 거부된 후에는 병합된 변경 내용이 `AcceptChanges`를 사용하여 커밋됩니다.</span><span class="sxs-lookup"><span data-stu-id="a3d84-166">After rejecting changes that resulted in an error, the merged changes are committed with `AcceptChanges`.</span></span>  
  
 [!code-csharp[DataWorks DataSet.MergeAcceptChanges#1](../../../../../samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataSet.MergeAcceptChanges/CS/source.cs#1)]
 [!code-vb[DataWorks DataSet.MergeAcceptChanges#1](../../../../../samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataSet.MergeAcceptChanges/VB/source.vb#1)]  
  
 [!code-csharp[DataWorks DataSet.MergeAcceptChanges#2](../../../../../samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataSet.MergeAcceptChanges/CS/source.cs#2)]
 [!code-vb[DataWorks DataSet.MergeAcceptChanges#2](../../../../../samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataSet.MergeAcceptChanges/VB/source.vb#2)]  
  
## <a name="see-also"></a><span data-ttu-id="a3d84-167">참고 항목</span><span class="sxs-lookup"><span data-stu-id="a3d84-167">See Also</span></span>  
 [<span data-ttu-id="a3d84-168">DataSet, DataTable 및 DataView</span><span class="sxs-lookup"><span data-stu-id="a3d84-168">DataSets, DataTables, and DataViews</span></span>](../../../../../docs/framework/data/adonet/dataset-datatable-dataview/index.md)  
 [<span data-ttu-id="a3d84-169">행 상태 및 행 버전</span><span class="sxs-lookup"><span data-stu-id="a3d84-169">Row States and Row Versions</span></span>](../../../../../docs/framework/data/adonet/dataset-datatable-dataview/row-states-and-row-versions.md)  
 [<span data-ttu-id="a3d84-170">DataAdapter 및 DataReader</span><span class="sxs-lookup"><span data-stu-id="a3d84-170">DataAdapters and DataReaders</span></span>](../../../../../docs/framework/data/adonet/dataadapters-and-datareaders.md)  
 [<span data-ttu-id="a3d84-171">ADO.NET에서 데이터 검색 및 수정</span><span class="sxs-lookup"><span data-stu-id="a3d84-171">Retrieving and Modifying Data in ADO.NET</span></span>](../../../../../docs/framework/data/adonet/retrieving-and-modifying-data.md)  
 [<span data-ttu-id="a3d84-172">ID 또는 일련 번호 값 검색</span><span class="sxs-lookup"><span data-stu-id="a3d84-172">Retrieving Identity or Autonumber Values</span></span>](../../../../../docs/framework/data/adonet/retrieving-identity-or-autonumber-values.md)  
 [<span data-ttu-id="a3d84-173">ADO.NET 관리되는 공급자 및 데이터 집합 개발자 센터</span><span class="sxs-lookup"><span data-stu-id="a3d84-173">ADO.NET Managed Providers and DataSet Developer Center</span></span>](https://go.microsoft.com/fwlink/?LinkId=217917)

---
title: Entity Framework 개요
ms.date: 09/17/2018
ms.assetid: a2166b3d-d8ba-4a0a-8552-6ba1e3eaaee0
ms.openlocfilehash: c79055adc2be12a5806fe5e8ff129b6ecd3d76f5
ms.sourcegitcommit: c4e9d05644c9cb89de5ce6002723de107ea2e2c4
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 05/19/2019
ms.locfileid: "65880027"
---
# <a name="entity-framework-overview"></a><span data-ttu-id="4d0fa-102">Entity Framework 개요</span><span class="sxs-lookup"><span data-stu-id="4d0fa-102">Entity Framework overview</span></span>

<span data-ttu-id="4d0fa-103">[!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)]는 데이터 지향 소프트웨어 응용 프로그램의 개발을 지원하는 ADO.NET의 기술 집합입니다.</span><span class="sxs-lookup"><span data-stu-id="4d0fa-103">The [!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)] is a set of technologies in ADO.NET that support the development of data-oriented software applications.</span></span> <span data-ttu-id="4d0fa-104">데이터 지향 응용 프로그램의 설계자와 개발자는 두 가지 다른 목적을 달성하기 위해 노력해 왔습니다.</span><span class="sxs-lookup"><span data-stu-id="4d0fa-104">Architects and developers of data-oriented applications have struggled with the need to achieve two very different objectives.</span></span> <span data-ttu-id="4d0fa-105">해결 중인 비즈니스 문제의 엔터티, 관계 및 논리를 모델링해야 하며, 데이터를 저장 및 검색하는 데 사용되는 데이터 엔진도 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4d0fa-105">They must model the entities, relationships, and logic of the business problems they are solving, and they must also work with the data engines used to store and retrieve the data.</span></span> <span data-ttu-id="4d0fa-106">데이터는 각각 해당 프로토콜을 가진 여러 개의 저장소 시스템에 걸쳐 있을 수 있습니다. 단일 저장소 시스템에서 작동하는 응용 프로그램도 저장소 시스템의 요구 사항 및 효율적이고 유지 가능한 응용 프로그램 코드를 작성하기 위한 요구 사항의 균형을 조정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4d0fa-106">The data may span multiple storage systems, each with its own protocols; even applications that work with a single storage system must balance the requirements of the storage system against the requirements of writing efficient and maintainable application code.</span></span>

<span data-ttu-id="4d0fa-107">그러나 [!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)]를 사용하면 개발자가 기본 데이터베이스 테이블과 해당 데이터가 저장된 열을 고려할 필요 없이 고객이나 고객 주소와 같은 데이터를 도메인 특정 개체 및 속성의 형태로 다룰 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4d0fa-107">The [!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)] enables developers to work with data in the form of domain-specific objects and properties, such as customers and customer addresses, without having to concern themselves with the underlying database tables and columns where this data is stored.</span></span> <span data-ttu-id="4d0fa-108">[!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)]를 사용하면 개발자가 데이터를 처리할 때 보다 높은 추상 수준에서 작업할 수 있으며, 기존의 응용 프로그램에서보다 적은 코드로 데이터 지향 응용 프로그램을 만들고 유지 관리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4d0fa-108">With the [!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)], developers can work at a higher level of abstraction when they deal with data, and can create and maintain data-oriented applications with less code than in traditional applications.</span></span> <span data-ttu-id="4d0fa-109">때문에 합니다 [!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)] .NET Framework의 구성 요소인 [!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)] 응용 프로그램 버전 3.5 SP1부터.NET Framework가 설치 된 모든 컴퓨터에서 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4d0fa-109">Because the [!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)] is a component of the .NET Framework, [!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)] applications can run on any computer on which the .NET Framework starting with version 3.5 SP1 is installed.</span></span>

## <a name="give-life-to-models"></a><span data-ttu-id="4d0fa-110">모델을 사용 하 여 수명 게</span><span class="sxs-lookup"><span data-stu-id="4d0fa-110">Give life to models</span></span>
 <span data-ttu-id="4d0fa-111">응용 프로그램 또는 서비스를 만들 때의 오랫동안 지속된 일반적인 디자인 방법은 응용 프로그램 또는 서비스를 도메인 모델, 논리 모델 및 실제 모델의 세 부분으로 나누는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="4d0fa-111">A longstanding and common design approach when building an application or service is the division of the application or service into three parts: a domain model, a logical model, and a physical model.</span></span> <span data-ttu-id="4d0fa-112">도메인 모델은 모델링되는 시스템의 엔터티 및 관계를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="4d0fa-112">The domain model defines the entities and relationships in the system that is being modeled.</span></span> <span data-ttu-id="4d0fa-113">관계형 데이터베이스에 대한 논리 모델은 FOREIGN KEY 제약 조건이 있는 테이블로 엔터티와 관계를 정규화합니다.</span><span class="sxs-lookup"><span data-stu-id="4d0fa-113">The logical model for a relational database normalizes the entities and relationships into tables with foreign key constraints.</span></span> <span data-ttu-id="4d0fa-114">실제 모델은 분할 및 인덱싱과 같은 저장소 세부 정보를 지정하여 특정 데이터 엔진의 기능을 다룹니다.</span><span class="sxs-lookup"><span data-stu-id="4d0fa-114">The physical model addresses the capabilities of a particular data engine by specifying storage details such as partitioning and indexing.</span></span>

 <span data-ttu-id="4d0fa-115">데이터베이스 관리자는 성능 향상을 위해 실제 모델을 미세 조정하지만, 응용 프로그램 코드를 작성하는 프로그래머는 주로 SQL 쿼리를 작성하고 저장 프로시저를 호출하여 논리 모델에서 작업합니다.</span><span class="sxs-lookup"><span data-stu-id="4d0fa-115">The physical model is refined by database administrators to improve performance, but programmers writing application code primarily confine themselves to working with the logical model by writing SQL queries and calling stored procedures.</span></span> <span data-ttu-id="4d0fa-116">도메인 모델은 일반적으로 응용 프로그램 요구 사항을 파악하고 전달하기 위한 도구로 사용되며, 프로젝트의 초기 단계에서 확인하고 토론한 다음 버려지는 단순한 다이어그램으로 사용되는 경우가 많습니다.</span><span class="sxs-lookup"><span data-stu-id="4d0fa-116">Domain models are generally used as a tool for capturing and communicating the requirements of an application, frequently as inert diagrams that are viewed and discussed in the early stages of a project and then abandoned.</span></span> <span data-ttu-id="4d0fa-117">대부분의 개발 팀에서는 개념적 모델을 만드는 단계를 생략하고 관계형 데이터베이스의 테이블, 열 및 키를 지정하는 단계에서 작업을 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="4d0fa-117">Many development teams skip creating a conceptual model and begin by specifying tables, columns, and keys in a relational database.</span></span>

 <span data-ttu-id="4d0fa-118">[!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)] 개발자가 엔터티를 쿼리 및 도메인 모델에서 관계를 사용 하 여 모델에서는 (호출을 *개념적* 모델를 [!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)])에 의존 하는 동안를 [!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)] 해당 변환 데이터 소스 관련 명령에 대 한 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="4d0fa-118">The [!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)] gives life to models by enabling developers to query entities and relationships in the domain model (called a *conceptual* model in the [!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)]) while relying on the [!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)] to translate those operations to data source–specific commands.</span></span> <span data-ttu-id="4d0fa-119">이렇게 하면 응용 프로그램이 하드 코딩 방식으로 특정 데이터 소스에 종속되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="4d0fa-119">This frees applications from hard-coded dependencies on a particular data source.</span></span>

 <span data-ttu-id="4d0fa-120">Code First를 사용하여 작업할 때 개념적 모델이 저장소 모델에 코드로 매핑됩니다.</span><span class="sxs-lookup"><span data-stu-id="4d0fa-120">When working with Code First, the conceptual model is mapped to the storage model in code.</span></span> <span data-ttu-id="4d0fa-121">[!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)]는 정의한 추가 구성과 개체 형식을 기반으로 한 개념적 모델을 유추할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4d0fa-121">The [!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)] can infer the conceptual model based on the object types and additional configurations that you define.</span></span> <span data-ttu-id="4d0fa-122">매핑 메타데이터는 사용자가 코드로 제공한 추가 구성 정보와 도메인 형식을 정의하는 방법을 기반으로 런타임 중 생성됩니다.</span><span class="sxs-lookup"><span data-stu-id="4d0fa-122">The mapping metadata is generated during run time based on a combination of how you defined your domain types and additional configuration information that you provide in code.</span></span> [!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)]<span data-ttu-id="4d0fa-123">에서는 메타데이터를 기반으로 필요에 따라 데이터베이스를 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="4d0fa-123">generates the database as needed based on the metadata.</span></span> <span data-ttu-id="4d0fa-124">자세한 내용은 [만들고 개념적 모델 매핑](https://go.microsoft.com/fwlink/?LinkID=235382)합니다.</span><span class="sxs-lookup"><span data-stu-id="4d0fa-124">For more information, see [Creating and Mapping a Conceptual Model](https://go.microsoft.com/fwlink/?LinkID=235382).</span></span>

 <span data-ttu-id="4d0fa-125">엔터티 데이터 모델 도구를 사용하여 작업할 때 개념적 모델, 저장소 모델 및 이 두 모델 간의 매핑은 XML 기반 스키마로 표현되고 해당 확장명의 파일에 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="4d0fa-125">When working with the Entity Data Model Tools, the conceptual model, the storage model, and the mappings between the two are expressed in XML-based schemas and defined in files that have corresponding name extensions:</span></span>

- <span data-ttu-id="4d0fa-126">CSDL(개념 스키마 정의 언어)은 개념적 모델을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="4d0fa-126">Conceptual schema definition language (CSDL) defines the conceptual model.</span></span> <span data-ttu-id="4d0fa-127">CSDL은는 [!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)]의 구현의 합니다 [엔터티 데이터 모델](../../../../../docs/framework/data/adonet/entity-data-model.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="4d0fa-127">CSDL is the [!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)]'s implementation of the [Entity Data Model](../../../../../docs/framework/data/adonet/entity-data-model.md).</span></span> <span data-ttu-id="4d0fa-128">파일 확장명은 .csdl입니다.</span><span class="sxs-lookup"><span data-stu-id="4d0fa-128">The file extension is .csdl.</span></span>

- <span data-ttu-id="4d0fa-129">SSDL(저장소 스키마 정의 언어)은 논리 모델이라고도 하는 저장소 모델을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="4d0fa-129">Store schema definition language (SSDL) defines the storage model, which is also called the logical model.</span></span> <span data-ttu-id="4d0fa-130">파일 확장명은 .ssdl입니다.</span><span class="sxs-lookup"><span data-stu-id="4d0fa-130">The file extension is .ssdl.</span></span>

- <span data-ttu-id="4d0fa-131">MSL(매핑 사양 언어)은 저장소 모델과 개념적 모델 간의 매핑을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="4d0fa-131">Mapping specification language (MSL) defines the mappings between the storage and conceptual models.</span></span> <span data-ttu-id="4d0fa-132">파일 확장명은 .msl입니다.</span><span class="sxs-lookup"><span data-stu-id="4d0fa-132">The file extension is .msl.</span></span>

<span data-ttu-id="4d0fa-133">저장소 모델과 매핑은 개념적 모델, 데이터 클래스 또는 응용 프로그램 코드를 변경하지 않고도 필요에 따라 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4d0fa-133">The storage model and mappings can change as needed without requiring changes to the conceptual model, data classes, or application code.</span></span> <span data-ttu-id="4d0fa-134">저장소 모델은 공급자와 관련이 있으므로 다양한 데이터 소스에서 일관성 있는 개념적 모델을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4d0fa-134">Because storage models are provider-specific, you can work with a consistent conceptual model across various data sources.</span></span>

<span data-ttu-id="4d0fa-135">[!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)] 에서는 이러한 모델 및 매핑 파일을 만들려면 읽기, 업데이트 및 데이터 소스의 동등한 작업을 개념적 모델의 엔터티 및 관계에 대 한 작업을 삭제 합니다.</span><span class="sxs-lookup"><span data-stu-id="4d0fa-135">The [!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)] uses these model and mapping files to create, read, update, and delete operations against entities and relationships in the conceptual model to equivalent operations in the data source.</span></span> <span data-ttu-id="4d0fa-136">[!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)] 도 데이터 원본에서 저장된 프로시저를 개념적 모델의 매핑 엔터티를 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="4d0fa-136">The [!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)] even supports mapping entities in the conceptual model to stored procedures in the data source.</span></span> <span data-ttu-id="4d0fa-137">자세한 내용은 [CSDL, SSDL 및 MSL 사양](../../../../../docs/framework/data/adonet/ef/language-reference/csdl-ssdl-and-msl-specifications.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="4d0fa-137">For more information, see [CSDL, SSDL, and MSL Specifications](../../../../../docs/framework/data/adonet/ef/language-reference/csdl-ssdl-and-msl-specifications.md).</span></span>

## <a name="map-objects-to-data"></a><span data-ttu-id="4d0fa-138">데이터 맵 개체</span><span class="sxs-lookup"><span data-stu-id="4d0fa-138">Map objects to data</span></span>
 <span data-ttu-id="4d0fa-139">개체 지향 프로그래밍을 사용하는 경우 데이터 저장소 시스템과 상호 작용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4d0fa-139">Object-oriented programming poses a challenge for interacting with data storage systems.</span></span> <span data-ttu-id="4d0fa-140">클래스의 구성은 관계형 데이터베이스 테이블의 구성을 미러링하는 경우가 많지만 완전히 일치하지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="4d0fa-140">Although the organization of classes frequently mirrors the organization of relational database tables, the fit is not perfect.</span></span> <span data-ttu-id="4d0fa-141">여러 개의 정규화된 테이블이 하나의 클래스에 해당하는 경우가 많으며 클래스 간의 관계가 테이블 간의 관계와 다르게 표현되기도 합니다.</span><span class="sxs-lookup"><span data-stu-id="4d0fa-141">Multiple normalized tables frequently correspond to a single class, and relationships between classes are often represented differently than relationships between tables are represented.</span></span> <span data-ttu-id="4d0fa-142">예를 들어 판매 주문의 고객을 나타내기 위해 `Order` 클래스는 `Customer` 클래스 인스턴스에 대한 참조가 포함된 속성을 사용할 수 있지만, 데이터베이스의 `Order` 테이블 행에는 `Customer` 테이블의 기본 키 값에 해당하는 값을 가진 외래 키 열(또는 열 집합)이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="4d0fa-142">For example, to represent the customer for a sales order, an `Order` class might use a property that contains a reference to an instance of a `Customer` class, while an `Order` table row in a database contains a foreign key column (or set of columns) with a value that corresponds to a primary key value in the `Customer` table.</span></span> <span data-ttu-id="4d0fa-143">`Customer` 클래스는 `Orders` 클래스 인스턴스의 컬렉션이 포함된 `Order` 속성을 가질 수 있는 반면, 데이터베이스의 `Customer` 테이블에는 해당하는 열이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="4d0fa-143">A `Customer` class might have a property named `Orders` that contains a collection of instances of the `Order` class, while the `Customer` table in a database has no comparable column.</span></span> <span data-ttu-id="4d0fa-144">[!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)]를 사용하면 개발자는 보다 융통성 있게 관계를 이 방식으로 표현하거나 데이터베이스에서 표현되는 방식과 보다 가깝게 관계를 모델링할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4d0fa-144">The [!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)] provides developers with the flexibility to represent relationships in this way, or to more closely model relationships as they are represented in the database.</span></span>

 <span data-ttu-id="4d0fa-145">기존 솔루션은 개체 지향 클래스와 속성을 관계형 테이블과 열에 매핑만 하여 흔히 "임피던스 불일치"라고 하는 이 간격을 연결하려고 했습니다.</span><span class="sxs-lookup"><span data-stu-id="4d0fa-145">Existing solutions have tried to bridge this gap, which is frequently called an "impedance mismatch", by only mapping object-oriented classes and properties to relational tables and columns.</span></span> <span data-ttu-id="4d0fa-146">기존의이 방법 대신는 [!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)] 관계형 테이블, 열 및 논리 모델에 외래 키 제약 조건을 개념적 모델의 엔터티 및 관계를 매핑합니다.</span><span class="sxs-lookup"><span data-stu-id="4d0fa-146">Instead of taking this traditional approach, the [!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)] maps relational tables, columns, and foreign key constraints in logical models to entities and relationships in conceptual models.</span></span> <span data-ttu-id="4d0fa-147">이렇게 하면 보다 유연성 있게 개체를 정의하고 논리 모델을 최적화할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4d0fa-147">This enables greater flexibility both in defining objects and optimizing the logical model.</span></span> <span data-ttu-id="4d0fa-148">[!INCLUDE[adonet_edm](../../../../../includes/adonet-edm-md.md)] 도구는 개념적 모델을 기반으로 확장 가능한 데이터 클래스를 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="4d0fa-148">The [!INCLUDE[adonet_edm](../../../../../includes/adonet-edm-md.md)] tools generate extensible data classes based on the conceptual model.</span></span> <span data-ttu-id="4d0fa-149">이러한 클래스는 개발자가 추가하는 멤버로 확장할 수 있는 부분 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="4d0fa-149">These classes are partial classes that can be extended with additional members that the developer adds.</span></span> <span data-ttu-id="4d0fa-150">기본적으로, 특정 개념적 모델에 대해 생성되는 클래스는 엔터티를 개체로 구체화하고 변경 내용을 추적 및 저장하기 위한 서비스를 제공하는 기본 클래스에서 파생됩니다.</span><span class="sxs-lookup"><span data-stu-id="4d0fa-150">By default, the classes that are generated for a particular conceptual model derive from base classes that provide services for materializing entities as objects and for tracking and saving changes.</span></span> <span data-ttu-id="4d0fa-151">개발자는 이러한 클래스를 통해 엔터티 및 관계를 연결에 의해 관련된 개체로 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4d0fa-151">Developers can use these classes to work with the entities and relationships as objects related by associations.</span></span> <span data-ttu-id="4d0fa-152">또한 개발자는 개념적 모델에 대해 생성된 클래스를 사용자 지정할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4d0fa-152">Developers can also customize the classes that are generated for a conceptual model.</span></span> <span data-ttu-id="4d0fa-153">자세한 내용은 [개체를 사용 하 여 작업](../../../../../docs/framework/data/adonet/ef/working-with-objects.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="4d0fa-153">For more information, see [Working with Objects](../../../../../docs/framework/data/adonet/ef/working-with-objects.md).</span></span>

## <a name="access-and-change-entity-data"></a><span data-ttu-id="4d0fa-154">엔터티 데이터를 액세스 및 변경</span><span class="sxs-lookup"><span data-stu-id="4d0fa-154">Access and change entity data</span></span>

<span data-ttu-id="4d0fa-155">단순한 개체-관계형 매핑 솔루션 이상의 의미가 있는 [!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)]는 근본적으로 응용 프로그램이 개념적 모델의 엔터티 및 관계로 표현된 데이터에 액세스하여 변경할 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="4d0fa-155">More than just another object-relational mapping solution, the [!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)] is fundamentally about enabling applications to access and change data that is represented as entities and relationships in the conceptual model.</span></span> <span data-ttu-id="4d0fa-156">[!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)]는 모델 및 매핑 파일의 정보를 사용하여 개념적 모델로 표현된 엔터티 형식에 대한 개체 쿼리를 데이터 소스에 대한 쿼리로 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="4d0fa-156">The [!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)] uses information in the model and mapping files to translate object queries against entity types represented in the conceptual model into data source-specific queries.</span></span> <span data-ttu-id="4d0fa-157">쿼리 결과를 개체로 구체화 되는 [!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)] 관리 합니다.</span><span class="sxs-lookup"><span data-stu-id="4d0fa-157">Query results are materialized into objects that the [!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)] manages.</span></span> <span data-ttu-id="4d0fa-158">[!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)] 개념적 모델을 쿼리하고 개체를 반환 하는 다음 방법을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="4d0fa-158">The [!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)] provides the following ways to query a conceptual model and return objects:</span></span>

- [!INCLUDE[linq_entities](../../../../../includes/linq-entities-md.md)]<span data-ttu-id="4d0fa-159">.</span><span class="sxs-lookup"><span data-stu-id="4d0fa-159">.</span></span> <span data-ttu-id="4d0fa-160">개념적 모델에 정의된 엔터티 형식을 쿼리하기 위한 LINQ(Language-Integrated Query) 지원을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="4d0fa-160">Provides Language-Integrated Query (LINQ) support for querying entity types that are defined in a conceptual model.</span></span> <span data-ttu-id="4d0fa-161">자세한 내용은 [LINQ to Entities](../../../../../docs/framework/data/adonet/ef/language-reference/linq-to-entities.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="4d0fa-161">For more information, see [LINQ to Entities](../../../../../docs/framework/data/adonet/ef/language-reference/linq-to-entities.md).</span></span>

- [!INCLUDE[esql](../../../../../includes/esql-md.md)]<span data-ttu-id="4d0fa-162">.</span><span class="sxs-lookup"><span data-stu-id="4d0fa-162">.</span></span> <span data-ttu-id="4d0fa-163">개념적 모델의 엔터티를 직접 사용 하며 지 원하는 SQL 저장소에 독립적인 언어 [!INCLUDE[adonet_edm](../../../../../includes/adonet-edm-md.md)] 개념입니다.</span><span class="sxs-lookup"><span data-stu-id="4d0fa-163">A storage-independent dialect of SQL that works directly with entities in the conceptual model and that supports [!INCLUDE[adonet_edm](../../../../../includes/adonet-edm-md.md)] concepts.</span></span> [!INCLUDE[esql](../../../../../includes/esql-md.md)] <span data-ttu-id="4d0fa-164">개체 쿼리와 EntityClient 공급자를 사용 하 여 실행 된 쿼리를 모두 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="4d0fa-164">is used both with object queries and queries that are executed by using the EntityClient provider.</span></span> <span data-ttu-id="4d0fa-165">자세한 내용은 [Entity SQL 개요](../../../../../docs/framework/data/adonet/ef/language-reference/entity-sql-overview.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="4d0fa-165">For more information, see [Entity SQL Overview](../../../../../docs/framework/data/adonet/ef/language-reference/entity-sql-overview.md).</span></span>

<span data-ttu-id="4d0fa-166">[!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)]에는 EntityClient 데이터 공급자가 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4d0fa-166">The [!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)] includes the EntityClient data provider.</span></span> <span data-ttu-id="4d0fa-167">이 공급자는 연결을 관리하고, 엔터티 쿼리를 데이터 소스 특정 쿼리로 변환하며, [!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)]에서 엔터티 데이터를 개체로 구체화할 때 사용하는 데이터 판독기를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="4d0fa-167">This provider manages connections, translates entity queries into data source-specific queries, and returns a data reader that the [!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)] uses to materialize entity data into objects.</span></span> <span data-ttu-id="4d0fa-168">개체 구체화가 필요하지 않은 경우 응용 프로그램에서 [!INCLUDE[esql](../../../../../includes/esql-md.md)] 쿼리를 실행하고 반환된 읽기 전용 데이터 판독기를 사용할 수 있도록 하여 EntityClient 공급자를 표준 ADO.NET 데이터 공급자처럼 사용할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4d0fa-168">When object materialization is not required, the EntityClient provider can also be used like a standard ADO.NET data provider by enabling applications to execute [!INCLUDE[esql](../../../../../includes/esql-md.md)] queries and consume the returned read-only data reader.</span></span> <span data-ttu-id="4d0fa-169">자세한 내용은 [Entity Framework 용 EntityClient 공급자](../../../../../docs/framework/data/adonet/ef/entityclient-provider-for-the-entity-framework.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="4d0fa-169">For more information, see [EntityClient Provider for the Entity Framework](../../../../../docs/framework/data/adonet/ef/entityclient-provider-for-the-entity-framework.md).</span></span>

<span data-ttu-id="4d0fa-170">다음 다이어그램에서는 데이터 액세스를 위한 [!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)] 아키텍처를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="4d0fa-170">The following diagram illustrates the [!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)] architecture for accessing data:</span></span>

<span data-ttu-id="4d0fa-171">![Entity Framework 아키텍처 다이어그램](../../../../../docs/framework/data/adonet/ef/media/wd-efarchdiagram.gif "wd_EFArchDiagram")</span><span class="sxs-lookup"><span data-stu-id="4d0fa-171">![Entity Framework Architectural Diagram](../../../../../docs/framework/data/adonet/ef/media/wd-efarchdiagram.gif "wd_EFArchDiagram")</span></span>

<span data-ttu-id="4d0fa-172">[!INCLUDE[adonet_edm](../../../../../includes/adonet-edm-md.md)] 도구는 개념적 모델의 엔터티 컨테이너를 나타내며 `System.Data.Objects.ObjectContext` 또는 `System.Data.Entity.DbContext`에서 파생된 클래스를 생성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4d0fa-172">The [!INCLUDE[adonet_edm](../../../../../includes/adonet-edm-md.md)] Tools can generate a class derived from `System.Data.Objects.ObjectContext` or `System.Data.Entity.DbContext` that represents the entity container in the conceptual model.</span></span> <span data-ttu-id="4d0fa-173">이 개체 컨텍스트는 변경 내용을 추적하고 ID, 동시성 및 관계를 관리하기 위한 기능을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="4d0fa-173">This object context provides the facilities for tracking changes and managing identities, concurrency, and relationships.</span></span> <span data-ttu-id="4d0fa-174">또한 이 클래스는 데이터 소스에 삽입, 업데이트 및 삭제를 쓰는 `SaveChanges` 메서드를 노출합니다.</span><span class="sxs-lookup"><span data-stu-id="4d0fa-174">This class also exposes a `SaveChanges` method that writes inserts, updates, and deletes to the data source.</span></span> <span data-ttu-id="4d0fa-175">쿼리와 마찬가지로, 이러한 변경 작업은 시스템에서 자동으로 생성된 명령이나 개발자가 지정한 저장 프로시저로 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="4d0fa-175">Like queries, these changes are either made by commands automatically generated by the system or by stored procedures that are specified by the developer.</span></span>

## <a name="data-providers"></a><span data-ttu-id="4d0fa-176">데이터 공급자</span><span class="sxs-lookup"><span data-stu-id="4d0fa-176">Data providers</span></span>

<span data-ttu-id="4d0fa-177">`EntityClient` 공급자 개념적 엔터티 및 관계 측면에서 데이터에 액세스 하 여 ADO.NET 공급자 모델을 확장 합니다.</span><span class="sxs-lookup"><span data-stu-id="4d0fa-177">The `EntityClient` provider extends the ADO.NET provider model by accessing data in terms of conceptual entities and relationships.</span></span> <span data-ttu-id="4d0fa-178">[!INCLUDE[esql](../../../../../includes/esql-md.md)]을 사용하는 쿼리를 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="4d0fa-178">It executes queries that use [!INCLUDE[esql](../../../../../includes/esql-md.md)].</span></span> [!INCLUDE[esql](../../../../../includes/esql-md.md)]<span data-ttu-id="4d0fa-179">에서는 `EntityClient`가 데이터베이스와 통신할 수 있도록 기본 쿼리 언어를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="4d0fa-179">provides the underlying query language that enables `EntityClient` to communicate with the database.</span></span> <span data-ttu-id="4d0fa-180">자세한 내용은 [Entity Framework 용 EntityClient 공급자](../../../../../docs/framework/data/adonet/ef/entityclient-provider-for-the-entity-framework.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="4d0fa-180">For more information, see [EntityClient Provider for the Entity Framework](../../../../../docs/framework/data/adonet/ef/entityclient-provider-for-the-entity-framework.md).</span></span>

<span data-ttu-id="4d0fa-181">[!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)]에는 정식 명령 트리를 지원하는 업데이트된 SqlClient 데이터 공급자가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4d0fa-181">The [!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)] includes an updated SqlClient Data Provider that supports canonical command trees.</span></span> <span data-ttu-id="4d0fa-182">자세한 내용은 [Entity Framework 용 SqlClient](../../../../../docs/framework/data/adonet/ef/sqlclient-for-the-entity-framework.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="4d0fa-182">For more information, see [SqlClient for the Entity Framework](../../../../../docs/framework/data/adonet/ef/sqlclient-for-the-entity-framework.md).</span></span>

## <a name="entity-data-model-tools"></a><span data-ttu-id="4d0fa-183">엔터티 데이터 모델 도구</span><span class="sxs-lookup"><span data-stu-id="4d0fa-183">Entity data model tools</span></span>

<span data-ttu-id="4d0fa-184">와 함께 [!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)] 런타임, Visual Studio는 매핑 및 모델링 도구를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="4d0fa-184">Together with the [!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)] runtime, Visual Studio includes the mapping and modeling tools.</span></span> <span data-ttu-id="4d0fa-185">자세한 내용은 [모델링 및 매핑](../../../../../docs/framework/data/adonet/ef/modeling-and-mapping.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="4d0fa-185">For more information, see [Modeling and Mapping](../../../../../docs/framework/data/adonet/ef/modeling-and-mapping.md).</span></span>

## <a name="learn-more"></a><span data-ttu-id="4d0fa-186">자세한 정보</span><span class="sxs-lookup"><span data-stu-id="4d0fa-186">Learn more</span></span>

<span data-ttu-id="4d0fa-187">에 대 한 자세한는 [!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)]를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="4d0fa-187">To learn more about the [!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)], see:</span></span>

<span data-ttu-id="4d0fa-188">[Getting Started](../../../../../docs/framework/data/adonet/ef/getting-started.md) -시작 하는 방법에 대 한 정보를 제공 하 고 신속 하 게 사용 하 여 실행 합니다 [빠른 시작](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb399182(v=vs.100))는 간단한 방법을 보여 주는 [!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)] 응용 프로그램입니다.</span><span class="sxs-lookup"><span data-stu-id="4d0fa-188">[Getting Started](../../../../../docs/framework/data/adonet/ef/getting-started.md) - Provides information about how to get up and running quickly using the [Quickstart](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb399182(v=vs.100)), which shows how to create a simple [!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)] application.</span></span>

<span data-ttu-id="4d0fa-189">[Entity Framework 용어](../../../../../docs/framework/data/adonet/ef/terminology.md) -대부분의 엔터티 데이터 모델을 여 도입 된 용어를 정의 하며 [!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)] 에서 사용 되는 및 [!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)] 설명서.</span><span class="sxs-lookup"><span data-stu-id="4d0fa-189">[Entity Framework Terminology](../../../../../docs/framework/data/adonet/ef/terminology.md) - Defines many of the terms that are introduced by the Entity Data Model and the [!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)] and that are used in [!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)] documentation.</span></span>

<span data-ttu-id="4d0fa-190">[Entity Framework 리소스](../../../../../docs/framework/data/adonet/ef/resources.md) 개념 항목에 대 한 링크를 제공 하 고 외부 항목 및 구성에 대 한 리소스에 연결- [!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)] 응용 프로그램입니다.</span><span class="sxs-lookup"><span data-stu-id="4d0fa-190">[Entity Framework Resources](../../../../../docs/framework/data/adonet/ef/resources.md) - Provides links to conceptual topics and links to external topics and resources for building [!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)] applications.</span></span>

## <a name="see-also"></a><span data-ttu-id="4d0fa-191">참고자료</span><span class="sxs-lookup"><span data-stu-id="4d0fa-191">See also</span></span>

- [<span data-ttu-id="4d0fa-192">ADO.NET Entity Framework</span><span class="sxs-lookup"><span data-stu-id="4d0fa-192">ADO.NET Entity Framework</span></span>](../../../../../docs/framework/data/adonet/ef/index.md)

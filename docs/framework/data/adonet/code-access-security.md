---
title: 코드 액세스 보안 및 ADO.NET
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: 93e099eb-daa1-4f1e-b031-c1e10a996f88
ms.openlocfilehash: 45c838fbac5e6f576a242c8839f849dc9529ef7d
ms.sourcegitcommit: 3c1c3ba79895335ff3737934e39372555ca7d6d0
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 09/05/2018
ms.locfileid: "43779275"
---
# <a name="code-access-security-and-adonet"></a><span data-ttu-id="b9cd2-102">코드 액세스 보안 및 ADO.NET</span><span class="sxs-lookup"><span data-stu-id="b9cd2-102">Code Access Security and ADO.NET</span></span>
<span data-ttu-id="b9cd2-103">.NET Framework는 역할 기반 보안과 CAS(코드 액세스 보안)를 제공합니다. 두 보안 기능 모두 CLR(공용 언어 런타임)이 제공하는 공용 인프라를 사용하여 구현되었습니다.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-103">The .NET Framework offers role-based security as well as code access security (CAS), both of which are implemented using a common infrastructure supplied by the common language runtime (CLR).</span></span> <span data-ttu-id="b9cd2-104">비관리 코드의 경우 대부분의 응용 프로그램은 사용자 또는 보안 주체 권한으로 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-104">In the world of unmanaged code, most applications execute with the permissions of the user or principal.</span></span> <span data-ttu-id="b9cd2-105">결과적으로 높은 권한을 가진 사용자가 악의적이거나 오류가 많은 소프트웨어를 실행하면 컴퓨터 시스템과 개인 데이터가 손상될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-105">As a result, computer systems can be damaged and private data compromised when malicious or error-filled software is run by a user with elevated privileges.</span></span>  
  
 <span data-ttu-id="b9cd2-106">이와 달리, .NET Framework에서 실행되는 관리 코드에는 해당 코드에만 적용되는 코드 액세스 보안 기능이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-106">By contrast, managed code executing in the .NET Framework includes code access security, which applies to code alone.</span></span> <span data-ttu-id="b9cd2-107">코드 실행 여부는 보안 주체의 ID만으로 결정되는 것이 아니라 코드 출처나 코드 ID의 다른 특성에 따라 결정됩니다.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-107">Whether the code is allowed to run or not depends on the code's origin or other aspects of the code's identity, not solely the identity of the principal.</span></span> <span data-ttu-id="b9cd2-108">이는 관리 코드가 오용될 가능성을 줄여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-108">This reduces the likelihood that managed code can be misused.</span></span>  
  
## <a name="code-access-permissions"></a><span data-ttu-id="b9cd2-109">코드 액세스 권한</span><span class="sxs-lookup"><span data-stu-id="b9cd2-109">Code Access Permissions</span></span>  
 <span data-ttu-id="b9cd2-110">코드가 실행되면 CLR 보안 시스템이 평가하는 증명 정보를 제시하게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-110">When code is executed, it presents evidence that is evaluated by the CLR security system.</span></span> <span data-ttu-id="b9cd2-111">일반적으로 증명 정보는 URL, 사이트 및 영역이 포함된 코드의 원본 및 어셈블리의 ID를 보장하는 디지털 서명으로 이루어져 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-111">Typically, this evidence comprises the origin of the code including URL, site, and zone, and digital signatures that ensure the identity of the assembly.</span></span>  
  
 <span data-ttu-id="b9cd2-112">CLR은 코드에 수행 권한이 있는 작업만 수행하도록 허용합니다.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-112">The CLR allows code to perform only those operations that the code has permission to perform.</span></span> <span data-ttu-id="b9cd2-113">코드에서 권한을 요청할 수 있으며 이러한 요청은 관리자가 설정한 보안 정책에 따라 허용 여부가 결정됩니다.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-113">Code can request permissions, and those requests are honored based on the security policy set by an administrator.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b9cd2-114">CLR에서 수행되는 코드는 자신에게 권한을 부여할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-114">Code executing in the CLR cannot grant permissions to itself.</span></span> <span data-ttu-id="b9cd2-115">예를 들어 코드에서 보안 정책이 허용하는 것보다 낮은 권한을 요청하고 부여 받을 수는 있지만 그 이상의 권한은 부여 받을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-115">For example, code can request and be granted fewer permissions than a security policy allows, but it will never be granted more permissions.</span></span> <span data-ttu-id="b9cd2-116">권한을 부여할 때는 아무런 권한 없이 시작한 다음 수행하는 특정 작업에 필요한 최소한의 권한만 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-116">When granting permissions, start with no permissions at all and then add the narrowest permissions for the particular task being performed.</span></span> <span data-ttu-id="b9cd2-117">모든 권한을 부여한 다음 필요하지 않은 권한을 개별적으로 허용하지 않으면 필요 이상의 권한이 주어질 수 있으므로 의도하지 않은 보안 허점이 생길 수 있습니다. 따라서 응용 프로그램이 안전하지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-117">Starting with all permissions and then denying individual ones leads to insecure applications that may contain unintentional security holes from granting more permissions than required.</span></span> <span data-ttu-id="b9cd2-118">자세한 내용은 [NIB: 보안 정책 구성](https://msdn.microsoft.com/library/0f130bcd-1bba-4346-b231-0bcca7dab1a4) 하 고 [NIB: 보안 정책 관리](https://msdn.microsoft.com/library/d754e05d-29dc-4d3a-a2c2-95eaaf1b82b9)합니다.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-118">For more information, see [NIB: Configuring Security Policy](https://msdn.microsoft.com/library/0f130bcd-1bba-4346-b231-0bcca7dab1a4) and [NIB: Security Policy Management](https://msdn.microsoft.com/library/d754e05d-29dc-4d3a-a2c2-95eaaf1b82b9).</span></span>  
  
 <span data-ttu-id="b9cd2-119">코드 액세스 권한에는 다음 세 가지 형식이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-119">There are three types of code access permissions:</span></span>  
  
-   <span data-ttu-id="b9cd2-120">`Code access permissions` 클래스에서 파생된 <xref:System.Security.CodeAccessPermission>.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-120">`Code access permissions` derive from the <xref:System.Security.CodeAccessPermission> class.</span></span> <span data-ttu-id="b9cd2-121">파일 및 환경 변수와 같은 보호된 리소스에 액세스하고, 비관리 코드에 액세스하는 등의 보호된 작업을 수행하는 데 필요한 권한입니다.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-121">Permissions are required in order to access protected resources, such as files and environment variables, and to perform protected operations, such as accessing unmanaged code.</span></span>  
  
-   <span data-ttu-id="b9cd2-122">`Identity permissions`은 어셈블리를 식별하는 특성을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-122">`Identity permissions` represent characteristics that identify an assembly.</span></span> <span data-ttu-id="b9cd2-123">디지털 서명이나 코드 출처와 같은 항목을 포함하는 증명 정보를 기준으로 어셈블리에 권한이 부여됩니다.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-123">Permissions are granted to an assembly based on evidence, which can include items such as a digital signature or where the code originated.</span></span> <span data-ttu-id="b9cd2-124"><xref:System.Security.CodeAccessPermission> 기본 클래스에서 ID 권한이 파생되는 경우도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-124">Identity permissions also derive from the <xref:System.Security.CodeAccessPermission> base class.</span></span>  
  
-   <span data-ttu-id="b9cd2-125">`Role-based security permissions`은 보안 주체가 지정된 ID를 가지고 있거나 지정된 역할의 멤버인지에 따라 결정됩니다.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-125">`Role-based security permissions` are based on whether a principal has a specified identity or is a member of a specified role.</span></span> <span data-ttu-id="b9cd2-126"><xref:System.Security.Permissions.PrincipalPermission> 클래스를 사용하면 활성 보안 주체에 대해 선언적 권한 검사와 필수 권한 검사를 모두 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-126">The <xref:System.Security.Permissions.PrincipalPermission> class allows both declarative and imperative permission checks against the active principal.</span></span>  
  
 <span data-ttu-id="b9cd2-127">리소스에 액세스하거나 작업을 수행할 수 있는 권한이 코드에 있는지 확인하기 위해서 런타임 보안 시스템은 호출 스택을 검색하여 각 호출자에게 부여된 권한과 요청된 권한을 비교합니다.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-127">To determine whether code is authorized to access a resource or perform an operation, the runtime's security system traverses the call stack, comparing the granted permissions of each caller to the permission being demanded.</span></span> <span data-ttu-id="b9cd2-128">호출 스택의 호출자에게 요청된 권한이 없는 경우 <xref:System.Security.SecurityException>이 throw되고 액세스가 거부됩니다.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-128">If any caller in the call stack does not have the demanded permission, a <xref:System.Security.SecurityException> is thrown and access is refused.</span></span>  
  
### <a name="requesting-permissions"></a><span data-ttu-id="b9cd2-129">권한 요청</span><span class="sxs-lookup"><span data-stu-id="b9cd2-129">Requesting Permissions</span></span>  
 <span data-ttu-id="b9cd2-130">권한을 요청하는 것은 응용 프로그램 실행에 필요한 권한에 대한 정보를 런타임으로 전달하고 실제 필요한 권한만 부여되도록 하기 위한 것입니다.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-130">The purpose of requesting permissions is to inform the runtime which permissions your application requires in order to run, and to ensure that it receives only the permissions that it actually needs.</span></span> <span data-ttu-id="b9cd2-131">예를 들어 응용 프로그램에서 로컬 디스크에 데이터를 써야 한다면 <xref:System.Security.Permissions.FileIOPermission>이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-131">For example, if your application needs to write data to the local disk, it requires <xref:System.Security.Permissions.FileIOPermission>.</span></span> <span data-ttu-id="b9cd2-132">해당 권한이 부여되어 있지 않으면 응용 프로그램에서 디스크에 쓰려고 할 때 오류가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-132">If that permission hasn't been granted, the application will fail when it attempts to write to the disk.</span></span> <span data-ttu-id="b9cd2-133">하지만 응용 프로그램이 `FileIOPermission`을 요청하나 해당 권한이 부여되어 있지 않으면 응용 프로그램이 초기에 예외를 생성하여 로드되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-133">However, if the application requests `FileIOPermission` and that permission has not been granted, the application will generate the exception at the outset and will not load.</span></span>  
  
 <span data-ttu-id="b9cd2-134">응용 프로그램이 디스크에서 데이터를 읽어 오기만 하면 되는 경우에는 쓰기 권한이 부여되지 않도록 요청할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-134">In a scenario where the application only needs to read data from the disk, you can request that it never be granted any write permissions.</span></span> <span data-ttu-id="b9cd2-135">이렇게 하면 버그나 악의적인 공격이 발생해도 코드가 작업 중인 데이터를 손상시킬 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-135">In the event of a bug or a malicious attack, your code cannot damage the data on which it operates.</span></span> <span data-ttu-id="b9cd2-136">자세한 내용은 [NIB: 권한 요청](https://msdn.microsoft.com/library/0447c49d-8cba-45e4-862c-ff0b59bebdc2)합니다.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-136">For more information, see [NIB: Requesting Permissions](https://msdn.microsoft.com/library/0447c49d-8cba-45e4-862c-ff0b59bebdc2).</span></span>  
  
## <a name="role-based-security-and-cas"></a><span data-ttu-id="b9cd2-137">역할 기반 보안 및 CAS</span><span class="sxs-lookup"><span data-stu-id="b9cd2-137">Role-Based Security and CAS</span></span>  
 <span data-ttu-id="b9cd2-138">역할 기반 보안과 CAS(코드 액세스 보안)를 모두 구현하면 응용 프로그램의 전체적인 보안이 향상됩니다.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-138">Implementing both role-based security and code-accessed security (CAS) enhances overall security for your application.</span></span> <span data-ttu-id="b9cd2-139">역할 기반 보안은 현재 스레드에서 보안 주체 관련 정보를 사용할 수 있도록 하여 Windows 계정이나 사용자 지정 ID에 따라 다르게 적용되도록 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-139">Role-based security can be based on a Windows account or a custom identity, making information about the security principal available to the current thread.</span></span> <span data-ttu-id="b9cd2-140">또한, 응용 프로그램은 주로 사용자가 제공하는 자격 증명에 따라 데이터 또는 리소스에 액세스하는 데 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-140">In addition, applications are often required to provide access to data or resources based on credentials supplied by the user.</span></span> <span data-ttu-id="b9cd2-141">일반적으로 이러한 응용 프로그램에서는 사용자의 역할을 확인한 후 해당 역할에 따라 리소스에 대한 액세스 권한을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-141">Typically, such applications check the role of a user and provide access to resources based on those roles.</span></span>  
  
 <span data-ttu-id="b9cd2-142">역할 기반 보안을 사용하면 구성 요소에서 현재 사용자와 그에 관련된 역할을 런타임에 식별할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-142">Role-based security enables a component to identify current users and their associated roles at run time.</span></span> <span data-ttu-id="b9cd2-143">그런 다음 CAS 정책을 사용하여 이 정보를 매핑함으로써 런타임에 부여된 권한 집합을 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-143">This information is then mapped using a CAS policy to determine the set of permissions granted at run time.</span></span> <span data-ttu-id="b9cd2-144">특정 응용 프로그램 도메인의 경우 호스트가 기본 역할 기반 보안 정책을 변경할 수 있으며 사용자를 나타내는 기본 보안 주체 및 해당 사용자와 관련된 역할을 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-144">For a specified application domain, the host can change the default role-based security policy and set a default security principal that represents a user and the roles associated with that user.</span></span>  
  
 <span data-ttu-id="b9cd2-145">CLR에서는 관리 코드에 제한을 적용하는 메커니즘을 구현하기 위해 권한을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-145">The CLR uses permissions to implement its mechanism for enforcing restrictions on managed code.</span></span> <span data-ttu-id="b9cd2-146">역할 기반 보안 권한은 사용자(또는 사용자 역할을 하는 에이전트)가 특정 ID를 가지고 있는지 또는 지정된 역할의 멤버인지를 확인하는 메커니즘을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-146">Role-based security permissions provide a mechanism for discovering whether a user (or the agent acting on the user's behalf) has a particular identity or is a member of a specified role.</span></span> <span data-ttu-id="b9cd2-147">자세한 내용은 [보안 권한을](https://msdn.microsoft.com/library/b03757b4-e926-4196-b738-3733ced2bda0)합니다.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-147">For more information, see [Security Permissions](https://msdn.microsoft.com/library/b03757b4-e926-4196-b738-3733ced2bda0).</span></span>  
  
 <span data-ttu-id="b9cd2-148">빌드하려는 응용 프로그램 종류에 따라 데이터베이스에 역할 기반 권한을 구현하는 것을 고려해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-148">Depending on the type of application you are building, you should also consider implementing role-based permissions in the database.</span></span> <span data-ttu-id="b9cd2-149">SQL Server에서 역할 기반 보안에 대 한 자세한 내용은 참조 하세요. [SQL Server 보안](../../../../docs/framework/data/adonet/sql/sql-server-security.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-149">For more information on role-based security in SQL Server, see [SQL Server Security](../../../../docs/framework/data/adonet/sql/sql-server-security.md).</span></span>  
  
## <a name="assemblies"></a><span data-ttu-id="b9cd2-150">어셈블리</span><span class="sxs-lookup"><span data-stu-id="b9cd2-150">Assemblies</span></span>  
 <span data-ttu-id="b9cd2-151">어셈블리는 .NET Framework 응용 프로그램에 대한 배포, 버전 제어, 재사용, 활성화 범위 및 보안 권한의 기본 단위를 형성합니다.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-151">Assemblies form the fundamental unit of deployment, version control, reuse, activation scoping, and security permissions for a .NET Framework application.</span></span> <span data-ttu-id="b9cd2-152">어셈블리는 함께 작동하도록 빌드되고 논리적 기능 단위를 형성하는 리소스 및 형식 컬렉션을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-152">An assembly provides a collection of types and resources that are built to work together and form a logical unit of functionality.</span></span> <span data-ttu-id="b9cd2-153">CLR의 경우 어셈블리 컨텍스트 외부에는 형식이 존재하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-153">To the CLR, a type does not exist outside the context of an assembly.</span></span> <span data-ttu-id="b9cd2-154">만들기 및 배포 어셈블리에 대 한 자세한 내용은 참조 하세요. [어셈블리를 사용한 프로그래밍](../../../../docs/framework/app-domains/programming-with-assemblies.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-154">For more information on creating and deploying assemblies, see [Programming with Assemblies](../../../../docs/framework/app-domains/programming-with-assemblies.md).</span></span>  
  
### <a name="strong-naming-assemblies"></a><span data-ttu-id="b9cd2-155">어셈블리에 강력한 이름 지정</span><span class="sxs-lookup"><span data-stu-id="b9cd2-155">Strong-naming Assemblies</span></span>  
 <span data-ttu-id="b9cd2-156">강력한 이름 또는 디지털 서명은 단순한 텍스트 이름, 버전 번호 및 문화권 정보(제공된 경우)를 포함하는 어셈블리의 ID에 공개 키와 디지털 서명이 추가되어 구성됩니다.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-156">A strong name, or digital signature, consists of the assembly's identity, which includes its simple text name, version number, and culture information (if provided), plus a public key and a digital signature.</span></span> <span data-ttu-id="b9cd2-157">디지털 서명은 해당 개인 키를 사용하여 어셈블리 파일에서 생성됩니다.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-157">The digital signature is generated from an assembly file using the corresponding private key.</span></span> <span data-ttu-id="b9cd2-158">어셈블리 파일은 어셈블리를 구성하는 모든 파일의 이름과 해시가 들어 있는 어셈블리 매니페스트를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-158">The assembly file contains the assembly manifest, which contains the names and hashes of all the files that make up the assembly.</span></span>  
  
 <span data-ttu-id="b9cd2-159">어셈블리에 강력한 이름을 지정하면 다른 소프트웨어에서 응용 프로그램이나 구성 요소를 명시적으로 참조하는 데 사용할 수 있는 고유 ID가 응용 프로그램이나 구성 요소에 지정됩니다.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-159">Strong naming an assembly gives an application or component a unique identity that other software can use to refer explicitly to it.</span></span> <span data-ttu-id="b9cd2-160">강력한 이름을 지정하면 부적절한 코드가 포함되어 있는 어셈블리로 인해 어셈블리가 스푸핑되지 않도록 보호됩니다.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-160">Strong naming guards assemblies against being spoofed by an assembly that contains hostile code.</span></span> <span data-ttu-id="b9cd2-161">또한 강력한 이름을 지정하면 구성 요소의 다양한 버전 간에 버전 관리 일관성을 유지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-161">Strong-naming also ensures versioning consistency among different versions of a component.</span></span> <span data-ttu-id="b9cd2-162">GAC(전역 어셈블리 캐시)에 배포할 어셈블리에는 강력한 이름을 지정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-162">You must strong name assemblies that will be deployed to the Global Assembly Cache (GAC).</span></span> <span data-ttu-id="b9cd2-163">자세한 내용은 [강력한 이름의 어셈블리 만들기 및 사용](../../../../docs/framework/app-domains/create-and-use-strong-named-assemblies.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-163">For more information, see [Creating and Using Strong-Named Assemblies](../../../../docs/framework/app-domains/create-and-use-strong-named-assemblies.md).</span></span>  
  
## <a name="partial-trust-in-adonet-20"></a><span data-ttu-id="b9cd2-164">ADO.NET 2.0에서의 부분 신뢰</span><span class="sxs-lookup"><span data-stu-id="b9cd2-164">Partial Trust in ADO.NET 2.0</span></span>  
 <span data-ttu-id="b9cd2-165">ADO.NET 2.0에서 .NET Framework Data Provider for SQL Server, .NET Framework Data Provider for OLE DB, .NET Framework Data Provider for ODBC 및 .NET Framework Data Provider for Oracle은 현재 모두 부분적으로 신뢰할 수 있는 환경에서 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-165">In ADO.NET 2.0, the .NET Framework Data Provider for SQL Server, the .NET Framework Data Provider for OLE DB, the .NET Framework Data Provider for ODBC, and the .NET Framework Data Provider for Oracle can now all run in partially trusted environments.</span></span> <span data-ttu-id="b9cd2-166">.NET Framework의 이전 릴리스의 경우, 부분적으로 신뢰할 수 있는 응용 프로그램에서는 <xref:System.Data.SqlClient>만 지원되었습니다.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-166">In previous releases of the .NET Framework, only <xref:System.Data.SqlClient> was supported in less than full-trust applications.</span></span>  
  
 <span data-ttu-id="b9cd2-167">SQL Server 공급자를 사용하는 부분적으로 신뢰할 수 있는 응용 프로그램은 실행 및 <xref:System.Data.SqlClient.SqlClientPermission> 권한이 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-167">At minimum, a partially trusted application using the SQL Server provider must have execution and <xref:System.Data.SqlClient.SqlClientPermission> permissions.</span></span>  
  
### <a name="permission-attribute-properties-for-partial-trust"></a><span data-ttu-id="b9cd2-168">부분 신뢰에 대한 권한 속성</span><span class="sxs-lookup"><span data-stu-id="b9cd2-168">Permission Attribute Properties for Partial Trust</span></span>  
 <span data-ttu-id="b9cd2-169">부분 신뢰의 경우 <xref:System.Data.SqlClient.SqlClientPermissionAttribute> 멤버를 사용하여 .NET Framework Data Provider for SQL Server에서 사용할 수 있는 기능을 추가로 제한할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-169">For partial trust scenarios, you can use <xref:System.Data.SqlClient.SqlClientPermissionAttribute> members to further restrict the capabilities available for the .NET Framework Data Provider for SQL Server.</span></span>  
  
 <span data-ttu-id="b9cd2-170">다음 표에서는 사용 가능한 <xref:System.Data.SqlClient.SqlClientPermissionAttribute> 속성과 해당 설명의 목록을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-170">The following table lists the available <xref:System.Data.SqlClient.SqlClientPermissionAttribute> properties and their descriptions:</span></span>  
  
|<span data-ttu-id="b9cd2-171">권한 속성</span><span class="sxs-lookup"><span data-stu-id="b9cd2-171">Permission attribute property</span></span>|<span data-ttu-id="b9cd2-172">설명</span><span class="sxs-lookup"><span data-stu-id="b9cd2-172">Description</span></span>|  
|-----------------------------------|-----------------|  
|`Action`|<span data-ttu-id="b9cd2-173">보안 동작을 가져오거나 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-173">Gets or sets a security action.</span></span> <span data-ttu-id="b9cd2-174"><xref:System.Security.Permissions.SecurityAttribute>에서 상속됩니다.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-174">Inherited from <xref:System.Security.Permissions.SecurityAttribute>.</span></span>|  
|`AllowBlankPassword`|<span data-ttu-id="b9cd2-175">연결 문자열에서 빈 암호 사용을 활성화하거나 비활성화합니다.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-175">Enables or disables the use of a blank password in a connection string.</span></span> <span data-ttu-id="b9cd2-176">빈 암호 사용을 활성화하는 `true`와 빈 암호 사용을 비활성화하는 `false`를 값으로 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-176">Valid values are `true` (to enable the use of blank passwords) and `false` (to disable the use of blank passwords).</span></span> <span data-ttu-id="b9cd2-177"><xref:System.Data.Common.DBDataPermissionAttribute>에서 상속됩니다.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-177">Inherited from <xref:System.Data.Common.DBDataPermissionAttribute>.</span></span>|  
|`ConnectionString`|<span data-ttu-id="b9cd2-178">허용되는 연결 문자열을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-178">Identifies a permitted connection string.</span></span> <span data-ttu-id="b9cd2-179">여러 개의 연결 문자열을 식별할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-179">Multiple connection strings can be identified.</span></span> <span data-ttu-id="b9cd2-180">**참고:** 연결 문자열에 사용자 ID 또는 암호를 포함 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-180">**Note:**  Do not include a user ID or password in your connection string.</span></span> <span data-ttu-id="b9cd2-181">이번 릴리스에서는 .NET Framework 구성 도구를 사용하여 연결 문자열 제한을 변경할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-181">In this release, you cannot change connection string restrictions using the .NET Framework Configuration Tool.</span></span> <br /><br /> <span data-ttu-id="b9cd2-182"><xref:System.Data.Common.DBDataPermissionAttribute>에서 상속됩니다.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-182">Inherited from <xref:System.Data.Common.DBDataPermissionAttribute>.</span></span>|  
|`KeyRestrictions`|<span data-ttu-id="b9cd2-183">허용되거나 허용되지 않는 연결 문자열 매개 변수를 식별합니다.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-183">Identifies connection string parameters that are allowed or disallowed.</span></span> <span data-ttu-id="b9cd2-184">연결 문자열 매개 변수 형식으로 식별 됩니다  *\<매개 변수 이름 > =* 합니다.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-184">Connection string parameters are identified in the form *\<parameter name>=*.</span></span> <span data-ttu-id="b9cd2-185">여러 매개 변수를 세미콜론(;)으로 구분하여 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-185">Multiple parameters can be specified, delimited using a semicolon (;).</span></span> <span data-ttu-id="b9cd2-186">**참고:** 지정 하지 않는 경우 `KeyRestrictions`를 설정 하지만 `KeyRestrictionBehavior` 속성을 `AllowOnly` 또는 `PreventUsage`, 추가 연결 문자열 매개 변수 없이 허용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-186">**Note:**  If you do not specify `KeyRestrictions`, but you set `KeyRestrictionBehavior` property to `AllowOnly` or `PreventUsage`, no additional connection string parameters are allowed.</span></span> <span data-ttu-id="b9cd2-187"><xref:System.Data.Common.DBDataPermissionAttribute>에서 상속됩니다.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-187">Inherited from <xref:System.Data.Common.DBDataPermissionAttribute>.</span></span>|  
|`KeyRestrictionBehavior`|<span data-ttu-id="b9cd2-188">연결 문자열 매개 변수를 허용되는 유일한 추가 매개 변수(`AllowOnly`)로 식별하거나 허용되지 않는 추가 매개 변수(`PreventUsage`)로 식별합니다.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-188">Identifies the connection string parameters as the only additional parameters allowed (`AllowOnly`), or identifies the additional parameters that are not allowed (`PreventUsage`).</span></span> <span data-ttu-id="b9cd2-189">기본값은 `AllowOnly`입니다.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-189">`AllowOnly` is the default.</span></span> <span data-ttu-id="b9cd2-190"><xref:System.Data.Common.DBDataPermissionAttribute>에서 상속됩니다.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-190">Inherited from <xref:System.Data.Common.DBDataPermissionAttribute>.</span></span>|  
|`TypeID`|<span data-ttu-id="b9cd2-191">파생 클래스에서 구현될 때 이 특성의 고유 식별자를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-191">Gets a unique identifier for this attribute when implemented in a derived class.</span></span> <span data-ttu-id="b9cd2-192"><xref:System.Attribute>에서 상속됩니다.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-192">Inherited from <xref:System.Attribute>.</span></span>|  
|`Unrestricted`|<span data-ttu-id="b9cd2-193">리소스에 무제한 권한이 선언되었는지 여부를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-193">Indicates whether unrestricted permission to the resource is declared.</span></span> <span data-ttu-id="b9cd2-194"><xref:System.Security.Permissions.SecurityAttribute>에서 상속됩니다.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-194">Inherited from <xref:System.Security.Permissions.SecurityAttribute>.</span></span>|  
  
#### <a name="connectionstring-syntax"></a><span data-ttu-id="b9cd2-195">ConnectionString 구문</span><span class="sxs-lookup"><span data-stu-id="b9cd2-195">ConnectionString Syntax</span></span>  
 <span data-ttu-id="b9cd2-196">다음 예제에서는 구성 파일의 `connectionStrings` 요소를 사용하여 특정 연결 문자열만 사용하도록 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-196">The following example demonstrates how to use the `connectionStrings` element of a configuration file to allow only a specific connection string to be used.</span></span> <span data-ttu-id="b9cd2-197">참조 [연결 문자열](../../../../docs/framework/data/adonet/connection-strings.md) 저장 하 고 구성 파일에서 연결 문자열 검색에 대 한 자세한 내용은 합니다.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-197">See [Connection Strings](../../../../docs/framework/data/adonet/connection-strings.md) for more information on storing and retrieving connection strings from configuration files.</span></span>  
  
```xml  
<connectionStrings>  
  <add name="DatabaseConnection"   
    connectionString="Data Source=(local);Initial   
    Catalog=Northwind;Integrated Security=true;" />  
</connectionStrings>  
```  
  
#### <a name="keyrestrictions-syntax"></a><span data-ttu-id="b9cd2-198">KeyRestrictions 구문</span><span class="sxs-lookup"><span data-stu-id="b9cd2-198">KeyRestrictions Syntax</span></span>  
 <span data-ttu-id="b9cd2-199">다음 예제에서는 동일한 연결 문자열을 사용 하도록 설정 합니다 `Encrypt` 고 `Packet Size` 연결 문자열 옵션 이지만 다른 모든 연결 문자열 옵션의 사용을 제한 합니다.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-199">The following example enables the same connection string, enables the use of the `Encrypt` and `Packet Size` connection string options, but restricts the use of any other connection string options.</span></span>  
  
```xml  
<connectionStrings>  
  <add name="DatabaseConnection"   
    connectionString="Data Source=(local);Initial   
    Catalog=Northwind;Integrated Security=true;"  
    KeyRestrictions="Encrypt=;Packet Size=;"  
    KeyRestrictionBehavior="AllowOnly" />  
</connectionStrings>  
```  
  
#### <a name="keyrestrictionbehavior-with-preventusage-syntax"></a><span data-ttu-id="b9cd2-200">PreventUsage 구문을 사용한 KeyRestrictionBehavior</span><span class="sxs-lookup"><span data-stu-id="b9cd2-200">KeyRestrictionBehavior with PreventUsage Syntax</span></span>  
 <span data-ttu-id="b9cd2-201">다음 예제에서는 동일한 연결 문자열을 사용하고 `User Id`, `Password` 및 `Persist Security Info`를 제외한 다른 모든 연결 매개 변수를 허용합니다.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-201">The following example enables the same connection string and allows all other connection parameters except for `User Id`, `Password` and `Persist Security Info`.</span></span>  
  
```xml  
<connectionStrings>  
  <add name="DatabaseConnection"   
    connectionString="Data Source=(local);Initial   
    Catalog=Northwind;Integrated Security=true;"  
    KeyRestrictions="User Id=;Password=;Persist Security Info=;"  
    KeyRestrictionBehavior="PreventUsage" />  
</connectionStrings>  
```  
  
#### <a name="keyrestrictionbehavior-with-allowonly-syntax"></a><span data-ttu-id="b9cd2-202">AllowOnly 구문을 사용한 KeyRestrictionBehavior</span><span class="sxs-lookup"><span data-stu-id="b9cd2-202">KeyRestrictionBehavior with AllowOnly Syntax</span></span>  
 <span data-ttu-id="b9cd2-203">다음 예제에서는 `Initial Catalog`, `Connection Timeout`, `Encrypt` 및 `Packet Size` 매개 변수가 들어 있는 두 개의 연결 문자열을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-203">The following example enables two connection strings that also contain `Initial Catalog`, `Connection Timeout`, `Encrypt`, and `Packet Size` parameters.</span></span> <span data-ttu-id="b9cd2-204">다른 모든 연결 문자열 매개 변수는 제한됩니다.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-204">All other connection string parameters are restricted.</span></span>  
  
```xml  
<connectionStrings>  
  <add name="DatabaseConnection"   
    connectionString="Data Source=(local);Initial   
    Catalog=Northwind;Integrated Security=true;"  
    KeyRestrictions="Initial Catalog;Connection Timeout=;  
       Encrypt=;Packet Size=;"   
    KeyRestrictionBehavior="AllowOnly" />  
  
  <add name="DatabaseConnection2"   
    connectionString="Data Source=SqlServer2;Initial   
    Catalog=Northwind2;Integrated Security=true;"  
    KeyRestrictions="Initial Catalog;Connection Timeout=;  
       Encrypt=;Packet Size=;"   
    KeyRestrictionBehavior="AllowOnly" />  
</connectionStrings>  
```  
  
### <a name="enabling-partial-trust-with-a-custom-permission-set"></a><span data-ttu-id="b9cd2-205">사용자 지정 권한 집합을 사용하여 부분 신뢰 활성화</span><span class="sxs-lookup"><span data-stu-id="b9cd2-205">Enabling Partial Trust with a Custom Permission Set</span></span>  
 <span data-ttu-id="b9cd2-206">특정 영역에 대해 <xref:System.Data.SqlClient> 권한 사용을 활성화하려면 시스템 관리자는 사용자 지정 권한 집합을 만들고 이를 특정 영역에 대한 권한 집합으로 설정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-206">To enable the use of <xref:System.Data.SqlClient> permissions for a particular zone, a system administrator must create a custom permission set and set it as the permission set for a particular zone.</span></span> <span data-ttu-id="b9cd2-207">`LocalIntranet`과 같은 기본 권한 집합은 수정할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-207">Default permission sets, such as `LocalIntranet`, cannot be modified.</span></span> <span data-ttu-id="b9cd2-208">예를 들어 포함 하도록 <xref:System.Data.SqlClient> 있는 코드에 대 한 권한을 <xref:System.Security.Policy.Zone> 의 `LocalIntranet`, 시스템 관리자는 사용 권한 집합을 복사할 수 있습니다 `LocalIntranet`이름을 "CustomLocalIntranet"으로, 추가 <xref:System.Data.SqlClient> 권한 가져오기 CustomLocalIntranet 권한 집합을 [Caspol.exe (코드 액세스 보안 정책 도구)](../../../../docs/framework/tools/caspol-exe-code-access-security-policy-tool.md)의 권한 집합 및 `LocalIntranet_Zone` CustomLocalIntranet를 합니다.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-208">For example, to include <xref:System.Data.SqlClient> permissions for code that has a <xref:System.Security.Policy.Zone> of `LocalIntranet`, a system administrator could copy the permission set for `LocalIntranet`, rename it to "CustomLocalIntranet", add the <xref:System.Data.SqlClient> permissions, import the CustomLocalIntranet permission set using the [Caspol.exe (Code Access Security Policy Tool)](../../../../docs/framework/tools/caspol-exe-code-access-security-policy-tool.md), and set the permission set of `LocalIntranet_Zone` to CustomLocalIntranet.</span></span>  
  
### <a name="sample-permission-set"></a><span data-ttu-id="b9cd2-209">권한 집합 예제</span><span class="sxs-lookup"><span data-stu-id="b9cd2-209">Sample Permission Set</span></span>  
 <span data-ttu-id="b9cd2-210">다음은 부분 신뢰 권한일 경우의 .NET Framework Data Provider for SQL Server에 대한 권한 집합 예제입니다.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-210">The following is a sample permission set for the .NET Framework Data Provider for SQL Server in a partially trusted scenario.</span></span> <span data-ttu-id="b9cd2-211">사용자 지정 권한 집합을 만드는 방법에 대 한 정보를 참조 하세요 [NIB: 구성 설정 사용 하 여 Caspol.exe를 권한](https://msdn.microsoft.com/library/94e2625e-21ad-4038-af36-6d1f9df40a57)합니다.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-211">For information on creating custom permission sets, see [NIB:Configuring Permission Sets Using Caspol.exe](https://msdn.microsoft.com/library/94e2625e-21ad-4038-af36-6d1f9df40a57).</span></span>  
  
```xml  
<PermissionSet class="System.Security.NamedPermissionSet"  
  version="1"  
  Name="CustomLocalIntranet"  
  Description="Custom permission set given to applications on  
    the local intranet">  
  
<IPermission class="System.Data.SqlClient.SqlClientPermission, System.Data, Version=2.0.0000.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"  
version="1"  
AllowBlankPassword="False">  
<add ConnectionString="Data Source=(local);Integrated Security=true;"  
 KeyRestrictions="Initial Catalog=;Connection Timeout=;  
   Encrypt=;Packet Size=;"   
 KeyRestrictionBehavior="AllowOnly" />  
 </IPermission>  
</PermissionSet>  
```  
  
## <a name="verifying-adonet-code-access-using-security-permissions"></a><span data-ttu-id="b9cd2-212">보안 권한을 사용하여 ADO.NET 코드 액세스 확인</span><span class="sxs-lookup"><span data-stu-id="b9cd2-212">Verifying ADO.NET Code Access Using Security Permissions</span></span>  
 <span data-ttu-id="b9cd2-213">부분 신뢰 권한의 경우 <xref:System.Data.SqlClient.SqlClientPermissionAttribute>를 지정하여 코드의 특정 메서드에 대해 CAS 권한을 요구할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-213">For partial-trust scenarios, you can require CAS privileges for particular methods in your code by specifying a <xref:System.Data.SqlClient.SqlClientPermissionAttribute>.</span></span> <span data-ttu-id="b9cd2-214">제한된 보안 정책의 적용으로 이 권한이 허용되지 않는 경우 코드가 실행되기 전에 예외가 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-214">If that privilege is not allowed by the restricted security policy in effect, an exception is thrown before your code is run.</span></span> <span data-ttu-id="b9cd2-215">보안 정책에 대 한 자세한 내용은 참조 하세요. [NIB: 보안 정책 관리](https://msdn.microsoft.com/library/d754e05d-29dc-4d3a-a2c2-95eaaf1b82b9) 하 고 [NIB: 보안 정책에 대 한 유용한 정보](https://msdn.microsoft.com/library/d49bc4d5-efb7-4caa-a2fe-e4d3cec63c05)합니다.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-215">For more information on security policy, see [NIB: Security Policy Management](https://msdn.microsoft.com/library/d754e05d-29dc-4d3a-a2c2-95eaaf1b82b9) and [NIB: Security Policy Best Practices](https://msdn.microsoft.com/library/d49bc4d5-efb7-4caa-a2fe-e4d3cec63c05).</span></span>  
  
### <a name="example"></a><span data-ttu-id="b9cd2-216">예제</span><span class="sxs-lookup"><span data-stu-id="b9cd2-216">Example</span></span>  
 <span data-ttu-id="b9cd2-217">다음 예제에서는 특정 연결 문자열을 필요로 하는 코드를 작성하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-217">The following example demonstrates how to write code that requires a particular connection string.</span></span> <span data-ttu-id="b9cd2-218">또한 이 예제에서는 시스템 관리자가 실제로 CAS 정책을 사용하여 구현하는 <xref:System.Data.SqlClient>에 대한 무제한 권한을 거부하는 것을 시뮬레이션합니다.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-218">It simulates denying unrestricted permissions to <xref:System.Data.SqlClient>, which a system administrator would implement using a CAS policy in the real world.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="b9cd2-219">ADO.NET에 대한 CAS 권한을 디자인할 때 올바른 패턴은 가장 제한이 심한 경우(권한이 없는 경우)부터 시작하여 코드가 수행해야 하는 특정 작업에 필요한 특정 권한을 추가하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-219">When designing CAS permissions for ADO.NET, the correct pattern is to start with the most restrictive case (no permissions at all) and then add the specific permissions that are needed for the particular task that the code needs to perform.</span></span> <span data-ttu-id="b9cd2-220">반대 패턴인 모든 권한을 부여한 다음 특정 권한을 부여하지 않는 방식은 동일한 연결 문자열을 표현하는 방법이 많으므로 안전하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-220">The opposite pattern, starting with all permissions and then denying a specific permission, is not secure because there are many ways of expressing the same connection string.</span></span> <span data-ttu-id="b9cd2-221">예를 들어, 모든 권한을 부여한 다음 연결 문자열 "server=someserver"에 대해 사용할 수 있는 권한을 주지 않아도 "server=someserver.mycompany.com"은 여전히 허용됩니다.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-221">For example, if you start with all permissions and then attempt to deny the use of the connection string "server=someserver", the string "server=someserver.mycompany.com" would still be allowed.</span></span> <span data-ttu-id="b9cd2-222">항상 권한을 전혀 부여하지 않은 상태에서 시작하여 권한 집합에 허점이 생길 위험을 줄이는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-222">By always starting by granting no permissions at all, you reduce the chances that there are holes in the permission set.</span></span>  
  
 <span data-ttu-id="b9cd2-223">다음 코드에서는 적절한 CAS 권한이 없는 경우 `SqlClient`가 <xref:System.Security.SecurityException>을 throw하는 보안 요구를 수행하는 방식을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-223">The following code demonstrates how `SqlClient` performs the security demand, which throws a <xref:System.Security.SecurityException> if the appropriate CAS permissions are not in place.</span></span> <span data-ttu-id="b9cd2-224"><xref:System.Security.SecurityException> 출력은 콘솔 창에 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-224">The <xref:System.Security.SecurityException> output is displayed in the console window.</span></span>  
  
 [!code-csharp[DataWorks SqlClient.CAS#1](../../../../samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks SqlClient.CAS/CS/source.cs#1)]
 [!code-vb[DataWorks SqlClient.CAS#1](../../../../samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks SqlClient.CAS/VB/source.vb#1)]  
  
 <span data-ttu-id="b9cd2-225">콘솔 창에 표시되는 출력은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-225">You should see this output in the Console window:</span></span>  
  
```  
Failed, as expected: <IPermission class="System.Data.SqlClient.  
SqlClientPermission, System.Data, Version=2.0.0.0,   
  Culture=neutral, PublicKeyToken=b77a5c561934e089" version="1"  
  AllowBlankPassword="False">  
<add ConnectionString="Data Source=(local);Initial Catalog=  
  Northwind;Integrated Security=SSPI" KeyRestrictions=""  
KeyRestrictionBehavior="AllowOnly"/>  
</IPermission>  
  
Connection opened, as expected.  
Failed, as expected: Request failed.  
```  
  
## <a name="interoperability-with-unmanaged-code"></a><span data-ttu-id="b9cd2-226">비관리 코드와의 상호 운용성</span><span class="sxs-lookup"><span data-stu-id="b9cd2-226">Interoperability with Unmanaged Code</span></span>  
 <span data-ttu-id="b9cd2-227">CLR 외부에서 실행되는 코드를 비관리 코드라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-227">Code that runs outside the CLR is called unmanaged code.</span></span> <span data-ttu-id="b9cd2-228">따라서 비관리 코드에는 CAS와 같은 보안 메커니즘을 적용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-228">Therefore, security mechanisms such as CAS cannot be applied to unmanaged code.</span></span> <span data-ttu-id="b9cd2-229">비관리 코드로는 COM 구성 요소, ActiveX 인터페이스, Win32 API 함수 등이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-229">COM components, ActiveX interfaces, and Win32 API functions are examples of unmanaged code.</span></span> <span data-ttu-id="b9cd2-230">비관리 코드를 실행할 때에는 특수한 보안 고려 사항이 적용되므로 전체적인 응용 프로그램 보안이 손상되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-230">Special security considerations apply when executing unmanaged code so that you do not jeopardize overall application security.</span></span> <span data-ttu-id="b9cd2-231">자세한 내용은 [비관리 코드 상호 운용](../../../../docs/framework/interop/index.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-231">For more information, see [Interoperating with Unmanaged Code](../../../../docs/framework/interop/index.md).</span></span>  
  
 <span data-ttu-id="b9cd2-232">.NET Framework는 COM interop를 통해 액세스를 제공함으로써 기존 COM 구성 요소에 대한 이전 버전과의 호환성도 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-232">The .NET Framework also supports backward compatibility to existing COM components by providing access through COM interop.</span></span> <span data-ttu-id="b9cd2-233">즉, 관련 COM 형식을 가져오는 COM interop 도구를 사용하여 COM 구성 요소를 .NET Framework 응용 프로그램에 통합할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-233">You can incorporate COM components into a .NET Framework application by using COM interop tools to import the relevant COM types.</span></span> <span data-ttu-id="b9cd2-234">COM 형식을 가져온 후에는 즉시 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-234">Once imported, the COM types are ready to use.</span></span> <span data-ttu-id="b9cd2-235">COM interop을 사용하면 어셈블리 메타데이터를 형식 라이브러리로 내보내고 관리 구성 요소를 COM 구성 요소로 등록하여 COM 클라이언트에서 관리 코드에 액세스할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-235">COM interop also enables COM clients to access managed code by exporting assembly metadata to a type library and registering the managed component as a COM component.</span></span> <span data-ttu-id="b9cd2-236">자세한 내용은 [고급 COM 상호 운용성](https://msdn.microsoft.com/library/3ada36e5-2390-4d70-b490-6ad8de92f2fb)합니다.</span><span class="sxs-lookup"><span data-stu-id="b9cd2-236">For more information, see [Advanced COM Interoperability](https://msdn.microsoft.com/library/3ada36e5-2390-4d70-b490-6ad8de92f2fb).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="b9cd2-237">참고 항목</span><span class="sxs-lookup"><span data-stu-id="b9cd2-237">See Also</span></span>  
 [<span data-ttu-id="b9cd2-238">ADO.NET 응용 프로그램 보안</span><span class="sxs-lookup"><span data-stu-id="b9cd2-238">Securing ADO.NET Applications</span></span>](../../../../docs/framework/data/adonet/securing-ado-net-applications.md)  
 [<span data-ttu-id="b9cd2-239">네이티브 및 .NET Framework 코드의 PAVE 보안</span><span class="sxs-lookup"><span data-stu-id="b9cd2-239">PAVE Security in Native and .NET Framework Code</span></span>](https://msdn.microsoft.com/library/bd61be84-c143-409a-a75a-44253724f784)  
 [<span data-ttu-id="b9cd2-240">코드 액세스 보안</span><span class="sxs-lookup"><span data-stu-id="b9cd2-240">Code Access Security</span></span>](https://msdn.microsoft.com/library/23a20143-241d-4fe5-9d9f-3933fd594c03)  
 [<span data-ttu-id="b9cd2-241">역할 기반 보안</span><span class="sxs-lookup"><span data-stu-id="b9cd2-241">Role-Based Security</span></span>](https://msdn.microsoft.com/library/239442e3-5be4-4203-b7fd-793baffea803)  
 [<span data-ttu-id="b9cd2-242">ADO.NET 관리되는 공급자 및 데이터 집합 개발자 센터</span><span class="sxs-lookup"><span data-stu-id="b9cd2-242">ADO.NET Managed Providers and DataSet Developer Center</span></span>](https://go.microsoft.com/fwlink/?LinkId=217917)

---
title: 단일 단계 커밋 및 승격 가능한 단일 단계 알림을 사용한 최적화
ms.date: 03/30/2017
ms.assetid: 57beaf1a-fb4d-441a-ab1d-bc0c14ce7899
ms.openlocfilehash: 73340f5f65de1d743e046cf669258ab5f6c66298
ms.sourcegitcommit: 9b552addadfb57fab0b9e7852ed4f1f1b8a42f8e
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 04/23/2019
ms.locfileid: "61793629"
---
# <a name="optimization-using-single-phase-commit-and-promotable-single-phase-notification"></a><span data-ttu-id="efc45-102">단일 단계 커밋 및 승격 가능한 단일 단계 알림을 사용한 최적화</span><span class="sxs-lookup"><span data-stu-id="efc45-102">Optimization using Single Phase Commit and Promotable Single Phase Notification</span></span>

<span data-ttu-id="efc45-103">이 항목에서는 <xref:System.Transactions> 인프라가 제공하는 성능 최적화 메커니즘에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="efc45-103">This topic describes the mechanisms provided by the <xref:System.Transactions> infrastructure to optimize performance.</span></span>

## <a name="promotable-single-phase-enlistment"></a><span data-ttu-id="efc45-104">승격 가능한 단일 단계 인리스트먼트</span><span class="sxs-lookup"><span data-stu-id="efc45-104">Promotable Single Phase Enlistment</span></span>

<span data-ttu-id="efc45-105"><xref:System.Transactions> 인터페이스는 하나 이하의 지속적인 리소스나 여러 개의 일시적인 리소스와 관련된 단일 애플리케이션 도메인 내부의 트랜잭션을 관리합니다.</span><span class="sxs-lookup"><span data-stu-id="efc45-105">The <xref:System.Transactions> infrastructure administrates a transaction inside a single application domain that involves at most a single durable resource or multiple volatile resources.</span></span> <span data-ttu-id="efc45-106"><xref:System.Transactions> 인프라는 애플리케이션 도메인 간 호출만 사용하므로 최상의 처리량과 성능을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="efc45-106">Since the <xref:System.Transactions> infrastructure uses only intra-application domain calls, it yields the best throughput and performance.</span></span>

<span data-ttu-id="efc45-107">그러나 동일한 컴퓨터에서 다른 애플리케이션 도메인의 다른 개체(프로세스 및 컴퓨터 경계를 넘는 경우 포함)에 트랜잭션을 제공하려는 경우 또는 다른 지속적인 리소스 관리자를 참여시키려는 경우 <xref:System.Transactions> 인프라가 자동으로 MSDTC에서 관리할 트랜잭션을 에스컬레이션합니다.</span><span class="sxs-lookup"><span data-stu-id="efc45-107">However, if the transaction is provided to another object in another application domain (including across process and machine boundaries) on the same computer, or if you were to enlist another durable resource manager, the <xref:System.Transactions> infrastructure automatically escalates the transaction to be managed by the MSDTC.</span></span> <span data-ttu-id="efc45-108">MSDTC에 의해 관리되는 트랜잭션은 <xref:System.Transactions> 인프라에서 관리되는 트랜잭션만큼 성능이 뛰어나지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="efc45-108">A transaction managed by MSDTC is not as performance-wise as one managed by the <xref:System.Transactions> infrastructure.</span></span>

<span data-ttu-id="efc45-109">성능을 최적화하기 위해 <xref:System.Transactions> 인프라는 다른 애플리케이션 도메인, 프로세스 또는 컴퓨터에 있는 하나의 지속적인 원격 리소스가 MSDTC 트랜잭션으로 에스컬레이션되지 않고도 <xref:System.Transactions> 트랜잭션에 참여할 수 있도록 하는 PSPE(승격 가능한 단일 단계 인리스트먼트)를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="efc45-109">To optimize performance, the <xref:System.Transactions> infrastructure provides the Promotable Single Phase Enlistment (PSPE) that allows a single remote durable resource, located in a different application domain, process or machine, to participate in a <xref:System.Transactions> transaction without causing it to be escalated to an MSDTC transaction.</span></span> <span data-ttu-id="efc45-110">이 RM(리소스 관리자)은 트랜잭션을 호스팅하고 "소유"할 수 있으며, 필요한 경우 나중에 해당 트랜잭션을 분산 트랜잭션(또는 MSDTC 트랜잭션)으로 에스컬레이션할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="efc45-110">This resource manager (RM) can host and "own" a transaction that can later be escalated to a distributed transaction (or MSDTC transaction) if necessary.</span></span> <span data-ttu-id="efc45-111">이 경우 MSDTC를 사용할 가능성이 줄어듭니다.</span><span class="sxs-lookup"><span data-stu-id="efc45-111">This reduces the chance of using the MSDTC.</span></span>

<span data-ttu-id="efc45-112">이 특정 리소스 관리자에는 일반적으로 분산되지 않은 고유한 내부 트랜잭션이 있으며, 런타임에 해당 트랜잭션을 분산 트랜잭션으로 변환하는 기능을 지원해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="efc45-112">This specific resource manager usually has its own internal non distributed transactions and it needs to support converting those transactions to distributed transactions at runtime.</span></span> <span data-ttu-id="efc45-113">예를 들어 SQL Server 2005가 이러한 리소스 관리자입니다.</span><span class="sxs-lookup"><span data-stu-id="efc45-113">For example, SQL Server 2005 is such a resource manager.</span></span> <span data-ttu-id="efc45-114">이 경우 <xref:System.Transactions> 인프라는 에스컬레이션할 필요가 있는지 트랜잭션을 모니터링만 하여 수동적인 관리 역할을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="efc45-114">In such case, the <xref:System.Transactions> infrastructure takes a passive management role by just monitoring the transaction for a need for escalation.</span></span> <span data-ttu-id="efc45-115"><xref:System.Transactions> 인프라와 리소스 관리자 간의 상호 작용을 지원하려면 리소스 관리자에서 <xref:System.Transactions.IPromotableSinglePhaseNotification> 인터페이스를 구현해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="efc45-115">To support the interaction between the <xref:System.Transactions> infrastructure and resource manager, the latter needs to implement the interface <xref:System.Transactions.IPromotableSinglePhaseNotification>.</span></span>

<span data-ttu-id="efc45-116"><xref:System.Transactions.Transaction.EnlistPromotableSinglePhase%2A> 메서드는 나중에 에스컬레이션할 수 있는 하나의 지속적인 리소스를 참여시키는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="efc45-116">The <xref:System.Transactions.Transaction.EnlistPromotableSinglePhase%2A> method is used to enlist a single durable resource that can be escalated later.</span></span> <span data-ttu-id="efc45-117">이 메서드를 사용하면 필요에 따라 인리스트먼트를 에스컬레이션할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="efc45-117">This method ensures that the enlistment can be escalated as needed.</span></span> <span data-ttu-id="efc45-118">인리스트먼트가 성공하면 RM은 내부 트랜잭션을 만들어 <xref:System.Transactions> 트랜잭션과 연결합니다.</span><span class="sxs-lookup"><span data-stu-id="efc45-118">If the enlistment succeeds, the RM creates its internal transaction and associates it with the <xref:System.Transactions> transaction.</span></span> <span data-ttu-id="efc45-119">PSPE 인리스트먼트가 실패하면 대신 RM에서 <xref:System.Transactions.Transaction.EnlistDurable%2A> 메서드를 사용하여 참여시켜야 합니다.</span><span class="sxs-lookup"><span data-stu-id="efc45-119">If the PSPE enlistment fails, the RM should instead enlist using the <xref:System.Transactions.Transaction.EnlistDurable%2A> method.</span></span> <span data-ttu-id="efc45-120">트랜잭션이 이미 분산 트랜잭션인 경우 또는 다른 RM에서 PSPE 인리스트먼트를 수행한 경우 PSPE의 인리스트먼트가 실패할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="efc45-120">Failures to enlist in PSPE might happen when the transaction is already a distributed transaction, or when another RM has already performed a PSPE enlistment</span></span>

<span data-ttu-id="efc45-121">참여되고 나면 <xref:System.Transactions> 트랜잭션을 커밋하거나 중단하는 클라이언트 호출이 각각 <xref:System.Transactions.IPromotableSinglePhaseNotification.SinglePhaseCommit%2A> 메서드나 <xref:System.Transactions.IPromotableSinglePhaseNotification.Rollback%2A>을 호출하여 리소스 관리자 호출로 변환됩니다.</span><span class="sxs-lookup"><span data-stu-id="efc45-121">Once enlisted, calls by clients to commit or abort the <xref:System.Transactions> transaction are converted to calls on the Resource Manager by invoking the <xref:System.Transactions.IPromotableSinglePhaseNotification.SinglePhaseCommit%2A> method, or the <xref:System.Transactions.IPromotableSinglePhaseNotification.Rollback%2A> respectively.</span></span>

<span data-ttu-id="efc45-122"><xref:System.Transactions> 트랜잭션에 에스컬레이션이 필요하지 않는 경우 트랜잭션을 커밋하면 RM이 <xref:System.Transactions.IPromotableSinglePhaseNotification.SinglePhaseCommit%2A> 알림을 받습니다.</span><span class="sxs-lookup"><span data-stu-id="efc45-122">If the <xref:System.Transactions> transaction never requires escalation, when the transaction is committed, the RM receives a <xref:System.Transactions.IPromotableSinglePhaseNotification.SinglePhaseCommit%2A> notification.</span></span> <span data-ttu-id="efc45-123">그런 다음 처음에 만들어진 내부 트랜잭션을 커밋할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="efc45-123">It can then commit the internal transaction that was initially created.</span></span>

<span data-ttu-id="efc45-124"><xref:System.Transactions> 트랜잭션을 워크플로 인스턴스해야 하는 경우(예: 여러 RM을 지원하기 위해) <xref:System.Transactions>는 <xref:System.Transactions.ITransactionPromoter.Promote%2A> 인터페이스가 파생되는 <xref:System.Transactions.ITransactionPromoter> 인터페이스에서 <xref:System.Transactions.IPromotableSinglePhaseNotification> 메서드를 호출하여 리소스 관리자에 알립니다.</span><span class="sxs-lookup"><span data-stu-id="efc45-124">If the <xref:System.Transactions> transaction needs to be escalated (e.g., to support multiple RMs), <xref:System.Transactions> informs the resource manager by calling the <xref:System.Transactions.ITransactionPromoter.Promote%2A> method on the <xref:System.Transactions.ITransactionPromoter> interface, from which the <xref:System.Transactions.IPromotableSinglePhaseNotification> interface derives.</span></span> <span data-ttu-id="efc45-125">그런 다음 리소스 관리자는 로깅이 필요하지 않은 로컬 트랜잭션에서 DTC 트랜잭션에 참여할 수 있는 트랜잭션 개체로 트랜잭션을 내부적으로 변환하고 이미 수행된 작업과 연결합니다.</span><span class="sxs-lookup"><span data-stu-id="efc45-125">The resource manager then converts the transaction internally from a local transaction (which does not require logging) to a transaction object that is capable of participating in a DTC transaction, and associates it with the work already done.</span></span> <span data-ttu-id="efc45-126">트랜잭션을 커밋하도록 요청된 경우에도 트랜잭션 관리자는 리소스 관리자에게 <xref:System.Transactions.IPromotableSinglePhaseNotification.SinglePhaseCommit%2A> 알림을 보내며, 리소스 관리자가 에스컬레이션 중에 만든 분산 트랜잭션을 커밋합니다.</span><span class="sxs-lookup"><span data-stu-id="efc45-126">When the transaction is asked to commit, the transaction manager still sends the <xref:System.Transactions.IPromotableSinglePhaseNotification.SinglePhaseCommit%2A> notification to the resource manager, which commits the distributed transaction that it created during escalation.</span></span>

> [!NOTE]
> <span data-ttu-id="efc45-127">합니다 **TransactionCommitted** DTC 트랜잭션의 활동 ID를 포함 하는 추적 (에스컬레이션 트랜잭션에서 커밋을 호출할 때 생성 됨).</span><span class="sxs-lookup"><span data-stu-id="efc45-127">The **TransactionCommitted** traces (that are generated when a Commit is invoked on the escalated transaction) contain the activity ID of the DTC transaction.</span></span>

<span data-ttu-id="efc45-128">관리 에스컬레이션에 대 한 자세한 내용은 참조 하세요. [트랜잭션 관리 에스컬레이션](../../../../docs/framework/data/transactions/transaction-management-escalation.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="efc45-128">For more information on management escalation, see [Transaction Management Escalation](../../../../docs/framework/data/transactions/transaction-management-escalation.md).</span></span>

## <a name="transaction-management-escalation-scenario"></a><span data-ttu-id="efc45-129">트랜잭션 관리 에스컬레이션 시나리오</span><span class="sxs-lookup"><span data-stu-id="efc45-129">Transaction Management Escalation Scenario</span></span>

<span data-ttu-id="efc45-130">다음 시나리오에서는 <xref:System.Data> 네임스페이스를 리소스 관리자의 '프록시'로 사용하여 분산 트랜잭션으로 에스컬레이션하는 과정을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="efc45-130">The following scenario demonstrates an escalation to a distributed transaction using the <xref:System.Data> namespace as the ‘proxy’ for the resource manager.</span></span> <span data-ttu-id="efc45-131">이 시나리오에서는 트랜잭션에 관련된 CN1 데이터베이스에 대한 <xref:System.Data> 연결이 이미 있으며 애플리케이션이 다른 <xref:System.Data> 연결인 CN2를 관련시키려 한다고 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="efc45-131">This scenario assumes that there is already one <xref:System.Data> connection to the database, CN1, involved in the transaction, and the application wants to involve another <xref:System.Data> connection, CN2.</span></span> <span data-ttu-id="efc45-132">완전히 분산된 2단계 커밋 트랜잭션으로 트랜잭션을 DTC로 에스컬레이션해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="efc45-132">The transaction must be escalated to DTC, as a full distributed two-phase commit transaction.</span></span>

<span data-ttu-id="efc45-133">이 시나리오에서는 다음 작업이 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="efc45-133">In this scenario,</span></span>

1. <span data-ttu-id="efc45-134">CN1이 트랜잭션에 참여할 <xref:System.Transactions.Transaction.EnlistPromotableSinglePhase%2A> 메서드를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="efc45-134">CN1 calls the <xref:System.Transactions.Transaction.EnlistPromotableSinglePhase%2A> method to enlist in the transaction.</span></span> <span data-ttu-id="efc45-135">그런 후에도 트랜잭션은 여전히 로컬이며 트랜잭션에 승격 가능한 다른 인리스트먼트가 없으므로 <xref:System.Transactions.Transaction.EnlistPromotableSinglePhase%2A> 호출이 성공합니다.</span><span class="sxs-lookup"><span data-stu-id="efc45-135">Then, the transaction is still local and there are no other promotable enlistments on the transaction, so the <xref:System.Transactions.Transaction.EnlistPromotableSinglePhase%2A> call succeeds.</span></span>

2. <span data-ttu-id="efc45-136">두 번째 연결인 CN2가 <xref:System.Transactions.Transaction.EnlistPromotableSinglePhase%2A>를 호출할 경우 승격 가능한 다른 인리스트먼트가 관련되어 있으므로 호출이 실패합니다.</span><span class="sxs-lookup"><span data-stu-id="efc45-136">When the second connection, CN2 calls <xref:System.Transactions.Transaction.EnlistPromotableSinglePhase%2A>, the call fails because there is another promotable enlistment involved.</span></span> <span data-ttu-id="efc45-137">이 때문에 CN2는 SQL로 전달하기 위해 DTC 트랜잭션을 가져와야 합니다.</span><span class="sxs-lookup"><span data-stu-id="efc45-137">Because of this, CN2 must get a DTC transaction in order to pass it to SQL.</span></span> <span data-ttu-id="efc45-138">이렇게 하려면 <xref:System.Transactions.TransactionInterop> 클래스가 제공하는 메서드 중 하나를 사용하여 SQL에 제공할 수 있는 트랜잭션 형식을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="efc45-138">To do this, it uses one of the methods provided by the <xref:System.Transactions.TransactionInterop> class to produce a format of the transaction that can be given to SQL.</span></span>

3. <span data-ttu-id="efc45-139"><xref:System.Transactions>는 CN1이 구현하는 <xref:System.Transactions.ITransactionPromoter.Promote%2A> 인터페이스에서 <xref:System.Transactions.ITransactionPromoter> 메서드를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="efc45-139"><xref:System.Transactions> calls the <xref:System.Transactions.ITransactionPromoter.Promote%2A> method on the <xref:System.Transactions.ITransactionPromoter> interface implemented by CN1.</span></span>

4. <span data-ttu-id="efc45-140">이때 CN1은 SQL 2005 및 <xref:System.Data>와 관련된 메커니즘을 사용하여 트랜잭션을 에스컬레이션합니다.</span><span class="sxs-lookup"><span data-stu-id="efc45-140">At this point, CN1 escalates the transaction, using some mechanism specific to SQL 2005 and <xref:System.Data>.</span></span>

5. <span data-ttu-id="efc45-141"><xref:System.Transactions.ITransactionPromoter.Promote%2A> 메서드의 반환 값은 트랜잭션에 대한 전파 토큰을 포함하는 바이트 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="efc45-141">The return value from the <xref:System.Transactions.ITransactionPromoter.Promote%2A> method is a byte array that contains a propagation token for the transaction.</span></span> <span data-ttu-id="efc45-142"><xref:System.Transactions> 이 전파 토큰을 사용 하 여 로컬 트랜잭션에 통합할 수 있는 DTC 트랜잭션을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="efc45-142"><xref:System.Transactions> uses this propagation token to create a DTC transaction that it can incorporate into the local transaction.</span></span>

6. <span data-ttu-id="efc45-143">이때 CN2는 <xref:System.Transactions.TransactionInterop>에 의해 메서드 중 하나를 호출하여 받은 데이터를 사용하여 트랜잭션을 SQL로 전달할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="efc45-143">At this point, CN2 can use the data received from calling one of the methods by <xref:System.Transactions.TransactionInterop> to pass the transaction to SQL.</span></span>

7. <span data-ttu-id="efc45-144">이제 둘 다 DTC 분산 트랜잭션에 참여합니다.</span><span class="sxs-lookup"><span data-stu-id="efc45-144">Now, both are enlisted in a DTC distributed transaction.</span></span>

## <a name="single-phase-commit-optimization"></a><span data-ttu-id="efc45-145">단일 단계 커밋 최적화</span><span class="sxs-lookup"><span data-stu-id="efc45-145">Single Phase Commit Optimization</span></span>

<span data-ttu-id="efc45-146">단일 단계 커밋 프로토콜은 모든 업데이트가 명시적 코디네이션 없이 수행되므로 런타임에 보다 효율적입니다.</span><span class="sxs-lookup"><span data-stu-id="efc45-146">The Single Phase Commit protocol is more efficient at runtime as all updates are done without any explicit coordination.</span></span> <span data-ttu-id="efc45-147">이 최적화를 활용하려면 리소스에 대해 <xref:System.Transactions.ISinglePhaseNotification> 인터페이스를 사용하는 리소스 관리자를 구현하고 <xref:System.Transactions.Transaction.EnlistDurable%2A> 또는 <xref:System.Transactions.Transaction.EnlistVolatile%2A> 메서드를 사용하여 트랜잭션에 참여해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="efc45-147">To take advantage of this optimization, you should implement a resource manager using <xref:System.Transactions.ISinglePhaseNotification> interface for the resource and enlist in a transaction using the <xref:System.Transactions.Transaction.EnlistDurable%2A> or <xref:System.Transactions.Transaction.EnlistVolatile%2A> method.</span></span> <span data-ttu-id="efc45-148">특히 합니다 *EnlistmentOptions* 매개 변수 같아야 <xref:System.Transactions.EnlistmentOptions.None> 단일 단계 커밋이 수행 되는 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="efc45-148">Specifically, the *EnlistmentOptions* parameter should equal to <xref:System.Transactions.EnlistmentOptions.None> to ensure that a single phase commit would be performed.</span></span>

<span data-ttu-id="efc45-149"><xref:System.Transactions.ISinglePhaseNotification> 인터페이스는 <xref:System.Transactions.IEnlistmentNotification> 인터페이스에서 파생되므로 RM이 단일 단계 커밋을 수행할 수 없는 경우에도 2단계 커밋 알림을 받을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="efc45-149">Since the <xref:System.Transactions.ISinglePhaseNotification> interface derives from the <xref:System.Transactions.IEnlistmentNotification> interface, if your RM is not eligible for single phase commit, it can still receive the two phase commit notifications.</span></span> <span data-ttu-id="efc45-150">RM은 TM에서 <xref:System.Transactions.ISinglePhaseNotification.SinglePhaseCommit%2A> 알림을 받을 경우 커밋하는 데 필요한 작업을 수행하고 <xref:System.Transactions.SinglePhaseEnlistment.Committed%2A> 매개 변수에서 <xref:System.Transactions.SinglePhaseEnlistment.Aborted%2A>, <xref:System.Transactions.SinglePhaseEnlistment.InDoubt%2A> 또는 <xref:System.Transactions.SinglePhaseEnlistment> 메서드를 호출하여 트랜잭션이 커밋 또는 롤백됨을 트랜잭션 관리자에게 적절하게 알려야 합니다.</span><span class="sxs-lookup"><span data-stu-id="efc45-150">If your RM receives a <xref:System.Transactions.ISinglePhaseNotification.SinglePhaseCommit%2A> notification from the TM, it should try to do the work necessary for it to commit and correspondingly inform the transaction manager if the transaction is to be committed or rolled back by calling the <xref:System.Transactions.SinglePhaseEnlistment.Committed%2A>, <xref:System.Transactions.SinglePhaseEnlistment.Aborted%2A>, or <xref:System.Transactions.SinglePhaseEnlistment.InDoubt%2A> method on the <xref:System.Transactions.SinglePhaseEnlistment> parameter.</span></span> <span data-ttu-id="efc45-151">이 단계에서 인리스트먼트에 대한 <xref:System.Transactions.Enlistment.Done%2A> 응답은 ReadOnly 의미 체계를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="efc45-151">A response of <xref:System.Transactions.Enlistment.Done%2A> on the enlistment at this stage implies ReadOnly semantics.</span></span> <span data-ttu-id="efc45-152">따라서 다른 모든 메서드와 마찬가지로 <xref:System.Transactions.Enlistment.Done%2A>을 응답하면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="efc45-152">Therefore, you should not reply <xref:System.Transactions.Enlistment.Done%2A> in addition to any of the other methods.</span></span>

<span data-ttu-id="efc45-153">하나의 일시적인 인 리스트 먼 트 및 없습니다 지속적인 인 리스트 먼 있으면 일시적인 인 리스트 먼 트 SPC 알림을 받습니다.</span><span class="sxs-lookup"><span data-stu-id="efc45-153">If there is only one volatile enlistment and no durable enlistment, the volatile enlistment receives SPC notification.</span></span> <span data-ttu-id="efc45-154">모든 일시적인 인 리스트 먼 트와 하나의 지속적인 인 리스트 먼 없으면 일시적인 인 리스트 먼 트가 2PC를 받습니다.</span><span class="sxs-lookup"><span data-stu-id="efc45-154">If there are any volatile enlistments and only one durable enlistment, the volatile enlistments receive 2PC.</span></span> <span data-ttu-id="efc45-155">완료되면 지속적인 인리스트먼트가 SPC를 받습니다.</span><span class="sxs-lookup"><span data-stu-id="efc45-155">When it is completed, the durable enlistment receives SPC.</span></span>

## <a name="see-also"></a><span data-ttu-id="efc45-156">참고자료</span><span class="sxs-lookup"><span data-stu-id="efc45-156">See also</span></span>

- [<span data-ttu-id="efc45-157">리소스를 트랜잭션에 참가 요소로 등록</span><span class="sxs-lookup"><span data-stu-id="efc45-157">Enlisting Resources as Participants in a Transaction</span></span>](../../../../docs/framework/data/transactions/enlisting-resources-as-participants-in-a-transaction.md)
- [<span data-ttu-id="efc45-158">단일 단계 및 다단계 트랜잭션 커밋</span><span class="sxs-lookup"><span data-stu-id="efc45-158">Committing a Transaction in Single-Phase and Multi-Phase</span></span>](../../../../docs/framework/data/transactions/committing-a-transaction-in-single-phase-and-multi-phase.md)

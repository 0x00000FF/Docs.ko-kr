---
title: 지원되지 않는 시나리오
ms.date: 03/30/2017
ms.assetid: 72027d0f-146d-40c5-9d72-e94392c8bb40
ms.openlocfilehash: 381175a95b696145df8a1e19b9a40f2e697eef1e
ms.sourcegitcommit: 6b308cf6d627d78ee36dbbae8972a310ac7fd6c8
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 01/23/2019
ms.locfileid: "54631267"
---
# <a name="unsupported-scenarios"></a><span data-ttu-id="1ad8c-102">지원되지 않는 시나리오</span><span class="sxs-lookup"><span data-stu-id="1ad8c-102">Unsupported Scenarios</span></span>
<span data-ttu-id="1ad8c-103">다양 한 이유로 Windows Communication Foundation (WCF)는 일부 특정 보안 시나리오를 지원 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="1ad8c-103">For various reasons, Windows Communication Foundation (WCF) does not support some specific security scenarios.</span></span> <span data-ttu-id="1ad8c-104">예를 들어 [!INCLUDE[wxp](../../../../includes/wxp-md.md)] Home Edition SSPI 또는 Kerberos 인증 프로토콜을 구현 하지 않으며 WCF 지원 하지 않습니다 해당 플랫폼에서 Windows 인증을 사용 하 여 서비스를 실행 합니다.</span><span class="sxs-lookup"><span data-stu-id="1ad8c-104">For example, [!INCLUDE[wxp](../../../../includes/wxp-md.md)] Home Edition does not implement the SSPI or Kerberos authentication protocols, and therefore WCF does not support running a service with Windows authentication on that platform.</span></span> <span data-ttu-id="1ad8c-105">Windows XP Home Edition에서 WCF를 실행 하는 경우 사용자 이름/암호 및 HTTP/HTTPS 통합된 인증과 같은 다른 인증 메커니즘이 지원 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1ad8c-105">Other authentication mechanisms, such as username/password and HTTP/HTTPS integrated authentication are supported when running WCF under Windows XP Home Edition.</span></span>  
  
## <a name="impersonation-scenarios"></a><span data-ttu-id="1ad8c-106">가장 시나리오</span><span class="sxs-lookup"><span data-stu-id="1ad8c-106">Impersonation Scenarios</span></span>  
  
### <a name="impersonated-identity-might-not-flow-when-clients-make-asynchronous-calls"></a><span data-ttu-id="1ad8c-107">클라이언트가 비동기 호출을 수행할 때 가장 ID 전달 실패</span><span class="sxs-lookup"><span data-stu-id="1ad8c-107">Impersonated Identity Might Not Flow When Clients Make Asynchronous Calls</span></span>  
 <span data-ttu-id="1ad8c-108">WCF 클라이언트가 가장을 사용하여 Windows 인증을 통해 WCF 서비스로 비동기 호출을 수행할 때 가장 ID 대신 클라이언트 프로세스 ID로 인증이 수행될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1ad8c-108">When a WCF client makes asynchronous calls to a WCF service using Windows authentication under impersonation, authentication might occur with the identity of the client process instead of the impersonated identity.</span></span>  
  
### <a name="windows-xp-and-secure-context-token-cookie-enabled"></a><span data-ttu-id="1ad8c-109">Windows XP 및 보안 컨텍스트 토큰 쿠키 사용</span><span class="sxs-lookup"><span data-stu-id="1ad8c-109">Windows XP and Secure Context Token Cookie Enabled</span></span>  
 <span data-ttu-id="1ad8c-110">WCF 가장을 지원 하지 않습니다 및 <xref:System.InvalidOperationException> 다음 조건이 충족 될 때 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1ad8c-110">WCF does not support impersonation and an <xref:System.InvalidOperationException> is thrown when the following conditions exist:</span></span>  
  
-   <span data-ttu-id="1ad8c-111">운영 체제가 [!INCLUDE[wxp](../../../../includes/wxp-md.md)]인 경우</span><span class="sxs-lookup"><span data-stu-id="1ad8c-111">The operating system is [!INCLUDE[wxp](../../../../includes/wxp-md.md)].</span></span>  
  
-   <span data-ttu-id="1ad8c-112">인증 모드에서 Windows ID를 생성하는 경우</span><span class="sxs-lookup"><span data-stu-id="1ad8c-112">The authentication mode results in a Windows identity.</span></span>  
  
-   <span data-ttu-id="1ad8c-113"><xref:System.ServiceModel.OperationBehaviorAttribute.Impersonation%2A>의 <xref:System.ServiceModel.OperationBehaviorAttribute> 속성은 <xref:System.ServiceModel.ImpersonationOption.Required>로 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="1ad8c-113">The <xref:System.ServiceModel.OperationBehaviorAttribute.Impersonation%2A> property of the <xref:System.ServiceModel.OperationBehaviorAttribute> is set to <xref:System.ServiceModel.ImpersonationOption.Required>.</span></span>  
  
-   <span data-ttu-id="1ad8c-114">상태 기반 SCT(보안 컨텍스트 토큰)가 만들어지는 경우(기본값: 만들기 사용 안 함)</span><span class="sxs-lookup"><span data-stu-id="1ad8c-114">A state-based security context token (SCT) is created (by default, creation is disabled).</span></span>  
  
 <span data-ttu-id="1ad8c-115">상태 기반 SCT는 사용자 지정 바인딩을 통해서만 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1ad8c-115">The state-based SCT can only be created using a custom binding.</span></span> <span data-ttu-id="1ad8c-116">자세한 내용은 [방법: 보안 컨텍스트를 만들 보안 세션에 대 한 토큰](../../../../docs/framework/wcf/feature-details/how-to-create-a-security-context-token-for-a-secure-session.md).) 코드에서 <xref:System.ServiceModel.Channels.SymmetricSecurityBindingElement> 또는 <xref:System.ServiceModel.Channels.AsymmetricSecurityBindingElement> 메서드를 사용하여 보안 바인딩 요소(<xref:System.ServiceModel.Channels.SecurityBindingElement.CreateSspiNegotiationBindingElement%28System.Boolean%29?displayProperty=nameWithType> 또는 <xref:System.ServiceModel.Channels.SecurityBindingElement.CreateSecureConversationBindingElement%28System.ServiceModel.Channels.SecurityBindingElement%2CSystem.Boolean%29?displayProperty=nameWithType>)를 만들고 `requireCancellation` 매개 변수를 `false`로 설정하여 토큰을 사용하도록 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="1ad8c-116">For more information, see [How to: Create a Security Context Token for a Secure Session](../../../../docs/framework/wcf/feature-details/how-to-create-a-security-context-token-for-a-secure-session.md).) In code, the token is enabled by creating a security binding element (either <xref:System.ServiceModel.Channels.SymmetricSecurityBindingElement> or <xref:System.ServiceModel.Channels.AsymmetricSecurityBindingElement>) using the <xref:System.ServiceModel.Channels.SecurityBindingElement.CreateSspiNegotiationBindingElement%28System.Boolean%29?displayProperty=nameWithType> or the <xref:System.ServiceModel.Channels.SecurityBindingElement.CreateSecureConversationBindingElement%28System.ServiceModel.Channels.SecurityBindingElement%2CSystem.Boolean%29?displayProperty=nameWithType> method and setting the `requireCancellation` parameter to `false`.</span></span> <span data-ttu-id="1ad8c-117">매개 변수는 SCT 캐싱을 참조합니다.</span><span class="sxs-lookup"><span data-stu-id="1ad8c-117">The parameter refers to the caching of the SCT.</span></span> <span data-ttu-id="1ad8c-118">값을 `false`로 설정하면 상태 기반 SCT 기능을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1ad8c-118">Setting the value to `false` enables the state-based SCT feature.</span></span>  
  
 <span data-ttu-id="1ad8c-119">또는 구성에서 <`customBinding`>을 만든 다음 <`security`> 요소를 추가하고 `authenticationMode` 특성을 SecureConversation으로 설정하고 `requireSecurityContextCancellation` 특성을 `true`로 설정하여 토큰을 사용하도록 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="1ad8c-119">Alternatively, in configuration, the token is enabled by creating a <`customBinding`>, then adding a <`security`> element, and setting the `authenticationMode` attribute to SecureConversation and the `requireSecurityContextCancellation` attribute to `true`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1ad8c-120">앞의 요구 사항은 각기 고유합니다.</span><span class="sxs-lookup"><span data-stu-id="1ad8c-120">The preceding requirements are specific.</span></span> <span data-ttu-id="1ad8c-121">예를 들어, <xref:System.ServiceModel.Channels.SecurityBindingElement.CreateKerberosBindingElement%2A>는 Windows ID를 생성하는 바인딩 요소를 만들지만 SCT를 설정하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="1ad8c-121">For example, the <xref:System.ServiceModel.Channels.SecurityBindingElement.CreateKerberosBindingElement%2A> creates a binding element that results in a Windows identity, but does not establish an SCT.</span></span> <span data-ttu-id="1ad8c-122">따라서 `Required`에서 [!INCLUDE[wxp](../../../../includes/wxp-md.md)] 옵션을 설정하여 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1ad8c-122">Therefore, you can use it with the `Required` option on [!INCLUDE[wxp](../../../../includes/wxp-md.md)].</span></span>  
  
### <a name="possible-aspnet-conflict"></a><span data-ttu-id="1ad8c-123">가능한 ASP.NET 충돌</span><span class="sxs-lookup"><span data-stu-id="1ad8c-123">Possible ASP.NET Conflict</span></span>  
 <span data-ttu-id="1ad8c-124">WCF 및 [!INCLUDE[vstecasp](../../../../includes/vstecasp-md.md)] 둘 다 설정 하거나 해제할 수 가장 합니다.</span><span class="sxs-lookup"><span data-stu-id="1ad8c-124">WCF and [!INCLUDE[vstecasp](../../../../includes/vstecasp-md.md)] can both enable or disable impersonation.</span></span> <span data-ttu-id="1ad8c-125">때 [!INCLUDE[vstecasp](../../../../includes/vstecasp-md.md)] WCF 응용 프로그램을 호스트 WCF 간에 충돌이 발생할 수 있습니다 및 [!INCLUDE[vstecasp](../../../../includes/vstecasp-md.md)] 구성 설정입니다.</span><span class="sxs-lookup"><span data-stu-id="1ad8c-125">When [!INCLUDE[vstecasp](../../../../includes/vstecasp-md.md)] hosts an WCF application, a conflict may exist between the WCF and [!INCLUDE[vstecasp](../../../../includes/vstecasp-md.md)] configuration settings.</span></span> <span data-ttu-id="1ad8c-126">충돌이 발생 한 WCF 설정 우선 하지 않는 한 합니다 <xref:System.ServiceModel.OperationBehaviorAttribute.Impersonation%2A> 속성이 <xref:System.ServiceModel.ImpersonationOption.NotAllowed>있으며이 경우는 [!INCLUDE[vstecasp](../../../../includes/vstecasp-md.md)] 가장 설정이 우선 합니다.</span><span class="sxs-lookup"><span data-stu-id="1ad8c-126">In case of conflict, the WCF setting takes precedence, unless the <xref:System.ServiceModel.OperationBehaviorAttribute.Impersonation%2A> property is set to <xref:System.ServiceModel.ImpersonationOption.NotAllowed>, in which case the [!INCLUDE[vstecasp](../../../../includes/vstecasp-md.md)] impersonation setting takes precedence.</span></span>  
  
### <a name="assembly-loads-may-fail-under-impersonation"></a><span data-ttu-id="1ad8c-127">가장에서 어셈블리 로드 실패</span><span class="sxs-lookup"><span data-stu-id="1ad8c-127">Assembly Loads May Fail Under Impersonation</span></span>  
 <span data-ttu-id="1ad8c-128">가장 컨텍스트에 어셈블리 로드 액세스 권한이 없고 CLR(공용 언어 런타임)에서 AppDomain에 대한 어셈블리 로드를 처음으로 시도하는 경우 <xref:System.AppDomain>은 오류를 캐시합니다.</span><span class="sxs-lookup"><span data-stu-id="1ad8c-128">If the impersonated context does not have access rights to load an assembly and if it is the first time the common language runtime (CLR) is attempting to load the assembly for that AppDomain, the <xref:System.AppDomain> caches the failure.</span></span> <span data-ttu-id="1ad8c-129">가장을 변환한 이후 변환된 컨텍스트에 어셈블리 로드 액세스 권한이 있더라도 후속 어셈블리 로드 시도는 실패합니다.</span><span class="sxs-lookup"><span data-stu-id="1ad8c-129">Subsequent attempts to load that assembly (or assemblies) fail, even after reverting the impersonation, and even if the reverted context has access rights to load the assembly.</span></span> <span data-ttu-id="1ad8c-130">CLR은 사용자 컨텍스트가 변경된 이후에 로드를 다시 시도하지 않기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="1ad8c-130">This is because the CLR does not re-attempt the load after the user context is changed.</span></span> <span data-ttu-id="1ad8c-131">오류를 복구하려면 응용 프로그램 도메인을 다시 시작해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="1ad8c-131">You must restart the application domain to recover from the failure.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1ad8c-132"><xref:System.ServiceModel.Security.WindowsClientCredential.AllowedImpersonationLevel%2A> 클래스의 <xref:System.ServiceModel.Security.WindowsClientCredential> 속성 기본값은 <xref:System.Security.Principal.TokenImpersonationLevel.Identification>입니다.</span><span class="sxs-lookup"><span data-stu-id="1ad8c-132">The default value for the <xref:System.ServiceModel.Security.WindowsClientCredential.AllowedImpersonationLevel%2A> property of the <xref:System.ServiceModel.Security.WindowsClientCredential> class is <xref:System.Security.Principal.TokenImpersonationLevel.Identification>.</span></span> <span data-ttu-id="1ad8c-133">대부분의 경우 확인 수준 가장 컨텍스트에는 추가 어셈블리 로드 권한이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="1ad8c-133">In most cases, an identification-level impersonation context has no rights to load any additional assemblies.</span></span> <span data-ttu-id="1ad8c-134">이는 기본값이므로 일반적인 조건으로 알아 두어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="1ad8c-134">This is the default value, so this is a very common condition to be aware of.</span></span> <span data-ttu-id="1ad8c-135">확인 수준 가장은 가장 프로세스에 `SeImpersonate` 권한이 없는 경우에도 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="1ad8c-135">Identification-level impersonation also occurs when the impersonating process does not have the `SeImpersonate` privilege.</span></span> <span data-ttu-id="1ad8c-136">자세한 내용은 [위임 및 가장](../../../../docs/framework/wcf/feature-details/delegation-and-impersonation-with-wcf.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="1ad8c-136">For more information, see [Delegation and Impersonation](../../../../docs/framework/wcf/feature-details/delegation-and-impersonation-with-wcf.md).</span></span>  
  
### <a name="delegation-requires-credential-negotiation"></a><span data-ttu-id="1ad8c-137">위임에 자격 증명 협상 필요</span><span class="sxs-lookup"><span data-stu-id="1ad8c-137">Delegation Requires Credential Negotiation</span></span>  
 <span data-ttu-id="1ad8c-138">Kerberos 인증 프로토콜을 위임과 함께 사용하려면 자격 증명 협상이 포함된 Kerberos 프로토콜(multi-leg 또는 multi-step Kerberos라고도 함)을 구현해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="1ad8c-138">To use the Kerberos authentication protocol with delegation, you must implement the Kerberos protocol with credential negotiation (sometimes called multi-leg or multi-step Kerberos).</span></span> <span data-ttu-id="1ad8c-139">자격 증명 협상이 포함되지 않은 Kerberos 프로토콜(one-shot 또는 single-leg Kerberos라고도 함)을 구현하면 예외가 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="1ad8c-139">If you implement Kerberos authentication without credential negotiation (sometimes called one-shot or single-leg Kerberos), an exception is thrown.</span></span> <span data-ttu-id="1ad8c-140">자격 증명 협상을 구현 하는 방법에 대 한 자세한 내용은 참조 하세요. [Windows 인증 오류 디버깅](../../../../docs/framework/wcf/feature-details/debugging-windows-authentication-errors.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="1ad8c-140">For more information about how to implement credential negotiation, see [Debugging Windows Authentication Errors](../../../../docs/framework/wcf/feature-details/debugging-windows-authentication-errors.md).</span></span>  
  
## <a name="cryptography"></a><span data-ttu-id="1ad8c-141">암호화</span><span class="sxs-lookup"><span data-stu-id="1ad8c-141">Cryptography</span></span>  
  
### <a name="sha-256-supported-only-for-symmetric-key-usages"></a><span data-ttu-id="1ad8c-142">대칭 키 사용에만 SHA-256 지원됨</span><span class="sxs-lookup"><span data-stu-id="1ad8c-142">SHA-256 Supported Only for Symmetric Key Usages</span></span>  
 <span data-ttu-id="1ad8c-143">WCF는 다양 한 암호화 및 시스템 제공 바인딩에서 알고리즘 모음을 사용 하 여 지정할 수 있는 서명 다이제스트 만들기 알고리즘을 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="1ad8c-143">WCF supports a variety of encryption and signature digest creation algorithms that you can specify using the algorithm suite in the system-provided bindings.</span></span> <span data-ttu-id="1ad8c-144">WCF는 보안 향상된을 위해 서명 다이제스트 해시를 만들기 위한 해시 알고리즘 (SHA (Secure) 2 알고리즘 특히 SHA-256을 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="1ad8c-144">For improved security, WCF supports Secure Hash Algorithm (SHA) 2 algorithms, specifically SHA-256, for creating signature digest hashes.</span></span> <span data-ttu-id="1ad8c-145">이 릴리스는 Kerberos 키와 같은 대칭 키를 사용하는 경우와 메시지 서명에 X.509 인증서를 사용하지 않는 경우에 SHA-256을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="1ad8c-145">This release supports SHA-256 only for symmetric key usages, such as Kerberos keys, and where an X.509 certificate is not used to sign the message.</span></span> <span data-ttu-id="1ad8c-146">WCF는 RSA 서명에 (X.509 인증서에 사용 됨)를 지원 하지 않습니다 RSA-sha256에서 현재 지원 부족으로 인해 SHA-256 해시를 사용 하 여 [!INCLUDE[vstecwinfx](../../../../includes/vstecwinfx-md.md)]입니다.</span><span class="sxs-lookup"><span data-stu-id="1ad8c-146">WCF does not support RSA signatures (used in X.509 certificates) using SHA-256 hash due to the current lack of support for RSA-SHA256 in the [!INCLUDE[vstecwinfx](../../../../includes/vstecwinfx-md.md)].</span></span>  
  
### <a name="fips-compliant-sha-256-hashes-not-supported"></a><span data-ttu-id="1ad8c-147">FIPS 규격 SHA-256 해시 지원되지 않음</span><span class="sxs-lookup"><span data-stu-id="1ad8c-147">FIPS-Compliant SHA-256 Hashes not Supported</span></span>  
 <span data-ttu-id="1ad8c-148">WCF는 SHA-256을 사용 하는 알고리즘 모음은 FIPS 준수 알고리즘 사용이 필요한 경우 시스템에서 WCF에 의해 지원 되지 않습니다 SHA-256 FIPS 규격 해시를 지원 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="1ad8c-148">WCF does not support SHA-256 FIPS-compliant hashes, so algorithm suites that use SHA-256 are not supported by WCF on systems where use of FIPS compliant algorithms is required.</span></span>  
  
### <a name="fips-compliant-algorithms-may-fail-if-registry-is-edited"></a><span data-ttu-id="1ad8c-149">레지스트리 편집 시 FIPS 규격 알고리즘 실패</span><span class="sxs-lookup"><span data-stu-id="1ad8c-149">FIPS-Compliant Algorithms May Fail if Registry Is Edited</span></span>  
 <span data-ttu-id="1ad8c-150">로컬 보안 설정 MMC(Microsoft Management Console) 스냅인을 사용하여 FIPS(Federal Information Processing Standards) 규격 알고리즘을 사용하거나 사용하지 않도록 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1ad8c-150">You can enable and disable Federal Information Processing Standards (FIPS)-compliant algorithms by using the Local Security Settings Microsoft Management Console (MMC) snap-in.</span></span> <span data-ttu-id="1ad8c-151">레지스트리에서 설정에 액세스할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1ad8c-151">You can also access the setting in the registry.</span></span> <span data-ttu-id="1ad8c-152">그러나 WCF 레지스트리 설정을 다시 설정 하려면 사용을 지원 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="1ad8c-152">Note, however, that WCF does not support using the registry to reset the setting.</span></span> <span data-ttu-id="1ad8c-153">1 또는 0 이외의 값을 설정하면 CLR과 운영 체제 간에 일치하지 않는 결과가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1ad8c-153">If the value is set to anything other than 1 or 0, inconsistent results can occur between the CLR and the operating system.</span></span>  
  
### <a name="fips-compliant-aes-encryption-limitation"></a><span data-ttu-id="1ad8c-154">FIPS 규격 AES 암호화 제한</span><span class="sxs-lookup"><span data-stu-id="1ad8c-154">FIPS-Compliant AES Encryption Limitation</span></span>  
 <span data-ttu-id="1ad8c-155">FIPS 규격 AES 암호화는 확인 수준 가장의 이중 콜백에서 작동하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="1ad8c-155">FIPS compliant AES encryption does not work in duplex callbacks under identification level impersonation.</span></span>  
  
### <a name="cngksp-certificates"></a><span data-ttu-id="1ad8c-156">CNG/KSP 인증서</span><span class="sxs-lookup"><span data-stu-id="1ad8c-156">CNG/KSP Certificates</span></span>  
 <span data-ttu-id="1ad8c-157">*암호화 API: CNG (next Generation)* cryptoapi를 장기적으로 대체 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1ad8c-157">*Cryptography API: Next Generation (CNG)* is the long-term replacement for the CryptoAPI.</span></span> <span data-ttu-id="1ad8c-158">이 API는 비관리 코드에서 사용할 수 있습니다 [!INCLUDE[wv](../../../../includes/wv-md.md)], [!INCLUDE[lserver](../../../../includes/lserver-md.md)] 및 이후 Windows 버전입니다.</span><span class="sxs-lookup"><span data-stu-id="1ad8c-158">This API is available in unmanaged code on [!INCLUDE[wv](../../../../includes/wv-md.md)],  [!INCLUDE[lserver](../../../../includes/lserver-md.md)] and later Windows versions.</span></span>  
  
 <span data-ttu-id="1ad8c-159">.NET framework 4.6.1 및 이전 버전 CNG/KSP 인증서를 처리 하는 레거시 CryptoAPI를 사용 하기 때문에 이러한 인증서 지원 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="1ad8c-159">.NET Framework 4.6.1 and earlier versions do not support these certificates because they use the legacy CryptoAPI to handle CNG/KSP certificates.</span></span> <span data-ttu-id="1ad8c-160">.NET Framework 4.6.1 및 이전 버전을 사용 하 여 이러한 인증서를 사용 하면 예외가 발생 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1ad8c-160">The use of these certificates with   .NET Framework 4.6.1 and earlier versions will cause an exception.</span></span>  
  
 <span data-ttu-id="1ad8c-161">인증서에서 KSP를 사용하는지 여부를 파악하는 방법은 다음 두 가지입니다.</span><span class="sxs-lookup"><span data-stu-id="1ad8c-161">There are two possible ways to tell if a certificate uses KSP:</span></span>  
  
-   <span data-ttu-id="1ad8c-162">`p/invoke`에 대해 `CertGetCertificateContextProperty`를 실행하고 반환되는 `dwProvType`에서 `CertGetCertificateContextProperty`이 있는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="1ad8c-162">Do a `p/invoke` of `CertGetCertificateContextProperty`, and inspect `dwProvType` on the returned `CertGetCertificateContextProperty`.</span></span>  
  
-   <span data-ttu-id="1ad8c-163">사용 된 `certutil` 인증서를 쿼리 하기 위한 명령줄에서 명령을 합니다.</span><span class="sxs-lookup"><span data-stu-id="1ad8c-163">Use the  `certutil` command from the command line for querying certificates.</span></span> <span data-ttu-id="1ad8c-164">자세한 내용은 [인증서 문제 해결을 위한 Certutil 작업](https://go.microsoft.com/fwlink/?LinkId=120056)합니다.</span><span class="sxs-lookup"><span data-stu-id="1ad8c-164">For more information, see [Certutil tasks for troubleshooting certificates](https://go.microsoft.com/fwlink/?LinkId=120056).</span></span>  
  
## <a name="message-security-fails-if-using-aspnet-impersonation-and-aspnet-compatibility-is-required"></a><span data-ttu-id="1ad8c-165">ASP.NET 가장 및 ASP.NET 호환성을 사용해야 하는 경우 메시지 보안 실패</span><span class="sxs-lookup"><span data-stu-id="1ad8c-165">Message Security Fails if Using ASP.NET Impersonation and ASP.NET Compatibility Is Required</span></span>  
 <span data-ttu-id="1ad8c-166">WCF는 클라이언트 인증을 방해할 수 있으므로 다음 설정 조합을 지원 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="1ad8c-166">WCF does not support the following combination of settings because they can prevent client authentication from occurring:</span></span>  
  
-   [!INCLUDE[vstecasp](../../../../includes/vstecasp-md.md)] <span data-ttu-id="1ad8c-167">가장이 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="1ad8c-167">Impersonation is enabled.</span></span> <span data-ttu-id="1ad8c-168">이 작업은 Web.config 파일에서 <`identity`> 요소의 `impersonate` 특성을 `true`로 설정하여 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="1ad8c-168">This is done in the Web.config file by setting the `impersonate` attribute of the <`identity`> element to `true`.</span></span>  
  
-   [!INCLUDE[vstecasp](../../../../includes/vstecasp-md.md)] <span data-ttu-id="1ad8c-169">호환성 모드를 설정 하 여 사용 합니다 `aspNetCompatibilityEnabled` 특성을 [ \<serviceHostingEnvironment >](../../../../docs/framework/configure-apps/file-schema/wcf/servicehostingenvironment.md) 를 `true`.</span><span class="sxs-lookup"><span data-stu-id="1ad8c-169">compatibility mode is enabled by setting the `aspNetCompatibilityEnabled` attribute of the [\<serviceHostingEnvironment>](../../../../docs/framework/configure-apps/file-schema/wcf/servicehostingenvironment.md) to `true`.</span></span>  
  
-   <span data-ttu-id="1ad8c-170">메시지 모드 보안이 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="1ad8c-170">Message mode security is used.</span></span>  
  
 <span data-ttu-id="1ad8c-171">[!INCLUDE[vstecasp](../../../../includes/vstecasp-md.md)] 호환성 모드를 해제하면 문제가 해결됩니다.</span><span class="sxs-lookup"><span data-stu-id="1ad8c-171">The work-around is to turn off the [!INCLUDE[vstecasp](../../../../includes/vstecasp-md.md)] compatibility mode.</span></span> <span data-ttu-id="1ad8c-172">또는 [!INCLUDE[vstecasp](../../../../includes/vstecasp-md.md)] 호환성 모드가 필요 함, 사용 하지 않도록 설정 된 [!INCLUDE[vstecasp](../../../../includes/vstecasp-md.md)] 가장 기능 및 WCF에서 제공 가장을 대신 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="1ad8c-172">Or, if the [!INCLUDE[vstecasp](../../../../includes/vstecasp-md.md)] compatibility mode is required, disable the [!INCLUDE[vstecasp](../../../../includes/vstecasp-md.md)] impersonation feature and use WCF-provided impersonation instead.</span></span> <span data-ttu-id="1ad8c-173">자세한 내용은 [위임 및 가장](../../../../docs/framework/wcf/feature-details/delegation-and-impersonation-with-wcf.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="1ad8c-173">For more information, see [Delegation and Impersonation](../../../../docs/framework/wcf/feature-details/delegation-and-impersonation-with-wcf.md).</span></span>  
  
## <a name="ipv6-literal-address-failure"></a><span data-ttu-id="1ad8c-174">IPv6 리터럴 주소 오류</span><span class="sxs-lookup"><span data-stu-id="1ad8c-174">IPv6 Literal Address Failure</span></span>  
 <span data-ttu-id="1ad8c-175">클라이언트와 서비스가 동일한 컴퓨터에 있고 IPv6 리터럴 주소가 서비스에 사용되는 경우 보안 요청이 실패합니다.</span><span class="sxs-lookup"><span data-stu-id="1ad8c-175">Security requests fail when the client and service are on the same machine, and IPv6 literal addresses are used for the service.</span></span>  
  
 <span data-ttu-id="1ad8c-176">리터럴 IPv6 주소는 서비스와 클라이언트가 서로 다른 컴퓨터에 있는 경우에 작동됩니다.</span><span class="sxs-lookup"><span data-stu-id="1ad8c-176">Literal IPv6 addresses work if the service and client are on different machines.</span></span>  
  
## <a name="wsdl-retrieval-failures-with-federated-trust"></a><span data-ttu-id="1ad8c-177">페더레이션 신뢰에서 WSDL 검색 오류</span><span class="sxs-lookup"><span data-stu-id="1ad8c-177">WSDL Retrieval Failures with Federated Trust</span></span>  
 <span data-ttu-id="1ad8c-178">WCF는 페더레이션된 신뢰 체인의 각 노드에 대해 정확히 하나의 WSDL 문서가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="1ad8c-178">WCF requires exactly one WSDL document for each node in the federated trust chain.</span></span> <span data-ttu-id="1ad8c-179">엔드포인트를 지정할 때 루프를 설정하지 않도록 주의해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="1ad8c-179">Be careful not to set up a loop when specifying endpoints.</span></span> <span data-ttu-id="1ad8c-180">루프를 발생시킬 수 있는 한 가지 방법은 같은 WSDL 문서에 두 개 이상의 링크가 포함된 페더레이션 신뢰 체인에 대해 WSDL 다운로드를 사용하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="1ad8c-180">One way in which loops can arise is using a WSDL download of federated trust chains with two or more links in the same WSDL document.</span></span> <span data-ttu-id="1ad8c-181">이 문제를 일으킬 수 있는 일반적인 시나리오로 보안 토큰 서버와 서비스가 동일한 ServiceHost 내에 포함된 페더레이션 서비스를 들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1ad8c-181">A common scenario that can produce this problem is a federated service where the Security Token Server and the service are contained inside the same ServiceHost.</span></span>  
  
 <span data-ttu-id="1ad8c-182">다음과 같은 세 엔드포인트 주소가 있는 서비스를 이러한 상황의 예로 들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1ad8c-182">An example of this situation is a service with the following three endpoint addresses:</span></span>  
  
- <span data-ttu-id="1ad8c-183">`http://localhost/CalculatorService/service` (서비스)</span><span class="sxs-lookup"><span data-stu-id="1ad8c-183">`http://localhost/CalculatorService/service` (the service)</span></span>  
  
- <span data-ttu-id="1ad8c-184">`http://localhost/CalculatorService/issue_ticket` (STS)</span><span class="sxs-lookup"><span data-stu-id="1ad8c-184">`http://localhost/CalculatorService/issue_ticket` (the STS)</span></span>  
  
- <span data-ttu-id="1ad8c-185">`http://localhost/CalculatorService/mex` (메타 데이터 끝점)</span><span class="sxs-lookup"><span data-stu-id="1ad8c-185">`http://localhost/CalculatorService/mex` (the metadata endpoint)</span></span>  
  
 <span data-ttu-id="1ad8c-186">이 경우 예외가 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="1ad8c-186">This throws an exception.</span></span>  
  
 <span data-ttu-id="1ad8c-187">`issue_ticket` 엔드포인트를 다른 곳에 넣어 이 시나리오가 작동하게 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1ad8c-187">You can make this scenario work by putting the `issue_ticket` endpoint elsewhere.</span></span>  
  
## <a name="wsdl-import-attributes-can-be-lost"></a><span data-ttu-id="1ad8c-188">WSDL 가져오기 특성이 손실될 수 있음</span><span class="sxs-lookup"><span data-stu-id="1ad8c-188">WSDL Import Attributes can be Lost</span></span>  
 <span data-ttu-id="1ad8c-189">WSDL 가져오기를 실행할 때는 WCF에서 `<wst:Claims>` 템플릿의 `RST` 요소에 대한 특성을 추적하지 않게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1ad8c-189">WCF loses track of the attributes on a `<wst:Claims>` element in an `RST` template when doing a WSDL import.</span></span> <span data-ttu-id="1ad8c-190">WSDL 가져오기 중에 클레임 형식 컬렉션을 직접 사용하지 않고 `<Claims>` 또는 `WSFederationHttpBinding.Security.Message.TokenRequestParameters`에서 직접 `IssuedSecurityTokenRequestParameters.AdditionalRequestParameters`를 지정하는 경우에 이 문제가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="1ad8c-190">This happens during a WSDL import if you specify `<Claims>` directly in `WSFederationHttpBinding.Security.Message.TokenRequestParameters` or `IssuedSecurityTokenRequestParameters.AdditionalRequestParameters` instead of using the claim type collections directly.</span></span>  <span data-ttu-id="1ad8c-191">가져오기 중에 특성이 손실되므로 바인딩이 WSDL을 통해 제대로 라운드트립되지 않고 클라이언트측에서 잘못됩니다.</span><span class="sxs-lookup"><span data-stu-id="1ad8c-191">Since the import loses the attributes, the binding does not round trip properly through WSDL and hence is incorrect on the client side.</span></span>  
  
 <span data-ttu-id="1ad8c-192">문제를 해결하려면 가져오기를 실행한 후 클라이언트에서 직접 바인딩을 수정합니다.</span><span class="sxs-lookup"><span data-stu-id="1ad8c-192">The fix is to modify the binding directly on the client after doing the import.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="1ad8c-193">참고자료</span><span class="sxs-lookup"><span data-stu-id="1ad8c-193">See also</span></span>
- [<span data-ttu-id="1ad8c-194">보안 고려 사항</span><span class="sxs-lookup"><span data-stu-id="1ad8c-194">Security Considerations</span></span>](../../../../docs/framework/wcf/feature-details/security-considerations-in-wcf.md)
- [<span data-ttu-id="1ad8c-195">정보 공개</span><span class="sxs-lookup"><span data-stu-id="1ad8c-195">Information Disclosure</span></span>](../../../../docs/framework/wcf/feature-details/information-disclosure.md)
- [<span data-ttu-id="1ad8c-196">권한 상승</span><span class="sxs-lookup"><span data-stu-id="1ad8c-196">Elevation of Privilege</span></span>](../../../../docs/framework/wcf/feature-details/elevation-of-privilege.md)
- [<span data-ttu-id="1ad8c-197">서비스 거부</span><span class="sxs-lookup"><span data-stu-id="1ad8c-197">Denial of Service</span></span>](../../../../docs/framework/wcf/feature-details/denial-of-service.md)
- [<span data-ttu-id="1ad8c-198">변조</span><span class="sxs-lookup"><span data-stu-id="1ad8c-198">Tampering</span></span>](../../../../docs/framework/wcf/feature-details/tampering.md)
- [<span data-ttu-id="1ad8c-199">재생 공격</span><span class="sxs-lookup"><span data-stu-id="1ad8c-199">Replay Attacks</span></span>](../../../../docs/framework/wcf/feature-details/replay-attacks.md)

---
title: "사용자 지정 인코더"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-clr
ms.tgt_pltfrm: 
ms.topic: article
ms.assetid: fa0e1d7f-af36-4bf4-aac9-cd4eab95bc4f
caps.latest.revision: "15"
author: Erikre
ms.author: erikre
manager: erikre
ms.openlocfilehash: d9a6c9705fbcf4dd3b9aeb6f07a7973081ea66c3
ms.sourcegitcommit: 4f3fef493080a43e70e951223894768d36ce430a
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 11/21/2017
---
# <a name="custom-encoders"></a><span data-ttu-id="bab09-102">사용자 지정 인코더</span><span class="sxs-lookup"><span data-stu-id="bab09-102">Custom Encoders</span></span>
<span data-ttu-id="bab09-103">이 항목에서는 사용자 지정 인코더를 만드는 방법을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="bab09-103">This topic discusses how to create custom encoders.</span></span>  
  
 <span data-ttu-id="bab09-104">[!INCLUDE[indigo1](../../../../includes/indigo1-md.md)], 사용 하면는 *바인딩* 네트워크를 통해 끝점 간에 데이터를 전송 하는 방법을 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bab09-104">In [!INCLUDE[indigo1](../../../../includes/indigo1-md.md)], you use a *binding* to specify how to transfer data across a network between endpoints.</span></span> <span data-ttu-id="bab09-105">시퀀스로 구성 된 바인딩을 *바인딩 요소의*합니다.</span><span class="sxs-lookup"><span data-stu-id="bab09-105">A binding is made up of a sequence of *binding elements*.</span></span> <span data-ttu-id="bab09-106">보안, 필수와 같은 선택적 프로토콜 바인딩 요소를 포함 하는 바인딩을 *메시지 인코더* 필수 전송 바인딩 요소 및 바인딩 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="bab09-106">A binding includes optional protocol binding elements such as security, a required *Message Encoder* binding element, and a required transport binding element.</span></span> <span data-ttu-id="bab09-107">메시지 인코더는 메시지 인코딩 바인딩 요소로 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="bab09-107">A message encoder is represented by a message encoding binding element.</span></span> <span data-ttu-id="bab09-108">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]에는 이진, MTOM(Message Transmission Optimization Mechanism) 및 텍스트의 세 가지 메시지 인코더가 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bab09-108">Three message encoders are included in [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]: Binary, Message Transmission Optimization Mechanism (MTOM), and Text.</span></span>  
  
 <span data-ttu-id="bab09-109">메시지 인코딩 바인딩 요소는 보내는 <xref:System.ServiceModel.Channels.Message>를 serialize한 다음 전송으로 전달하거나, 전송에서 serialize된 메시지 형식을 받은 다음 프로토콜 계층이 있으면 프로토콜 계층에 전달하고 없으면 응용 프로그램에 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="bab09-109">A message encoding binding element serializes an outgoing <xref:System.ServiceModel.Channels.Message> and passes it to the transport, or receives the serialized form of a message from the transport and passes it to the protocol layer if present, or to the application, if not present.</span></span>  
  
 <span data-ttu-id="bab09-110">메시지 인코더는 <xref:System.ServiceModel.Channels.Message> 인스턴스를 연결 표시로 또는 그 반대로 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="bab09-110">Message encoders transform <xref:System.ServiceModel.Channels.Message> instances to and from a wire representation.</span></span> <span data-ttu-id="bab09-111">인코더가 채널 스택에서 전송 계층 위에 있는 것으로 설명될지라도 전송 계층 내부에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bab09-111">Although encoders are described as sitting above the transport layer in the channel stack, they reside inside the transport layer.</span></span> <span data-ttu-id="bab09-112">전송(예: HTTP)은 전송 표준 요구 사항에 따라 메시지의 형식을 지정하며</span><span class="sxs-lookup"><span data-stu-id="bab09-112">Transports (for example HTTP) format the message according to the requirements of the transport standard.</span></span> <span data-ttu-id="bab09-113">인코더(예: Text Xml)는 단지 메시지를 인코딩합니다.</span><span class="sxs-lookup"><span data-stu-id="bab09-113">Encoders (for example Text Xml) just encode the message.</span></span>  
  
 <span data-ttu-id="bab09-114">기존 클라이언트 또는 서버에 연결할 경우에는 특정 메시지 인코딩을 사용하지 못할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bab09-114">When connecting to a preexisting client or server, you may not have a choice about using a particular message encoding.</span></span> <span data-ttu-id="bab09-115">그러나 여러 끝점을 통해 각각 서로 다른 메시지 인코더를 사용하여 [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] 서비스에 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bab09-115">However, [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] services can be made accessible through multiple endpoints, each with a different message encoder.</span></span> <span data-ttu-id="bab09-116">단일 인코더가 서비스의 전체 대상을 수용하지 못하는 경우 여러 끝점을 통해 서비스를 공개해 보세요.</span><span class="sxs-lookup"><span data-stu-id="bab09-116">When a single encoder does not cover the entire audience for your service, consider exposing your service over multiple endpoints.</span></span> <span data-ttu-id="bab09-117">그러면 클라이언트 응용 프로그램에서 가장 적합한 끝점을 선택할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bab09-117">Client applications can then choose the endpoint that is best for them.</span></span> <span data-ttu-id="bab09-118">여러 끝점을 사용하면 여러 메시지 인코더의 이점을 다른 바인딩 요소와 결합할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bab09-118">Using multiple endpoints allows you to combine the advantages of different message encoders with other binding elements.</span></span>  
  
## <a name="system-provided-encoders"></a><span data-ttu-id="bab09-119">시스템 제공 인코더</span><span class="sxs-lookup"><span data-stu-id="bab09-119">System-Provided Encoders</span></span>  
 [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]<span data-ttu-id="bab09-120">는 가장 일반적인 응용 프로그램 시나리오를 다루도록 고안된 여러 개의 시스템 제공 바인딩을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="bab09-120"> provides several system-provided bindings that are designed to cover the most common application scenarios.</span></span> <span data-ttu-id="bab09-121">이러한 각 바인딩은 전송, 메시지 인코더 및 기타 옵션(예: 보안)을 결합합니다.</span><span class="sxs-lookup"><span data-stu-id="bab09-121">Each of these bindings combine a transport, message encoder, and other options (security, for example).</span></span> <span data-ttu-id="bab09-122">이 항목에서는 `Text`에 포함된 `Binary`, `MTOM` 및 [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] 메시지 인코더를 확장하거나 고유의 사용자 지정 인코더를 만드는 방법에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="bab09-122">This topic describes how to extend the `Text`, `Binary`, and `MTOM` message encoders that are included in [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)], or create your own custom encoder.</span></span> <span data-ttu-id="bab09-123">텍스트 메시지 인코더는 일반 XML 인코딩뿐 아니라 SOAP 인코딩을 모두 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="bab09-123">The text message encoder supports both a plain XML encoding as well as SOAP encodings.</span></span> <span data-ttu-id="bab09-124">텍스트 메시지 인코더의 일반 XML 인코딩 모드는 텍스트 기반 SOAP 인코딩과 구별하기 위해 POX("Plain Old Xml") 인코더라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="bab09-124">The plain XML encoding mode of the text message encoder is called the POX ("Plain Old XML") encoder to distinguish it from the text-based SOAP encoding.</span></span>  
  
 [!INCLUDE[crabout](../../../../includes/crabout-md.md)]<span data-ttu-id="bab09-125">해당 섹션을 참조 하는 바인딩 요소에서 시스템 제공 바인딩이 제공 하는 방법을 [전송 선택](../../../../docs/framework/wcf/feature-details/choosing-a-transport.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="bab09-125"> the combinations of binding elements provided by the system-provided bindings, see the corresponding section in [Choosing a Transport](../../../../docs/framework/wcf/feature-details/choosing-a-transport.md).</span></span>  
  
## <a name="how-to-work-with-system-provided-encoders"></a><span data-ttu-id="bab09-126">시스템 제공 인코더 작업 방법</span><span class="sxs-lookup"><span data-stu-id="bab09-126">How to Work with System-Provided Encoders</span></span>  
 <span data-ttu-id="bab09-127">인코딩은 <xref:System.ServiceModel.Channels.MessageEncodingBindingElement>에서 파생된 클래스를 사용하여 바인딩에 추가됩니다.</span><span class="sxs-lookup"><span data-stu-id="bab09-127">An encoding is added to a binding using a class derived from <xref:System.ServiceModel.Channels.MessageEncodingBindingElement>.</span></span>  
  
 [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]<span data-ttu-id="bab09-128">에서는 텍스트, 이진 및 MTOM(Message Transmission Optimization Mechanism) 인코딩에 제공할 수 있는 <xref:System.ServiceModel.Channels.MessageEncodingBindingElement> 클래스에서 파생된 다음과 같은 형식의 바인딩 요소를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="bab09-128"> provides the following types of binding elements derived from the <xref:System.ServiceModel.Channels.MessageEncodingBindingElement> class that can provide for text, binary and Message Transmission Optimization Mechanism (MTOM) encoding:</span></span>  
  
-   <span data-ttu-id="bab09-129"><xref:System.ServiceModel.Channels.TextMessageEncodingBindingElement>: 상호 운용성이 가장 뛰어나지만 XML 메시지에 대해서는 효율성이 가장 낮은 인코더입니다.</span><span class="sxs-lookup"><span data-stu-id="bab09-129"><xref:System.ServiceModel.Channels.TextMessageEncodingBindingElement>: The most interoperable, but the least efficient encoder for XML messages.</span></span> <span data-ttu-id="bab09-130">웹 서비스 또는 웹 서비스 클라이언트는 일반적으로 텍스트 XML을 이해할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bab09-130">A Web service or Web service client can generally understand textual XML.</span></span> <span data-ttu-id="bab09-131">대량의 이진 데이터 블록을 텍스트로 전송하는 것은 비효율적입니다.</span><span class="sxs-lookup"><span data-stu-id="bab09-131">However, transmitting large blocks of binary data as text is not efficient.</span></span>  
  
-   <span data-ttu-id="bab09-132"><xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement>: 이진 기반 XML 메시지에 사용되는 문자 인코딩 및 메시지 버전 관리를 지정하는 바인딩 요소를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="bab09-132"><xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement>: Represents the binding element that specifies the character encoding and message versioning used for binary-based XML messages.</span></span> <span data-ttu-id="bab09-133">가장 효율적인 인코딩 옵션인 반면 [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] 끝점에서만 지원하기 때문에 상호 운용성이 가장 낮습니다.</span><span class="sxs-lookup"><span data-stu-id="bab09-133">This is most efficient of the encoding options, but the least interoperable, because it is only supported by [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] endpoints.</span></span>  
  
-   <span data-ttu-id="bab09-134"><<!--zz xref:System.ServiceModel.Channels.MTOMMessageEncodingBindingElement -->`System.ServiceModel.Channels.MTOMMessageEncodingBindingElement`>: 메시지 전송 MTOM (Optimization Mechanism) 인코딩을 사용 하 여 메시지에 사용 되는 메시지 버전 관리 및 문자 인코딩을 지정 하는 바인딩 요소를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="bab09-134"><<!--zz xref:System.ServiceModel.Channels.MTOMMessageEncodingBindingElement --> `System.ServiceModel.Channels.MTOMMessageEncodingBindingElement`>: Represents the binding element that specifies the character encoding and message versioning used for a message using a Message Transmission Optimization Mechanism (MTOM) encoding.</span></span> <span data-ttu-id="bab09-135">MTOM은 [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] 메시지의 이진 데이터를 효율적으로 전송하는 기술입니다.</span><span class="sxs-lookup"><span data-stu-id="bab09-135">MTOM is an efficient technology for transmitting binary data in [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] messages.</span></span> <span data-ttu-id="bab09-136">MTOM 인코더는 효율성과 호환성 간의 균형을 유지하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="bab09-136">The MTOM encoder attempts to balance between efficiency and interoperability.</span></span> <span data-ttu-id="bab09-137">MTOM 인코딩은 대부분의 XML을 텍스트 형식으로 전송하지만, 큰 이진 데이터 블록의 경우에는 텍스트로 변환하지 않고 있는 그대로 전송하여 최적화합니다.</span><span class="sxs-lookup"><span data-stu-id="bab09-137">The MTOM encoding transmits most XML in textual form, but optimizes large blocks of binary data by transmitting them as-is, without conversion to text.</span></span>  
  
 <span data-ttu-id="bab09-138">바인딩 요소는 이진, MTOM 또는 텍스트 <xref:System.ServiceModel.Channels.MessageEncoderFactory>를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="bab09-138">The binding element creates a binary, MTOM, or text <xref:System.ServiceModel.Channels.MessageEncoderFactory>.</span></span> <span data-ttu-id="bab09-139">팩터리는 이진, MTOM 또는 텍스트 <xref:System.ServiceModel.Channels.MessageEncoderFactory> 인스턴스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="bab09-139">The factory creates a binary, MTOM, or text <xref:System.ServiceModel.Channels.MessageEncoderFactory> instance.</span></span> <span data-ttu-id="bab09-140">일반적으로 인스턴스는 하나만 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bab09-140">Typically, there is only a single instance.</span></span> <span data-ttu-id="bab09-141">그러나 세션을 사용하는 경우에는 세션마다 다른 인코더가 제공될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bab09-141">However if sessions are used, a different encoder may be provided to each session.</span></span> <span data-ttu-id="bab09-142">이진 인코더는 이를 사용하여 동적 사전을 조정합니다(XML 인프라 참조).</span><span class="sxs-lookup"><span data-stu-id="bab09-142">The Binary encoder makes use of this to coordinate dynamic dictionaries (see XML Infrastructure).</span></span>  
  
 <span data-ttu-id="bab09-143"><xref:System.ServiceModel.Channels.MessageEncoder.ReadMessage%2A> 및 <xref:System.ServiceModel.Channels.MessageEncoder.WriteMessage%2A> 메서드는 인코더의 핵심입니다.</span><span class="sxs-lookup"><span data-stu-id="bab09-143">The <xref:System.ServiceModel.Channels.MessageEncoder.ReadMessage%2A> and <xref:System.ServiceModel.Channels.MessageEncoder.WriteMessage%2A> methods are the core of the encoders.</span></span> <span data-ttu-id="bab09-144">이러한 메서드를 사용하면 스트림 또는 <xref:System.Byte> 배열에서 메시지를 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bab09-144">The methods provide for reading a message from a stream or from a <xref:System.Byte> array.</span></span> <span data-ttu-id="bab09-145">전송이 버퍼링 모드에서 작동할 때는 바이트 배열이 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="bab09-145">Byte arrays are used when the transport is operating in buffered mode.</span></span> <span data-ttu-id="bab09-146">메시지는 항상 스트림에 기록됩니다.</span><span class="sxs-lookup"><span data-stu-id="bab09-146">Messages are always written to streams.</span></span> <span data-ttu-id="bab09-147">메시지를 버퍼링해야 하는 경우 전송은 버퍼링을 수행하는 스트림을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="bab09-147">If the transport must buffer the message, it provides a stream that does the buffering.</span></span>  
  
 <span data-ttu-id="bab09-148">나머지 멤버는 지원 콘텐츠, 미디어 유형 및 <xref:System.ServiceModel.Channels.MessageEncoder.MessageVersion%2A>과 함께 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="bab09-148">The rest of the members work with support content, media types, and <xref:System.ServiceModel.Channels.MessageEncoder.MessageVersion%2A>.</span></span> <span data-ttu-id="bab09-149">전송에서는 이러한 인코더 메서드를 호출하여 들어오는 메시지를 디코딩할 수 있는지 여부를 테스트하거나 보내는 메시지가 이 인코더에 유효한지를 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="bab09-149">The transport calls these encoder methods to test whether the incoming message can be decoded by it, or to determine if the outgoing message is valid for this encoder.</span></span>  
  
 <span data-ttu-id="bab09-150">세 가지 각 인코더 구현은 특정 인코딩과 관련된 속성을 추가하며 완전히 구성 가능합니다.</span><span class="sxs-lookup"><span data-stu-id="bab09-150">Each of the three encoder implementations adds properties that are relevant to the specific encodings and is fully configurable.</span></span> <span data-ttu-id="bab09-151">인코더는 또한 보안 기본값을 갖는 판독기 할당량을 공개합니다.</span><span class="sxs-lookup"><span data-stu-id="bab09-151">The encoders also expose reader quotas that have secure defaults.</span></span> <span data-ttu-id="bab09-152">할당량에 대한 자세한 내용은 XML 인프라를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="bab09-152">See XML Infrastructure for a discussion of the quotas.</span></span>  
  
## <a name="features-of-system-provided-encoders"></a><span data-ttu-id="bab09-153">시스템 제공 인코더의 기능</span><span class="sxs-lookup"><span data-stu-id="bab09-153">Features of System-Provided Encoders</span></span>  
 <span data-ttu-id="bab09-154">시스템 제공 인코더는 다양한 기능을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="bab09-154">There are a number of features provided by the system-provided encoders.</span></span>  
  
### <a name="pooling"></a><span data-ttu-id="bab09-155">Pooling</span><span class="sxs-lookup"><span data-stu-id="bab09-155">Pooling</span></span>  
 <span data-ttu-id="bab09-156">각 인코더 구현에서는 가능한 한 많이 풀링하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="bab09-156">Each of the encoder implementations tries to pool as much as possible.</span></span> <span data-ttu-id="bab09-157">관리 코드의 성능을 향상시키기 위한 주요 방법은 할당을 줄이는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="bab09-157">Reducing allocations is a key way to improve the performance of managed code.</span></span> <span data-ttu-id="bab09-158">이 풀링을 수행하기 위해 구현에서는 `SynchronizedPool` 클래스를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="bab09-158">To accomplish this pooling, the implementations use the `SynchronizedPool` class.</span></span> <span data-ttu-id="bab09-159">C# 파일에는 이 클래스에서 사용하는 추가 최적화에 대한 설명이 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bab09-159">The C# file contains a description of the additional optimizations used by this class.</span></span>  
  
 <span data-ttu-id="bab09-160">`XmlDictionaryReader` 및 `XmlDictionaryWriter` 인스턴스를 풀링하고 다시 초기화하여 각 메시지의 새 인스턴스가 할당되지 않도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="bab09-160">`XmlDictionaryReader` and `XmlDictionaryWriter` instances are pooled and reinitialized to prevent allocating new ones for each message.</span></span> <span data-ttu-id="bab09-161">판독기의 경우 `OnClose`가 호출될 때 `Close()` 콜백이 판독기를 회수합니다.</span><span class="sxs-lookup"><span data-stu-id="bab09-161">For the readers, an `OnClose` callback reclaims the reader when `Close()` is called.</span></span> <span data-ttu-id="bab09-162">인코더는 또한 메시지를 구성할 때 사용된 일부 메시지 상태 개체를 재활용합니다.</span><span class="sxs-lookup"><span data-stu-id="bab09-162">The encoder also recycles some message state objects used when constructing messages.</span></span> <span data-ttu-id="bab09-163">이러한 풀의 크기는 `MaxReadPoolSize`에서 파생된 세 가지 각 클래스에 대한 `MaxWritePoolSize` 및 <xref:System.ServiceModel.Channels.MessageEncodingBindingElement> 속성으로 구성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bab09-163">The sizes of these pools are configurable by the `MaxReadPoolSize` and `MaxWritePoolSize` properties on each of the three classes derived from <xref:System.ServiceModel.Channels.MessageEncodingBindingElement>.</span></span>  
  
### <a name="binary-encoding"></a><span data-ttu-id="bab09-164">이진 인코딩</span><span class="sxs-lookup"><span data-stu-id="bab09-164">Binary Encoding</span></span>  
 <span data-ttu-id="bab09-165">이진 인코딩에서 세션을 사용하는 경우 동적 사전 문자열을 메시지 수신자에게 전달해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="bab09-165">When binary encoding uses sessions, the dynamic dictionary string must be communicated to the receiver of the message.</span></span> <span data-ttu-id="bab09-166">이 작업은 동적 사전 문자열을 메시지의 접두사로 지정하여 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="bab09-166">This is done by prefixing the message with the dynamic dictionary strings.</span></span> <span data-ttu-id="bab09-167">수신자는 문자열을 제거하여 세션에 추가한 다음 메시지를 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="bab09-167">The receiver strips off the strings, adds them to the session, and processes the message.</span></span> <span data-ttu-id="bab09-168">사전 문자열을 올바르게 전달하려면 전송을 버퍼링해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="bab09-168">Correctly passing dictionary strings requires that the transport be buffered.</span></span>  
  
 <span data-ttu-id="bab09-169">문자열은 내부 `AddSessionInformationToMessage` 메서드에 의해 메시지에 추가됩니다.</span><span class="sxs-lookup"><span data-stu-id="bab09-169">The strings are appended to the message by an internal `AddSessionInformationToMessage` method.</span></span> <span data-ttu-id="bab09-170">이 메서드는 해당 문자열의 길이로 접두사가 지정된 메시지 앞에 문자열을 UTF-8로 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="bab09-170">It adds the strings as UTF-8 to the front of the message prefixed with their length.</span></span> <span data-ttu-id="bab09-171">그런 다음 이 데이터의 길이를 전체 사전 헤더의 접두사로 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="bab09-171">The entire dictionary header is then prefixed with the length of its data.</span></span> <span data-ttu-id="bab09-172">이 반대 작업은 내부 `ExtractSessionInformationFromMessage` 메서드에 의해 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="bab09-172">The reverse operation is performed by an internal `ExtractSessionInformationFromMessage` method.</span></span>  
  
 <span data-ttu-id="bab09-173">동적 사전 키를 처리하는 이외에도 성공적으로 버퍼링된 메시지를 고유한 방식으로 수신합니다.</span><span class="sxs-lookup"><span data-stu-id="bab09-173">In addition to processing dynamic dictionary keys, buffered sessionful messages are received in a unique way.</span></span> <span data-ttu-id="bab09-174">이진 인코더는 문서에 대한 판독기를 만들어 문서를 처리하는 대신 내부 `MessagePatterns` 클래스를 사용하여 이진 스트림을 해체합니다.</span><span class="sxs-lookup"><span data-stu-id="bab09-174">Instead of creating a reader over the document and processing it, the binary encoder uses the internal `MessagePatterns` class to deconstruct the binary stream.</span></span> <span data-ttu-id="bab09-175">대부분의 메시지에는 [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]에서 생성된 순서대로 표시되는 특정 헤더 집합이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bab09-175">The idea is that most messages have a certain set of headers that show up in a certain order when generated by [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)].</span></span> <span data-ttu-id="bab09-176">패턴 시스템은 필요에 따라 메시지를 분리합니다.</span><span class="sxs-lookup"><span data-stu-id="bab09-176">The pattern system breaks the message apart based on what it expects.</span></span> <span data-ttu-id="bab09-177">성공하면 XML을 구문 분석하지 않고 <xref:System.ServiceModel.Channels.MessageHeaders> 개체를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="bab09-177">If it is successful, it initializes a <xref:System.ServiceModel.Channels.MessageHeaders> object without parsing the XML.</span></span> <span data-ttu-id="bab09-178">실패하면 표준 메서드로 변경됩니다.</span><span class="sxs-lookup"><span data-stu-id="bab09-178">If not, it falls back to the standard method.</span></span>  
  
### <a name="mtom-encoding"></a><span data-ttu-id="bab09-179">MTOM 인코딩</span><span class="sxs-lookup"><span data-stu-id="bab09-179">MTOM Encoding</span></span>  
 <span data-ttu-id="bab09-180"><<!--zz xref:System.ServiceModel.Channels.MTOMMessageEncodingBindingElement --> `System.ServiceModel.Channels.MTOMMessageEncodingBindingElement`> 클래스에 추가 구성 속성인 <<!--zz xref:System.ServiceModel.Channels.MTOMMessageEncodingBindingElement --> `System.ServiceModel.Channels.MTOMMessageEncodingBindingElement`합니다. MaxBufferSize %2A > 합니다.</span><span class="sxs-lookup"><span data-stu-id="bab09-180">The <<!--zz xref:System.ServiceModel.Channels.MTOMMessageEncodingBindingElement --> `System.ServiceModel.Channels.MTOMMessageEncodingBindingElement`> class has an additional configuration property called <<!--zz xref:System.ServiceModel.Channels.MTOMMessageEncodingBindingElement --> `System.ServiceModel.Channels.MTOMMessageEncodingBindingElement`.MaxBufferSize%2A>.</span></span> <span data-ttu-id="bab09-181">이 속성은 메시지를 읽는 동안 버퍼링할 수 있는 데이터의 크기에 대한 상한을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="bab09-181">This places an upper bound on how much data it is allowed to buffer during the process of reading a message.</span></span> <span data-ttu-id="bab09-182">모든 MIME 부분을 단일 메시지로 다시 어셈블하려면 XML Infoset(정보 집합) 또는 다른 MIME 부분을 버퍼링해야 할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bab09-182">The XML Information Set (Infoset), or other MIME parts, may need to be buffered to reassemble all the MIME parts into a single message.</span></span>  
  
 <span data-ttu-id="bab09-183">HTTP에서 올바로 작동하기 위해 내부 MTOM 메시지 인코더 클래스는 내부 `GetContentType` 및 public이며 재정의 가능한 `WriteMessage`에 대한 몇 가지 내부 API를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="bab09-183">To work correctly with HTTP, the internal MTOM message encoder class provides some internal APIs for `GetContentType` (which is also internal) and `WriteMessage`, which is public and can be overridden.</span></span> <span data-ttu-id="bab09-184">HTTP 헤더의 값과 MIME 헤더의 값이 일치하려면 더 많은 통신이 수행되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="bab09-184">More communication must occur to ensure values in the HTTP headers agree with values in the MIME headers.</span></span>  
  
 <span data-ttu-id="bab09-185">내부적으로 MTOM 메시지 인코더는 [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]의 텍스트 판독기를 사용하며 텍스트 인코더와 비슷합니다.</span><span class="sxs-lookup"><span data-stu-id="bab09-185">Internally, the MTOM message encoder uses [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]'s text readers, and is similar to the Text encoder.</span></span> <span data-ttu-id="bab09-186">주된 차이점은 MTOM 메시지 인코더는 대량의 이진, 즉 "BLOB"(Binary Large Object)를 메시지 바이트에 포함하기 전에 Base-64 인코딩으로 변환하지 않음으로써 최적화한다는 데 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bab09-186">The main difference is that it optimizes large chunks of binary, or "Binary Large Objects" (BLOBs), by not converting them to Base-64 encoding prior to being embedded into the message bytes.</span></span> <span data-ttu-id="bab09-187">대신 이러한 BLOB는 추출되어 MIME 첨부 파일로 참조됩니다.</span><span class="sxs-lookup"><span data-stu-id="bab09-187">Instead, these BLOBs are kept extracted, and referenced as the MIME attachments.</span></span>  
  
## <a name="writing-your-own-encoder"></a><span data-ttu-id="bab09-188">사용자 고유의 인코더 작성</span><span class="sxs-lookup"><span data-stu-id="bab09-188">Writing your own Encoder</span></span>  
 <span data-ttu-id="bab09-189">사용자 지정 메시지 인코더를 구현하려면 다음 추상 기본 클래스에 대한 사용자 지정 구현을 제공해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="bab09-189">To implement your own custom message encoder, you must provide custom implementations of the following abstract base classes:</span></span>  
  
-   <xref:System.ServiceModel.Channels.MessageEncoder>  
  
-   <xref:System.ServiceModel.Channels.MessageEncoderFactory>  
  
-   <xref:System.ServiceModel.Channels.MessageEncodingBindingElement>  
  
 <span data-ttu-id="bab09-190">메시지의 메모리 내 표현을 스트림에 기록할 수 있는 표현으로 변환하여 <xref:System.ServiceModel.Channels.MessageEncoder> 클래스 내에 캡슐화합니다. 이 클래스는 특정 유형의 XML 인코딩을 지원하는 XML 판독기 및 XML 작성기의 팩터리 역할을 합니다.</span><span class="sxs-lookup"><span data-stu-id="bab09-190">Converting from the in-memory representation of a message to a representation that can be written to a stream is encapsulated within the <xref:System.ServiceModel.Channels.MessageEncoder> class, which serves as a factory for XML readers and XML writers that support specific types of XML encodings.</span></span>  
  
-   <span data-ttu-id="bab09-191">재정의해야 하는 이 클래스의 주요 메서드는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="bab09-191">The key methods of this class that you must override are:</span></span>  
  
-   <span data-ttu-id="bab09-192"><xref:System.ServiceModel.Channels.MessageEncoder.WriteMessage%2A> - <xref:System.ServiceModel.Channels.MessageEncodingBindingElement> 개체를 가져와서 <xref:System.IO.Stream> 개체에 씁니다.</span><span class="sxs-lookup"><span data-stu-id="bab09-192"><xref:System.ServiceModel.Channels.MessageEncoder.WriteMessage%2A> which takes a <xref:System.ServiceModel.Channels.MessageEncodingBindingElement> object and writes it into a <xref:System.IO.Stream> object.</span></span>  
  
-   <span data-ttu-id="bab09-193"><xref:System.ServiceModel.Channels.MessageEncoder.ReadMessage%2A> - <xref:System.IO.Stream> 개체와 최대 헤더 크기를 가져오고 <xref:System.ServiceModel.Channels.Message> 개체를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="bab09-193"><xref:System.ServiceModel.Channels.MessageEncoder.ReadMessage%2A> which takes a <xref:System.IO.Stream> object and a maximum header size and returns a <xref:System.ServiceModel.Channels.Message> object.</span></span>  
  
 <span data-ttu-id="bab09-194">이러한 메서드에 작성하는 코드로, 표준 전송 프로토콜과 사용자 지정 인코딩 간의 변환을 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="bab09-194">It is the code you write in these methods that handles conversion between the standard transport protocol, and your customized encoding.</span></span>  
  
 <span data-ttu-id="bab09-195">다음으로는 사용자 지정 인코더를 만드는 팩터리 클래스를 코딩해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="bab09-195">Next you need to code a factory class that creates your custom encoder.</span></span> <span data-ttu-id="bab09-196">사용자 지정 <xref:System.ServiceModel.Channels.MessageEncoderFactory.Encoder%2A>의 인스턴스를 반환하도록 <xref:System.ServiceModel.Channels.MessageEncoder>를 재정의합니다.</span><span class="sxs-lookup"><span data-stu-id="bab09-196">Override the <xref:System.ServiceModel.Channels.MessageEncoderFactory.Encoder%2A> to return an instance of your custom <xref:System.ServiceModel.Channels.MessageEncoder>.</span></span>  
  
 <span data-ttu-id="bab09-197">그런 다음 이 팩터리의 인스턴스를 반환하도록 <xref:System.ServiceModel.Channels.MessageEncoderFactory> 메서드를 재정의하여 서비스 또는 클라이언트를 구성하는 데 사용되는 바인딩 요소 스택에 사용자 지정 <xref:System.ServiceModel.Channels.MessageEncodingBindingElement.CreateMessageEncoderFactory%2A>를 연결합니다.</span><span class="sxs-lookup"><span data-stu-id="bab09-197">Then connect your custom <xref:System.ServiceModel.Channels.MessageEncoderFactory> to the binding element stack used to configure the service or client by overriding the <xref:System.ServiceModel.Channels.MessageEncodingBindingElement.CreateMessageEncoderFactory%2A> method to return an instance of this factory.</span></span>  
  
 <span data-ttu-id="bab09-198">와 함께 제공 되는 두 개의 샘플이 있습니다 [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] 샘플 코드를 사용 하 여이 프로세스를 보여 주는: [사용자 지정 메시지 인코더: 사용자 지정 텍스트 인코더](../../../../docs/framework/wcf/samples/custom-message-encoder-custom-text-encoder.md) 및 [사용자 지정 메시지 인코더: 압축 인코더](../../../../docs/framework/wcf/samples/custom-message-encoder-compression-encoder.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="bab09-198">There are two samples provided with [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] that illustrate this process with sample code: [Custom Message Encoder: Custom Text Encoder](../../../../docs/framework/wcf/samples/custom-message-encoder-custom-text-encoder.md) and [Custom Message Encoder: Compression Encoder](../../../../docs/framework/wcf/samples/custom-message-encoder-compression-encoder.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="bab09-199">참고 항목</span><span class="sxs-lookup"><span data-stu-id="bab09-199">See Also</span></span>  
 <xref:System.ServiceModel.Channels.MessageEncodingBindingElement>  
 <xref:System.ServiceModel.Channels.MessageEncoderFactory>  
 <xref:System.ServiceModel.Channels.MessageEncoder>  
 [<span data-ttu-id="bab09-200">데이터 전송 아키텍처 개요</span><span class="sxs-lookup"><span data-stu-id="bab09-200">Data Transfer Architectural Overview</span></span>](../../../../docs/framework/wcf/feature-details/data-transfer-architectural-overview.md)  
 [<span data-ttu-id="bab09-201">메시지 인코더 선택</span><span class="sxs-lookup"><span data-stu-id="bab09-201">Choosing a Message Encoder</span></span>](../../../../docs/framework/wcf/feature-details/choosing-a-message-encoder.md)  
 [<span data-ttu-id="bab09-202">전송 선택</span><span class="sxs-lookup"><span data-stu-id="bab09-202">Choosing a Transport</span></span>](../../../../docs/framework/wcf/feature-details/choosing-a-transport.md)

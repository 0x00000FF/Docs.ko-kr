---
title: "방법: 리플렉션 내보내기를 사용하여 제네릭 메서드 정의"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: 
ms.suite: 
ms.technology:
- dotnet-clr
ms.tgt_pltfrm: 
ms.topic: article
helpviewer_keywords:
- generics [.NET Framework], reflection emit
- reflection emit, generic methods
- generics [.NET Framework], dynamic types
ms.assetid: 93892fa4-90b3-4ec4-b147-4bec9880de2b
caps.latest.revision: 13
author: rpetrusha
ms.author: ronpet
manager: wpickett
ms.translationtype: HT
ms.sourcegitcommit: 306c608dc7f97594ef6f72ae0f5aaba596c936e1
ms.openlocfilehash: 655ec9d5c53de10e6044cacc0eb8239fefe36489
ms.contentlocale: ko-kr
ms.lasthandoff: 07/28/2017

---
# <a name="how-to-define-a-generic-method-with-reflection-emit"></a><span data-ttu-id="94195-102">방법: 리플렉션 내보내기를 사용하여 제네릭 메서드 정의</span><span class="sxs-lookup"><span data-stu-id="94195-102">How to: Define a Generic Method with Reflection Emit</span></span>
<span data-ttu-id="94195-103">첫 번째 절차에서는 두 개의 형식 매개 변수가 있는 간단한 제네릭 메서드를 만드는 방법 및 형식 매개 변수에 클래스 제약 조건, 인터페이스 제약 조건 및 특수 제약 조건을 적용하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="94195-103">The first procedure shows how to create a simple generic method with two type parameters, and how to apply class constraints, interface constraints, and special constraints to the type parameters.</span></span>  
  
 <span data-ttu-id="94195-104">두 번째 절차에서는 메서드 본문을 내보내는 방법 및 제네릭 메서드의 형식 매개 변수를 사용하여 제네릭 형식 인스턴스를 만들고 해당 메서드를 호출하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="94195-104">The second procedure shows how to emit the method body, and how to use the type parameters of the generic method to create instances of generic types and to call their methods.</span></span>  
  
 <span data-ttu-id="94195-105">세 번째 절차에서는 제네릭 메서드를 호출하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="94195-105">The third procedure shows how to invoke the generic method.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="94195-106">제네릭 형식에 속하고 해당 형식의 형식 매개 변수를 사용한다고 해서 제네릭 메서드가 되는 것은 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="94195-106">A method is not generic just because it belongs to a generic type and uses the type parameters of that type.</span></span> <span data-ttu-id="94195-107">고유한 형식 매개 변수 목록을 포함하는 경우에만 제네릭 메서드입니다.</span><span class="sxs-lookup"><span data-stu-id="94195-107">A method is generic only if it has its own type parameter list.</span></span> <span data-ttu-id="94195-108">제네릭 메서드는 이 예제와 같이 제네릭이 아닌 형식에 나타날 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94195-108">A generic method can appear on a nongeneric type, as in this example.</span></span> <span data-ttu-id="94195-109">제네릭 형식의 제네릭이 아닌 메서드에 대한 예제는 [방법: 리플렉션 내보내기를 사용하여 제네릭 형식 정의](../../../docs/framework/reflection-and-codedom/how-to-define-a-generic-type-with-reflection-emit.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="94195-109">For an example of a nongeneric method on a generic type, see [How to: Define a Generic Type with Reflection Emit](../../../docs/framework/reflection-and-codedom/how-to-define-a-generic-type-with-reflection-emit.md).</span></span>  
  
### <a name="to-define-a-generic-method"></a><span data-ttu-id="94195-110">제네릭 메서드를 정의하려면</span><span class="sxs-lookup"><span data-stu-id="94195-110">To define a generic method</span></span>  
  
1.  <span data-ttu-id="94195-111">시작하기 전에, 상위 수준 언어를 사용하여 작성할 경우 제네릭 메서드가 표시되는 방식을 확인하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="94195-111">Before beginning, it is useful to look at how the generic method appears when written using a high-level language.</span></span> <span data-ttu-id="94195-112">이 항목에 대한 예제 코드에는 제네릭 메서드를 호출하는 코드와 함께 다음 코드가 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94195-112">The following code is included in the example code for this topic, along with code to call the generic method.</span></span> <span data-ttu-id="94195-113">메서드에는 두 개의 형식 매개 변수 `TInput` 및 `TOutput`이 있습니다. 두 번째 매개 변수는 참조 형식(`class`)이어야 하고, 매개 변수가 없는 생성자(`new`)를 포함해야 하며, `ICollection(Of TInput)`(C#에서는 `ICollection<TInput>`)을 구현해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="94195-113">The method has two type parameters, `TInput` and `TOutput`, the second of which must be a reference type (`class`), must have a parameterless constructor (`new`), and must implement `ICollection(Of TInput)` (`ICollection<TInput>` in C#).</span></span> <span data-ttu-id="94195-114">이 인터페이스 제약 조건은 <xref:System.Collections.Generic.ICollection%601.Add%2A?displayProperty=fullName> 메서드를 사용하여 이 메서드가 만드는 `TOutput` 컬렉션에 요소를 추가할 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="94195-114">This interface constraint ensures that the <xref:System.Collections.Generic.ICollection%601.Add%2A?displayProperty=fullName> method can be used to add elements to the `TOutput` collection that the method creates.</span></span> <span data-ttu-id="94195-115">메서드에는 `TInput` 배열인 하나의 형식 매개 변수 `input`이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94195-115">The method has one formal parameter, `input`, which is an array of `TInput`.</span></span> <span data-ttu-id="94195-116">메서드는 `TOutput` 형식의 컬렉션을 만들고 `input`의 요소를 컬렉션에 복사합니다.</span><span class="sxs-lookup"><span data-stu-id="94195-116">The method creates a collection of type `TOutput` and copies the elements of `input` to the collection.</span></span>  
  
     <span data-ttu-id="94195-117">[!code-csharp[GenericMethodHowTo#20](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#20)]  [!code-vb[GenericMethodHowTo#20](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#20)]</span><span class="sxs-lookup"><span data-stu-id="94195-117">[!code-csharp[GenericMethodHowTo#20](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#20)]  [!code-vb[GenericMethodHowTo#20](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#20)]</span></span>  
  
2.  <span data-ttu-id="94195-118">제네릭 메서드가 속하는 형식을 포함할 동적 모듈 및 동적 어셈블리를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="94195-118">Define a dynamic assembly and a dynamic module to contain the type the generic method belongs to.</span></span> <span data-ttu-id="94195-119">이 경우 어셈블리에는 `DemoMethodBuilder1`이라는 모듈 하나만 포함되며, 모듈 이름은 어셈블리 이름에 확장명을 추가한 이름과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="94195-119">In this case, the assembly has only one module, named `DemoMethodBuilder1`, and the module name is the same as the assembly name plus an extension.</span></span> <span data-ttu-id="94195-120">이 예제에서는 어셈블리가 디스크에 저장되고 실행되므로 <xref:System.Reflection.Emit.AssemblyBuilderAccess.RunAndSave?displayProperty=fullName>이 지정됩니다.</span><span class="sxs-lookup"><span data-stu-id="94195-120">In this example, the assembly is saved to disk and also executed, so <xref:System.Reflection.Emit.AssemblyBuilderAccess.RunAndSave?displayProperty=fullName> is specified.</span></span> <span data-ttu-id="94195-121">[Ildasm.exe(IL 디스어셈블러)](../../../docs/framework/tools/ildasm-exe-il-disassembler.md)를 사용하여 DemoMethodBuilder1.dll를 검사하고 1단계에 표시된 메서드에 대한 MSIL(Microsoft Intermediate Language)과 비교합니다.</span><span class="sxs-lookup"><span data-stu-id="94195-121">You can use the [Ildasm.exe (IL Disassembler)](../../../docs/framework/tools/ildasm-exe-il-disassembler.md) to examine DemoMethodBuilder1.dll and to compare it to the Microsoft intermediate language (MSIL) for the method shown in step 1.</span></span>  
  
     <span data-ttu-id="94195-122">[!code-csharp[GenericMethodHowTo#2](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#2)]  [!code-vb[GenericMethodHowTo#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#2)]</span><span class="sxs-lookup"><span data-stu-id="94195-122">[!code-csharp[GenericMethodHowTo#2](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#2)]  [!code-vb[GenericMethodHowTo#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#2)]</span></span>  
  
3.  <span data-ttu-id="94195-123">제네릭 메서드가 속하는 형식을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="94195-123">Define the type the generic method belongs to.</span></span> <span data-ttu-id="94195-124">제네릭 형식일 필요는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="94195-124">The type does not have to be generic.</span></span> <span data-ttu-id="94195-125">제네릭 메서드는 제네릭 형식 또는 제네릭이 아닌 형식에 속할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94195-125">A generic method can belong to either a generic or nongeneric type.</span></span> <span data-ttu-id="94195-126">이 예제에서 형식은 클래스이고, 제네릭이 아니며, 이름이 `DemoType`입니다.</span><span class="sxs-lookup"><span data-stu-id="94195-126">In this example, the type is a class, is not generic, and is named `DemoType`.</span></span>  
  
     <span data-ttu-id="94195-127">[!code-csharp[GenericMethodHowTo#3](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#3)]  [!code-vb[GenericMethodHowTo#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#3)]</span><span class="sxs-lookup"><span data-stu-id="94195-127">[!code-csharp[GenericMethodHowTo#3](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#3)]  [!code-vb[GenericMethodHowTo#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#3)]</span></span>  
  
4.  <span data-ttu-id="94195-128">제네릭 메서드를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="94195-128">Define the generic method.</span></span> <span data-ttu-id="94195-129">제네릭 메서드의 공식 매개 변수 형식이 제네릭 메서드의 제네릭 형식 매개 변수로 지정된 경우 <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%28System.String%2CSystem.Reflection.MethodAttributes%29> 메서드 오버로드를 사용하여 메서드를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="94195-129">If the types of a generic method's formal parameters are specified by generic type parameters of the generic method, use the <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%28System.String%2CSystem.Reflection.MethodAttributes%29> method overload to define the method.</span></span> <span data-ttu-id="94195-130">메서드의 제네릭 형식 매개 변수는 아직 정의되지 않았으므로 <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A> 호출에서 메서드의 공식 매개 변수 형식을 지정할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="94195-130">The generic type parameters of the method are not yet defined, so you cannot specify the types of the method's formal parameters in the call to <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A>.</span></span> <span data-ttu-id="94195-131">이 예제에서 메서드 이름은 `Factory`입니다.</span><span class="sxs-lookup"><span data-stu-id="94195-131">In this example, the method is named `Factory`.</span></span> <span data-ttu-id="94195-132">메서드가 public이고 `static`(Visual Basic에서는 `Shared`)입니다.</span><span class="sxs-lookup"><span data-stu-id="94195-132">The method is public and `static` (`Shared` in Visual Basic).</span></span>  
  
     <span data-ttu-id="94195-133">[!code-csharp[GenericMethodHowTo#4](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#4)]  [!code-vb[GenericMethodHowTo#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#4)]</span><span class="sxs-lookup"><span data-stu-id="94195-133">[!code-csharp[GenericMethodHowTo#4](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#4)]  [!code-vb[GenericMethodHowTo#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#4)]</span></span>  
  
5.  <span data-ttu-id="94195-134">매개 변수 이름이 포함된 문자열 배열을 <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=fullName> 메서드에 전달하여 `DemoMethod`의 제네릭 형식 매개 변수를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="94195-134">Define the generic type parameters of `DemoMethod` by passing an array of strings containing the names of the parameters to the <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=fullName> method.</span></span> <span data-ttu-id="94195-135">이렇게 하면 메서드가 제네릭 메서드가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="94195-135">This makes the method a generic method.</span></span> <span data-ttu-id="94195-136">다음 코드에서는 형식 매개 변수 `TInput` 및 `TOutput`을 사용하여 `Factory`를 제네릭 메서드로 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="94195-136">The following code makes `Factory` a generic method with type parameters `TInput` and `TOutput`.</span></span> <span data-ttu-id="94195-137">코드를 읽기 쉽도록 두 개의 형식 매개 변수를 나타내는 <xref:System.Reflection.Emit.GenericTypeParameterBuilder> 개체를 포함하기 위해 이러한 이름을 가진 변수가 생성되었습니다.</span><span class="sxs-lookup"><span data-stu-id="94195-137">To make the code easier to read, variables with these names are created to hold the <xref:System.Reflection.Emit.GenericTypeParameterBuilder> objects representing the two type parameters.</span></span>  
  
     <span data-ttu-id="94195-138">[!code-csharp[GenericMethodHowTo#5](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#5)]  [!code-vb[GenericMethodHowTo#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#5)]</span><span class="sxs-lookup"><span data-stu-id="94195-138">[!code-csharp[GenericMethodHowTo#5](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#5)]  [!code-vb[GenericMethodHowTo#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#5)]</span></span>  
  
6.  <span data-ttu-id="94195-139">필요에 따라 형식 매개 변수에 특수 제약 조건을 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="94195-139">Optionally add special constraints to the type parameters.</span></span> <span data-ttu-id="94195-140">특수 제약 조건은 <xref:System.Reflection.Emit.GenericTypeParameterBuilder.SetGenericParameterAttributes%2A> 메서드를 사용하여 추가됩니다.</span><span class="sxs-lookup"><span data-stu-id="94195-140">Special constraints are added using the <xref:System.Reflection.Emit.GenericTypeParameterBuilder.SetGenericParameterAttributes%2A> method.</span></span> <span data-ttu-id="94195-141">이 예제에서 `TOutput`은 참조 형식으로, 매개 변수가 없는 생성자를 갖도록 제한됩니다.</span><span class="sxs-lookup"><span data-stu-id="94195-141">In this example, `TOutput` is constrained to be a reference type and to have a parameterless constructor.</span></span>  
  
     <span data-ttu-id="94195-142">[!code-csharp[GenericMethodHowTo#6](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#6)]  [!code-vb[GenericMethodHowTo#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#6)]</span><span class="sxs-lookup"><span data-stu-id="94195-142">[!code-csharp[GenericMethodHowTo#6](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#6)]  [!code-vb[GenericMethodHowTo#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#6)]</span></span>  
  
7.  <span data-ttu-id="94195-143">필요에 따라 형식 매개 변수에 클래스 및 인터페이스 제약 조건을 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="94195-143">Optionally add class and interface constraints to the type parameters.</span></span> <span data-ttu-id="94195-144">이 예제에서 형식 매개 변수 `TOutput`은 `ICollection(Of TInput)`(C#에서는 `ICollection<TInput>`) 인터페이스를 구현하는 형식으로 제한됩니다.</span><span class="sxs-lookup"><span data-stu-id="94195-144">In this example, type parameter `TOutput` is constrained to types that implement the `ICollection(Of TInput)` (`ICollection<TInput>` in C#) interface.</span></span> <span data-ttu-id="94195-145">이렇게 하면 <xref:System.Collections.Generic.ICollection%601.Add%2A> 메서드를 사용하여 요소를 추가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94195-145">This ensures that the <xref:System.Collections.Generic.ICollection%601.Add%2A> method can be used to add elements.</span></span>  
  
     <span data-ttu-id="94195-146">[!code-csharp[GenericMethodHowTo#7](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#7)]  [!code-vb[GenericMethodHowTo#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#7)]</span><span class="sxs-lookup"><span data-stu-id="94195-146">[!code-csharp[GenericMethodHowTo#7](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#7)]  [!code-vb[GenericMethodHowTo#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#7)]</span></span>  
  
8.  <span data-ttu-id="94195-147"><xref:System.Reflection.Emit.MethodBuilder.SetParameters%2A> 메서드를 사용하여 메서드의 공식 매개 변수를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="94195-147">Define the formal parameters of the method, using the <xref:System.Reflection.Emit.MethodBuilder.SetParameters%2A> method.</span></span> <span data-ttu-id="94195-148">이 예제에서 `Factory` 메서드에는 `TInput` 배열인 매개 변수 하나가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94195-148">In this example, the `Factory` method has one parameter, an array of `TInput`.</span></span> <span data-ttu-id="94195-149">`TInput`을 나타내는 <xref:System.Reflection.Emit.GenericTypeParameterBuilder>에서 <xref:System.Type.MakeArrayType%2A> 메서드를 호출하면 이 형식이 생성됩니다.</span><span class="sxs-lookup"><span data-stu-id="94195-149">This type is created by calling the <xref:System.Type.MakeArrayType%2A> method on the <xref:System.Reflection.Emit.GenericTypeParameterBuilder> that represents `TInput`.</span></span> <span data-ttu-id="94195-150"><xref:System.Reflection.Emit.MethodBuilder.SetParameters%2A>의 인수는 <xref:System.Type> 개체 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="94195-150">The argument of <xref:System.Reflection.Emit.MethodBuilder.SetParameters%2A> is an array of <xref:System.Type> objects.</span></span>  
  
     <span data-ttu-id="94195-151">[!code-csharp[GenericMethodHowTo#8](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#8)]  [!code-vb[GenericMethodHowTo#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#8)]</span><span class="sxs-lookup"><span data-stu-id="94195-151">[!code-csharp[GenericMethodHowTo#8](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#8)]  [!code-vb[GenericMethodHowTo#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#8)]</span></span>  
  
9. <span data-ttu-id="94195-152"><xref:System.Reflection.Emit.MethodBuilder.SetReturnType%2A> 메서드를 사용하여 메서드의 반환 형식을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="94195-152">Define the return type for the method, using the <xref:System.Reflection.Emit.MethodBuilder.SetReturnType%2A> method.</span></span> <span data-ttu-id="94195-153">이 예제에서는 `TOutput` 인스턴스가 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="94195-153">In this example, an instance of `TOutput` is returned.</span></span>  
  
     <span data-ttu-id="94195-154">[!code-csharp[GenericMethodHowTo#9](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#9)]   [!code-vb[GenericMethodHowTo#9](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#9)]</span><span class="sxs-lookup"><span data-stu-id="94195-154">[!code-csharp[GenericMethodHowTo#9](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#9)]   [!code-vb[GenericMethodHowTo#9](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#9)]</span></span>  
  
10. <span data-ttu-id="94195-155"><xref:System.Reflection.Emit.ILGenerator>를 사용하여 메서드 본문을 내보냅니다.</span><span class="sxs-lookup"><span data-stu-id="94195-155">Emit the method body, using <xref:System.Reflection.Emit.ILGenerator>.</span></span> <span data-ttu-id="94195-156">자세한 내용은 다음에 나오는 메서드 본문을 내보내기 위한 절차를 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="94195-156">For details, see the accompanying procedure for emitting the method body.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="94195-157">제네릭 형식의 메서드 호출을 내보내고 이러한 형식의 형식 인수가 제네릭 메서드의 형식 매개 변수인 경우 <xref:System.Reflection.Emit.TypeBuilder> 클래스의 `static`<xref:System.Reflection.Emit.TypeBuilder.GetConstructor%28System.Type%2CSystem.Reflection.ConstructorInfo%29>, <xref:System.Reflection.Emit.TypeBuilder.GetMethod%28System.Type%2CSystem.Reflection.MethodInfo%29> 및 <xref:System.Reflection.Emit.TypeBuilder.GetField%28System.Type%2CSystem.Reflection.FieldInfo%29> 메서드 오버로드를 사용하여 생성된 형식의 메서드를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="94195-157">When you emit calls to methods of generic types, and the type arguments of those types are type parameters of the generic method, you must use the `static`<xref:System.Reflection.Emit.TypeBuilder.GetConstructor%28System.Type%2CSystem.Reflection.ConstructorInfo%29>, <xref:System.Reflection.Emit.TypeBuilder.GetMethod%28System.Type%2CSystem.Reflection.MethodInfo%29>, and <xref:System.Reflection.Emit.TypeBuilder.GetField%28System.Type%2CSystem.Reflection.FieldInfo%29> method overloads of the <xref:System.Reflection.Emit.TypeBuilder> class to obtain constructed forms of the methods.</span></span> <span data-ttu-id="94195-158">자세한 내용은 다음에 나오는 메서드 본문을 내보내는 절차를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="94195-158">The accompanying procedure for emitting the method body demonstrates this.</span></span>  
  
11. <span data-ttu-id="94195-159">메서드를 포함하는 형식을 완성하고 어셈블리를 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="94195-159">Complete the type that contains the method and save the assembly.</span></span> <span data-ttu-id="94195-160">다음에 나오는 제네릭 메서드 호출에 대한 절차에서는 완성된 메서드를 호출하는 두 가지 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="94195-160">The accompanying procedure for invoking the generic method shows two ways to invoke the completed method.</span></span>  
  
     <span data-ttu-id="94195-161">[!code-csharp[GenericMethodHowTo#14](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#14)]  [!code-vb[GenericMethodHowTo#14](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#14)]</span><span class="sxs-lookup"><span data-stu-id="94195-161">[!code-csharp[GenericMethodHowTo#14](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#14)]  [!code-vb[GenericMethodHowTo#14](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#14)]</span></span>  
  
<a name="procedureSection1"></a>   
### <a name="to-emit-the-method-body"></a><span data-ttu-id="94195-162">메서드 본문을 내보내려면</span><span class="sxs-lookup"><span data-stu-id="94195-162">To emit the method body</span></span>  
  
1.  <span data-ttu-id="94195-163">코드 생성기를 가져오고 지역 변수와 레이블을 선언합니다.</span><span class="sxs-lookup"><span data-stu-id="94195-163">Get a code generator and declare local variables and labels.</span></span> <span data-ttu-id="94195-164"><xref:System.Reflection.Emit.ILGenerator.DeclareLocal%2A> 메서드는 지역 변수를 선언하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="94195-164">The <xref:System.Reflection.Emit.ILGenerator.DeclareLocal%2A> method is used to declare local variables.</span></span> <span data-ttu-id="94195-165">`Factory` 메서드에는 4개의 지역 변수가 있습니다. `retVal`은 메서드에서 반환되는 새 `TOutput`을 포함하고, `ic`는 `ICollection(Of TInput)`(C#에서는 `ICollection<TInput>`)으로 캐스팅된 `TOutput`을 포함하고, `input`은 `TInput` 개체의 입력 배열을 포함하고, `index`는 배열을 반복합니다.</span><span class="sxs-lookup"><span data-stu-id="94195-165">The `Factory` method has four local variables: `retVal` to hold the new `TOutput` that is returned by the method, `ic` to hold the `TOutput` when it is cast to `ICollection(Of TInput)` (`ICollection<TInput>` in C#), `input` to hold the input array of `TInput` objects, and `index` to iterate through the array.</span></span> <span data-ttu-id="94195-166">메서드에는 루프를 시작하는 레이블(`enterLoop`)과 <xref:System.Reflection.Emit.ILGenerator.DefineLabel%2A> 메서드를 사용하여 정의된 루프 맨 위 레이블(`loopAgain`)이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94195-166">The method also has two labels, one to enter the loop (`enterLoop`) and one for the top of the loop (`loopAgain`), defined using the <xref:System.Reflection.Emit.ILGenerator.DefineLabel%2A> method.</span></span>  
  
     <span data-ttu-id="94195-167">메서드에서 수행하는 첫 번째 작업은 <xref:System.Reflection.Emit.OpCodes.Ldarg_0> opcode를 사용하여 해당 인수를 로드하고 <xref:System.Reflection.Emit.OpCodes.Stloc_S> opcode를 사용하여 지역 변수 `input`에 저장하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="94195-167">The first thing the method does is to load its argument using <xref:System.Reflection.Emit.OpCodes.Ldarg_0> opcode and to store it in the local variable `input` using <xref:System.Reflection.Emit.OpCodes.Stloc_S> opcode.</span></span>  
  
     <span data-ttu-id="94195-168">[!code-csharp[GenericMethodHowTo#10](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#10)]  [!code-vb[GenericMethodHowTo#10](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#10)]</span><span class="sxs-lookup"><span data-stu-id="94195-168">[!code-csharp[GenericMethodHowTo#10](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#10)]  [!code-vb[GenericMethodHowTo#10](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#10)]</span></span>  
  
2.  <span data-ttu-id="94195-169"><xref:System.Activator.CreateInstance%2A?displayProperty=fullName> 메서드의 제네릭 메서드 오버로드를 사용하여 `TOutput` 인스턴스를 만드는 코드를 내보냅니다.</span><span class="sxs-lookup"><span data-stu-id="94195-169">Emit code to create an instance of `TOutput`, using the generic method overload of the <xref:System.Activator.CreateInstance%2A?displayProperty=fullName> method.</span></span> <span data-ttu-id="94195-170">이 오버로드를 사용하려면 지정된 형식이 매개 변수가 없는 생성자를 포함해야 하며, 이런 이유로 해당 제약 조건을 `TOutput`에 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="94195-170">Using this overload requires the specified type to have a parameterless constructor, which is the reason for adding that constraint to `TOutput`.</span></span> <span data-ttu-id="94195-171">`TOutput`을 <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A>에 전달하여 생성된 제네릭 메서드를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="94195-171">Create the constructed generic method by passing `TOutput` to <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A>.</span></span> <span data-ttu-id="94195-172">메서드를 호출하는 코드를 내보낸 후 <xref:System.Reflection.Emit.OpCodes.Stloc_S>를 사용하여 지역 변수 `retVal`에 저장하는 코드를 내보냅니다.</span><span class="sxs-lookup"><span data-stu-id="94195-172">After emitting code to call the method, emit code to store it in the local variable `retVal` using <xref:System.Reflection.Emit.OpCodes.Stloc_S></span></span>  
  
     <span data-ttu-id="94195-173">[!code-csharp[GenericMethodHowTo#11](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#11)]  [!code-vb[GenericMethodHowTo#11](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#11)]</span><span class="sxs-lookup"><span data-stu-id="94195-173">[!code-csharp[GenericMethodHowTo#11](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#11)]  [!code-vb[GenericMethodHowTo#11](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#11)]</span></span>  
  
3.  <span data-ttu-id="94195-174">새 `TOutput` 개체를 `ICollection(Of TInput)`으로 캐스팅하고 지역 변수 `ic`에 저장하는 코드를 내보냅니다.</span><span class="sxs-lookup"><span data-stu-id="94195-174">Emit code to cast the new `TOutput` object to `ICollection(Of TInput)` and store it in the local variable `ic`.</span></span>  
  
     <span data-ttu-id="94195-175">[!code-csharp[GenericMethodHowTo#31](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#31)]  [!code-vb[GenericMethodHowTo#31](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#31)]</span><span class="sxs-lookup"><span data-stu-id="94195-175">[!code-csharp[GenericMethodHowTo#31](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#31)]  [!code-vb[GenericMethodHowTo#31](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#31)]</span></span>  
  
4.  <span data-ttu-id="94195-176"><xref:System.Collections.Generic.ICollection%601.Add%2A?displayProperty=fullName> 메서드를 나타내는 <xref:System.Reflection.MethodInfo>를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="94195-176">Get a <xref:System.Reflection.MethodInfo> representing the <xref:System.Collections.Generic.ICollection%601.Add%2A?displayProperty=fullName> method.</span></span> <span data-ttu-id="94195-177">메서드는 `ICollection(Of TInput)`(C#에서는 `ICollection<TInput>`)에 대해 작동하므로 생성된 해당 형식과 관련된 `Add` 메서드를 가져와야 합니다.</span><span class="sxs-lookup"><span data-stu-id="94195-177">The method is acting on an `ICollection(Of TInput)` (`ICollection<TInput>` in C#), so it is necessary to get the `Add` method specific to that constructed type.</span></span> <span data-ttu-id="94195-178"><xref:System.Type.GetMethod%2A>는 <xref:System.Reflection.Emit.GenericTypeParameterBuilder>로 생성된 형식에서 지원되지 않으므로 <xref:System.Type.GetMethod%2A> 메서드를 사용하여 이 <xref:System.Reflection.MethodInfo>를 `icollOfTInput`에서 직접 가져올 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="94195-178">You cannot use the <xref:System.Type.GetMethod%2A> method to get this <xref:System.Reflection.MethodInfo> directly from `icollOfTInput`, because <xref:System.Type.GetMethod%2A> is not supported on a type that has been constructed with a <xref:System.Reflection.Emit.GenericTypeParameterBuilder>.</span></span> <span data-ttu-id="94195-179">대신, <xref:System.Collections.Generic.ICollection%601> 제네릭 인터페이스에 대한 제네릭 형식 정의를 포함하는 `icoll`에서 <xref:System.Type.GetMethod%2A>를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="94195-179">Instead, call <xref:System.Type.GetMethod%2A> on `icoll`, which contains the generic type definition for the <xref:System.Collections.Generic.ICollection%601> generic interface.</span></span> <span data-ttu-id="94195-180">그런 다음 <xref:System.Reflection.Emit.TypeBuilder.GetMethod%28System.Type%2CSystem.Reflection.MethodInfo%29>`static` 메서드를 사용하여 생성된 형식에 대한 <xref:System.Reflection.MethodInfo>를 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="94195-180">Then use the <xref:System.Reflection.Emit.TypeBuilder.GetMethod%28System.Type%2CSystem.Reflection.MethodInfo%29>`static` method to produce the <xref:System.Reflection.MethodInfo> for the constructed type.</span></span> <span data-ttu-id="94195-181">다음 코드에서는 이 작업을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="94195-181">The following code demonstrates this.</span></span>  
  
     <span data-ttu-id="94195-182">[!code-csharp[GenericMethodHowTo#12](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#12)]  [!code-vb[GenericMethodHowTo#12](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#12)]</span><span class="sxs-lookup"><span data-stu-id="94195-182">[!code-csharp[GenericMethodHowTo#12](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#12)]  [!code-vb[GenericMethodHowTo#12](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#12)]</span></span>  
  
5.  <span data-ttu-id="94195-183">32비트 정수 0을 로드하고 변수에 저장하여 `index` 변수를 초기화하는 코드를 내보냅니다.</span><span class="sxs-lookup"><span data-stu-id="94195-183">Emit code to initialize the `index` variable, by loading a 32-bit integer 0 and storing it in the variable.</span></span> <span data-ttu-id="94195-184">`enterLoop` 레이블로 분기하는 코드를 내보냅니다.</span><span class="sxs-lookup"><span data-stu-id="94195-184">Emit code to branch to the label `enterLoop`.</span></span> <span data-ttu-id="94195-185">이 레이블은 루프 내에 있기 때문에 아직 표시되지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="94195-185">This label has not yet been marked, because it is inside the loop.</span></span> <span data-ttu-id="94195-186">다음 단계에서는 루프에 대한 코드를 내보냅니다.</span><span class="sxs-lookup"><span data-stu-id="94195-186">Code for the loop is emitted in the next step.</span></span>  
  
     <span data-ttu-id="94195-187">[!code-csharp[GenericMethodHowTo#32](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#32)]  [!code-vb[GenericMethodHowTo#32](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#32)]</span><span class="sxs-lookup"><span data-stu-id="94195-187">[!code-csharp[GenericMethodHowTo#32](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#32)]  [!code-vb[GenericMethodHowTo#32](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#32)]</span></span>  
  
6.  <span data-ttu-id="94195-188">루프에 대한 코드를 내보냅니다.</span><span class="sxs-lookup"><span data-stu-id="94195-188">Emit code for the loop.</span></span> <span data-ttu-id="94195-189">첫 번째 단계는 `loopAgain` 레이블로 <xref:System.Reflection.Emit.ILGenerator.MarkLabel%2A>을 호출하여 루프 맨 위를 표시하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="94195-189">The first step is to mark the top of the loop, by calling <xref:System.Reflection.Emit.ILGenerator.MarkLabel%2A> with the `loopAgain` label.</span></span> <span data-ttu-id="94195-190">이제 레이블을 사용하는 분기 문이 코드의 이 지점으로 분기됩니다.</span><span class="sxs-lookup"><span data-stu-id="94195-190">Branch statements that use the label will now branch to this point in the code.</span></span> <span data-ttu-id="94195-191">다음 단계는 `ICollection(Of TInput)`으로 캐스팅된 `TOutput` 개체를 스택에 푸시하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="94195-191">The next step is to push the `TOutput` object, cast to `ICollection(Of TInput)`, onto the stack.</span></span> <span data-ttu-id="94195-192">즉시 필요하지는 않지만 `Add` 메서드를 호출하려면 제자리에 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="94195-192">It is not needed immediately, but needs to be in position for calling the `Add` method.</span></span> <span data-ttu-id="94195-193">그다음 입력 배열이 스택에 푸시되고 현재 인덱스를 포함하는 `index` 변수가 배열에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="94195-193">Next the input array is pushed onto the stack, then the `index` variable containing the current index into the array.</span></span> <span data-ttu-id="94195-194"><xref:System.Reflection.Emit.OpCodes.Ldelem> opcode는 스택에서 인덱스 및 배열을 팝하고 인덱싱된 배열 요소를 스택에 푸시합니다.</span><span class="sxs-lookup"><span data-stu-id="94195-194">The <xref:System.Reflection.Emit.OpCodes.Ldelem> opcode pops the index and the array off the stack and pushes the indexed array element onto the stack.</span></span> <span data-ttu-id="94195-195">이제 스택이 <xref:System.Collections.Generic.ICollection%601.Add%2A?displayProperty=fullName> 메서드를 호출할 준비가 되었습니다. 컬렉션과 새 요소가 스택에서 팝되고 컬렉션에 요소가 추가됩니다.</span><span class="sxs-lookup"><span data-stu-id="94195-195">The stack is now ready for the call to the <xref:System.Collections.Generic.ICollection%601.Add%2A?displayProperty=fullName> method, which pops the collection and the new element off the stack and adds the element to the collection.</span></span>  
  
     <span data-ttu-id="94195-196">루프의 나머지 코드는 인덱스를 증가하고 테스트하여 루프가 완료되었는지 여부를 확인합니다. 인덱스 및 32비트 정수 1이 스택에 푸시되고 더해져서 스택에 합계가 남고 `index`에 저장됩니다.</span><span class="sxs-lookup"><span data-stu-id="94195-196">The rest of the code in the loop increments the index and tests to see whether the loop is finished: The index and a 32-bit integer 1 are pushed onto the stack and added, leaving the sum on the stack; the sum is stored in `index`.</span></span> <span data-ttu-id="94195-197"><xref:System.Reflection.Emit.ILGenerator.MarkLabel%2A>이 호출되어 이 지점을 루프에 대한 진입점으로 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="94195-197"><xref:System.Reflection.Emit.ILGenerator.MarkLabel%2A> is called to set this point as the entry point for the loop.</span></span> <span data-ttu-id="94195-198">인덱스가 다시 로드됩니다.</span><span class="sxs-lookup"><span data-stu-id="94195-198">The index is loaded again.</span></span> <span data-ttu-id="94195-199">입력 배열이 스택에 푸시되고 해당 길이를 가져오기 위해 <xref:System.Reflection.Emit.OpCodes.Ldlen>이 내보내집니다.</span><span class="sxs-lookup"><span data-stu-id="94195-199">The input array is pushed on the stack, and <xref:System.Reflection.Emit.OpCodes.Ldlen> is emitted to get its length.</span></span> <span data-ttu-id="94195-200">이제 인덱스 및 길이가 스택에 있으며 비교를 위해 <xref:System.Reflection.Emit.OpCodes.Clt>가 내보내집니다.</span><span class="sxs-lookup"><span data-stu-id="94195-200">The index and the length are now on the stack, and <xref:System.Reflection.Emit.OpCodes.Clt> is emitted to compare them.</span></span> <span data-ttu-id="94195-201">인덱스가 길이보다 작으면 <xref:System.Reflection.Emit.OpCodes.Brtrue_S>가 루프의 시작 부분으로 다시 분기됩니다.</span><span class="sxs-lookup"><span data-stu-id="94195-201">If the index is less than the length, <xref:System.Reflection.Emit.OpCodes.Brtrue_S> branches back to the beginning of the loop.</span></span>  
  
     <span data-ttu-id="94195-202">[!code-csharp[GenericMethodHowTo#13](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#13)]  [!code-vb[GenericMethodHowTo#13](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#13)]</span><span class="sxs-lookup"><span data-stu-id="94195-202">[!code-csharp[GenericMethodHowTo#13](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#13)]  [!code-vb[GenericMethodHowTo#13](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#13)]</span></span>  
  
7.  <span data-ttu-id="94195-203">`TOutput` 개체를 스택에 푸시하는 코드를 내보내고 메서드에서 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="94195-203">Emit code to push the `TOutput` object onto the stack and return from the method.</span></span> <span data-ttu-id="94195-204">지역 변수 `retVal` 및 `ic` 둘 다에 새 `TOutput`에 대한 참조가 포함되어 있습니다. `ic`는 <xref:System.Collections.Generic.ICollection%601.Add%2A?displayProperty=fullName> 메서드에 액세스하는 데만 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="94195-204">The local variables `retVal` and `ic` both contain references to the new `TOutput`; `ic` is used only to access the <xref:System.Collections.Generic.ICollection%601.Add%2A?displayProperty=fullName> method.</span></span>  
  
     <span data-ttu-id="94195-205">[!code-csharp[GenericMethodHowTo#33](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#33)]  [!code-vb[GenericMethodHowTo#33](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#33)]</span><span class="sxs-lookup"><span data-stu-id="94195-205">[!code-csharp[GenericMethodHowTo#33](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#33)]  [!code-vb[GenericMethodHowTo#33](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#33)]</span></span>  
  
<a name="procedureSection2"></a>   
### <a name="to-invoke-the-generic-method"></a><span data-ttu-id="94195-206">제네릭 메서드를 호출하려면</span><span class="sxs-lookup"><span data-stu-id="94195-206">To invoke the generic method</span></span>  
  
1.  <span data-ttu-id="94195-207">`Factory`는 제네릭 메서드 정의입니다.</span><span class="sxs-lookup"><span data-stu-id="94195-207">`Factory` is a generic method definition.</span></span> <span data-ttu-id="94195-208">호출하려면 해당 제네릭 형식 매개 변수에 형식을 할당해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="94195-208">In order to invoke it, you must assign types to its generic type parameters.</span></span> <span data-ttu-id="94195-209">이렇게 하려면 <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A> 메서드를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="94195-209">Use the <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A> method to do this.</span></span> <span data-ttu-id="94195-210">다음 코드에서는 `TInput`에 대해 <xref:System.String>을 지정하고 `TOutput`에 대해 `List(Of String)`(C#에서는 `List<string>`)을 지정하여 생성된 제네릭 메서드를 만들고 메서드의 문자열 표현을 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="94195-210">The following code creates a constructed generic method, specifying <xref:System.String> for `TInput` and `List(Of String)` (`List<string>` in C#) for `TOutput`, and displays a string representation of the method.</span></span>  
  
     <span data-ttu-id="94195-211">[!code-csharp[GenericMethodHowTo#21](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#21)]  [!code-vb[GenericMethodHowTo#21](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#21)]</span><span class="sxs-lookup"><span data-stu-id="94195-211">[!code-csharp[GenericMethodHowTo#21](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#21)]  [!code-vb[GenericMethodHowTo#21](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#21)]</span></span>  
  
2.  <span data-ttu-id="94195-212">런타임에 바인딩된 메서드를 호출하려면 <xref:System.Reflection.MethodBase.Invoke%2A> 메서드를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="94195-212">To invoke the method late-bound, use the <xref:System.Reflection.MethodBase.Invoke%2A> method.</span></span> <span data-ttu-id="94195-213">다음 코드는 유일한 요소로 문자열 배열을 포함하여 <xref:System.Object> 배열을 만들고 제네릭 메서드의 인수 목록으로 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="94195-213">The following code creates an array of <xref:System.Object>, containing as its only element an array of strings, and passes it as the argument list for the generic method.</span></span> <span data-ttu-id="94195-214"><xref:System.Reflection.MethodBase.Invoke%2A>의 첫 번째 매개 변수는 메서드가 `static`이므로 null 참조입니다.</span><span class="sxs-lookup"><span data-stu-id="94195-214">The first parameter of <xref:System.Reflection.MethodBase.Invoke%2A> is a null reference because the method is `static`.</span></span> <span data-ttu-id="94195-215">반환 값은 `List(Of String)`로 캐스팅되며 첫 번째 요소가 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="94195-215">The return value is cast to `List(Of String)`, and its first element is displayed.</span></span>  
  
     <span data-ttu-id="94195-216">[!code-csharp[GenericMethodHowTo#22](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#22)]  [!code-vb[GenericMethodHowTo#22](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#22)]</span><span class="sxs-lookup"><span data-stu-id="94195-216">[!code-csharp[GenericMethodHowTo#22](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#22)]  [!code-vb[GenericMethodHowTo#22](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#22)]</span></span>  
  
3.  <span data-ttu-id="94195-217">대리자를 사용하여 메서드를 호출하려면 생성된 제네릭 메서드의 시그니처와 일치하는 대리자가 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="94195-217">To invoke the method using a delegate, you must have a delegate that matches the signature of the constructed generic method.</span></span> <span data-ttu-id="94195-218">이 작업을 수행하는 편리한 방법은 제네릭 대리자를 만드는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="94195-218">An easy way to do this is to create a generic delegate.</span></span> <span data-ttu-id="94195-219">다음 코드는 <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29?displayProperty=fullName> 메서드 오버로드를 사용하여 예제 코드에서 정의된 제네릭 대리자 `D`의 인스턴스를 만들고 대리자를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="94195-219">The following code creates an instance of the generic delegate `D` defined in the example code, using the <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29?displayProperty=fullName> method overload, and invokes the delegate.</span></span> <span data-ttu-id="94195-220">대리자는 런타임에 바인딩된 호출보다 성능이 우수합니다.</span><span class="sxs-lookup"><span data-stu-id="94195-220">Delegates perform better than late-bound calls.</span></span>  
  
     <span data-ttu-id="94195-221">[!code-csharp[GenericMethodHowTo#23](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#23)]  [!code-vb[GenericMethodHowTo#23](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#23)]</span><span class="sxs-lookup"><span data-stu-id="94195-221">[!code-csharp[GenericMethodHowTo#23](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#23)]  [!code-vb[GenericMethodHowTo#23](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#23)]</span></span>  
  
4.  <span data-ttu-id="94195-222">저장된 어셈블리를 참조하는 프로그램에서 내보낸 메서드를 호출할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94195-222">The emitted method can also be called from a program that refers to the saved assembly.</span></span>  
  
## <a name="example"></a><span data-ttu-id="94195-223">예제</span><span class="sxs-lookup"><span data-stu-id="94195-223">Example</span></span>  
 <span data-ttu-id="94195-224">다음 코드 예제에서는 제네릭 메서드 `Factory`를 사용하여 제네릭이 아닌 형식 `DemoType`을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="94195-224">The following code example creates a nongeneric type, `DemoType`, with a generic method, `Factory`.</span></span> <span data-ttu-id="94195-225">이 메서드에는 두 개의 제네릭 형식 매개 변수가 있습니다. `TInput`은 입력 형식을 지정하고 `TOutput`은 출력 형식을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="94195-225">This method has two generic type parameters, `TInput` to specify an input type and `TOutput` to specify an output type.</span></span> <span data-ttu-id="94195-226">`TOutput` 형식 매개 변수는 `ICollection<TInput>`(Visual Basic에서는 `ICollection(Of TInput)`)을 매개 변수가 없는 생성자를 갖는 참조 형식으로 구현하도록 제한됩니다.</span><span class="sxs-lookup"><span data-stu-id="94195-226">The `TOutput` type parameter is constrained to implement `ICollection<TInput>` (`ICollection(Of TInput)` in Visual Basic), to be a reference type, and to have a parameterless constructor.</span></span>  
  
 <span data-ttu-id="94195-227">메서드에는 `TInput` 배열인 하나의 공식 매개 변수가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94195-227">The method has one formal parameter, which is an array of `TInput`.</span></span> <span data-ttu-id="94195-228">메서드는 입력 배열의 모든 요소를 포함하는 `TOutput` 인스턴스를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="94195-228">The method returns an instance of `TOutput` that contains all the elements of the input array.</span></span> <span data-ttu-id="94195-229">`TOutput`은 <xref:System.Collections.Generic.ICollection%601> 제네릭 인터페이스를 구현하는 제네릭 컬렉션 형식일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94195-229">`TOutput` can be any generic collection type that implements the <xref:System.Collections.Generic.ICollection%601> generic interface.</span></span>  
  
 <span data-ttu-id="94195-230">코드를 실행하면 동적 어셈블리가 DemoGenericMethod1.dll로 저장되며 [Ildasm.exe(IL 디스어셈블러)](../../../docs/framework/tools/ildasm-exe-il-disassembler.md)를 사용하여 검사할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94195-230">When the code is executed, the dynamic assembly is saved as DemoGenericMethod1.dll, and can be examined using the [Ildasm.exe (IL Disassembler)](../../../docs/framework/tools/ildasm-exe-il-disassembler.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="94195-231">코드를 내보내는 방법을 알아보려면 내보내려는 작업을 수행하는 Visual Basic, C# 또는 Visual C++ 프로그램을 작성하고 디스어셈블러를 사용하여 컴파일러에 의해 생성된 MSIL을 검사하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="94195-231">A good way to learn how to emit code is to write a Visual Basic, C#, or Visual C++ program that performs the task you are trying to emit, and use the disassembler to examine the MSIL produced by the compiler.</span></span>  
  
 <span data-ttu-id="94195-232">코드 예제에는 내보낸 메서드에 해당하는 소스 코드가 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94195-232">The code example includes source code that is equivalent to the emitted method.</span></span> <span data-ttu-id="94195-233">내보낸 메서드는 런타임에 바인딩되고 코드 예제에서 선언된 제네릭 대리자를 사용하여 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="94195-233">The emitted method is invoked late-bound and also by using a generic delegate declared in the code example.</span></span>  
  
 <span data-ttu-id="94195-234">[!code-csharp[GenericMethodHowTo#1](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#1)] [!code-vb[GenericMethodHowTo#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#1)]</span><span class="sxs-lookup"><span data-stu-id="94195-234">[!code-csharp[GenericMethodHowTo#1](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#1)] [!code-vb[GenericMethodHowTo#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#1)]</span></span>  
  
## <a name="compiling-the-code"></a><span data-ttu-id="94195-235">코드 컴파일</span><span class="sxs-lookup"><span data-stu-id="94195-235">Compiling the Code</span></span>  
  
-   <span data-ttu-id="94195-236">코드에는 컴파일하는 데 필요한 C# `using` 문(Visual Basic에서는 `Imports`)이 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="94195-236">The code contains the C# `using` statements (`Imports` in Visual Basic) necessary for compilation.</span></span>  
  
-   <span data-ttu-id="94195-237">추가 어셈블리 참조는 필요하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="94195-237">No additional assembly references are required.</span></span>  
  
-   <span data-ttu-id="94195-238">csc.exe, vbc.exe 또는 cl.exe를 사용하여 명령줄에서 코드를 컴파일합니다.</span><span class="sxs-lookup"><span data-stu-id="94195-238">Compile the code at the command line using csc.exe, vbc.exe, or cl.exe.</span></span> <span data-ttu-id="94195-239">Visual Studio에서 코드를 컴파일하려면 콘솔 응용 프로그램 프로젝트 템플릿에 배치합니다.</span><span class="sxs-lookup"><span data-stu-id="94195-239">To compile the code in Visual Studio, place it in a console application project template.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="94195-240">참고 항목</span><span class="sxs-lookup"><span data-stu-id="94195-240">See Also</span></span>  
 <span data-ttu-id="94195-241"><xref:System.Reflection.Emit.MethodBuilder></span><span class="sxs-lookup"><span data-stu-id="94195-241"><xref:System.Reflection.Emit.MethodBuilder></span></span>   
 [<span data-ttu-id="94195-242">방법: 리플렉션 내보내기를 사용하여 제네릭 형식 정의</span><span class="sxs-lookup"><span data-stu-id="94195-242">How to: Define a Generic Type with Reflection Emit</span></span>](../../../docs/framework/reflection-and-codedom/how-to-define-a-generic-type-with-reflection-emit.md)


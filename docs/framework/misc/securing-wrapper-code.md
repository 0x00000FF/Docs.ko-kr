---
title: 래퍼 코드 보안
ms.date: 03/30/2017
helpviewer_keywords:
- security [.NET Framework], wrapper code
- wrapper code, securing
- secure coding, wrapper code
- code security, wrapper code
ms.assetid: 1df6c516-5bba-48bd-b450-1070e04b7389
author: mairaw
ms.author: mairaw
ms.openlocfilehash: c74a130c078077d9f692fbf6107e9d5aefc16b9a
ms.sourcegitcommit: 6b308cf6d627d78ee36dbbae8972a310ac7fd6c8
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 01/23/2019
ms.locfileid: "54505941"
---
# <a name="securing-wrapper-code"></a><span data-ttu-id="6d1c7-102">래퍼 코드 보안</span><span class="sxs-lookup"><span data-stu-id="6d1c7-102">Securing Wrapper Code</span></span>
[!INCLUDE[net_security_note](../../../includes/net-security-note-md.md)]  
  
 <span data-ttu-id="6d1c7-103">특히 래퍼의 신뢰 수준이 래퍼를 사용하는 코드보다 더 높은 래퍼 코드는 고유한 보안 약점 집합을 초래할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6d1c7-103">Wrapper code, especially where the wrapper has higher trust than code that uses it, can open a unique set of security weaknesses.</span></span> <span data-ttu-id="6d1c7-104">호출자의 제한된 권한이 적절한 보안 검사에 포함되지 않은 경우 호출자 대신 수행되는 모든 작업은 악용되는 잠재적인 약점이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="6d1c7-104">Anything done on behalf of a caller, where the caller's limited permissions are not included in the appropriate security check, is a potential weakness to be exploited.</span></span>  
  
 <span data-ttu-id="6d1c7-105">래퍼를 통해 호출자가 직접 수행할 수 없는 작업을 사용하도록 설정하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="6d1c7-105">Never enable something through the wrapper that the caller could not do itself.</span></span> <span data-ttu-id="6d1c7-106">전체 스택 워크 요구와 반대인 제한된 보안 검사와 관련된 작업을 수행할 때는 특히 위험합니다.</span><span class="sxs-lookup"><span data-stu-id="6d1c7-106">This is a special danger when doing something that involves a limited security check, as opposed to a full stack walk demand.</span></span> <span data-ttu-id="6d1c7-107">단일 수준 검사가 관련된 경우 실제 호출자와 해당 API 요소 사이에 래퍼 코드를 삽입하면 보안 검사가 성공하지 않아야 할 때 쉽게 성공하여 보안이 약화될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6d1c7-107">When single-level checks are involved, interposing the wrapper code between the real caller and the API element in question can easily cause the security check to succeed when it should not, thereby weakening security.</span></span>  
  
## <a name="delegates"></a><span data-ttu-id="6d1c7-108">대리자</span><span class="sxs-lookup"><span data-stu-id="6d1c7-108">Delegates</span></span>  
 <span data-ttu-id="6d1c7-109">대리자 보안은 .NET Framework 버전마다 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="6d1c7-109">Delegate security differs between versions of the .NET Framework.</span></span>  <span data-ttu-id="6d1c7-110">이 섹션에서는 다양한 대리자 동작 및 관련된 보안 고려 사항을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="6d1c7-110">This section describes the different delegate behaviors and associated security considerations.</span></span>  
  
### <a name="in-version-10-and-11-of-the-net-framework"></a><span data-ttu-id="6d1c7-111">.NET Framework 버전 1.0 및 1.1</span><span class="sxs-lookup"><span data-stu-id="6d1c7-111">In version 1.0 and 1.1 of the .NET Framework</span></span>  
 <span data-ttu-id="6d1c7-112">.NET Framework 버전 1.0 및 1.1에서는 대리자 작성자 및 대리자 호출자에 대해 다음과 같은 보안 동작을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="6d1c7-112">Version 1.0 and 1.1 of the .NET Framework perform the following security actions against a delegate creator and a delegate caller.</span></span>  
  
-   <span data-ttu-id="6d1c7-113">대리자를 만들면 대리자 작성자의 권한 부여 집합에 대해 대리자 대상 메서드의 보안 링크 요구가 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="6d1c7-113">When a delegate is created, security link demands on the delegate target method are performed against the grant set of the delegate creator.</span></span>  <span data-ttu-id="6d1c7-114">보안 동작을 충족하지 못하면 <xref:System.Security.SecurityException>이 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="6d1c7-114">Failure to satisfy the security action results in a <xref:System.Security.SecurityException>.</span></span>  
  
-   <span data-ttu-id="6d1c7-115">대리자를 호출하면 대리자 호출자의 모든 기존 보안 요구가 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="6d1c7-115">When the delegate is invoked, any existing security demands on the delegate caller are performed.</span></span>  
  
 <span data-ttu-id="6d1c7-116">사용자 코드가 해당 코드를 호출할 수 있는 덜 신뢰되는 코드에서 <xref:System.Delegate>를 가져오는 경우 덜 신뢰되는 코드가 권한을 에스컬레이션할 수 없도록 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="6d1c7-116">Whenever your code takes a <xref:System.Delegate> from less-trusted code that might call it, make sure that you are not enabling the less-trusted code to escalate its permissions.</span></span> <span data-ttu-id="6d1c7-117">대리자를 가져와서 나중에 사용하는 경우 대리자를 만든 코드가 호출 스택에 없으며, 대리자의 코드에서 보호된 작업을 시도해도 해당 권한이 테스트되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="6d1c7-117">If you take a delegate and use it later, the code that created the delegate is not on the call stack and its permissions will not be tested if code in or under the delegate attempts a protected operation.</span></span> <span data-ttu-id="6d1c7-118">사용자 코드와 호출자 코드에 작성자보다 더 높은 권한이 있을 경우 작성자가 호출 스택에 포함되지 않아도 호출 경로를 조정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6d1c7-118">If your code and the caller code have higher privileges than the creator, the creator can orchestrate the call path without being part of the call stack.</span></span>  
  
### <a name="in-version-20-and-later-versions-of-the-net-framework"></a><span data-ttu-id="6d1c7-119">버전 2.0 및.NET Framework의 이후 버전</span><span class="sxs-lookup"><span data-stu-id="6d1c7-119">In version 2.0 and later versions of the .NET Framework</span></span>  
 <span data-ttu-id="6d1c7-120">이전 버전과 달리 버전 2.0 및 이후 버전의.NET Framework 보안 작업을 수행 대리자 작성자에 대 한 대리자를 만들고 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="6d1c7-120">Unlike previous versions, version 2.0 and later versions of the .NET Framework performs security action against the delegate creator when the delegate is created and called.</span></span>  
  
-   <span data-ttu-id="6d1c7-121">대리자를 만들면 대리자 작성자의 권한 부여 집합에 대해 대리자 대상 메서드의 보안 링크 요구가 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="6d1c7-121">When a delegate is created, security link demands on the delegate target method are performed against the grant set of the delegate creator.</span></span>  <span data-ttu-id="6d1c7-122">보안 동작을 충족하지 못하면 <xref:System.Security.SecurityException>이 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="6d1c7-122">Failure to satisfy the security action results in a <xref:System.Security.SecurityException>.</span></span>  
  
-   <span data-ttu-id="6d1c7-123">대리자를 만드는 동안 대리자 작성자의 권한 부여 집합도 캡처되어 대리자와 함께 저장됩니다.</span><span class="sxs-lookup"><span data-stu-id="6d1c7-123">The delegate creator's grant set is also captured during delegate creation and stored with the delegate.</span></span>  
  
-   <span data-ttu-id="6d1c7-124">대리자를 호출하면 대리자 작성자와 호출자가 서로 다른 어셈블리에 속하는 경우 대리자 작성자의 캡처된 권한 부여 집합이 현재 컨텍스트의 모든 요구에 대해 먼저 평가됩니다.</span><span class="sxs-lookup"><span data-stu-id="6d1c7-124">When the delegate is invoked, the delegate creator's captured grant set is first evaluated against any demands in the current context if the delegate creator and caller belong to different assemblies.</span></span>  <span data-ttu-id="6d1c7-125">다음에는 대리자 호출자의 모든 기존 보안 요구가 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="6d1c7-125">Next, any existing security demands on the delegate caller are performed.</span></span>  
  
## <a name="link-demands-and-wrappers"></a><span data-ttu-id="6d1c7-126">링크 요구 및 래퍼</span><span class="sxs-lookup"><span data-stu-id="6d1c7-126">Link demands and wrappers</span></span>  
 <span data-ttu-id="6d1c7-127">링크 요구를 포함하는 특수 보호 사례가 보안 인프라에서 강화되었지만 여전히 코드에서 보안 약점이 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6d1c7-127">A special protection case with link demands has been strengthened in the security infrastructure, but it is still a source of possible weakness in your code.</span></span>  
  
 <span data-ttu-id="6d1c7-128">완전히 신뢰할 수 있는 코드는 속성, 이벤트 또는로 보호 되는 메서드를 호출 하는 경우는 [LinkDemand](../../../docs/framework/misc/link-demands.md), 호출이 성공 하는 경우를 **LinkDemand** 호출자에 대 한 사용 권한 검사가 충족 됩니다.</span><span class="sxs-lookup"><span data-stu-id="6d1c7-128">If fully trusted code calls a property, event, or method protected by a [LinkDemand](../../../docs/framework/misc/link-demands.md), the call succeeds if the **LinkDemand** permission check for the caller is satisfied.</span></span> <span data-ttu-id="6d1c7-129">또한 호출 하는 속성의 이름을 사용 하는 클래스를 노출 하는 완전히 신뢰할 수 있는 코드를 해당 **가져옵니다** 접근자를 호출 하는 리플렉션을 사용 하는 **가져오기** 접근자에 사용자 코드가 없더라도 성공적으로 실행 이 속성에 액세스할 수 있는 권한이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="6d1c7-129">Additionally, if the fully trusted code exposes a class that takes the name of a property and calls its **get** accessor using reflection, that call to the **get** accessor succeeds even though the user code does not have the right to access this property.</span></span> <span data-ttu-id="6d1c7-130">왜냐하면 합니다 **LinkDemand** 가 완전히 신뢰할 수 있는 코드 인 직접 실행 호출자만 검사 합니다.</span><span class="sxs-lookup"><span data-stu-id="6d1c7-130">This is because the **LinkDemand** checks only the immediate caller, which is the fully trusted code.</span></span> <span data-ttu-id="6d1c7-131">기본적으로 완전히 신뢰할 수 있는 코드는 사용자 코드에 해당 호출을 수행할 권한이 있는지 확인하지 않고 사용자 코드 대신 권한 있는 호출을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="6d1c7-131">In essence, the fully trusted code is making a privileged call on behalf of user code without making sure that the user code has the right to make that call.</span></span>  
  
 <span data-ttu-id="6d1c7-132">이러한 보안 허점을 방지 하기 위해 공용 언어 런타임 모든 간접 호출 메서드, 생성자, 속성 또는 이벤트에 의해 보호에 대 한 전체 스택 워크 요구로 검사를 확장 한 **LinkDemand**합니다.</span><span class="sxs-lookup"><span data-stu-id="6d1c7-132">To help prevent such security holes, the common language runtime extends the check into a full stack-walking demand on any indirect call to a method, constructor, property, or event protected by a **LinkDemand**.</span></span> <span data-ttu-id="6d1c7-133">이 보호를 사용할 경우 성능이 약간 저하되고 보안 검사의 의미 체계가 변경됩니다. 보다 신속한 단일 수준 검사는 성공했을 경우에도 전체 스택 워크 요구는 실패할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6d1c7-133">This protection incurs some performance costs and changes the semantics of the security check; the full stack-walk demand might fail where the faster, one-level check would have passed.</span></span>  
  
## <a name="assembly-loading-wrappers"></a><span data-ttu-id="6d1c7-134">어셈블리 로딩 래퍼</span><span class="sxs-lookup"><span data-stu-id="6d1c7-134">Assembly loading wrappers</span></span>  
 <span data-ttu-id="6d1c7-135"><xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>를 포함하여 관리 코드를 로드하는 데 사용되는 여러 메서드는 호출자의 증거와 함께 어셈블리를 로드합니다.</span><span class="sxs-lookup"><span data-stu-id="6d1c7-135">Several methods used to load managed code, including <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>, load assemblies with the evidence of the caller.</span></span> <span data-ttu-id="6d1c7-136">이러한 메서드를 래핑하는 경우 보안 시스템이 래퍼 호출자의 권한 대신 코드의 권한 부여를 사용하여 어셈블리를 로드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6d1c7-136">If you wrap any of these methods, the security system could use your code's permission grant, instead of the permissions of the caller to your wrapper, to load the assemblies.</span></span> <span data-ttu-id="6d1c7-137">덜 신뢰되는 코드가 래퍼 호출자의 권한보다 더 높은 권한이 부여된 코드를 로드할 수 있도록 허용하면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="6d1c7-137">You should not allow less-trusted code to load code that is granted higher permissions than those of the caller to your wrapper.</span></span>  
  
 <span data-ttu-id="6d1c7-138">완전 신뢰 또는 잠재적인 호출자(인터넷 권한 수준 호출자 포함)보다 더 높은 신뢰 수준의 코드는 이런 방식으로 보안을 약화시킬 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6d1c7-138">Any code that has full trust or significantly higher trust than a potential caller (including an Internet-permissions-level caller) could weaken security in this way.</span></span> <span data-ttu-id="6d1c7-139">코드에 바이트 배열을 받아 전달 하는 공용 메서드 **Assembly.Load**시켜 호출자를 대신 하 여 어셈블리를 만들 보안이 손상 될 수 있습니다 것입니다.</span><span class="sxs-lookup"><span data-stu-id="6d1c7-139">If your code has a public method that takes a byte array and passes it to **Assembly.Load**, thereby creating an assembly on the caller's behalf, it might break security.</span></span>  
  
 <span data-ttu-id="6d1c7-140">이 문제는 다음과 같은 API 요소에 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="6d1c7-140">This issue applies to the following API elements:</span></span>  
  
-   <xref:System.AppDomain.DefineDynamicAssembly%2A?displayProperty=nameWithType>  
  
-   <xref:System.AppDomain.Load%2A?displayProperty=nameWithType>  
  
-   <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType>  
  
-   <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>  
  
## <a name="demand-vs-linkdemand"></a><span data-ttu-id="6d1c7-141">Demand와 LinkDemand 비교</span><span class="sxs-lookup"><span data-stu-id="6d1c7-141">Demand vs. LinkDemand</span></span>  
 <span data-ttu-id="6d1c7-142">선언적 보안은 서로 비슷하지만 전혀 다른 검사를 수행하는 두 종류의 보안 검사를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="6d1c7-142">Declarative security offers two kinds of security checks that are similar but perform very different checks.</span></span> <span data-ttu-id="6d1c7-143">잘못 선택하면 보안이 약화되거나 성능이 저하될 수 있으므로 두 형태를 모두 이해해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="6d1c7-143">You should understand both forms because the wrong choice can result in weak security or performance loss.</span></span>  
  
 <span data-ttu-id="6d1c7-144">선언적 보안은 다음과 같은 보안 검사를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="6d1c7-144">Declarative security offers the following security checks:</span></span>  
  
-   <span data-ttu-id="6d1c7-145"><xref:System.Security.Permissions.SecurityAction.Demand>는 코드 액세스 보안 스택 워크를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="6d1c7-145"><xref:System.Security.Permissions.SecurityAction.Demand> specifies the code access security stack walk.</span></span> <span data-ttu-id="6d1c7-146">성공하려면 스택의 모든 호출자에게 지정된 권한이나 ID가 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="6d1c7-146">All callers on the stack must have the specified permission or identity to pass.</span></span> <span data-ttu-id="6d1c7-147">**필요 시** 스택의 다양 한 호출자가 포함 될 수 있으므로 모든 호출에 대해 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="6d1c7-147">**Demand** occurs on every call because the stack might contain different callers.</span></span> <span data-ttu-id="6d1c7-148">메서드를 반복해서 호출하는 경우 이 보안 검사는 매번 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="6d1c7-148">If you call a method repeatedly, this security check occurs each time.</span></span> <span data-ttu-id="6d1c7-149">**필요 시** 유인 공격에 유용한 보호는 통과 하는 동안 무단된 코드 검색 됩니다.</span><span class="sxs-lookup"><span data-stu-id="6d1c7-149">**Demand** is good protection against luring attacks; unauthorized code trying to get through it will be detected.</span></span>  
  
-   <span data-ttu-id="6d1c7-150">[LinkDemand](../../../docs/framework/misc/link-demands.md) -just-in-time (JIT) 컴파일 타임에 발생 하 고 즉각적인 호출자만 검사 합니다.</span><span class="sxs-lookup"><span data-stu-id="6d1c7-150">[LinkDemand](../../../docs/framework/misc/link-demands.md) happens at just-in-time (JIT) compilation time and checks only the immediate caller.</span></span> <span data-ttu-id="6d1c7-151">이 보안 검사는 호출자의 호출자를 검사하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="6d1c7-151">This security check does not check the caller's caller.</span></span> <span data-ttu-id="6d1c7-152">이 검사가 성공하고 나면 호출자가 호출할 수 있는 횟수에 관계없이 추가 보안 오버헤드가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="6d1c7-152">Once this check passes, there is no additional security overhead no matter how many times the caller might call.</span></span> <span data-ttu-id="6d1c7-153">그러나 유인 공격으로부터 보호되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="6d1c7-153">However, there is also no protection from luring attacks.</span></span> <span data-ttu-id="6d1c7-154">사용 하 여 **LinkDemand**, 악성 코드를 권한이 부여 된 코드를 사용 하 여 호출할 수 있도록 하 여 테스트를 통과 하 고 코드를 참조할 수 있는 모든 코드 보안을 잠재적으로 위반할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6d1c7-154">With **LinkDemand**, any code that passes the test and can reference your code can potentially break security by allowing malicious code to call using the authorized code.</span></span> <span data-ttu-id="6d1c7-155">따라서 사용 하지 마세요 **LinkDemand** 않으면 가능한 모든 보안 약점을 완전히 방지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6d1c7-155">Therefore, do not use **LinkDemand** unless all the possible weaknesses can be thoroughly avoided.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="6d1c7-156">에 [!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)], 링크 요청으로 대체 되었습니다 합니다 <xref:System.Security.SecurityCriticalAttribute> 특성 <xref:System.Security.SecurityRuleSet.Level2> 어셈블리입니다.</span><span class="sxs-lookup"><span data-stu-id="6d1c7-156">In the [!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)], link demands have been replaced by the <xref:System.Security.SecurityCriticalAttribute> attribute in <xref:System.Security.SecurityRuleSet.Level2> assemblies.</span></span> <span data-ttu-id="6d1c7-157">그러나 <xref:System.Security.SecurityCriticalAttribute> 완전 신뢰에 대 한 링크 요청은 상속 규칙도 적용 합니다.</span><span class="sxs-lookup"><span data-stu-id="6d1c7-157">The <xref:System.Security.SecurityCriticalAttribute> is equivalent to a link demand for full trust; however, it also affects inheritance rules.</span></span> <span data-ttu-id="6d1c7-158">이 변경에 대 한 자세한 내용은 참조 하세요. [보안 투명 코드, 수준 2](../../../docs/framework/misc/security-transparent-code-level-2.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="6d1c7-158">For more information about this change, see [Security-Transparent Code, Level 2](../../../docs/framework/misc/security-transparent-code-level-2.md).</span></span>  
  
 <span data-ttu-id="6d1c7-159">사용할 때 필요한 추가 예방 조치 **LinkDemand** 개별적으로 프로그래밍 해야 합니다;을 적용 하 여 도움이 보안 시스템이 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6d1c7-159">The extra precautions required when using **LinkDemand** must be programmed individually; the security system can help with enforcement.</span></span> <span data-ttu-id="6d1c7-160">실수는 보안 약점이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="6d1c7-160">Any mistake opens a security weakness.</span></span> <span data-ttu-id="6d1c7-161">사용자 코드를 사용하는 모든 권한 있는 코드는 다음을 수행하여 추가 보안을 구현해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="6d1c7-161">All authorized code that uses your code must be responsible for implementing additional security by doing the following:</span></span>  
  
-   <span data-ttu-id="6d1c7-162">클래스 또는 어셈블리에 대한 호출 코드의 액세스 권한 제한.</span><span class="sxs-lookup"><span data-stu-id="6d1c7-162">Restricting the calling code's access to the class or assembly.</span></span>  
  
-   <span data-ttu-id="6d1c7-163">호출되는 코드에 표시되는 것과 동일한 보안 검사를 호출 코드에 배치하고 호출자도 이렇게 하도록 강제.</span><span class="sxs-lookup"><span data-stu-id="6d1c7-163">Placing the same security checks on the calling code that appear on the code being called and obligating its callers to do so.</span></span> <span data-ttu-id="6d1c7-164">로 메서드를 호출 하는 코드를 작성 하는 경우 보호 되는 예를 들어를 **LinkDemand** 에 대 한 합니다 <xref:System.Security.Permissions.SecurityPermission> 사용 하 여를 <xref:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode> 플래그 지정 된 방법을 확인 해야를 **LinkDemand** (또는 **수요**, 보다 강력한는)이 사용이 권한에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="6d1c7-164">For example, if you write code that calls a method that is protected with a **LinkDemand** for the <xref:System.Security.Permissions.SecurityPermission> with the <xref:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode> flag specified, your method should also make a **LinkDemand** (or **Demand**, which is stronger) for this permission.</span></span> <span data-ttu-id="6d1c7-165">예외는 코드를 사용 하는 경우는 **LinkDemand**-결정 하는 제한 된 방식으로 보호 된 메서드는 안전 하 게 코드에서 요구와 같은 다른 보안 보호 메커니즘을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="6d1c7-165">The exception is if your code uses the **LinkDemand**-protected method in a limited way that you decide is safe, given other security protection mechanisms (such as demands) in your code.</span></span> <span data-ttu-id="6d1c7-166">이 예외적인 경우에서는 내부 코드의 보안 보호 약화에 대한 책임이 호출자에게 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6d1c7-166">In this exceptional case, the caller takes responsibility in weakening the security protection on the underlying code.</span></span>  
  
-   <span data-ttu-id="6d1c7-167">코드의 호출자가 사용자 코드에서 보호된 코드를 대신 호출하도록 속일 수 없는지 확인.</span><span class="sxs-lookup"><span data-stu-id="6d1c7-167">Ensuring that your code's callers cannot trick your code into calling the protected code on their behalf.</span></span> <span data-ttu-id="6d1c7-168">즉, 호출자는 권한 있는 코드에서 특정 매개 변수를 보호된 코드로 전달하거나 보호된 코드에서 결과를 가져오도록 강제할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="6d1c7-168">In other words, callers cannot force the authorized code to pass specific parameters to the protected code, or to get results back from it.</span></span>  
  
### <a name="interfaces-and-link-demands"></a><span data-ttu-id="6d1c7-169">인터페이스 및 링크 요구</span><span class="sxs-lookup"><span data-stu-id="6d1c7-169">Interfaces and Link Demands</span></span>  
 <span data-ttu-id="6d1c7-170">가상 메서드, 속성 또는 이벤트를 하는 경우 **LinkDemand** 기본 클래스 메서드를 재정의 기본 클래스 메서드 또한 같아야 **LinkDemand** 적용 하기 위해 재정의 된 메서드에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="6d1c7-170">If a virtual method, property, or event with **LinkDemand** overrides a base class method, the base class method must also have the same **LinkDemand** for the overridden method in order to be effective.</span></span> <span data-ttu-id="6d1c7-171">악성 코드가 기본 형식으로 다시 캐스팅되어 기본 클래스 메서드를 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6d1c7-171">It is possible for malicious code to cast back to the base type and call the base class method.</span></span> <span data-ttu-id="6d1c7-172">또한 <xref:System.Security.AllowPartiallyTrustedCallersAttribute> 어셈블리 수준 특성이 없는 어셈블리에 링크 요구를 암시적으로 추가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6d1c7-172">Also note that link demands can be added implicitly to assemblies that do not have the <xref:System.Security.AllowPartiallyTrustedCallersAttribute> assembly-level attribute.</span></span>  
  
 <span data-ttu-id="6d1c7-173">인터페이스 메서드에도 링크 요구가 있는 경우 링크 요구로 메서드 구현을 보호하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="6d1c7-173">It is a good practice to protect method implementations with link demands when interface methods also have link demands.</span></span> <span data-ttu-id="6d1c7-174">인터페이스와 함께 링크 요구를 사용하는 경우에 대한 다음 사항을 확인하세요.</span><span class="sxs-lookup"><span data-stu-id="6d1c7-174">Note the following about using link demands with interfaces:</span></span>  
  
-   <span data-ttu-id="6d1c7-175">배치 하는 경우는 **LinkDemand** 인터페이스 메서드를 구현 하는 클래스의 공용 메서드에 합니다 **LinkDemand** 다음 인터페이스로 캐스팅 하 고 메서드를 호출 하는 경우 적용 되지 것입니다.</span><span class="sxs-lookup"><span data-stu-id="6d1c7-175">If you place a **LinkDemand** on a public method of a class that implements an interface method, the **LinkDemand** will not be enforced if you then cast to the interface and call the method.</span></span> <span data-ttu-id="6d1c7-176">이 경우에 인터페이스에 대해 연결 했으므로 인터페이스의 **LinkDemand** 인터페이스에 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="6d1c7-176">In this case, because you linked against the interface, only the **LinkDemand** on the interface is honored.</span></span>  
  
 <span data-ttu-id="6d1c7-177">보안 문제에 대한 다음 항목을 검토합니다.</span><span class="sxs-lookup"><span data-stu-id="6d1c7-177">Review the following items for security issues:</span></span>  
  
-   <span data-ttu-id="6d1c7-178">인터페이스 메서드의 명시적 링크 요구</span><span class="sxs-lookup"><span data-stu-id="6d1c7-178">Explicit link demands on interface methods.</span></span> <span data-ttu-id="6d1c7-179">이러한 링크 요구가 필요한 보호를 제공하는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="6d1c7-179">Make sure these link demands offer the expected protection.</span></span> <span data-ttu-id="6d1c7-180">앞에서 설명한 대로 악성 코드가 캐스트를 사용하여 링크 요구를 해결할 수 있는지 여부를 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="6d1c7-180">Determine whether malicious code can use a cast to get around the link demands as described previously.</span></span>  
  
-   <span data-ttu-id="6d1c7-181">링크 요구가 적용된 가상 메서드</span><span class="sxs-lookup"><span data-stu-id="6d1c7-181">Virtual methods with link demands applied.</span></span>  
  
-   <span data-ttu-id="6d1c7-182">가상 메서드가 구현하는 형식 및 인터페이스</span><span class="sxs-lookup"><span data-stu-id="6d1c7-182">Types and the interfaces they implement.</span></span> <span data-ttu-id="6d1c7-183">링크 요구를 일관되게 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="6d1c7-183">These should use link demands consistently.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="6d1c7-184">참고자료</span><span class="sxs-lookup"><span data-stu-id="6d1c7-184">See also</span></span>
- [<span data-ttu-id="6d1c7-185">보안 코딩 지침</span><span class="sxs-lookup"><span data-stu-id="6d1c7-185">Secure Coding Guidelines</span></span>](../../../docs/standard/security/secure-coding-guidelines.md)

---
title: Windows Workflow Foundation 4 성능
ms.date: 03/30/2017
ms.assetid: 67d2b3e8-3777-49f8-9084-abbb33b5a766
ms.openlocfilehash: 5fec41baacca0f35618dd5bc409b88ac792ad125
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/12/2020
ms.locfileid: "79182973"
---
# <a name="windows-workflow-foundation-4-performance"></a><span data-ttu-id="7c38d-102">Windows Workflow Foundation 4 성능</span><span class="sxs-lookup"><span data-stu-id="7c38d-102">Windows Workflow Foundation 4 Performance</span></span>

 <span data-ttu-id="7c38d-103">.NET Framework 4에는 성능에 막대한 투자를 한 WF(Windows 워크플로우 재단)의 주요 개정판이 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-103">.NET Framework 4 includes a major revision of the Windows Workflow Foundation (WF) with heavy investments in performance.</span></span> <span data-ttu-id="7c38d-104">이 새로운 개정판에서는 .NET Framework 3.0 및 .NET Framework 3.5의 일부로 제공된 이전 버전의 [!INCLUDE[wf1](../../../includes/wf1-md.md)] 디자인 변경 사항이 크게 변경되었습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-104">This new revision introduces significant design changes from the previous versions of [!INCLUDE[wf1](../../../includes/wf1-md.md)] that shipped as part of .NET Framework 3.0 and .NET Framework 3.5.</span></span> <span data-ttu-id="7c38d-105">성능과 유용성을 보다 향상시키기 위해 프로그래밍 모델, 런타임 및 도구의 핵심에서 다시 설계되었습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-105">It has been re-architected from the core of the programming model, runtime, and tooling to greatly improve performance and usability.</span></span> <span data-ttu-id="7c38d-106">이 항목에서는 이러한 수정 버전의 중요한 성능 특징을 보여 주고 이전 버전의 성능 특징과 비교합니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-106">This topic shows the important performance characteristics of these revisions and compares them against those of the previous version.</span></span>

 <span data-ttu-id="7c38d-107">개별 워크플로 구성 요소 성능은 WF3과 WF4 사이에 몇 배나 증가했습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-107">Individual workflow component performance has increased by orders of magnitude between WF3 and WF4.</span></span>  <span data-ttu-id="7c38d-108">이렇게 하면 WCF(수작업으로 코딩된 Windows 통신 재단) 서비스와 WCF 워크플로 서비스 간의 격차가 매우 작아질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-108">This leaves the gap between hand-coded Windows Communication Foundation (WCF) services and WCF workflow services to be quite small.</span></span>  <span data-ttu-id="7c38d-109">WF4에서는 워크플로 대기 시간이 훨씬 줄었습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-109">Workflow latency has been significantly reduced in WF4.</span></span>  <span data-ttu-id="7c38d-110">지속성 성능은 2.5-3.0의 비율로 증가했습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-110">Persistence performance has increased by a factor of 2.5 - 3.0.</span></span>  <span data-ttu-id="7c38d-111">워크플로 추적을 통한 상태 모니터링의 오버헤드가 훨씬 줄었습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-111">Health monitoring by means of workflow tracking has significantly less overhead.</span></span>  <span data-ttu-id="7c38d-112">이러한 특성은 애플리케이션에서 WF4로 마이그레이션하거나 채택하는 강력한 이유가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-112">These are compelling reasons to migrate to or adopt WF4 in your applications.</span></span>

## <a name="terminology"></a><span data-ttu-id="7c38d-113">용어</span><span class="sxs-lookup"><span data-stu-id="7c38d-113">Terminology</span></span>

 <span data-ttu-id="7c38d-114">.NET [!INCLUDE[wf1](../../../includes/wf1-md.md)] Framework 4에 도입된 버전은 이 항목의 나머지 부분에서 WF4라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-114">The version of [!INCLUDE[wf1](../../../includes/wf1-md.md)] introduced in .NET Framework 4 will be referred to as WF4 for the rest of this topic.</span></span> [!INCLUDE[wf1](../../../includes/wf1-md.md)]<span data-ttu-id="7c38d-115">.NET Framework 3.0에 도입되었으며 .NET Framework 3.5 SP1을 통해 몇 가지 사소한 수정이 있었습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-115">was introduced in .NET Framework 3.0 and had a few minor revisions through .NET Framework 3.5 SP1.</span></span> <span data-ttu-id="7c38d-116">.NET Framework 3.5 버전의 워크플로 우 파데이션은 이 항목의 나머지 부분에서 WF3이라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-116">The .NET Framework 3.5 version of Workflow Foundation will be referred to as WF3 for the rest of this topic.</span></span> <span data-ttu-id="7c38d-117">WF3는 .NET Framework 4와 WF4와 나란히 배송됩니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-117">WF3 is shipped in .NET Framework 4 side-by-side with WF4.</span></span> <span data-ttu-id="7c38d-118">WF3 아티팩트를 WF4로 마이그레이션하는 것에 대한 자세한 내용은 [Windows 워크플로 기반 4 마이그레이션 가이드를](migration-guidance.md)참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="7c38d-118">For more information about migrating WF3 artifacts to WF4 see: [Windows Workflow Foundation 4 Migration Guide](migration-guidance.md).</span></span>

 <span data-ttu-id="7c38d-119">WCF(Windows 통신 재단)는 서비스 지향 응용 프로그램을 빌드하기 위한 Microsoft의 통합 프로그래밍 모델입니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-119">Windows Communication Foundation (WCF) is Microsoft’s unified programming model for building service-oriented applications.</span></span> <span data-ttu-id="7c38d-120">WF3과 함께 .NET 3.0의 일부로 처음 도입되었으며 지금은 .NET Framework의 핵심 구성 요소 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-120">It was first introduced as part of .NET 3.0 together with WF3 and now is one of the key components of the .NET Framework.</span></span>

 <span data-ttu-id="7c38d-121">Windows Server AppFabric은 IIS에서 실행되는 웹 애플리케이션 및 복합 애플리케이션을 쉽게 빌드하고, 확장 및 관리할 수 있게 하는 통합 기술 집합입니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-121">Windows Server AppFabric is a set of integrated technologies that make it easier to build, scale and manage Web and composite applications that run on IIS.</span></span> <span data-ttu-id="7c38d-122">서비스와 워크플로를 모니터링 및 관리하기 위한 도구를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-122">It provides tools for monitoring and managing services and workflows.</span></span> <span data-ttu-id="7c38d-123">자세한 내용은 [Windows 서버 AppFabric 1.0을](https://docs.microsoft.com/previous-versions/appfabric/ff384253(v=azure.10))참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="7c38d-123">For more information, see [Windows Server AppFabric 1.0](https://docs.microsoft.com/previous-versions/appfabric/ff384253(v=azure.10)).</span></span>

## <a name="goals"></a><span data-ttu-id="7c38d-124">목표</span><span class="sxs-lookup"><span data-stu-id="7c38d-124">Goals</span></span>
 <span data-ttu-id="7c38d-125">이 항목은 각각 다른 시나리오에 대해 측정된 데이터와 함께 WF4의 성능 특성을 보여 주는 것을 목표로 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-125">The goal of this topic is to show the performance characteristics of WF4 with data measured for different scenarios.</span></span> <span data-ttu-id="7c38d-126">또한 WF4와 WF3을 자세히 비교하고 이 새로운 수정 버전에서 향상된 기능을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-126">It also provides detailed comparisons between WF4 and WF3, and thus shows the great improvements that have been made in this new revision.</span></span> <span data-ttu-id="7c38d-127">이 문서에 제공된 시나리오와 데이터는 WF4 및 WF3의 여러 측면에 대한 기본 비용을 수량화합니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-127">The scenarios and data presented in this article quantify the underlying cost of different aspects of WF4 and WF3.</span></span> <span data-ttu-id="7c38d-128">이 데이터는 WF4의 성능 특징을 파악하는 데 유용하며 WF3에서 WF4로의 마이그레이션을 계획하거나 애플리케이션 개발에 WF4를 사용할 때 도움이 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-128">This data is useful in understanding the performance characteristics of WF4 and can be helpful in planning migrations from WF3 to WF4 or using WF4 in application development.</span></span> <span data-ttu-id="7c38d-129">하지만 이 문서에 제공된 데이터에서 결론을 도출할 때는 주의해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-129">However, care should be taken in the conclusions drawn from the data presented in this article.</span></span> <span data-ttu-id="7c38d-130">복합 워크플로 애플리케이션의 성능은 워크플로 구현 방법과 여러 구성 요소의 통합 방법에 따라 크게 달라집니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-130">The performance of a composite workflow application is highly dependent on how the workflow is implemented and how different components are integrated.</span></span> <span data-ttu-id="7c38d-131">각 애플리케이션을 측정하여 해당 애플리케이션의 성능 특성을 결정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-131">One must measure each application to determine the performance characteristics of that application.</span></span>

## <a name="overview-of-wf4-performance-enhancements"></a><span data-ttu-id="7c38d-132">WF4 성능 개선 사항 개요</span><span class="sxs-lookup"><span data-stu-id="7c38d-132">Overview of WF4 Performance Enhancements</span></span>
 <span data-ttu-id="7c38d-133">WF4는 다음 단원에서 설명하는 고성능 및 확장성을 제공하도록 신중하게 설계 및 구현되었습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-133">WF4 was carefully designed and implemented with high performance and scalability which are described in the following sections.</span></span>

### <a name="wf-runtime"></a><span data-ttu-id="7c38d-134">WF 런타임</span><span class="sxs-lookup"><span data-stu-id="7c38d-134">WF Runtime</span></span>
 <span data-ttu-id="7c38d-135">[!INCLUDE[wf1](../../../includes/wf1-md.md)] 런타임의 핵심에는 워크플로의 작업 실행을 구동하는 비동기 스케줄러가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-135">At the core of the [!INCLUDE[wf1](../../../includes/wf1-md.md)] runtime is an asynchronous scheduler that drives the execution of the activities in a workflow.</span></span> <span data-ttu-id="7c38d-136">비동기 스케줄러는 예측 가능한 고성능 작업 실행 환경을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-136">It provides a performant, predictable execution environment for activities.</span></span> <span data-ttu-id="7c38d-137">이 환경에는 실행, 연속, 완료, 취소, 예외 및 예측 가능한 스레딩 모델에 대한 정의가 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-137">The environment has a well-defined contract for execution, continuation, completion, cancellation, exceptions, and a predictable threading model.</span></span>

 <span data-ttu-id="7c38d-138">WF3에 비해 WF4 런타임의 스케줄러는 더 효율적입니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-138">In comparison to WF3, the WF4 runtime has a more efficient scheduler.</span></span> <span data-ttu-id="7c38d-139">WCF에 사용되는 것과 동일한 I/O 스레드 풀을 활용하므로 일괄 처리된 작업 항목을 실행하는 데 매우 효율적입니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-139">It leverages the same I/O thread pool that is used for WCF, which is very efficient at executing batched work items.</span></span> <span data-ttu-id="7c38d-140">내부 작업 항목 스케줄러 큐는 가장 일반적인 사용 패턴에 최적화되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-140">The internal work item scheduler queue is optimized for most common usage patterns.</span></span> <span data-ttu-id="7c38d-141">또한 WF4 런타임은 최소한의 동기화 및 이벤트 처리 논리로 실행 상태를 매우 가볍게 관리하지만 WF3은 상태 전환을 위한 복잡한 동기화를 수행하기 위해 무거운 이벤트 등록 및 호출에 따라 달라집니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-141">The WF4 runtime also manages the execution states in a very lightweight way with minimal synchronization and event handling logic, while WF3 depends on heavy-weight event registration and invocation to perform complex synchronization for state transitions.</span></span>

### <a name="data-storage-and-flow"></a><span data-ttu-id="7c38d-142">데이터 스토리지 및 흐름</span><span class="sxs-lookup"><span data-stu-id="7c38d-142">Data Storage and Flow</span></span>
 <span data-ttu-id="7c38d-143">WF3에서는 작업과 연결된 데이터가 <xref:System.Windows.DependencyProperty> 형식으로 구현된 종속성 속성을 통해 모델링됩니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-143">In WF3, data associated with an activity is modeled through dependency properties implemented by the type <xref:System.Windows.DependencyProperty>.</span></span> <span data-ttu-id="7c38d-144">종속성 속성 패턴은 WPF(Windows 프레젠테이션 파운데이션)에 도입되었습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-144">The dependency property pattern was introduced in Windows Presentation Foundation (WPF).</span></span> <span data-ttu-id="7c38d-145">일반적으로 이 패턴은 쉬운 데이터 바인딩 및 기타 UI 기능을 매우 유연하게 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-145">In general, this pattern is very flexible to support easy data binding and other UI features.</span></span> <span data-ttu-id="7c38d-146">하지만 이 패턴을 사용하려면 워크플로 정의에서 속성을 정적 필드로 정의해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-146">However, the pattern requires the properties to be defined as static fields in the workflow definition.</span></span> <span data-ttu-id="7c38d-147">[!INCLUDE[wf1](../../../includes/wf1-md.md)] 런타임이 속성 값을 설정하거나 가져올 때마다 중량 조회 논리가 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-147">Whenever the [!INCLUDE[wf1](../../../includes/wf1-md.md)] runtime sets or gets the property values, it involves heavily-weighted look-up logic.</span></span>

 <span data-ttu-id="7c38d-148">WF4는 명료한 데이터 범위 논리를 사용하여 워크플로에서 데이터가 처리되는 방식을 크게 향상시킵니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-148">WF4 uses clear data scoping logic to greatly improve how data is handled in a workflow.</span></span> <span data-ttu-id="7c38d-149">WF4는 서로 다른 두 가지 개념인 변수와 인수를 사용하여 작업에 저장되는 데이터와 작업 경계를 넘어서 전달되는 데이터를 구분합니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-149">It separates the data stored in an activity from the data that is flowing across the activity boundaries by using two different concepts: variables and arguments.</span></span> <span data-ttu-id="7c38d-150">변수에 대한 명확한 계층 적 범위와 "In/Out/InOut" 인수를 사용하면 활동에 대한 데이터 사용 복잡성이 크게 줄어들고 데이터의 수명도 자동으로 범위가 조정됩니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-150">By using a clear hierarchical scope for variables and "In/Out/InOut" arguments, the data usage complexity for activities is dramatically reduced and the lifetime of the data is also automatically scoped.</span></span> <span data-ttu-id="7c38d-151">작업에는 인수로 설명되는 잘 정의된 시그니처가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-151">Activities have a well-defined signature described by its arguments.</span></span> <span data-ttu-id="7c38d-152">작업을 검사하기만 하면 받아야 하는 데이터와 실행 결과로 생성되는 데이터를 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-152">By simply inspecting an activity you can determine what data it expects to receive and what data will be produced by it as the result of its execution.</span></span>

 <span data-ttu-id="7c38d-153">WF3에서는 워크플로를 만들 때 작업이 초기화되었습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-153">In WF3 activities were initialized when a workflow was created.</span></span> <span data-ttu-id="7c38d-154">WF4에서는 해당 작업이 실행되는 경우에만 작업이 초기화됩니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-154">In WF 4 activities are initialized only when the corresponding activities are executing.</span></span> <span data-ttu-id="7c38d-155">이렇게 하면 새 워크플로 인스턴스를 만들 때 초기화/초기화 취소 작업을 수행하지 않고 작업 수명 주기를 간소화할 수 있으므로 효율성이 향상됩니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-155">This allows a simpler activity lifecycle without performing Initialize/Uninitialize operations when a new workflow instance is created, and thus has achieved more efficiency</span></span>

### <a name="control-flow"></a><span data-ttu-id="7c38d-156">제어 흐름</span><span class="sxs-lookup"><span data-stu-id="7c38d-156">Control Flow</span></span>
 <span data-ttu-id="7c38d-157">모든 프로그래밍 언어와 마찬가지로 [!INCLUDE[wf1](../../../includes/wf1-md.md)]에서는 시퀀싱, 반복, 분기 및 기타 패턴에 대한 제어 흐름 작업 집합을 도입하여 워크플로 정의에 대한 제어 흐름을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-157">Just as in any programming language, [!INCLUDE[wf1](../../../includes/wf1-md.md)] provides support for control flows for workflow definitions by introducing a set of control flow activities for sequencing, looping, branching and other patterns.</span></span> <span data-ttu-id="7c38d-158">WF3에서는 동일한 작업을 다시 실행해야 하는 경우 새로운 <xref:System.Workflow.ComponentModel.ActivityExecutionContext>가 생성되고 <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter>를 기반으로 하는 중량 serialization 및 deserialization 논리를 통해 작업이 복제됩니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-158">In WF3, when the same activity needs to be re-executed, a new <xref:System.Workflow.ComponentModel.ActivityExecutionContext> is created and the activity is cloned through a heavy-weight serialization and deserialization logic based on <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter>.</span></span> <span data-ttu-id="7c38d-159">일반적으로 반복 제어 흐름의 성능은 작업 시퀀스를 실행하는 것보다 훨씬 느립니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-159">Usually the performance for iterative control flows is much slower than executing a sequence of activities.</span></span>

 <span data-ttu-id="7c38d-160">WF4에서는 이러한 경우를 완전히 다른 방식으로 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-160">WF4 handles this quite differently.</span></span> <span data-ttu-id="7c38d-161">작업 템플릿을 사용하고 새 ActivityInstance 개체를 만든 다음 스케줄러 큐에 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-161">It takes the activity template, creates a new ActivityInstance object, and adds it to the scheduler queue.</span></span> <span data-ttu-id="7c38d-162">이 전체 프로세스는 명시적 개체 만들기만 포함하며 매우 가볍습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-162">This whole process only involves explicit object creation and is very lightweight.</span></span>

### <a name="asynchronous-programming"></a><span data-ttu-id="7c38d-163">비동기 프로그래밍</span><span class="sxs-lookup"><span data-stu-id="7c38d-163">Asynchronous Programming</span></span>
 <span data-ttu-id="7c38d-164">일반적으로 I/O 또는 분산 컴퓨팅 작업과 같은 장기 실행 차단 작업에 대해 비동기 프로그래밍을 사용하면 애플리케이션의 성능과 확장성이 향상됩니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-164">Applications usually have better performance and scalability with asynchronous programming for long running blocking operations such as I/O or distributed computing operations.</span></span> <span data-ttu-id="7c38d-165">WF4에서는 기본 작업 형식 <xref:System.Activities.AsyncCodeActivity>, <xref:System.Activities.AsyncCodeActivity%601>를 통해 비동기 지원을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-165">WF4 provides asynchronous support through base activity types <xref:System.Activities.AsyncCodeActivity>, <xref:System.Activities.AsyncCodeActivity%601>.</span></span> <span data-ttu-id="7c38d-166">런타임은 기본적으로 비동기 작업을 이해하므로 비동기 작업이 처리되는 동안 자동으로 인스턴스를 지속적이지 않은 영역에 배치할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-166">The runtime natively understands asynchronous activities and therefore can automatically put the instance in a no-persist zone while the asynchronous work is outstanding.</span></span> <span data-ttu-id="7c38d-167">워크플로 스케줄러 스레드를 보류하지 않고 병렬로 실행될 수 있는 작업을 차단하지 않으면서 비동기 작업을 수행하기 위해 이러한 유형에서 사용자 지정 작업이 파생될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-167">Custom activities can derive from these types to perform asynchronous work without holding the workflow scheduler thread and blocking any activities that may be able to run in parallel.</span></span>

### <a name="messaging"></a><span data-ttu-id="7c38d-168">메시징</span><span class="sxs-lookup"><span data-stu-id="7c38d-168">Messaging</span></span>
 <span data-ttu-id="7c38d-169">처음에 WF3은 외부 이벤트 또는 웹 서비스 호출을 통해 매우 제한된 메시징을 지원했습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-169">Initially WF3 had very limited messaging support through external events or web services invocations.</span></span> <span data-ttu-id="7c38d-170">.NET 3.5에서 워크플로는 WCF 클라이언트로 구현되거나 <xref:System.Workflow.Activities.SendActivity> <xref:System.Workflow.Activities.ReceiveActivity>을 통해 WCF 서비스로 노출될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-170">In .NET 3.5, workflows could be implemented as WCF clients or exposed as WCF services through <xref:System.Workflow.Activities.SendActivity> and <xref:System.Workflow.Activities.ReceiveActivity>.</span></span> <span data-ttu-id="7c38d-171">WF4에서는 WCF 메시징 논리를 WF에 긴밀하게 통합하여 워크플로 기반 메시징 프로그래밍의 개념이 더욱 강화되었습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-171">In WF4, the concept of workflow-based messaging programming has been further strengthened through the tight integration of WCF messaging logic into WF.</span></span>

 <span data-ttu-id="7c38d-172">.NET 4에서 WCF에 제공되는 통합 메시지 처리 파이프라인은 WF4 서비스가 WF3보다 훨씬 향상된 성능과 확장성을 갖도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-172">The unified message processing pipeline provided in WCF in .NET 4 helps WF4 services to have significantly better performance and scalability than WF3.</span></span> <span data-ttu-id="7c38d-173">WF4는 복잡한 MEP(메시지 Exchange 패턴)를 모델링할 수 있는 보다 풍부한 메시징 프로그래밍 지원도 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-173">WF4 also provides richer messaging programming support that can model complex Message Exchange Patterns (MEPs).</span></span> <span data-ttu-id="7c38d-174">개발자는 형식화된 서비스 계약을 사용하여 프로그래밍을 간소화하거나 형식화되지 않은 서비스 계약을 사용하여 serialization 비용 없이 성능을 향상시킬 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-174">Developers can use either typed service contracts to achieve easy programming or un-typed service contracts to achieve better performance without paying serialization costs.</span></span> <span data-ttu-id="7c38d-175">WF4의 <xref:System.ServiceModel.Activities.SendMessageChannelCache> 클래스를 통한 클라이언트 쪽 채널 캐싱 지원은 개발자가 최소한의 노력으로 빠른 애플리케이션을 빌드하는 데 도움이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-175">The client-side channel caching support through the <xref:System.ServiceModel.Activities.SendMessageChannelCache> class in WF4 helps developers build fast applications with minimal effort.</span></span> <span data-ttu-id="7c38d-176">자세한 내용은 [활동 보내기에 대한 캐시 공유 수준 변경을](../wcf/feature-details/changing-the-cache-sharing-levels-for-send-activities.md)참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="7c38d-176">For more information, see [Changing the Cache Sharing Levels for Send Activities](../wcf/feature-details/changing-the-cache-sharing-levels-for-send-activities.md).</span></span>

### <a name="declarative-programming"></a><span data-ttu-id="7c38d-177">선언적 프로그래밍</span><span class="sxs-lookup"><span data-stu-id="7c38d-177">Declarative Programming</span></span>
 <span data-ttu-id="7c38d-178">WF4는 비즈니스 프로세스 및 서비스를 모델링하는 명료하고 단순한 선언적 프로그래밍 프레임워크를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-178">WF4 provides a clean and simple declarative programming framework to model business processes and services.</span></span> <span data-ttu-id="7c38d-179">프로그래밍 모델은 코드 없이 선언적 작업 구성을 지원하므로 워크플로 작성이 훨씬 간소화됩니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-179">The programming model supports fully declarative composition of activities, with no code-beside, greatly simplifying workflow authoring.</span></span> <span data-ttu-id="7c38d-180">.NET Framework 4에서 XAML 기반 선언적 프로그래밍 프레임워크는 WPF와 WF를 모두 지원하기 위해 단일 어셈블리 System.Xaml.dll로 통합되었습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-180">In .NET Framework 4, the XAML-based declarative programming framework has been unified into the single assembly System.Xaml.dll to support both WPF and WF.</span></span>

 <span data-ttu-id="7c38d-181">WF4에서는 XAML이 선언적 경험을 제공하며 .NET을 사용하여 빌드된 작업과 형식을 참조하여 XML 태그로 전체 워크플로 정의를 정의할 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-181">In WF4, XAML provides a truly declarative experience and allows for the entire definition of the workflow to be defined in XML markup, referencing activities and types built using .NET.</span></span> <span data-ttu-id="7c38d-182">사용자 지정 코드 숨김 논리를 포함하지 않는 WF3의 XOML 형식으로는 이러한 작업을 수행하는 것이 어려웠습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-182">This was difficult to do in WF3 with XOML format without involving custom code-behind logic.</span></span> <span data-ttu-id="7c38d-183">.NET 4의 새로운 XAML 스택은 워크플로우 아티팩트를 직렬화/역직렬화하는 데 있어 훨씬 더 나은 성능을 제공하며 선언적 프로그래밍을 보다 매력적이고 견고하게 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-183">The new XAML-stack in .NET 4 has much better performance in serializing/deserializing workflow artifacts and makes declarative programming more attractive and solid.</span></span>

### <a name="workflow-designer"></a><span data-ttu-id="7c38d-184">Workflow Designer</span><span class="sxs-lookup"><span data-stu-id="7c38d-184">Workflow Designer</span></span>
 <span data-ttu-id="7c38d-185">WF4에서는 선언적 프로그래밍을 지원하므로 큰 워크플로의 경우 디자인 타임 성능을 위해 보다 엄격한 요구 사항이 명시적으로 부과됩니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-185">Fully declarative programming support for WF4 explicitly imposes higher requirements for design time performance for large workflows.</span></span> <span data-ttu-id="7c38d-186">WF4의 워크플로 디자이너에서는 WF3에 비해 큰 워크플로에 대한 확장성이 향상되었습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-186">The Workflow designer in WF4 has much better scalability for large workflows than that for WF3.</span></span> <span data-ttu-id="7c38d-187">WF3 디자이너에서는 몇백 개의 작업으로 구성된 워크플로도 거의 로드할 수 없는 반면에 WF4 디자이너는 UI 가상화 지원을 통해 1000개 작업으로 구성된 큰 워크플로를 몇 초 만에 쉽게 로드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-187">With UI virtualization support, the designer can easily load a large workflow of 1000 activities in a few seconds, while it is almost impossible to load a workflow of a few hundred activities with the WF3 designer.</span></span>

## <a name="component-level-performance-comparisons"></a><span data-ttu-id="7c38d-188">구성 요소 수준 성능 비교</span><span class="sxs-lookup"><span data-stu-id="7c38d-188">Component-level Performance Comparisons</span></span>
 <span data-ttu-id="7c38d-189">이 단원에는 WF3 및 WF4 워크플로의 개별 작업을 직접 비교한 결과 데이터가 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-189">This section contains data on direct comparisons between individual activities in WF3 and WF4 workflows.</span></span>  <span data-ttu-id="7c38d-190">지속성과 같은 주요 영역이 개별 작업 구성 요소보다 성능에 더 큰 영향을 줍니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-190">Key areas like persistence have a more profound impact on performance than the individual activity components.</span></span>  <span data-ttu-id="7c38d-191">이제 구성 요소가 직접 코딩된 오케스트레이션 논리와 비교될 수 있을 만큼 빠르기 때문에 WF4의 개별 구성 요소 성능 향상은 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-191">The performance improvements in individual components in WF4 are important though because the components are now fast enough to be compared against hand-coded orchestration logic.</span></span>  <span data-ttu-id="7c38d-192">다음 섹션에서 는 "서비스 구성 시나리오"에서 다룹니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-192">An example of which is covered in the next section: "Service Composition Scenario."</span></span>

### <a name="environment-setup"></a><span data-ttu-id="7c38d-193">환경 설정</span><span class="sxs-lookup"><span data-stu-id="7c38d-193">Environment Setup</span></span>
 ![워크플로우 성능 측정을 위한 환경 설정](./media/performance/performance-test-environment.gif)

 <span data-ttu-id="7c38d-195">위의 그림은 구성 요소 수준 성능 측정에 사용되는 컴퓨터 구성을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-195">The above figure shows the machine configuration used for component-level performance measurement.</span></span> <span data-ttu-id="7c38d-196">1Gbps 이더넷 네트워크 인터페이스 하나를 통해 연결된 클라이언트 5대와 서버 1대.</span><span class="sxs-lookup"><span data-stu-id="7c38d-196">A single server and five clients connected over one 1-Gbps Ethernet network interface.</span></span> <span data-ttu-id="7c38d-197">측정하기 쉽도록 서버는 Windows Server 2008 x86을 실행하는 듀얼 프로세서/쿼드 코어 서버의 단일 코어를 사용하도록 구성됩니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-197">For easy measurements, the server is configured to use a single core of a dual-proc/quad-core server  running Windows Server 2008 x86.</span></span> <span data-ttu-id="7c38d-198">시스템 CPU 사용률은 거의 100% 유지됩니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-198">The system CPU utilization is maintained at nearly 100%.</span></span>

### <a name="test-details"></a><span data-ttu-id="7c38d-199">테스트 정보</span><span class="sxs-lookup"><span data-stu-id="7c38d-199">Test Details</span></span>
 <span data-ttu-id="7c38d-200">대체로 WF3 <xref:System.Workflow.Activities.CodeActivity>는 WF3 워크플로에서 사용할 수 있는 가장 간단한 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-200">The WF3 <xref:System.Workflow.Activities.CodeActivity> is likely the simplest activity that can be used in a WF3 workflow.</span></span>  <span data-ttu-id="7c38d-201">이 작업은 워크플로 프로그래머가 사용자 지정 코드를 넣을 수 있는 코드 숨김의 메서드를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-201">The activity calls a method in the code-behind that the workflow programmer can put custom code into.</span></span>  <span data-ttu-id="7c38d-202">WF4에는 WF3 <xref:System.Workflow.Activities.CodeActivity>와 동일한 기능을 수행하는 동등한 기능이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-202">In WF4, there is no direct analog to the WF3 <xref:System.Workflow.Activities.CodeActivity> that provides the same functionality.</span></span>  <span data-ttu-id="7c38d-203">WF4에는 WF3 <xref:System.Activities.CodeActivity>와 관련이 없는 <xref:System.Workflow.Activities.CodeActivity> 기본 클래스가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-203">Note that there is a <xref:System.Activities.CodeActivity> base class in WF4 that is not related to the WF3 <xref:System.Workflow.Activities.CodeActivity>.</span></span>  <span data-ttu-id="7c38d-204">워크플로 작성자는 사용자 지정 작업을 만든 다음 XAML 전용 워크플로를 빌드하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-204">Workflow authors are encouraged to create custom activities and build XAML-only workflows.</span></span>  <span data-ttu-id="7c38d-205">아래 테스트에서는 비어 있는 `Comment` 대신 <xref:System.Workflow.Activities.CodeActivity>라는 작업이 WF4 워크플로에 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-205">In the tests below, an activity called `Comment` is used in place of an empty <xref:System.Workflow.Activities.CodeActivity> in WF4 workflows.</span></span>  <span data-ttu-id="7c38d-206">`Comment` 작업의 코드는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-206">The code in the `Comment` activity is as follows:</span></span>

```csharp
[ContentProperty("Body")]
    public sealed class Comment : CodeActivity
    {
        public Comment()
            : base()
        {
        }

        [DefaultValue(null)]
        public Activity Body
        {
            get;
            set;
        }

        protected override void Execute(CodeActivityContext context)
        {
        }
    }
```

### <a name="empty-workflow"></a><span data-ttu-id="7c38d-207">빈 워크플로</span><span class="sxs-lookup"><span data-stu-id="7c38d-207">Empty Workflow</span></span>
 <span data-ttu-id="7c38d-208">이 테스트에서는 자식 작업이 없는 시퀀스 워크플로를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-208">This test uses a sequence workflow with no child activities.</span></span>

### <a name="single-activity"></a><span data-ttu-id="7c38d-209">단일 작업</span><span class="sxs-lookup"><span data-stu-id="7c38d-209">Single Activity</span></span>
 <span data-ttu-id="7c38d-210">이 워크플로는 자식 작업 한 개가 포함된 시퀀스 워크플로입니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-210">The workflow is a sequence workflow containing one child activity.</span></span>  <span data-ttu-id="7c38d-211">작업은 WF3의 경우 코드가 없고 WF4의 경우 <xref:System.Workflow.Activities.CodeActivity> 작업이 있는 `Comment`입니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-211">The activity is a <xref:System.Workflow.Activities.CodeActivity> with no code in the WF3 case and a `Comment` activity in the WF4 case.</span></span>

### <a name="while-with-1000-iterations"></a><span data-ttu-id="7c38d-212">1000회 반복이 포함된 While</span><span class="sxs-lookup"><span data-stu-id="7c38d-212">While with 1000 Iterations</span></span>
 <span data-ttu-id="7c38d-213">시퀀스 워크플로에는 아무 작업도 수행하지 않는 자식 작업 한 개가 루프에 포함된 <xref:System.Activities.Statements.While> 작업 한 개가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-213">The sequence workflow contains one <xref:System.Activities.Statements.While> activity with one child activity in the loop that does not perform any work.</span></span>

### <a name="replicator-compared-to-parallelforeach"></a><span data-ttu-id="7c38d-214">ParallelForEach와 비교되는 복제기</span><span class="sxs-lookup"><span data-stu-id="7c38d-214">Replicator compared to ParallelForEach</span></span>
 <span data-ttu-id="7c38d-215">WF3의 <xref:System.Workflow.Activities.ReplicatorActivity>에는 순차 실행 모드와 병렬 실행 모드가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-215"><xref:System.Workflow.Activities.ReplicatorActivity> in WF3 has sequential and parallel execution modes.</span></span>  <span data-ttu-id="7c38d-216">순차 모드에서는 작업 성능이 <xref:System.Workflow.Activities.WhileActivity>와 유사합니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-216">In sequential mode, the activity’s performance is similar to the <xref:System.Workflow.Activities.WhileActivity>.</span></span>  <span data-ttu-id="7c38d-217"><xref:System.Workflow.Activities.ReplicatorActivity>는 병렬 실행에 가장 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-217">The <xref:System.Workflow.Activities.ReplicatorActivity> is most useful for parallel execution.</span></span>  <span data-ttu-id="7c38d-218">WF4에서 이 작업과 유사한 작업은 <xref:System.Activities.Statements.ParallelForEach%601> 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-218">The WF4 analog for this is the <xref:System.Activities.Statements.ParallelForEach%601> activity.</span></span>

 <span data-ttu-id="7c38d-219">다음 다이어그램에서는 이 테스트에 사용되는 워크플로를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-219">The following diagram shows the workflows used for this test.</span></span> <span data-ttu-id="7c38d-220">왼쪽은 WF3 워크플로이고 오른쪽은 WF4 워크플로입니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-220">The WF3 workflow is on the left and the WF4 workflow is on the right.</span></span>

 ![WF3 ReplicatorActivity 및 WF4 ParallelForEach](./media/performance/replicator-parallel-wf3-wf4.gif)

### <a name="sequential-workflow-with-five-activities"></a><span data-ttu-id="7c38d-222">5개 작업이 포함된 순차 워크플로</span><span class="sxs-lookup"><span data-stu-id="7c38d-222">Sequential Workflow with Five Activities</span></span>
 <span data-ttu-id="7c38d-223">이 테스트는 여러 작업을 순차적으로 실행할 경우의 결과를 보여 주기 위한 것입니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-223">This test is meant to show the effect of having several activities execute in sequence.</span></span>  <span data-ttu-id="7c38d-224">이 시퀀스에는 5개 작업이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-224">There are five activities in the sequence.</span></span>

### <a name="transaction-scope"></a><span data-ttu-id="7c38d-225">트랜잭션 범위</span><span class="sxs-lookup"><span data-stu-id="7c38d-225">Transaction Scope</span></span>
 <span data-ttu-id="7c38d-226">트랜잭션 범위 테스트는 각 반복에 대해 새 워크플로 인스턴스가 생성되지 않는다는 점에서 다른 테스트와 약간 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-226">The transaction scope test differs from the other tests slightly in that a new workflow instance is not created for every iteration.</span></span>  <span data-ttu-id="7c38d-227">대신 아무 작업도 수행하지 않는 작업 한 개가 있는 <xref:System.Activities.Statements.TransactionScope> 작업을 포함하는 워크플로가 while 루프를 사용하여 구성됩니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-227">Instead, the workflow is structured with a while loop containing a <xref:System.Activities.Statements.TransactionScope> activity containing a single activity that does no work.</span></span>  <span data-ttu-id="7c38d-228">while 루프를 50회 반복하는 일괄 처리 작업을 매번 실행할 때마다 단일 작업으로 계산됩니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-228">Each run of a batch of 50 iterations through the while loop is counted as a single operation.</span></span>

### <a name="compensation"></a><span data-ttu-id="7c38d-229">보정</span><span class="sxs-lookup"><span data-stu-id="7c38d-229">Compensation</span></span>
 <span data-ttu-id="7c38d-230">WF3 워크플로에는 `WorkScope`라는 보정 가능한 작업 한 개가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-230">The WF3 workflow has a single compensatable activity named `WorkScope`.</span></span>  <span data-ttu-id="7c38d-231">이 작업은 단순히 <xref:System.Workflow.ComponentModel.ICompensatableActivity> 인터페이스를 구현합니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-231">The activity simply implements the <xref:System.Workflow.ComponentModel.ICompensatableActivity> interface:</span></span>

```csharp
class WorkScope :
        CompositeActivity, ICompensatableActivity
    {
        public WorkScope() : base() { }

        public WorkScope(string name)
        {
            this.Name = name;
        }

        public ActivityExecutionStatus Compensate(
            ActivityExecutionContext executionContext)
        {
            return ActivityExecutionStatus.Closed;
        }
    }
```

 <span data-ttu-id="7c38d-232">오류 처리기는 `WorkScope` 활동을 대상으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-232">The fault handler targets the `WorkScope` activity.</span></span> <span data-ttu-id="7c38d-233">WF4 워크플로우도 똑같이 단순합니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-233">The WF4 workflow is equally simplistic.</span></span>  <span data-ttu-id="7c38d-234"><xref:System.Activities.Statements.CompensableActivity>에는 본문과 보정 처리기가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-234">A <xref:System.Activities.Statements.CompensableActivity> has a body and a compensation handler.</span></span>  <span data-ttu-id="7c38d-235">명시적 보정은 시퀀스의 다음 항목입니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-235">An explicit compensate is next in the sequence.</span></span>  <span data-ttu-id="7c38d-236">본문 작업과 보정 처리기 작업은 모두 빈 구현입니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-236">The body activity and compensation handler activity are both empty implementations:</span></span>

```csharp
public sealed class CompensableActivityEmptyCompensation : CodeActivity
    {
        public CompensableActivityEmptyCompensation()
            : base() { }

        public Activity Body { get; set; }

        protected override void Execute(CodeActivityContext context) { }
    }
    public sealed class CompensableActivityEmptyBody : CodeActivity
    {
        public CompensableActivityEmptyBody()
            : base() { }

        public Activity Body { get; set; }

        protected override void Execute(CodeActivityContext context) { }
    }
```

<span data-ttu-id="7c38d-237">다음 다이어그램은 기본 보정 워크플로를 보여 주며 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-237">The following diagram shows the basic compensation workflow.</span></span> <span data-ttu-id="7c38d-238">왼쪽은 WF3 워크플로이고 오른쪽은 WF4 워크플로입니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-238">The WF3 workflow is on the left and the WF4 workflow is on the right.</span></span>

![WF3 및 WF4 기본 보정 워크플로우](./media/performance/basic-compensation-workflows-wf3-wf4.gif)

### <a name="performance-test-results"></a><span data-ttu-id="7c38d-240">성능 테스트 결과</span><span class="sxs-lookup"><span data-stu-id="7c38d-240">Performance Test Results</span></span>

 ![성능 테스트 결과 데이터를 보여 주면 표](./media/performance/performance-test-data.gif)

 ![WF3 및 WF4 성능 테스트 데이터를 비교하는 열차트](./media/performance/performance-test-chart.gif)

 <span data-ttu-id="7c38d-243">모든 테스트는 트랜잭션 범위 테스트를 제외하고 초당 워크플로 수로 측정됩니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-243">All tests are measured in workflows per second with the exception of the transaction scope test.</span></span>  <span data-ttu-id="7c38d-244">위에서 볼 수 있듯이 [!INCLUDE[wf1](../../../includes/wf1-md.md)] 런타임 성능이 전반적으로, 특히 while 루프와 같이 동일한 작업을 여러 번 실행해야 하는 영역에서 향상되었습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-244">As can be seen above, the [!INCLUDE[wf1](../../../includes/wf1-md.md)] runtime performance has improved across the board, especially in areas that require multiple executions of the same activity like the while loop.</span></span>

## <a name="service-composition-scenario"></a><span data-ttu-id="7c38d-245">서비스 컴퍼지션 시나리오</span><span class="sxs-lookup"><span data-stu-id="7c38d-245">Service Composition Scenario</span></span>
 <span data-ttu-id="7c38d-246">이전 섹션인 "구성 요소 수준 성능 비교"에서 와 같이 WF3과 WF4 간의 오버헤드가 크게 감소했습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-246">As is shown in the previous section, "Component-level Performance Comparisons," there has been a significant reduction in overhead between WF3 and WF4.</span></span>  <span data-ttu-id="7c38d-247">WCF 워크플로 서비스는 이제 수동 으로 코딩된 WCF 서비스의 성능과 거의 [!INCLUDE[wf1](../../../includes/wf1-md.md)] 일치할 수 있지만 런타임의 모든 이점을 누릴 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-247">WCF workflow services can now almost match the performance of hand-coded WCF services but still have all the benefits of the [!INCLUDE[wf1](../../../includes/wf1-md.md)] runtime.</span></span>  <span data-ttu-id="7c38d-248">이 테스트 시나리오에서는 WCF 서비스를 WF4의 WCF 워크플로 서비스와 비교합니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-248">This test scenario compares a WCF service against a WCF workflow service in WF4.</span></span>

### <a name="online-store-service"></a><span data-ttu-id="7c38d-249">온라인 저장소 서비스</span><span class="sxs-lookup"><span data-stu-id="7c38d-249">Online Store Service</span></span>
 <span data-ttu-id="7c38d-250">Windows 워크플로 재단의 강점 중 하나는 여러 서비스를 사용하여 프로세스를 구성하는 기능입니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-250">One of the strengths of Windows Workflow Foundation is the ability to compose processes using several services.</span></span>  <span data-ttu-id="7c38d-251">이러한 예로 서비스 호출 두 개를 오케스트레이션하여 주문을 구입하는 온라인 저장소 서비스가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-251">For this example, there is an online store service that orchestrates two service calls to purchase an order.</span></span>  <span data-ttu-id="7c38d-252">첫 번째 단계에서는 주문 확인 서비스를 사용하여 주문을 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-252">The first step is to validate the order using an Order Validating Service.</span></span>  <span data-ttu-id="7c38d-253">두 번째 단계에서는 웨어하우스 서비스를 사용하여 주문을 채웁니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-253">The second step is to fill the order using a Warehouse Service.</span></span>

 <span data-ttu-id="7c38d-254">두 개의 백 엔드 서비스인 주문 확인 서비스와 웨어하우스 서비스는 두 테스트에서 모두 동일하게 유지됩니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-254">The two backend services, Order Validating Service and Warehouse Service, remain the same for both tests.</span></span>  <span data-ttu-id="7c38d-255">변경되는 부분은 오케스트레이션을 수행하는 온라인 저장소 서비스입니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-255">The part that changes is the Online Store Service that performs the orchestration.</span></span>  <span data-ttu-id="7c38d-256">한 경우 서비스는 WCF 서비스로 직접 코딩됩니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-256">In one case, the service is hand-coded as a WCF service.</span></span>  <span data-ttu-id="7c38d-257">다른 경우 서비스는 WF4에서 WCF 워크플로 서비스로 기록됩니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-257">For the other case, the service is written as a WCF workflow service in WF4.</span></span> <span data-ttu-id="7c38d-258">추적 및 지속성과 같은 [!INCLUDE[wf1](../../../includes/wf1-md.md)] 관련 기능은 이 테스트에서 해제됩니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-258">[!INCLUDE[wf1](../../../includes/wf1-md.md)]-specific features like tracking and persistence are turned off for this test.</span></span>

### <a name="environment"></a><span data-ttu-id="7c38d-259">Environment</span><span class="sxs-lookup"><span data-stu-id="7c38d-259">Environment</span></span>
![성능 측정을 위한 환경 설정](./media/performance/performance-test-environment.gif)

 <span data-ttu-id="7c38d-261">여러 컴퓨터에서 HTTP를 통해 온라인 저장소 서비스에 대한 클라이언트 요청이 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-261">Client requests are made to the Online Store Service via HTTP from multiple computers.</span></span>  <span data-ttu-id="7c38d-262">한 컴퓨터에서 서비스 3개를 모두 호스트합니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-262">A single computer hosts all three services.</span></span>  <span data-ttu-id="7c38d-263">온라인 저장소 서비스와 백 엔드 서비스 사이의 전송 계층은 TCP 또는 HTTP입니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-263">The transport layer between the Online Store Service and the backend services is TCP or HTTP.</span></span>  <span data-ttu-id="7c38d-264">작업/초 측정은 온라인 저장소 서비스에 대해 완료된 `PurchaseOrder` 호출 수를 기반으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-264">The measurement of operations/second is based on the number of completed `PurchaseOrder` calls made to the Online Store Service.</span></span>  <span data-ttu-id="7c38d-265">채널 풀링은 WF4의 새로운 기능입니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-265">Channel pooling is a new feature available in WF4.</span></span>  <span data-ttu-id="7c38d-266">이 테스트 채널 풀링의 WCF 부분에서는 즉시 제공되지 않으므로 간단한 풀링 기술의 수동 코딩 구현이 온라인 스토어 서비스에서 사용되었습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-266">In the WCF portion of this test channel pooling is not provided out of the box so a hand-coded implementation of a simple pooling technique was used in the Online Store Service.</span></span>

### <a name="performance"></a><span data-ttu-id="7c38d-267">성능</span><span class="sxs-lookup"><span data-stu-id="7c38d-267">Performance</span></span>
![온라인 스토어 서비스 실적을 보여주는 열차트](./media/performance/online-store-performance-graph.gif)

 <span data-ttu-id="7c38d-269">채널 풀링 없이 백엔드 TCP 서비스에 연결하는 [!INCLUDE[wf1](../../../includes/wf1-md.md)] 서비스는 처리량에 17.2% 영향을 줍니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-269">Connecting to backend TCP services without channel pooling, the [!INCLUDE[wf1](../../../includes/wf1-md.md)] service has a 17.2% impact on throughput.</span></span>  <span data-ttu-id="7c38d-270">채널 풀링을 사용할 경우 약 23.8% 손실이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-270">With channel pooling, the penalty is about 23.8%.</span></span>  <span data-ttu-id="7c38d-271">HTTP의 경우 영향이 훨씬 적습니다. 풀링이 없을 경우 4.3% 손실이 있고 풀링을 사용할 경우 8.1% 손실이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-271">For HTTP, the impact is much less: 4.3% without pooling and 8.1% with pooling.</span></span>  <span data-ttu-id="7c38d-272">HTTP를 사용할 때는 채널 풀링의 이점이 거의 없다는 것도 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-272">It is also important to note that the channel pooling provides very little benefit when using HTTP.</span></span>

 <span data-ttu-id="7c38d-273">이 테스트에서 손으로 코딩된 WCF 서비스와 비교하여 WF4 런타임의 오버헤드가 있지만 최악의 시나리오로 간주될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-273">While there is overhead from the WF4 runtime compared with a hand-coded WCF service in this test, it could be considered a worst-case scenario.</span></span>  <span data-ttu-id="7c38d-274">이 테스트의 백 엔드 서비스 두 개는 거의 작업을 수행하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-274">The two backend services in this test do very little work.</span></span>  <span data-ttu-id="7c38d-275">실제 엔드투엔드 시나리오에서는 이러한 서비스가 데이터베이스 호출과 같은 보다 광범위한 작업을 수행하여 전송 계층이 성능에 미치는 영향을 줄입니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-275">In a real end-to-end scenario, these services would perform more expensive operations like database calls, making the performance impact of the transport layer less important.</span></span>  <span data-ttu-id="7c38d-276">이러한 장점 외에도 WF4에서 사용 가능한 기능의 이점 덕분에 Workflow Foundation은 오케스트레이션 서비스를 만들 때 유용한 선택이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-276">This plus the benefits of the features available in WF4 makes Workflow Foundation a viable choice for creating orchestration services.</span></span>

## <a name="key-performance-considerations"></a><span data-ttu-id="7c38d-277">주요 성능 고려 사항</span><span class="sxs-lookup"><span data-stu-id="7c38d-277">Key Performance Considerations</span></span>
 <span data-ttu-id="7c38d-278">interop을 제외한 이 단원의 기능 영역은 WF3과 WF4 사이에서 크게 변경되었습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-278">The feature areas in this section, with the exception of interop, have dramatically changed between WF3 and WF4.</span></span>  <span data-ttu-id="7c38d-279">이러한 변경은 성능은 물론 워크플로 애플리케이션의 디자인에도 영향을 줍니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-279">This affects the design of workflow applications as well as the performance.</span></span>

#### <a name="workflow-activation-latency"></a><span data-ttu-id="7c38d-280">워크플로 활성화 대기 시간</span><span class="sxs-lookup"><span data-stu-id="7c38d-280">Workflow Activation Latency</span></span>
 <span data-ttu-id="7c38d-281">WCF 워크플로 서비스 응용 프로그램에서는 새 워크플로를 시작하거나 기존 워크플로를 로드하는 대기 시간이 차단될 수 있으므로 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-281">In a WCF workflow service application, the latency for starting a new workflow or loading an existing workflow is important as it can be blocking.</span></span>  <span data-ttu-id="7c38d-282">이 테스트 사례에서는 일반적인 시나리오의 WF4 XAMLX 호스트를 기준으로 WF3 XOML 호스트를 측정합니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-282">This test case measures a WF3 XOML host against a WF4 XAMLX host in a typical scenario.</span></span>

##### <a name="environment-setup"></a><span data-ttu-id="7c38d-283">환경 설정</span><span class="sxs-lookup"><span data-stu-id="7c38d-283">Environment Setup</span></span>
 ![대기 시간 및 처리량 테스트를 위한 환경 설정](./media/performance/latency-throughput-environment-setup.gif)

##### <a name="test-setup"></a><span data-ttu-id="7c38d-285">테스트 설치</span><span class="sxs-lookup"><span data-stu-id="7c38d-285">Test Setup</span></span>
 <span data-ttu-id="7c38d-286">시나리오에서 클라이언트 컴퓨터는 컨텍스트 기반 상관 관계를 사용하여 WCF 워크플로 서비스에 연결합니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-286">In the scenario, a client computer contacts a WCF workflow service using context-based correlation.</span></span>  <span data-ttu-id="7c38d-287">컨텍스트 상관 관계에는 특수 컨텍스트 바인딩이 필요하며 컨텍스트 헤더나 쿠키를 사용하여 메시지를 올바른 워크플로 인스턴스에 연결합니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-287">Context correlation requires a special context binding and uses a context header or cookie to relate messages to the correct workflow instance.</span></span>  <span data-ttu-id="7c38d-288">상관 관계 ID가 메시지 헤더에 있으므로 메시지 본문을 구문 분석할 필요가 없다는 점에서 성능 이점이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-288">It has a performance benefit in that the correlation Id is located in the message header so the message body does not need to be parsed.</span></span>

 <span data-ttu-id="7c38d-289">서비스는 요청을 사용하여 새 워크플로를 만들고 즉각적인 응답을 보내어 대기 시간 측정에 워크플로 실행 시간이 포함되지 않도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-289">The service will create a new workflow with the request and send an immediate response so that the measurement of latency does not include the time spent running the workflow.</span></span>  <span data-ttu-id="7c38d-290">WF3 워크플로는 코드 숨김이 있는 XOML이고 WF4 워크플로는 완전히 XAML입니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-290">The WF3 workflow is XOML with a code-behind and the WF4 workflow is entirely XAML.</span></span>  <span data-ttu-id="7c38d-291">WF4 워크플로는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-291">The WF4 workflow looks like this:</span></span>

 ![WF4 상관 범위 워크플로우](./media/performance/wf4-correlationscope-workflow.gif)

 <span data-ttu-id="7c38d-293"><xref:System.ServiceModel.Activities.Receive> 작업은 워크플로 인스턴스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-293">The <xref:System.ServiceModel.Activities.Receive> activity creates the workflow instance.</span></span>  <span data-ttu-id="7c38d-294">받은 메시지에 전달된 값은 회신 메시지에서 에코됩니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-294">A value passed in the received message is echoed in the reply message.</span></span>  <span data-ttu-id="7c38d-295">회신 후의 시퀀스에는 워크플로의 나머지 부분이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-295">A sequence following the reply contains the rest of the workflow.</span></span>  <span data-ttu-id="7c38d-296">위의 사례에서는 주석 작업 한 개만 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-296">In the above case, only one comment activity is shown.</span></span>  <span data-ttu-id="7c38d-297">주석 작업 수가 워크플로 복잡성을 시뮬레이션하기 위해 변경됩니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-297">The number of comment activities is changed to simulate workflow complexity.</span></span>  <span data-ttu-id="7c38d-298">주석 작업은 아무 작업도 수행하지 않는 WF3 <xref:System.Workflow.Activities.CodeActivity>에 해당합니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-298">A comment activity is equivalent to a WF3 <xref:System.Workflow.Activities.CodeActivity> that performs no work.</span></span> <span data-ttu-id="7c38d-299">주석 활동에 대한 자세한 내용은 이 문서의 "구성 요소 수준 성능 비교" 절을 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="7c38d-299">For more information about the comment activity, see the "Component-level Performance Comparison" section earlier in this article.</span></span>

##### <a name="test-results"></a><span data-ttu-id="7c38d-300">테스트 결과</span><span class="sxs-lookup"><span data-stu-id="7c38d-300">Test Results</span></span>

 <span data-ttu-id="7c38d-301">WCF 워크플로 우식 서비스에 대한 대기 및 웜 대기 시간:</span><span class="sxs-lookup"><span data-stu-id="7c38d-301">Cold and warm latency for WCF workflow services:</span></span>

 ![WF3 및 WF4를 사용하는 WCF 워크플로우 서비스에 대해 대기 및 웜 대기 시간을 보여 주면 열차트](./media/performance/latency-results-graph.gif)

 <span data-ttu-id="7c38d-303">이전 차트에서 cold는 지정된 워크플로에 대한 <xref:System.ServiceModel.WorkflowServiceHost> 기존이 없는 경우를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-303">In the previous chart, cold refers to the case where there is not an existing <xref:System.ServiceModel.WorkflowServiceHost> for the given workflow.</span></span>  <span data-ttu-id="7c38d-304">즉, 콜드 대기 시간은 워크플로가 처음 사용되고 있으며 XOML 또는 XAML을 컴파일해야 하는 경우입니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-304">In other words, cold latency is when the workflow is being used for the first time and the XOML or XAML needs to be compiled.</span></span>  <span data-ttu-id="7c38d-305">웜 대기 시간은 워크플로 형식이 이미 컴파일된 경우 새 워크플로 인스턴스를 만드는 시간입니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-305">Warm latency is the time to create a new workflow instance when the workflow type has already been compiled.</span></span>  <span data-ttu-id="7c38d-306">WF4 사례에서는 워크플로 복잡성에 거의 차이가 없지만 WF3 사례에서는 선형으로 진행합니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-306">The complexity of the workflow makes very little difference in the WF4 case but has a linear progression in the WF3 case.</span></span>

#### <a name="correlation-throughput"></a><span data-ttu-id="7c38d-307">상관 관계 처리량</span><span class="sxs-lookup"><span data-stu-id="7c38d-307">Correlation Throughput</span></span>
 <span data-ttu-id="7c38d-308">WF4에서는 콘텐츠 기반의 새 상관 관계 기능이 도입되었습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-308">WF4 introduces a new content-based correlation feature.</span></span>  <span data-ttu-id="7c38d-309">WF3은 컨텍스트 기반 상관 관계만 제공했습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-309">WF3 provided only context-based correlation.</span></span>  <span data-ttu-id="7c38d-310">컨텍스트 기반 상관 관계는 특정 WCF 채널 바인딩에 대해서만 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-310">Context-based correlation could only be done over specific WCF channel bindings.</span></span>  <span data-ttu-id="7c38d-311">이러한 바인딩을 사용하는 경우 메시지 헤더에 워크플로 ID가 삽입됩니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-311">The workflow Id is inserted into the message header when using these bindings.</span></span>  <span data-ttu-id="7c38d-312">WF3 런타임은 해당 ID로만 워크플로를 식별할 수 있습니다.  콘텐츠 기반 상관 관계를 사용하면 워크플로 작성자는 계정 번호 또는 고객 ID와 같은 관련 데이터에서 상관 관계 키를 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-312">The WF3 runtime could only identify a workflow by its Id.  With content-based correlation, the workflow author can create a correlation key out of a relevant piece of data like an account number or customer Id.</span></span>

 <span data-ttu-id="7c38d-313">컨텍스트 기반 상관 관계는 상관 관계 키가 메시지 헤더에 있다는 점에서 성능 이점이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-313">Context-based correlation has a performance advantage in that the correlation key is located in the message header.</span></span>  <span data-ttu-id="7c38d-314">deserialization/메시지 복사 없이 메시지에서 키를 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-314">The key can be read from the message without de-serialization/message-copying.</span></span>  <span data-ttu-id="7c38d-315">콘텐츠 기반 상관 관계에서는 상관 관계 키가 메시지 본문에 저장됩니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-315">In content-based correlation, the correlation key is stored in the message body.</span></span>  <span data-ttu-id="7c38d-316">XPath 식을 사용하여 키를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-316">An XPath expression is used to locate the key.</span></span>  <span data-ttu-id="7c38d-317">이 추가 처리 비용은 메시지 크기, 본문에서 키의 깊이 및 키 개수에 따라 달라집니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-317">The cost of this extra processing depends on the size of the message, depth of the key in the body, and the number of keys.</span></span>  <span data-ttu-id="7c38d-318">이 테스트에서는 컨텍스트 및 콘텐츠 기반 상관 관계를 비교하고 여러 키를 사용할 때의 성능 저하를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-318">This test compares context- and content-based correlation and also shows the performance degradation when using multiple keys.</span></span>

#### <a name="environment-setup"></a><span data-ttu-id="7c38d-319">환경 설정</span><span class="sxs-lookup"><span data-stu-id="7c38d-319">Environment Setup</span></span>
![워크플로 성능 테스트를 위한 환경 설정](./media/performance/performance-test-environment.gif)

#### <a name="test-setup"></a><span data-ttu-id="7c38d-321">테스트 설치</span><span class="sxs-lookup"><span data-stu-id="7c38d-321">Test Setup</span></span>
<span data-ttu-id="7c38d-322">![상관 관계 처리량 워크플로 테스트](./media/performance/correlation-throughput-workflow.gif "상관 처리량 워크플로 테스트 설정")</span><span class="sxs-lookup"><span data-stu-id="7c38d-322">![Correlation Throughput Workflow Test](./media/performance/correlation-throughput-workflow.gif "Correlation throughput workflow test setup")</span></span>

 <span data-ttu-id="7c38d-323">이전 워크플로는 [지속성](#persistence) 섹션에 사용된 워크플로와 동일합니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-323">The previous workflow is the same one used in the [Persistence](#persistence) section.</span></span> <span data-ttu-id="7c38d-324">지속성이 없는 상관 관계 테스트의 경우 런타임에 설치된 지속성 공급자가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-324">For the correlation tests without persistence, there is no persistence provider installed in the runtime.</span></span> <span data-ttu-id="7c38d-325">상관 관계는 CreateOrder 및 CompleteOrder의 두 위치에서 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-325">Correlation occurs in two places: CreateOrder and CompleteOrder.</span></span>

#### <a name="test-results"></a><span data-ttu-id="7c38d-326">테스트 결과</span><span class="sxs-lookup"><span data-stu-id="7c38d-326">Test Results</span></span>
<span data-ttu-id="7c38d-327">![상관 관계 처리량](./media/performance/correlation-throughput-graph.gif "상관 처리량 그래프")</span><span class="sxs-lookup"><span data-stu-id="7c38d-327">![Correlation Throughput](./media/performance/correlation-throughput-graph.gif "Correlation throughput graph")</span></span>

 <span data-ttu-id="7c38d-328">이 그래프에서는 콘텐츠 기반 상관 관계에서 사용된 키 개수가 증가할 때의 성능 저하를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-328">This graph shows a decrease in performance as the number of keys used in content-based correlation increases.</span></span>  <span data-ttu-id="7c38d-329">TCP와 HTTP의 곡선이 유사한 것은 이러한 프로토콜과 연결된 오버헤드를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-329">The similarity in the curves between TCP and HTTP indicates the overhead associated with these protocols.</span></span>

#### <a name="correlation-with-persistence"></a><span data-ttu-id="7c38d-330">지속성이 포함된 상관 관계</span><span class="sxs-lookup"><span data-stu-id="7c38d-330">Correlation with Persistence</span></span>
 <span data-ttu-id="7c38d-331">지속형 워크플로를 사용할 경우 콘텐츠 기반 상관 관계의 CPU 부담이 워크플로 런타임에서 SQL 데이터베이스로 이동합니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-331">With a persisted workflow, the CPU pressure from content-based correlation shifts from the workflow runtime to the SQL database.</span></span>  <span data-ttu-id="7c38d-332">SQL 지속성 공급자의 저장 프로시저는 키를 일치시켜 해당 워크플로를 찾는 작업을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-332">The stored procedures in the SQL persistence provider do the work of matching the keys to locate the appropriate workflow.</span></span>

 ![상관 관계 및 지속성 결과를 보여 줄 표선 차트](./media/performance/correlation-persistence-graph.gif)

 <span data-ttu-id="7c38d-334">여전히 컨텍스트 기반 상관 관계가 콘텐츠 기반 상관 관계보다 더 빠릅니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-334">Context-based correlation is still faster than content-based correlation.</span></span>  <span data-ttu-id="7c38d-335">그러나 지속성이 상관 관계보다 성능에 더 많은 영향을 주기 때문에 차이가 덜 두드러집니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-335">However, the difference is less pronounced as persistence has more impact on performance than correlation.</span></span>

### <a name="complex-workflow-throughput"></a><span data-ttu-id="7c38d-336">복잡한 워크플로 처리량</span><span class="sxs-lookup"><span data-stu-id="7c38d-336">Complex Workflow Throughput</span></span>
 <span data-ttu-id="7c38d-337">워크플로 복잡성은 작업 수로만 측정되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-337">The complexity of a workflow is not measured only by the number of activities.</span></span>  <span data-ttu-id="7c38d-338">복합 작업에는 많은 자식이 포함될 수 있으며 이러한 자식도 복합 작업일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-338">Composite activities can contain many children and those children can also be composite activities.</span></span>  <span data-ttu-id="7c38d-339">중첩 수준 수가 증가함에 따라 현재 실행 상태에 있는 작업 수와 특정 상태에 있는 변수 개수도 증가합니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-339">As the number of levels of nesting increases, so does the number of activities that can be currently in the executing state and the number of variables that can be in state.</span></span>  <span data-ttu-id="7c38d-340">이 테스트에서는 복잡한 워크플로를 실행할 때 WF3과 WF4의 처리량을 비교합니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-340">This test compares throughput between WF3 and WF4 when executing complex workflows.</span></span>

### <a name="test-setup"></a><span data-ttu-id="7c38d-341">테스트 설치</span><span class="sxs-lookup"><span data-stu-id="7c38d-341">Test Setup</span></span>
 <span data-ttu-id="7c38d-342">이러한 테스트는 Windows Server 2008 x64를 실행하는 Intel Xeon X5355 @ 2.66GHz 4방향 컴퓨터(4GB RAM)에서 실행되었습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-342">These tests were executed on an Intel Xeon X5355 @ 2.66GHz 4-way computer with 4GB RAM running Windows Server 2008 x64.</span></span>  <span data-ttu-id="7c38d-343">테스트 코드는 100% CPU 사용률에 도달하기 위해 코어당 스레드 한 개를 사용하여 단일 프로세스에서 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-343">The test code runs in a single process with one thread per core to reach 100% CPU utilization.</span></span>

 <span data-ttu-id="7c38d-344">이 테스트에 대해 생성된 워크플로에는 각 시퀀스의 작업 수와 깊이를 나타내는 두 개의 기본 변수가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-344">The workflows generated for this test have two main variables: depth and number of activities in each sequence.</span></span>  <span data-ttu-id="7c38d-345">각 깊이 수준에는 병렬 작업, while 루프, 결정, 할당 및 시퀀스가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-345">Each depth level includes a parallel activity, while loop, decisions, assignments, and sequences.</span></span>  <span data-ttu-id="7c38d-346">아래 그림의 WF4 디자이너에는 최상위 순서도가 나와 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-346">In the WF4 designer pictured below, the top-level flow chart is pictured.</span></span>  <span data-ttu-id="7c38d-347">각 순서도 작업은 기본 순서도와 비슷합니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-347">Each flowchart activity resembles the main flowchart.</span></span>  <span data-ttu-id="7c38d-348">깊이가 테스트 매개 변수로 제한되는 이 워크플로를 그림으로 그리는 경우 프랙탈을 고려하는 것이 유용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-348">It may be helpful to think of a fractal when picturing this workflow, where the depth is limited to the parameters of the test.</span></span>

 <span data-ttu-id="7c38d-349">지정된 테스트의 작업 수는 시퀀스당 작업 수와 깊이에 의해 결정됩니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-349">The number of activities in a given test is determined by the depth and number of activities per sequence.</span></span>  <span data-ttu-id="7c38d-350">다음 수식에서는 WF4 테스트의 작업 수를 계산합니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-350">The following equation computes the number of activities in the WF4 test:</span></span>

 ![활동 수를 계산하는 수식](./media/performance/number-activities-equation.gif)

 <span data-ttu-id="7c38d-352">WF3 테스트의 작업 수는 추가 시퀀스로 인해 약간 다른 수식으로 계산할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-352">The WF3 test’s activity count can be computed with a slightly different equation due to an extra sequence:</span></span>

 ![WF3 활동 수를 계산하는 방정식](./media/performance/wf3-number-activities-equation.gif)

 <span data-ttu-id="7c38d-354">여기서 d는 깊이이고 a는 시퀀스당 작업 수입니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-354">Where d is the depth and a is the number of activities per sequence.</span></span>  <span data-ttu-id="7c38d-355">이러한 수식 뒤의 논리는 첫 번째 상수에 a를 곱한 값이 시퀀스 수이고, 두 번째 상수는 현재 수준의 정적 작업 수라는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-355">The logic behind these equations is that the first constant, multiplied by a, is the number of sequences and the second constant is the static number of activities in the current level.</span></span>  <span data-ttu-id="7c38d-356">각 순서도에는 순서도 자식 작업 3개가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-356">There are three flowchart child activities in each flowchart.</span></span>  <span data-ttu-id="7c38d-357">최하위 수준에서는 이러한 순서도가 비어 있지만 다른 수준에서는 기본 순서도의 복사본입니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-357">At the bottom depth level, these flowcharts are empty but at the other levels they are copies of the main flowchart.</span></span>  <span data-ttu-id="7c38d-358">각 테스트 변형의 워크플로 정의에 포함된 작업 수는 다음 표에 나와 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-358">The number of activities in each test variation’s workflow definition is indicated in the following table:</span></span>

 ![각 테스트에 사용된 활동 수를 보여 주는 테이블](./media/performance/workflow-variation-compare-table.gif)

 <span data-ttu-id="7c38d-360">각 깊이 수준에 따라 워크플로 정의의 작업 수가 급격하게 증가합니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-360">The number of activities in the workflow definition increases sharply with each depth level.</span></span>  <span data-ttu-id="7c38d-361">그러나 지정된 워크플로에서 결정당 경로 한 개만 실행되기 때문에 실제 작업의 일부만 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-361">But only one path per decision point is executed in a given workflow instance, so only a small subset of the actual activities are executed.</span></span>

 ![복잡한 처리량 워크플로의 순서도](./media/performance/complex-workflow-throughput-workflow.gif)

 <span data-ttu-id="7c38d-363">WF3에 대해 동등한 워크플로가 생성되었습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-363">An equivalent workflow was created for WF3.</span></span> <span data-ttu-id="7c38d-364">WF3 디자이너는 중첩하지 않고 전체 워크플로를 디자인 영역에 표시하기 때문에 이 항목에서 표시하기에 너무 큽니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-364">The WF3 designer shows the entire workflow in the design area instead of nesting, therefore it is too big to display in this topic.</span></span> <span data-ttu-id="7c38d-365">워크플로의 코드 조각은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-365">A snippet of the workflow is shown below.</span></span>

 ![WF3 워크플로의 순서도 스니펫](./media/performance/wf3-workflow-snippet.gif)

 <span data-ttu-id="7c38d-367">극단적인 사례에서 중첩을 연습하기 위해 이 테스트에 포함된 다른 워크플로에서는 중첩된 시퀀스 100개를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-367">To exercise nesting in an extreme case, another workflow that is part of this test uses 100 nested sequences.</span></span>  <span data-ttu-id="7c38d-368">가장 안쪽의 시퀀스에는 `Comment` 또는 <xref:System.Workflow.Activities.CodeActivity> 한 개가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-368">In the innermost sequence is a single `Comment` or <xref:System.Workflow.Activities.CodeActivity>.</span></span>

 ![중첩 된 시퀀스의 순서도](./media/performance/nested-sequence-workflow.gif)

 <span data-ttu-id="7c38d-370">추적 및 지속성은 이 테스트의 일부로 사용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-370">Tracking and persistence are not used as part of this test.</span></span>

### <a name="test-results"></a><span data-ttu-id="7c38d-371">테스트 결과</span><span class="sxs-lookup"><span data-stu-id="7c38d-371">Test Results</span></span>
 ![처리량 실적 결과를 보여주는 열차트](./media/performance/throughput-performance-results.gif)

 <span data-ttu-id="7c38d-373">많은 깊이와 다수의 작업이 포함된 복잡한 워크플로에서도 성능 결과는 이 문서의 앞부분에 표시된 다른 처리량 수치와 일관됩니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-373">Even with complex workflows with lots of depth and a high number of activities, the performance results are consistent with other throughput numbers shown earlier in this article.</span></span>  <span data-ttu-id="7c38d-374">WF4의 처리량은 몇 배나 더 빠르며 로그 눈금으로 비교해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-374">WF4’s throughput is orders of magnitude faster and has to be compared on a logarithmic scale.</span></span>

### <a name="memory"></a><span data-ttu-id="7c38d-375">메모리</span><span class="sxs-lookup"><span data-stu-id="7c38d-375">Memory</span></span>
 <span data-ttu-id="7c38d-376">Windows Workflow Foundation의 메모리 오버헤드는 워크플로 복잡성과 워크플로 정의 수의 두 가지 주요 영역에서 측정됩니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-376">The memory overhead of Windows Workflow Foundation is measured in two key areas: workflow complexity and number of workflow definitions.</span></span>  <span data-ttu-id="7c38d-377">메모리 측정은 Windows 7 64비트 워크스테이션에서 수행되었습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-377">Memory measurements were taken on a Windows 7 64-bit workstation.</span></span>  <span data-ttu-id="7c38d-378">성능 카운터 모니터링, Polling Environment.WorkingSet 또는 [VMMap에서](/sysinternals/downloads/vmmap)사용할 수 있는 VMMap과 같은 도구를 사용하는 등 작업 집합 크기를 측정하는 방법에는 여러 가지가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-378">There are many ways to obtain the measurement of working set size such as monitoring performance counters, polling Environment.WorkingSet, or using a tool like VMMap available from [VMMap](/sysinternals/downloads/vmmap).</span></span> <span data-ttu-id="7c38d-379">각 테스트의 결과를 얻고 확인하기 위해 여러 방법의 조합이 사용되었습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-379">A combination of methods was used to obtain and verify the results of each test.</span></span>

### <a name="workflow-complexity-test"></a><span data-ttu-id="7c38d-380">워크플로 복잡성 테스트</span><span class="sxs-lookup"><span data-stu-id="7c38d-380">Workflow Complexity Test</span></span>
 <span data-ttu-id="7c38d-381">워크플로 복잡성 테스트는 워크플로 복잡성을 기준으로 작업 집합 차이를 측정합니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-381">The workflow complexity test measures the working set difference based on the complexity of the workflow.</span></span>  <span data-ttu-id="7c38d-382">이전 단원에서 사용된 복잡한 워크플로 외에도 단일 작업 워크플로 및 1000개 작업이 포함된 시퀀스의 두 가지 기본 사례를 다루기 위해 새 변형이 추가되었습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-382">In addition to the complex workflows used in the previous section, new variations are added to cover two basic cases: a single activity workflow and a sequence with 1000 activities.</span></span>  <span data-ttu-id="7c38d-383">이러한 테스트에서 워크플로는 완료될 때까지 1분 동안 단일 직렬 루프로 초기화 및 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-383">For these tests the workflows are initialized and executed to completion in a single serial loop for a period of one minute.</span></span>  <span data-ttu-id="7c38d-384">각 테스트 변형이 3회 실행되고 기록되는 데이터는 3회 실행의 평균입니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-384">Each test variation is run three times and the data recorded is the average of those three runs.</span></span>

 <span data-ttu-id="7c38d-385">새 기본 테스트 2개에는 다음과 같은 워크플로가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-385">The two new basic tests have workflows that look like those shown below:</span></span>

 ![WF3 및 WF4 모두를 위한 복잡한 워크플로우](./media/performance/complex-workflow-wf3-wf4.gif)

 <span data-ttu-id="7c38d-387">위에 표시된 WF3 워크플로에서는 비어 있는 <xref:System.Workflow.Activities.CodeActivity> 작업이 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-387">In the WF3 workflow shown above, empty <xref:System.Workflow.Activities.CodeActivity> activities are used.</span></span>  <span data-ttu-id="7c38d-388">위의 WF4 워크플로는 `Comment` 작업을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-388">The WF4 workflow above uses `Comment` activities.</span></span>  <span data-ttu-id="7c38d-389">`Comment` 작업은 이 문서의 앞부분에 있는 구성 요소 수준 성능 비교 단원에서 설명되었습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-389">The `Comment` activity was described in the Component-level Performance Comparisons section earlier in this article.</span></span>

 ![WF3 및 WF4 워크플로에 대한 복잡한 워크플로우 메모리 사용량을 보여 주면 열차트](./media/performance/complex-memory-usage-wf3-wf4.gif)

 <span data-ttu-id="7c38d-391">이 그래프에서 확인할 명확한 추세 중 하나는 WF3과 WF4에서 모두 중첩이 메모리 사용에 미치는 영향이 비교적 최소화된다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-391">One of the clear trends to notice in this graph is that nesting has relatively minimal impact on memory usage in both WF3 and WF4.</span></span>  <span data-ttu-id="7c38d-392">가장 중요한 메모리 영향은 지정된 워크플로의 작업 수에서 비롯됩니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-392">The most significant memory impact comes from the number of activities in a given workflow.</span></span>  <span data-ttu-id="7c38d-393">시퀀스 1000, 복잡한 깊이 5 시퀀스 5 및 복잡한 깊이 7 시퀀스 1 변형의 데이터가 주어질 경우 작업 수가 수천 개로 늘어나면 메모리 사용 증가가 더 두드러집니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-393">Given the data from the sequence 1000, complex depth 5 sequence 5, and complex depth 7 sequence 1 variations, it is clear that as the number of activities enters the thousands, the memory usage increase becomes more noticeable.</span></span>  <span data-ttu-id="7c38d-394">~29K 작업이 있는 극단적인 사례(깊이 7 시퀀스 1)에서 WF4는 WF3보다 거의 79% 더 적은 메모리를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-394">In the extreme case (depth 7 sequence 1) where there are ~29K activities, WF4 is using almost 79% less memory than WF3.</span></span>

### <a name="multiple-workflow-definitions-test"></a><span data-ttu-id="7c38d-395">여러 워크플로 정의 테스트</span><span class="sxs-lookup"><span data-stu-id="7c38d-395">Multiple Workflow Definitions Test</span></span>
 <span data-ttu-id="7c38d-396">WF3 및 WF4에서 워크플로를 호스트하는 데 사용 가능한 옵션 때문에 워크플로 정의당 메모리 측정은 두 가지 테스트로 나뉩니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-396">Measuring memory per workflow definition is divided into two different tests because of the available options for hosting workflows in WF3 and WF4.</span></span>  <span data-ttu-id="7c38d-397">이러한 테스트는 지정된 워크플로가 정의당 한 번만 인스턴스화되고 실행된다는 점에서 워크플로 복잡성 테스트와는 다른 방식으로 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-397">The tests are run in a different manner than the workflow complexity test in that a given workflow is instanced and executed only once per definition.</span></span>  <span data-ttu-id="7c38d-398">워크플로 정의와 해당 호스트가 AppDomain 수명 동안 메모리에 남아 있기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-398">This is because the workflow definition and its host remain in memory for the lifetime of the AppDomain.</span></span>  <span data-ttu-id="7c38d-399">지정된 워크플로 인스턴스를 실행할 때 사용된 메모리를 가비지 수집 중에 정리해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-399">The memory used by running a given workflow instance should be cleaned up during garbage collection.</span></span>  <span data-ttu-id="7c38d-400">호스팅 옵션에 대한 자세한 내용은 WF4에 대한 마이그레이션 지침을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="7c38d-400">The migration guidance for WF4 contains more detailed information on the hosting options.</span></span> <span data-ttu-id="7c38d-401">자세한 내용은 [WF 마이그레이션 쿡북: 워크플로 호스팅](migration-guidance.md)을 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="7c38d-401">For more information, see [WF Migration Cookbook: Workflow Hosting](migration-guidance.md).</span></span>

 <span data-ttu-id="7c38d-402">여러 가지 방법으로 워크플로 정의 테스트에 사용할 많은 워크플로 정의를 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-402">Creating many workflow definitions for a workflow definition test can be done in several ways.</span></span>  <span data-ttu-id="7c38d-403">예를 들어, 코드 생성을 사용하여 이름만 제외하고 모두 동일한 1000개 워크플로 집합을 만들고 각 워크플로를 개별 파일에 저장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-403">For instance, one could use code generation to create a set of 1000 workflows that are identical except in name and save each of those workflows into separate files.</span></span>  <span data-ttu-id="7c38d-404">이 방법은 콘솔 호스팅 테스트에 사용되었습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-404">This approach was taken for the console-hosted test.</span></span>  <span data-ttu-id="7c38d-405">WF3에서는 워크플로 정의를 실행하기 위해 <xref:System.Workflow.Runtime.WorkflowRuntime> 클래스가 사용되었습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-405">In WF3, the <xref:System.Workflow.Runtime.WorkflowRuntime> class was used to run the workflow definitions.</span></span>  <span data-ttu-id="7c38d-406">WF4는 <xref:System.Activities.WorkflowApplication>을 사용하여 단일 워크플로 인스턴스를 만들거나 직접 <xref:System.Activities.WorkflowInvoker>를 사용하여 메서드 호출인 것처럼 작업을 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-406">WF4 can either use <xref:System.Activities.WorkflowApplication> to create a single workflow instance or directly use <xref:System.Activities.WorkflowInvoker> to run the activity as if it were a method call.</span></span>  <span data-ttu-id="7c38d-407"><xref:System.Activities.WorkflowApplication>은 단일 워크플로 인스턴스의 호스트이며 기능 패리티가 <xref:System.Workflow.Runtime.WorkflowRuntime>에 더 가깝기 때문에 이 테스트에서는 이 클래스가 사용되었습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-407"><xref:System.Activities.WorkflowApplication> is a host of a single workflow instance and has closer feature parity to <xref:System.Workflow.Runtime.WorkflowRuntime> so that was used in this test.</span></span>

 <span data-ttu-id="7c38d-408">IIS에서 워크플로를 호스트하는 경우 XAMLX 또는 XOML 파일을 모두 생성하는 대신 <xref:System.Web.Hosting.VirtualPathProvider>를 사용하여 새 <xref:System.ServiceModel.WorkflowServiceHost>를 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-408">When hosting workflows in IIS it is possible to use a <xref:System.Web.Hosting.VirtualPathProvider> to create a new <xref:System.ServiceModel.WorkflowServiceHost> instead of generating all of the XAMLX or XOML files.</span></span>  <span data-ttu-id="7c38d-409">들어오는 <xref:System.Web.Hosting.VirtualPathProvider> 요청을 처리하고 데이터베이스에서 로드하거나 이 경우 즉시 생성할 수 있는 "가상 파일"로 응답합니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-409">The <xref:System.Web.Hosting.VirtualPathProvider> handles the incoming request and responds with a "virtual file" that can be loaded from a database or, in this case, generated on the fly.</span></span>  <span data-ttu-id="7c38d-410">따라서 실제 파일 1000개를 만들 필요는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-410">It is therefore unnecessary to create 1000 physical files.</span></span>

 <span data-ttu-id="7c38d-411">콘솔 테스트에서 사용된 워크플로 정의는 단일 작업이 포함된 단순한 순차 워크플로였습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-411">The workflow definitions used in the console test were simple sequential workflows with a single activity.</span></span>  <span data-ttu-id="7c38d-412">단일 작업은 WF3 사례의 경우 비어 있는 <xref:System.Workflow.Activities.CodeActivity>이고 WF4 사례의 경우 `Comment` 작업이었습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-412">The single activity was an empty <xref:System.Workflow.Activities.CodeActivity> for the WF3 case and a `Comment` activity for the WF4 case.</span></span>  <span data-ttu-id="7c38d-413">IIS 호스팅 사례에서는 메시지 수신에서 시작되고 회신 전송에서 끝나는 워크플로를 사용했습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-413">The IIS-hosted case used workflows that start on receiving a message and end on sending a reply:</span></span>

<span data-ttu-id="7c38d-414">다음 이미지는 수신 활동이 있는 WF3 워크플로우와 요청/응답 패턴이 있는 WF4 워크플로를 보여 주며, 다음 이미지는 다음과 같은 작업을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-414">The following image shows a WF3 workflow with ReceiveActivity and a WF4 workflow with request/response pattern:</span></span>

 ![WF3 및 WF4의 워크플로 서비스](./media/performance/workflow-receive-activity.gif)

 <span data-ttu-id="7c38d-416">다음 표에서는 단일 워크플로 정의와 1001 정의 사이의 작업 집합의 델타를 보여 주며 다음과 같은 작업을 보여 주며 다음과 같은 작업을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-416">The following table shows the delta in working set between a single workflow definition and 1001 definitions:</span></span>

|<span data-ttu-id="7c38d-417">호스팅 옵션</span><span class="sxs-lookup"><span data-stu-id="7c38d-417">Hosting Options</span></span>|<span data-ttu-id="7c38d-418">WF3 작업 집합 델타</span><span class="sxs-lookup"><span data-stu-id="7c38d-418">WF3 Working Set Delta</span></span>|<span data-ttu-id="7c38d-419">WF4 작업 집합 델타</span><span class="sxs-lookup"><span data-stu-id="7c38d-419">WF4 Working Set Delta</span></span>|
|---------------------|---------------------------|---------------------------|
|<span data-ttu-id="7c38d-420">콘솔 애플리케이션 호스트 워크플로</span><span class="sxs-lookup"><span data-stu-id="7c38d-420">Console Application Hosted Workflows</span></span>|<span data-ttu-id="7c38d-421">18 MB</span><span class="sxs-lookup"><span data-stu-id="7c38d-421">18 MB</span></span>|<span data-ttu-id="7c38d-422">9 MB</span><span class="sxs-lookup"><span data-stu-id="7c38d-422">9 MB</span></span>|
|<span data-ttu-id="7c38d-423">IIS 호스트 워크플로 서비스</span><span class="sxs-lookup"><span data-stu-id="7c38d-423">IIS Hosted Workflow Services</span></span>|<span data-ttu-id="7c38d-424">446 MB</span><span class="sxs-lookup"><span data-stu-id="7c38d-424">446 MB</span></span>|<span data-ttu-id="7c38d-425">364 MB</span><span class="sxs-lookup"><span data-stu-id="7c38d-425">364 MB</span></span>|

 <span data-ttu-id="7c38d-426">IIS에서 워크플로 정의를 호스팅하면 <xref:System.ServiceModel.WorkflowServiceHost>자세한 WCF 서비스 아티팩트 및 호스트와 연결된 메시지 처리 논리로 인해 훨씬 더 많은 메모리가 소비됩니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-426">Hosting workflow definitions in IIS consumes much more memory due to the <xref:System.ServiceModel.WorkflowServiceHost>, detailed WCF service artifacts, and the message processing logic associated with the host.</span></span>

 <span data-ttu-id="7c38d-427">WF3의 콘솔 호스팅에서는 워크플로가 XOML 대신 코드로 구현되었습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-427">For console hosting in WF3 the workflows were implemented in code instead of XOML.</span></span>  <span data-ttu-id="7c38d-428">WF4에서는 XAML을 사용하는 것이 기본값입니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-428">In WF4 the default is to use XAML.</span></span>  <span data-ttu-id="7c38d-429">XAML은 어셈블리에 포함된 리소스로 저장되며 런타임 중에 컴파일되어 워크플로 구현을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-429">The XAML is stored as an embedded resource in the assembly and compiled during runtime to provide the implementation of the workflow.</span></span>  <span data-ttu-id="7c38d-430">이 프로세스와 연결된 약간의 오버헤드가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-430">There is some overhead associated with this process.</span></span>  <span data-ttu-id="7c38d-431">WF3과 WF4의 공정한 비교를 위해 XAML 대신 코딩된 워크플로가 사용되었습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-431">In order to make a fair comparison between WF3 and WF4, coded workflows were used instead of XAML.</span></span>  <span data-ttu-id="7c38d-432">다음은 WF4 워크플로 중 하나의 예제입니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-432">An example of one of the WF4 workflows is shown below:</span></span>

```csharp
public class Workflow1 : Activity
{
    protected override Func<Activity> Implementation
    {
        get
        {
            return new Func<Activity>(() =>
            {
                return new Sequence
                {
                    Activities = {
                        new Comment()
                    }
                };
            });
        }
        set
        {
            base.Implementation = value;
        }
    }
}
```

 <span data-ttu-id="7c38d-433">메모리 사용에 영향을 줄 수 있는 다른 여러 요인이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-433">There are many other factors that can affect memory consumption.</span></span> <span data-ttu-id="7c38d-434">관리되는 모든 프로그램에 대한 동일한 조언이 여전히 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-434">The same advice for all managed programs still applies.</span></span>  <span data-ttu-id="7c38d-435">IIS 호스팅 환경에서는 워크플로 정의에 대해 생성된 <xref:System.ServiceModel.WorkflowServiceHost> 개체가 애플리케이션 풀이 재생될 때까지 메모리에 남아 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-435">In IIS-hosted environments, the <xref:System.ServiceModel.WorkflowServiceHost> object created for a workflow definition stays in memory until the application pool is recycled.</span></span>  <span data-ttu-id="7c38d-436">확장을 작성할 때 이 점을 염두에 두어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-436">This should be kept in mind when writing extensions.</span></span>  <span data-ttu-id="7c38d-437">또한 "전역" 변수(전체 워크플로로 범위가 조정된 변수)를 피하고 가능한 한 변수의 범위를 제한하는 것이 가장 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-437">Also, it is best to avoid "global" variables (variables scoped to the whole workflow) and limit the scope of variables wherever possible.</span></span>

## <a name="workflow-runtime-services"></a><span data-ttu-id="7c38d-438">워크플로 런타임 서비스</span><span class="sxs-lookup"><span data-stu-id="7c38d-438">Workflow Runtime Services</span></span>

### <a name="persistence"></a><span data-ttu-id="7c38d-439">지속성</span><span class="sxs-lookup"><span data-stu-id="7c38d-439">Persistence</span></span>
 <span data-ttu-id="7c38d-440">WF3과 WF4에는 모두 SQL 지속성 공급자가 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-440">WF3 and WF4 both ship with a SQL persistence provider.</span></span>  <span data-ttu-id="7c38d-441">WF3 SQL 지속성 공급자는 워크플로 인스턴스를 serialize(직렬화)하고 blob에 저장하는 간단한 구현입니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-441">The WF3 SQL persistence provider is a simple implementation that serializes the workflow instance and stores it in a blob.</span></span>  <span data-ttu-id="7c38d-442">이런 이유로 이 공급자의 성능은 워크플로 인스턴스의 크기에 따라 달라집니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-442">For this reason, the performance of this provider depends heavily on the size of the workflow instance.</span></span>  <span data-ttu-id="7c38d-443">이 문서의 앞부분에서 설명했듯이 WF3에서는 인스턴스 크기가 여러 이유로 증가할 수 있었습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-443">In WF3, the instance size could increase for many reasons, as is discussed previously in this paper.</span></span>  <span data-ttu-id="7c38d-444">serialize(직렬화)된 인스턴스를 데이터베이스에 저장할 경우 워크플로 상태가 표시되지 않으므로 기본 SQL 지속성 공급자를 사용하지 않는 고객이 많습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-444">Many customers choose not to use the default SQL persistence provider because storing a serialized instance in a database gives no visibility into the state of the workflow.</span></span>  <span data-ttu-id="7c38d-445">워크플로 ID를 모르고 특정 워크플로를 찾으려면 유지된 각 인스턴스를 deserialize(역직렬화)하고 콘텐츠를 검사해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-445">In order to find a particular workflow without knowing the workflow id, one would have to deserialize each persisted instance and examine the contents.</span></span>  <span data-ttu-id="7c38d-446">이러한 장애를 극복하기 위해 고유한 지속성 공급자를 작성하는 개발자가 많습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-446">Many developers prefer to write their own persistence providers to overcome this obstacle.</span></span>

 <span data-ttu-id="7c38d-447">WF4 SQL 지속성 공급자는 이러한 문제 중 일부를 해결하려고 했습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-447">The WF4 SQL persistence provider has tried to address some of these concerns.</span></span>  <span data-ttu-id="7c38d-448">지속성 테이블에는 활성 책갈피, 수준을 올릴 수 있는 속성 등의 특정 정보가 노출됩니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-448">The persistence tables expose certain information such as the active bookmarks and promotable properties.</span></span>  <span data-ttu-id="7c38d-449">WF4의 새 콘텐츠 기반 상관 관계 기능은 유지된 워크플로 인스턴스의 구성을 일부 변경한 WF3 SQL 지속성 방법에서는 제대로 수행되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-449">The new content-based correlation feature in WF4 would not perform well using the WF3 SQL persistence approach, which has driven some change in the organization of the persisted workflow instance.</span></span>  <span data-ttu-id="7c38d-450">이로 인해 지속성 공급자의 작업이 더 복잡해지며 데이터베이스에 추가 부담을 주게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-450">This makes the job of the persistence provider more complex and puts extra stress on the database.</span></span>

### <a name="environment-setup"></a><span data-ttu-id="7c38d-451">환경 설정</span><span class="sxs-lookup"><span data-stu-id="7c38d-451">Environment Setup</span></span>
![워크플로 성능 테스트를 위한 환경 설정](./media/performance/performance-test-environment.gif)

### <a name="test-setup"></a><span data-ttu-id="7c38d-453">테스트 설치</span><span class="sxs-lookup"><span data-stu-id="7c38d-453">Test Setup</span></span>
 <span data-ttu-id="7c38d-454">향상된 기능 집합과 보다 효율적인 동시성 처리 외에도 WF4의 SQL 지속성 공급자는 WF3의 공급자보다 더 빠릅니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-454">Even with an improved feature set and better concurrency handling, the SQL persistence provider in WF4 is faster than the provider in WF3.</span></span>  <span data-ttu-id="7c38d-455">속도 차이를 보여 주기 위해 WF3과 WF4에서 본질적으로 동일한 작업을 수행하는 워크플로 두 개의 비교 결과가 아래에 나와 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-455">To showcase this, two workflows that perform essentially the same operations in WF3 and WF4 are compared below.</span></span>

 ![왼쪽의 WF3및 오른쪽의 WF4의 지속성 워크플로우](./media/performance/persist-workflow-wf3-wf4.gif)

 <span data-ttu-id="7c38d-457">두 워크플로는 모두 받은 메시지에 의해 생성됩니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-457">The two workflows are both created by a received message.</span></span>  <span data-ttu-id="7c38d-458">초기 회신을 보낸 후 워크플로가 유지됩니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-458">After sending an initial reply, the workflow is persisted.</span></span>  <span data-ttu-id="7c38d-459">WF3 사례에서는 비어 있는 <xref:System.Workflow.ComponentModel.TransactionScopeActivity>를 사용하여 지속성을 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-459">In the WF3 case, an empty <xref:System.Workflow.ComponentModel.TransactionScopeActivity> is used to initiate the persistence.</span></span>  <span data-ttu-id="7c38d-460">WF3에서도 활동을 "닫기 지속"으로 표시하여 동일한 작업을 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-460">The same could be achieved in WF3 by marking an activity as "persist on close."</span></span>  <span data-ttu-id="7c38d-461">연결된 두 번째 메시지가 워크플로를 완료합니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-461">A second, correlated message completes the workflow.</span></span>  <span data-ttu-id="7c38d-462">워크플로는 유지되고 언로드되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-462">The workflows are persisted but not unloaded.</span></span>

### <a name="test-results"></a><span data-ttu-id="7c38d-463">테스트 결과</span><span class="sxs-lookup"><span data-stu-id="7c38d-463">Test Results</span></span>
 ![처리량 지속성을 보여 주면 열 차트](./media/performance/throughput-persistence-graph.gif)

 <span data-ttu-id="7c38d-465">클라이언트와 중간 계층 간의 전송이 HTTP인 경우 WF4의 지속성이 2.6배 향상됩니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-465">When the transport between client and middle tier is HTTP, persistence in WF4 shows an improvement of 2.6 times.</span></span>  <span data-ttu-id="7c38d-466">TCP 전송을 사용할 경우 해당 비율이 3.0배로 증가합니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-466">The TCP transport increases that factor to 3.0 times.</span></span>  <span data-ttu-id="7c38d-467">모든 사례에서 중간 계층의 CPU 사용률은 98% 이상입니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-467">In all cases, CPU utilization on the middle tier is 98% or higher.</span></span>  <span data-ttu-id="7c38d-468">WF4 처리량이 더 많은 이유는 워크플로 런타임이 더 빠르기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-468">The reason that WF4 throughput is greater is due to the faster workflow runtime.</span></span>  <span data-ttu-id="7c38d-469">serialize(직렬화)된 인스턴스 크기는 두 사례에서 모두 작으며 이러한 상황에서 주요 영향 요인이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-469">The size of the serialized instance is low for both cases and is not a major contributing element in this situation.</span></span>

 <span data-ttu-id="7c38d-470">이 테스트의 WF3 및 WF4 워크플로는 모두 작업을 사용하여 지속성이 발생해야 하는 시기를 명시적으로 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-470">Both the WF3 and WF4 workflows in this test use an activity to explicitly indicate when persistence should occur.</span></span>  <span data-ttu-id="7c38d-471">이렇게 하면 워크플로를 언로드하지 않고 유지할 수 있는 이점이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-471">This has the benefit of persisting the workflow without unloading it.</span></span>  <span data-ttu-id="7c38d-472">WF3에서는 <xref:System.ServiceModel.Activities.Description.WorkflowIdleBehavior.TimeToUnload%2A> 기능을 사용하여 유지할 수도 있지만 이 경우 워크플로 인스턴스가 메모리에서 언로드됩니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-472">In WF3, it is also possible to persist using the <xref:System.ServiceModel.Activities.Description.WorkflowIdleBehavior.TimeToUnload%2A> feature, but this unloads the workflow instance from memory.</span></span>  <span data-ttu-id="7c38d-473">WF3을 사용하는 개발자가 특정 지점에서 워크플로를 유지하려는 경우 워크플로 정의를 변경하거나 워크플로 인스턴스를 언로드한 후 다시 로드해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-473">If a developer using WF3 wants to make sure a workflow persists at certain points, they either have to alter the workflow definition or pay the cost for unloading and re-loading the workflow instance.</span></span>  <span data-ttu-id="7c38d-474">WF4의 새로운 기능인 <xref:System.ServiceModel.Activities.Description.WorkflowIdleBehavior.TimeToPersist%2A>를 사용하면 언로드하지 않고 유지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-474">A new feature in WF4 makes it possible to persist without unloading: <xref:System.ServiceModel.Activities.Description.WorkflowIdleBehavior.TimeToPersist%2A>.</span></span>  <span data-ttu-id="7c38d-475">이 기능을 통해 유휴 시 워크플로 인스턴스가 유지되고 <xref:System.ServiceModel.Activities.Description.WorkflowIdleBehavior.TimeToUnload%2A> 임계값에 도달하거나 실행이 다시 시작될 때까지 메모리에 남아 있도록 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-475">This feature allows the workflow instance to be persisted on idle but stay in memory until the <xref:System.ServiceModel.Activities.Description.WorkflowIdleBehavior.TimeToUnload%2A> threshold is met or execution is resumed.</span></span>

 <span data-ttu-id="7c38d-476">WF4 SQL 지속성 공급자는 데이터베이스 계층에서 더 많은 작업을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-476">Note that the WF4 SQL persistence provider performs more work in the database tier.</span></span>  <span data-ttu-id="7c38d-477">SQL 데이터베이스는 병목이 될 수 있으므로 SQL 데이터베이스의 CPU 및 디스크 사용을 모니터링하는 것이 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-477">The SQL database can become a bottleneck so it is important to monitor the CPU and disk usage there.</span></span>  <span data-ttu-id="7c38d-478">워크플로 애플리케이션의 성능을 테스트하는 경우 SQL 데이터베이스의 다음 성능 카운터를 포함해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-478">Be sure to include the following performance counters from the SQL database when performance testing workflow applications:</span></span>

- <span data-ttu-id="7c38d-479">물리적\\디스크 % 디스크 읽기 시간</span><span class="sxs-lookup"><span data-stu-id="7c38d-479">PhysicalDisk\\%Disk Read Time</span></span>

- <span data-ttu-id="7c38d-480">물리적\\디스크 % 디스크 시간</span><span class="sxs-lookup"><span data-stu-id="7c38d-480">PhysicalDisk\\% Disk Time</span></span>

- <span data-ttu-id="7c38d-481">물리적\\디스크 % 디스크 쓰기 시간</span><span class="sxs-lookup"><span data-stu-id="7c38d-481">PhysicalDisk\\% Disk Write Time</span></span>

- <span data-ttu-id="7c38d-482">물리적\\디스크 % 평균 디스크 큐 길이</span><span class="sxs-lookup"><span data-stu-id="7c38d-482">PhysicalDisk\\% Avg. Disk Queue Length</span></span>

- <span data-ttu-id="7c38d-483">물리적 디스크\평균. 디스크 읽기 큐 길이</span><span class="sxs-lookup"><span data-stu-id="7c38d-483">PhysicalDisk\Avg. Disk Read Queue Length</span></span>

- <span data-ttu-id="7c38d-484">물리적 디스크\평균. 디스크 쓰기 큐 길이</span><span class="sxs-lookup"><span data-stu-id="7c38d-484">PhysicalDisk\Avg. Disk Write Queue Length</span></span>

- <span data-ttu-id="7c38d-485">PhysicalDisk\Current Disk Queue Length</span><span class="sxs-lookup"><span data-stu-id="7c38d-485">PhysicalDisk\Current Disk Queue Length</span></span>

- <span data-ttu-id="7c38d-486">프로세서\\정보 % 프로세서 시간</span><span class="sxs-lookup"><span data-stu-id="7c38d-486">Processor Information\\% Processor Time</span></span>

- <span data-ttu-id="7c38d-487">SQLServer:Latches\Average Latch Wait Time (ms)</span><span class="sxs-lookup"><span data-stu-id="7c38d-487">SQLServer:Latches\Average Latch Wait Time (ms)</span></span>

- <span data-ttu-id="7c38d-488">SQLServer:Latches\Latch Waits/sec</span><span class="sxs-lookup"><span data-stu-id="7c38d-488">SQLServer:Latches\Latch Waits/sec</span></span>

### <a name="tracking"></a><span data-ttu-id="7c38d-489">추적</span><span class="sxs-lookup"><span data-stu-id="7c38d-489">Tracking</span></span>
 <span data-ttu-id="7c38d-490">워크플로 추적을 사용하여 워크플로 진행률을 추적할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-490">Workflow tracking can be used to track the progress of a workflow.</span></span>  <span data-ttu-id="7c38d-491">추적 이벤트에 포함되는 정보는 추적 프로필에서 결정됩니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-491">The information that is included in the tracking events is determined by a tracking profile.</span></span>  <span data-ttu-id="7c38d-492">추적 프로필이 복잡할수록 추적 비용이 증가합니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-492">The more complex the tracking profile, the more expensive tracking becomes.</span></span>

 <span data-ttu-id="7c38d-493">WF3에는 SQL 기반 추적 서비스가 포함되어 있었습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-493">WF3 shipped with a SQL-based tracking service.</span></span>  <span data-ttu-id="7c38d-494">이 서비스는 일괄 처리 모드와 비일괄 처리 모드로 작동할 수 있었습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-494">This service could work in batched and non-batched modes.</span></span>  <span data-ttu-id="7c38d-495">비일괄 처리 모드에서는 추적 이벤트가 데이터베이스에 직접 기록됩니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-495">In non-batched mode, tracking events are written directly to the database.</span></span>  <span data-ttu-id="7c38d-496">일괄 처리 모드에서는 추적 이벤트가 동일한 일괄 처리에 워크플로 인스턴스 상태로 수집됩니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-496">In batched mode, tracking events are collected into the same batch as the workflow instance state.</span></span>  <span data-ttu-id="7c38d-497">일괄 처리 모드는 광범위한 워크플로 디자인에서 최고 성능을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-497">The batched mode has the best performance for the widest range of workflow designs.</span></span>  <span data-ttu-id="7c38d-498">그러나 워크플로에서 많은 작업을 유지하지 않고 실행하며 이러한 작업이 추적되는 경우 일괄 처리 시 성능이 저하될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-498">However, batching can have a negative performance impact if the workflow runs many activities without persisting and those activities are tracked.</span></span>  <span data-ttu-id="7c38d-499">이 문제는 대체로 루프에서 발생하며, 이 시나리오를 방지하는 가장 좋은 방법은 지속성 지점이 포함될 큰 루프를 디자인하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-499">This would commonly happen in loops and the best way to avoid this scenario is to design large loops to contain a persistence point.</span></span>  <span data-ttu-id="7c38d-500">지속성 지점을 루프에 포함하는 경우에도 성능이 저하될 수 있으므로 각 루프의 비용을 측정하고 균형을 이루는 것이 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-500">Introducing a persistence point into a loop can negatively affect performance as well so it is important to measure the costs of each and come up with a balance.</span></span>

 <span data-ttu-id="7c38d-501">WF4에는 SQL 추적 서비스가 포함되어 있지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-501">WF4 is not shipped with a SQL tracking service.</span></span>  <span data-ttu-id="7c38d-502">추적 정보를 SQL 데이터베이스에 기록하는 것은 .NET Framework에 내장된 것이 아니라 응용 프로그램 서버에서 더 잘 처리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-502">Recording tracking information to a SQL database can be handled better from an application server rather than built into the .NET Framework.</span></span> <span data-ttu-id="7c38d-503">따라서 이제 AppFabric에서 SQL 추적을 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-503">Therefore SQL tracking is now handled by AppFabric.</span></span>  <span data-ttu-id="7c38d-504">WF4의 기본 제공 추적 공급자는 ETW(Windows용 이벤트 추적)를 기반으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-504">The out-of-the-box tracking provider in WF4 is based on Event Tracing for Windows (ETW).</span></span>

 <span data-ttu-id="7c38d-505">ETW는 Windows에 기본 제공되며 대기 시간이 짧은 커널 수준의 이벤트 시스템입니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-505">ETW is a kernel-level, low-latency event system built into Windows.</span></span>  <span data-ttu-id="7c38d-506">ETW는 실제로 소비자가 있는 경우에만 이벤트 추적 비용을 발생시키는 공급자/소비자 모델을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-506">It uses a provider/consumer model that makes it possible to only incur the penalty for event tracing when there is actually a consumer.</span></span>  <span data-ttu-id="7c38d-507">프로세서, 디스크, 메모리, 네트워크 사용 등의 커널 이벤트뿐 아니라 많은 애플리케이션이 ETW도 활용합니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-507">In addition to kernel events such as processor, disk, memory, and network usage, many applications leverage ETW as well.</span></span>  <span data-ttu-id="7c38d-508">애플리케이션에 맞게 이벤트를 사용자 지정할 수 있다는 점에서 ETW 이벤트는 성능 카운터보다 더 강력합니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-508">ETW events are more powerful than performance counters in that events can be customized to the application.</span></span>  <span data-ttu-id="7c38d-509">이벤트에는 워크플로 ID, 정보 메시지 등의 텍스트가 포함될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-509">An event can contain text such as a workflow ID or an informational message.</span></span>  <span data-ttu-id="7c38d-510">또한 특정 이벤트 하위 집합을 사용할 경우 모든 이벤트를 캡처할 때보다 성능에 미치는 영향이 감소하도록 이벤트가 비트 마스크로 분류됩니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-510">Also, events are categorized with bitmasks so that consuming a certain subset of events will have less performance impact than capturing all events.</span></span>

 <span data-ttu-id="7c38d-511">SQL 대신 ETW를 추적에 사용할 경우 다음과 같은 이점이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-511">Benefits to the approach of using ETW for tracking instead of SQL include:</span></span>

- <span data-ttu-id="7c38d-512">추적 이벤트 컬렉션을 다른 프로세스로 구분할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-512">Collection of tracking events can be separated to another process.</span></span>  <span data-ttu-id="7c38d-513">이렇게 하면 이벤트 기록 방법의 유연성이 증가합니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-513">This gives greater flexibility in how the events are recorded.</span></span>

- <span data-ttu-id="7c38d-514">ETW 추적 이벤트는 WCF ETW 이벤트 또는 SQL Server 또는 커널 공급자와 같은 다른 ETW 공급자와 쉽게 결합됩니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-514">ETW tracking events are easily combined with the WCF ETW events or other ETW providers such as a SQL Server or kernel provider.</span></span>

- <span data-ttu-id="7c38d-515">워크플로 작성자가 WF3 SQL 추적 서비스의 일괄 처리 모드와 같은 특정 추적 구현에서 보다 효율적으로 작동하도록 워크플로를 변경할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-515">Workflow authors do not need to alter a workflow to work better with a particular tracking implementation, such as the WF3 SQL tracking service’s batch mode.</span></span>

- <span data-ttu-id="7c38d-516">관리자가 호스트 프로세스를 재생하지 않고 추적을 설정하거나 해제할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-516">An administrator can turn tracking on or off without recycling the host process.</span></span>

 <span data-ttu-id="7c38d-517">ETW 추적의 성능 이점에는 단점도 수반됩니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-517">The performance benefits to ETW tracking come with a drawback.</span></span>  <span data-ttu-id="7c38d-518">시스템의 리소스 부담이 큰 경우 ETW 이벤트가 손실될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-518">ETW events can be lost if the system is under intense resource pressure.</span></span>  <span data-ttu-id="7c38d-519">이벤트 처리는 정상적인 프로그램 실행을 차단하지 않으므로 모든 ETW 이벤트가 해당 구독자에게 브로드캐스트될 것을 보장할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-519">The processing of events is not meant to block normal program execution and therefore it is not guaranteed that all ETW events will be broadcast to their subscribers.</span></span>  <span data-ttu-id="7c38d-520">이런 이유로 ETW 추적은 상태 모니터링에 유용하지만 감사에는 적합하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-520">This makes ETW tracking great for health monitoring but not suitable for auditing.</span></span>

 <span data-ttu-id="7c38d-521">WF4에는 SQL 추적 공급자가 없지만 AppFabric에는 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-521">While WF4 does not have a SQL tracking provider, AppFabric does.</span></span>  <span data-ttu-id="7c38d-522">AppFabric의 SQL 추적 방법은 이벤트를 일괄 처리하고 빠른 삽입용으로 디자인된 SQL 테이블에 쓰는 Windows 서비스를 사용하여 ETW 이벤트를 구독하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-522">AppFabric’s SQL tracking approach is to subscribe to ETW events with a Windows Service that batches the events and writes them to a SQL table designed for quick inserts.</span></span>  <span data-ttu-id="7c38d-523">별도의 작업이 이 테이블에서 데이터를 드레이닝한 후 AppFabric 대시보드에서 볼 수 있는 보고 테이블로 개정합니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-523">A separate job drains the data from this table and reforms it into reporting tables that can be viewed on the AppFabric dashboard.</span></span>  <span data-ttu-id="7c38d-524">즉, 추적 이벤트의 일괄 처리는 원본 워크플로에 독립적으로 처리되므로 기록되기 전에 지속성 지점을 기다릴 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-524">This means that a batch of tracking events is handled independent of the workflow it came from and therefore does not have to wait for a persistence point before being recorded.</span></span>

 <span data-ttu-id="7c38d-525">logman 또는 xperf와 같은 도구를 사용하여 ETW 이벤트를 기록할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-525">ETW events can be recorded with tools such as logman or xperf.</span></span>  <span data-ttu-id="7c38d-526">xperfview 등의 도구로 압축 ETL 파일을 볼 수 있거나 tracerpt를 사용하여 보다 읽기 쉬운 XML 등의 형식으로 변환할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-526">The compact ETL file can be viewed with a tool like xperfview or converted to a more readable format, such as XML, with tracerpt.</span></span>  <span data-ttu-id="7c38d-527">WF3에서 SQL 데이터베이스 없이 추적 이벤트를 가져오는 유일한 옵션은 사용자 지정 추적 서비스를 만드는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-527">In WF3, the only option for getting tracking events without a SQL database is to create a custom tracking service.</span></span> <span data-ttu-id="7c38d-528">ETW에 대한 자세한 내용은 Windows 및 이벤트 추적 [- Windows 응용 프로그램에](/windows/desktop/etw/event-tracing-portal)대한 [WCF 서비스 및 이벤트 추적을](../wcf/samples/wcf-services-and-event-tracing-for-windows.md) 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="7c38d-528">For more information about ETW, see [WCF Services and Event Tracing for Windows](../wcf/samples/wcf-services-and-event-tracing-for-windows.md) and [Event Tracing - Windows applications](/windows/desktop/etw/event-tracing-portal).</span></span>

 <span data-ttu-id="7c38d-529">워크플로 추적을 사용하도록 설정하면 다양한 수준으로 성능에 영향을 주게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-529">Enabling workflow tracking will impact performance in varying degrees.</span></span>  <span data-ttu-id="7c38d-530">아래 벤치마크에서는 logman 도구를 통해 ETW 추적 이벤트를 사용하고 ETL 파일에 기록합니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-530">The benchmark below uses the logman tool to consume the ETW tracking events and record them to an ETL file.</span></span>  <span data-ttu-id="7c38d-531">AppFabric에서의 SQL 추적 비용은 이 문서의 범위를 벗어납니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-531">The cost of the SQL tracking in AppFabric is not in the scope of this article.</span></span>  <span data-ttu-id="7c38d-532">이 벤치마크에는 역시 AppFabric에서 사용된 기본 추적 프로필이 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-532">The basic tracking profile, also used in AppFabric, is shown in this benchmark.</span></span>  <span data-ttu-id="7c38d-533">상태 모니터링 이벤트만 추적하는 비용도 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-533">Also included is the cost of tracking only health monitoring events.</span></span>  <span data-ttu-id="7c38d-534">이러한 이벤트는 문제를 해결하고 시스템의 평균 처리량을 확인하는 데 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-534">These events are useful for troubleshooting problems and determining the average throughput of the system.</span></span>

### <a name="environment-setup"></a><span data-ttu-id="7c38d-535">환경 설정</span><span class="sxs-lookup"><span data-stu-id="7c38d-535">Environment Setup</span></span>
 ![워크플로 성능 테스트를 위한 환경 설정](./media/performance/performance-test-environment.gif)

### <a name="test-results"></a><span data-ttu-id="7c38d-537">테스트 결과</span><span class="sxs-lookup"><span data-stu-id="7c38d-537">Test Results</span></span>

 ![워크플로 추적 비용을 보여주는 열차트](./media/performance/workflow-tracking-costs.gif)

 <span data-ttu-id="7c38d-539">상태 모니터링은 처리량에 대략 3% 영향을 줍니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-539">Health monitoring has roughly a 3% impact on throughput.</span></span>  <span data-ttu-id="7c38d-540">기본 프로필 비용은 약 8%입니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-540">The basic profile’s cost is around 8%.</span></span>

## <a name="interop"></a><span data-ttu-id="7c38d-541">Interop</span><span class="sxs-lookup"><span data-stu-id="7c38d-541">Interop</span></span>
 <span data-ttu-id="7c38d-542">WF4는 [!INCLUDE[wf1](../../../includes/wf1-md.md)]에서 거의 완전히 다시 작성되었으므로 WF3 워크플로와 작업은 WF4와 직접 호환되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-542">WF4 is almost a complete rewrite of [!INCLUDE[wf1](../../../includes/wf1-md.md)] and therefore WF3 workflows and activities are not directly compatible with WF4.</span></span>  <span data-ttu-id="7c38d-543">Windows 워크플로 파운데이션을 일찍 채택한 많은 고객은 WF3에 대한 사내 또는 타사 워크플로 정의 및 사용자 지정 활동을 갖습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-543">Many customers that adopted Windows Workflow Foundation early will have in-house or third-party workflow definitions and custom activities for WF3.</span></span>  <span data-ttu-id="7c38d-544">WF4로 간단하게 전환하는 방법 중 하나는 WF4 워크플로 내에서 WF3 작업을 실행할 수 있는 Interop 작업을 사용하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-544">One way to ease the transition to WF4 is to use the Interop activity, which can execute WF3 activities from within a WF4 workflow.</span></span>  <span data-ttu-id="7c38d-545">필요한 경우 <xref:System.Activities.Statements.Interop> 작업만 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-545">It is recommended that the <xref:System.Activities.Statements.Interop> activity only be used when necessary.</span></span> <span data-ttu-id="7c38d-546">WF4로 마이그레이션에 대한 자세한 내용은 [WF4 마이그레이션 지침을](migration-guidance.md)확인하십시오.</span><span class="sxs-lookup"><span data-stu-id="7c38d-546">For more information about migrating to WF4 check out the [WF4 Migration Guidance](migration-guidance.md).</span></span>

### <a name="environment-setup"></a><span data-ttu-id="7c38d-547">환경 설정</span><span class="sxs-lookup"><span data-stu-id="7c38d-547">Environment Setup</span></span>
 ![워크플로 성능 테스트를 위한 환경 설정](./media/performance/performance-test-environment.gif)

### <a name="test-results"></a><span data-ttu-id="7c38d-549">테스트 결과</span><span class="sxs-lookup"><span data-stu-id="7c38d-549">Test Results</span></span>

<span data-ttu-id="7c38d-550">다음 표에서는 다양한 구성의 시퀀스에 5개의 활동이 포함된 워크플로를 실행한 결과를 보여 주십니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-550">The following table shows the results of running a workflow containing five activities in a sequence in various configurations.</span></span>

|<span data-ttu-id="7c38d-551">테스트</span><span class="sxs-lookup"><span data-stu-id="7c38d-551">Test</span></span>|<span data-ttu-id="7c38d-552">처리량(워크플로/초)</span><span class="sxs-lookup"><span data-stu-id="7c38d-552">Throughput (workflows/sec)</span></span>|
|----------|-----------------------------------|
|<span data-ttu-id="7c38d-553">WF3 런타임의 WF3 시퀀스</span><span class="sxs-lookup"><span data-stu-id="7c38d-553">WF3 Sequence in WF3 runtime</span></span>|<span data-ttu-id="7c38d-554">1,576</span><span class="sxs-lookup"><span data-stu-id="7c38d-554">1,576</span></span>|
|<span data-ttu-id="7c38d-555">Interop을 사용하는 WF4 런타임의 WF3 시퀀스</span><span class="sxs-lookup"><span data-stu-id="7c38d-555">WF3 Sequence in WF4 runtime using Interop</span></span>|<span data-ttu-id="7c38d-556">2,745</span><span class="sxs-lookup"><span data-stu-id="7c38d-556">2,745</span></span>|
|<span data-ttu-id="7c38d-557">WF4 시퀀스</span><span class="sxs-lookup"><span data-stu-id="7c38d-557">WF4 Sequence</span></span>|<span data-ttu-id="7c38d-558">153,582</span><span class="sxs-lookup"><span data-stu-id="7c38d-558">153,582</span></span>|

 <span data-ttu-id="7c38d-559">직선 WF3을 통해 Interop을 사용할 경우 성능이 훨씬 향상됩니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-559">There is a notable performance increase to using Interop over straight WF3.</span></span>  <span data-ttu-id="7c38d-560">그러나 WF4 작업과 비교할 경우 이러한 증가는 무시될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-560">However, when compared against WF4 activities, the increase is negligible.</span></span>

## <a name="summary"></a><span data-ttu-id="7c38d-561">요약</span><span class="sxs-lookup"><span data-stu-id="7c38d-561">Summary</span></span>
 <span data-ttu-id="7c38d-562">WF4의 성능에 대한 막대한 투자는 중요한 여러 영역에서 충분한 결실을 맺었습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-562">Heavy investments in performance for WF4 have paid off in many crucial areas.</span></span>  <span data-ttu-id="7c38d-563">경우에 따라 개별 워크플로 구성 요소의 성능은 보다 간결한 [!INCLUDE[wf1](../../../includes/wf1-md.md)] 런타임으로 인해 WF3보다 WF4에서 수백 배 더 빠릅니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-563">Individual workflow component performance is in some cases hundreds of times faster in WF4 compared to WF3 due to a leaner [!INCLUDE[wf1](../../../includes/wf1-md.md)] runtime.</span></span>  <span data-ttu-id="7c38d-564">대기 시간 수치도 훨씬 낫습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-564">Latency numbers are significantly better as well.</span></span>  <span data-ttu-id="7c38d-565">즉, WCF 오케스트레이션 서비스를 직접 코딩하는 것과 달리 사용에 [!INCLUDE[wf1](../../../includes/wf1-md.md)] 대한 성능 [!INCLUDE[wf1](../../../includes/wf1-md.md)]페널티는 을 사용하는 추가 이점을 고려할 때 매우 작습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-565">This means the performance penalty for using [!INCLUDE[wf1](../../../includes/wf1-md.md)] as opposed to hand-coding WCF orchestration services is very small considering the added benefits of using [!INCLUDE[wf1](../../../includes/wf1-md.md)].</span></span>  <span data-ttu-id="7c38d-566">지속성 성능은 2.5-3.0의 비율로 증가했습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-566">Persistence performance has increased by a factor of 2.5 - 3.0.</span></span>  <span data-ttu-id="7c38d-567">이제 워크플로 추적을 통한 상태 모니터링의 오버헤드가 매우 적습니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-567">Health monitoring by means of workflow tracking now has very little overhead.</span></span>  <span data-ttu-id="7c38d-568">WF3에서 WF4로의 이동을 고려하는 사용자를 위해 포괄적인 마이그레이션 가이드 집합이 제공됩니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-568">A comprehensive set of migration guides are available for those that are considering moving from WF3 to WF4.</span></span>  <span data-ttu-id="7c38d-569">이러한 모든 특성 때문에 WF4는 복잡한 애플리케이션을 작성할 때 유용한 옵션이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="7c38d-569">All of this should make WF4 an attractive option for writing complex applications.</span></span>

---
title: 트랜잭션된 큐
ms.date: 03/30/2017
ms.assetid: b1b011dd-5e0b-482c-9bb0-9d8727038f14
ms.openlocfilehash: db6a9686334eefb02b9360827a23ca8363127eb5
ms.sourcegitcommit: 2eceb05f1a5bb261291a1f6a91c5153727ac1c19
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 09/04/2018
ms.locfileid: "43535506"
---
# <a name="transacted-queues"></a><span data-ttu-id="2dcdd-102">트랜잭션된 큐</span><span class="sxs-lookup"><span data-stu-id="2dcdd-102">Transacted Queues</span></span>
<span data-ttu-id="2dcdd-103">이 샘플에는 큐와 트랜잭션을에서 Windows WF (Workflow Foundation) 확장 가능 하며 안정적인 서비스를 만드는 통합 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="2dcdd-103">This sample shows how to integrate queues and transactions in Windows Workflow Foundation (WF) to create reliable and scalable services.</span></span> <span data-ttu-id="2dcdd-104">A <!--zz <xref:System.Activities.TransactionScope>--> `System.Activities.TransactionScope` 클라이언트 워크플로에서 사용 하 여 트랜잭션 중인 큐에 메시지를 보내는 데 사용 된 <xref:System.ServiceModel.NetMsmqBinding>합니다.</span><span class="sxs-lookup"><span data-stu-id="2dcdd-104">A <!--zz <xref:System.Activities.TransactionScope>--> `System.Activities.TransactionScope` is used in the client workflow to send message to a queue under a transaction using the <xref:System.ServiceModel.NetMsmqBinding>.</span></span> <span data-ttu-id="2dcdd-105">서버에서는 큐로부터 메시지를 받고 동일한 트랜잭션을 진행 중인 워크플로의 상태를 업데이트하기 위해 <xref:System.ServiceModel.Activities.TransactedReceiveScope>를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="2dcdd-105">A <xref:System.ServiceModel.Activities.TransactedReceiveScope> is used on the server to receive messages from the queue and update the state of the workflow under the same transaction.</span></span>  
  
## <a name="demonstrates"></a><span data-ttu-id="2dcdd-106">세부 항목</span><span class="sxs-lookup"><span data-stu-id="2dcdd-106">Demonstrates</span></span>  
 <span data-ttu-id="2dcdd-107"><xref:System.Activities.Statements.TransactionScope>, <xref:System.ServiceModel.Activities.TransactedReceiveScope>, <xref:System.ServiceModel.NetMsmqBinding>, <xref:System.ServiceModel.Activities.Receive> 및 내용 기반 상관 관계</span><span class="sxs-lookup"><span data-stu-id="2dcdd-107"><xref:System.Activities.Statements.TransactionScope>, <xref:System.ServiceModel.Activities.TransactedReceiveScope>, <xref:System.ServiceModel.NetMsmqBinding>, <xref:System.ServiceModel.Activities.Receive>, and content-based correlation.</span></span>  
  
## <a name="discussion"></a><span data-ttu-id="2dcdd-108">토론</span><span class="sxs-lookup"><span data-stu-id="2dcdd-108">Discussion</span></span>  
 <span data-ttu-id="2dcdd-109">이 샘플에서 다룰 기능을 보여 주기 위해 `RewardsPoints` 워크플로 서비스를 만듭니다. 이 워크플로 서비스는 특정 계정이 획득하고 사용한 점수를 추적하는 역할을 합니다.</span><span class="sxs-lookup"><span data-stu-id="2dcdd-109">To demonstrate the features covered in this sample, a `RewardsPoints` workflow service is created, which keeps track of the points earned and used for a given account.</span></span> <span data-ttu-id="2dcdd-110">클라이언트에서는 <xref:System.Activities.WorkflowInvoker>를 사용하여 큐에 다양한 요청을 게시하는 과정을 시뮬레이션합니다.</span><span class="sxs-lookup"><span data-stu-id="2dcdd-110">The client uses <xref:System.Activities.WorkflowInvoker> to simulate posting various requests to the queue.</span></span> <span data-ttu-id="2dcdd-111">트랜잭션 중인 큐에 메시지를 게시하기 위해 <xref:System.ServiceModel.Activities.Send>의 <xref:System.Activities.Statements.TransactionScope.Body%2A> 내에 <xref:System.Activities.Statements.TransactionScope> 활동을 배치할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2dcdd-111">To post a message to the queue under a transaction, the <xref:System.ServiceModel.Activities.Send> activity can be placed inside the <xref:System.Activities.Statements.TransactionScope.Body%2A> of a <xref:System.Activities.Statements.TransactionScope>.</span></span> <span data-ttu-id="2dcdd-112">이 샘플에서는 큐에 대기 중인 메시지를 통해 클라이언트 및 서버 응용 프로그램이 어떻게 분리되는지 보여 주기 위해 클라이언트를 먼저 실행한 다음 서버를 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="2dcdd-112">In this sample, the client runs first, followed by the server, to demonstrate how queued messages can decouple the client and server applications.</span></span>  
  
 <span data-ttu-id="2dcdd-113">클라이언트가 완료되고 나면 서비스가 구성 및 호스트됩니다.</span><span class="sxs-lookup"><span data-stu-id="2dcdd-113">Once the client completes, the service is configured and hosted.</span></span> <span data-ttu-id="2dcdd-114">서비스가 열리는 즉시 큐에 이미 대기 중이던 메시지의 처리가 시작됩니다.</span><span class="sxs-lookup"><span data-stu-id="2dcdd-114">As soon as it opens, it starts processing the messages that have already been placed in the queue.</span></span> <span data-ttu-id="2dcdd-115">각 메시지는 동일한 서버 트랜잭션 내에서 수신 및 처리됩니다.</span><span class="sxs-lookup"><span data-stu-id="2dcdd-115">Each message is received and processed under the same server transaction.</span></span> <span data-ttu-id="2dcdd-116">이 샘플에서 수신되는 첫 메시지는 인스턴스를 만들고 요청 메시지의 일부로 전달된 계정 이름을 기준으로 내용 상관 관계를 초기화하는 `CreateAccount` 요청입니다.</span><span class="sxs-lookup"><span data-stu-id="2dcdd-116">In this sample, the first message received is a `CreateAccount` request that creates the instance and initializes the content correlation based on the account name passed as part of the request message.</span></span> <span data-ttu-id="2dcdd-117">실제 상황에서 충분히 예상할 수 있는 종류의 서비스를 모델링하기 위해 <xref:System.ServiceModel.Activities.TransactedReceiveScope> 및 `AddPoints` 메시지를 처리하는 두 가지 `UsePoints` 활동을 `while` 루프 내의 병렬 분기에 배치하고 해당 메시지를 순서에 관계 없이 반복하여 처리할 수 있도록 했습니다.</span><span class="sxs-lookup"><span data-stu-id="2dcdd-117">To model the kind of service you might expect in the real world, the following two <xref:System.ServiceModel.Activities.TransactedReceiveScope> activities that process the `AddPoints` and `UsePoints` messages are placed in parallel branches within a `while` loop so that they can process these messages repeatedly in any order.</span></span>  
  
 <span data-ttu-id="2dcdd-118"><xref:System.Activities.Statements.TransactionScope> 및 <xref:System.ServiceModel.Activities.TransactedReceiveScope>의 각 범위 끝에는 암시적 지속성 지점이 있습니다. 따라서 큐와 함께 [!INCLUDE[wf1](../../../../includes/wf1-md.md)]에서 이러한 활동을 사용하면 해당 메시지를 잃지 않으면서 특정 지속성 상태로부터 다음 상태로 워크플로를 안정적으로 이동할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2dcdd-118"><xref:System.Activities.Statements.TransactionScope> and <xref:System.ServiceModel.Activities.TransactedReceiveScope> each have an implicit persistence point at the end of their scopes, so using these activities in [!INCLUDE[wf1](../../../../includes/wf1-md.md)] combined with queues is a reliable way to move your workflow from one consistent state to the next, while ensuring that messages are never lost.</span></span>  
  
#### <a name="to-set-up-build-and-run-the-sample"></a><span data-ttu-id="2dcdd-119">샘플을 설치, 빌드 및 실행하려면</span><span class="sxs-lookup"><span data-stu-id="2dcdd-119">To set up, build, and run the sample</span></span>  
  
1.  <span data-ttu-id="2dcdd-120">MSMQ를 설치하고 구성합니다.</span><span class="sxs-lookup"><span data-stu-id="2dcdd-120">Install and configure MSMQ.</span></span> <span data-ttu-id="2dcdd-121">참조 [메시지 큐 설치](https://go.microsoft.com/fwlink/?LinkId=178526) 세부 정보에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="2dcdd-121">See [Installing Message Queuing](https://go.microsoft.com/fwlink/?LinkId=178526) for details.</span></span>  
  
2.  <span data-ttu-id="2dcdd-122">명령줄에서 다음 명령을 실행하여 MSDTC가 실행되고 있는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="2dcdd-122">Ensure that MSDTC is running by executing the following command on a command line.</span></span> `net start msdtc`  
  
3.  <span data-ttu-id="2dcdd-123">프로젝트를 컴파일하고 실행 파일을 열거나 [!INCLUDE[vs2010](../../../../includes/vs2010-md.md)]에서 프로젝트를 열고 디버그 메뉴에서 시작 옵션을 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="2dcdd-123">Compile the project and open the executable, or open the project in [!INCLUDE[vs2010](../../../../includes/vs2010-md.md)] and select a start option from the debug menu.</span></span> <span data-ttu-id="2dcdd-124">제일 먼저 큐가 만들어진 다음 클라이언트가 실행되고 큐에 메시지가 게시됩니다. 마지막으로 서비스가 시작되고 메시지가 처리됩니다.</span><span class="sxs-lookup"><span data-stu-id="2dcdd-124">First, the queue is created, then the client runs and posts messages to the queue, and finally the service starts and the messages are processed.</span></span> <span data-ttu-id="2dcdd-125">프로그램을 끝내려면 Enter 키를 누릅니다.</span><span class="sxs-lookup"><span data-stu-id="2dcdd-125">To exit the program, press ENTER.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="2dcdd-126">컴퓨터에 이 샘플이 이미 설치되어 있을 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2dcdd-126">The samples may already be installed on your machine.</span></span> <span data-ttu-id="2dcdd-127">계속하기 전에 다음(기본) 디렉터리를 확인하세요.</span><span class="sxs-lookup"><span data-stu-id="2dcdd-127">Check for the following (default) directory before continuing.</span></span>  
>   
>  `<InstallDrive>:\WF_WCF_Samples`  
>   
>  <span data-ttu-id="2dcdd-128">이 디렉터리가 없으면로 이동 [Windows Communication Foundation (WCF) 및.NET Framework 4 용 Windows WF (Workflow Foundation) 샘플](https://go.microsoft.com/fwlink/?LinkId=150780) 모든 Windows Communication Foundation (WCF)를 다운로드 하 고 [!INCLUDE[wf1](../../../../includes/wf1-md.md)] 샘플.</span><span class="sxs-lookup"><span data-stu-id="2dcdd-128">If this directory does not exist, go to [Windows Communication Foundation (WCF) and Windows Workflow Foundation (WF) Samples for .NET Framework 4](https://go.microsoft.com/fwlink/?LinkId=150780) to download all Windows Communication Foundation (WCF) and [!INCLUDE[wf1](../../../../includes/wf1-md.md)] samples.</span></span> <span data-ttu-id="2dcdd-129">이 샘플은 다음 디렉터리에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2dcdd-129">This sample is located in the following directory.</span></span>  
>   
>  `<InstallDrive>:\WF_WCF_Samples\WF\Scenario\Transactions\TransactedQueues`

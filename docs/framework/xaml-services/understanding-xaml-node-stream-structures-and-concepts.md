---
title: "XAML 노드 스트림 구조 및 개념 이해"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-wpf
ms.tgt_pltfrm: 
ms.topic: article
helpviewer_keywords:
- XAML node streams [XAML Services]
- nodes [XAML Services], XAML node stream
- XAML [XAML Services], XAML node streams
ms.assetid: 7c11abec-1075-474c-9d9b-778e5dab21c3
caps.latest.revision: "14"
author: wadepickett
ms.author: wpickett
manager: wpickett
ms.openlocfilehash: ae5cfd6cdb557aff4910f38ea0fb7f4b54afbbb0
ms.sourcegitcommit: 4f3fef493080a43e70e951223894768d36ce430a
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 11/21/2017
---
# <a name="understanding-xaml-node-stream-structures-and-concepts"></a><span data-ttu-id="79b66-102">XAML 노드 스트림 구조 및 개념 이해</span><span class="sxs-lookup"><span data-stu-id="79b66-102">Understanding XAML Node Stream Structures and Concepts</span></span>
<span data-ttu-id="79b66-103">.NET Framework XAML 서비스에 구현된 XAML 판독기와 XAML 작성기는 XAML 노드 스트림의 디자인 개념을 기반으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-103">XAML readers and XAML writers as implemented in .NET Framework XAML Services are based on the design concept of a XAML node stream.</span></span> <span data-ttu-id="79b66-104">XAML 노드 스트림은 XAML 노드 집합의 개념화입니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-104">The XAML node stream is a conceptualization of a set of XAML nodes.</span></span> <span data-ttu-id="79b66-105">이 개념화에서 XAML 프로세서는 한 번에 하나씩 XAML의 노드 관계 구조를 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-105">In this conceptualization, a XAML processor walks through the structure of the node relationships in the XAML one at a time.</span></span> <span data-ttu-id="79b66-106">언제든지 하나의 현재 레코드 또는 현재 위치만 열린 XAML 노드 스트림에 있으며 API는 대부분 해당 위치에서 사용할 수 있는 정보만 보고합니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-106">At any time, only one current record or current position exists in an open XAML node stream, and many aspects of the API report only the information available from that position.</span></span> <span data-ttu-id="79b66-107">XAML 노드 스트림의 현재 노드는 개체, 멤버 또는 값으로 설명될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-107">The current node in a XAML node stream can be described as being an object, a member, or a value.</span></span> <span data-ttu-id="79b66-108">XAML을 XAML 노드 스트림으로 처리하여 XAML 판독기는 XAML 작성기와 통신하고 XAML을 포함하는 경로 로드 또는 경로 저장 작업 중에 프로그램이 XAML 노드 스트림을 보거나, 상호 작용하거나, 콘텐츠를 변경할 수 있게 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-108">By treating XAML as a XAML node stream, XAML readers can communicate with XAML writers and enable a program to view, interact with, or alter the contents of a XAML node stream during either a load path or a save path operation that involves XAML.</span></span> <span data-ttu-id="79b66-109">XAML 판독기/작성기 API 디자인 및 XAML 노드 스트림 개념은 이전의 관련된 판독기/작성기 디자인 및 개념과 비슷합니다(예: [!INCLUDE[TLA#tla_xmldom](../../../includes/tlasharptla-xmldom-md.md)] , <xref:System.Xml.XmlReader> 및 <xref:System.Xml.XmlWriter> 클래스).</span><span class="sxs-lookup"><span data-stu-id="79b66-109">XAML reader and writer API design and the XAML node stream concept are similar to previous related reader and writer designs and concepts, such as the [!INCLUDE[TLA#tla_xmldom](../../../includes/tlasharptla-xmldom-md.md)] and the <xref:System.Xml.XmlReader> and <xref:System.Xml.XmlWriter> classes.</span></span> <span data-ttu-id="79b66-110">이 항목에서는 XAML 노드 스트림 개념과 XAML 노드 수준에서 XAML 표현과 상호 작용하는 루틴을 작성하는 방법을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-110">This topic discusses XAML node stream concepts and describes how you can write routines that interact with XAML representations at the XAML node level.</span></span>  
  
<a name="loading_into_a_xaml_reader"></a>   
## <a name="loading-xaml-into-a-xaml-reader"></a><span data-ttu-id="79b66-111">XAML 판독기에 XAML 로드</span><span class="sxs-lookup"><span data-stu-id="79b66-111">Loading XAML into a XAML Reader</span></span>  
 <span data-ttu-id="79b66-112">기본 <xref:System.Xaml.XamlReader> 클래스는 XAML 판독기에 초기 XAML을 로드하기 위한 특정 기술을 선언하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-112">The base <xref:System.Xaml.XamlReader> class does not declare a particular technique for loading the initial XAML into a XAML reader.</span></span> <span data-ttu-id="79b66-113">대신, 파생 클래스가 XAML에 대한 입력 소스의 일반적인 특징 및 제약 조건을 포함하여 로드 기술을 선언하고 구현합니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-113">Instead, a derived class declares and implements the loading technique, including the general characteristics and constraints of its input source for XAML.</span></span> <span data-ttu-id="79b66-114">예를 들어 <xref:System.Xaml.XamlObjectReader> 는 루트 또는 기준을 나타내는 단일 개체의 입력 소스부터 시작하여 개체 그래프를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-114">For example, a <xref:System.Xaml.XamlObjectReader> reads an object graph, starting from the input source of a single object that represents the root or base.</span></span> <span data-ttu-id="79b66-115">그런 다음 <xref:System.Xaml.XamlObjectReader> 는 개체 그래프에서 XAML 노드 스트림을 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-115">The <xref:System.Xaml.XamlObjectReader> then produces a XAML node stream from the object graph.</span></span>  
  
 <span data-ttu-id="79b66-116">.NET Framework XAML 서비스에서 정의된 가장 두드러진 <xref:System.Xaml.XamlReader> 하위 클래스는 <xref:System.Xaml.XamlXmlReader>입니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-116">The most prominent .NET Framework XAML Services–defined <xref:System.Xaml.XamlReader> subclass is <xref:System.Xaml.XamlXmlReader>.</span></span> <span data-ttu-id="79b66-117"><xref:System.Xaml.XamlXmlReader> 는 스트림 또는 파일 경로를 통해 직접적으로 또는 관련된 판독기 클래스(예: <xref:System.IO.TextReader>)를 통해 간접적으로 텍스트 파일을 로드하여 초기 XAML을 로드합니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-117"><xref:System.Xaml.XamlXmlReader> loads the initial XAML, either by loading a text file directly through a stream or file path, or indirectly through a related reader class such as <xref:System.IO.TextReader>.</span></span> <span data-ttu-id="79b66-118"><xref:System.Xaml.XamlReader> 를 로드 후 전체 XAML 입력 소스를 포함하는 것으로 생각할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-118">The <xref:System.Xaml.XamlReader> can be thought of as containing the entirety of the XAML input source after it has loaded.</span></span> <span data-ttu-id="79b66-119">그러나 <xref:System.Xaml.XamlReader> 기본 API는 판독기가 XAML의 단일 노드와 상호 작용하도록 설계되었습니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-119">However, the <xref:System.Xaml.XamlReader> base API is designed so that the reader is interacting with a single node of the XAML.</span></span> <span data-ttu-id="79b66-120">처음 로드할 때 발견되는 첫 번째 단일 노드는 XAML 루트 및 해당 시작 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-120">When first loaded, the first single node you encounter is the root of the XAML, and its start object.</span></span>  
  
### <a name="the-xaml-node-stream-concept"></a><span data-ttu-id="79b66-121">XAML 노드 스트림 개념</span><span class="sxs-lookup"><span data-stu-id="79b66-121">The XAML Node Stream Concept</span></span>  
 <span data-ttu-id="79b66-122">일반적으로 DOM, 트리 메타포 또는 XML 기반 기술에 액세스하는 쿼리 기반 접근 방식에 더 익숙한 경우 XAML 노드 스트림을 개념화하는 데 유용한 방법은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-122">If you are generally more familiar with a DOM, tree metaphor, or query-based approach towards accessing XML-based technologies, a helpful way to conceptualize a XAML node stream is as follows.</span></span> <span data-ttu-id="79b66-123">로드된 XAML이 가능한 모든 노드가 전체 확장된 다음 선형적으로 표시되는 트리 또는 DOM이라고 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-123">Imagine that the loaded XAML is a DOM or a tree where every possible node is expanded all the way, and then presented linearly.</span></span> <span data-ttu-id="79b66-124">노드를 탐색할 때 DOM과 관련된 수준을 "진입" 또는 "진출"할 수 있지만 이러한 수준 개념은 노드 스트림과 관련이 없기 때문에 XAML 노드 스트림에서 명시적으로 추적하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-124">As you advance through the nodes, you might be traversing "in" or "out" of levels that would be relevant to a DOM, but the XAML node stream does not explicitly keep track because these level concepts are not relevant to a node stream.</span></span> <span data-ttu-id="79b66-125">노드 스트림에는 "현재" 위치가 있지만 스트림 자체의 다른 부분을 참조로 저장하지 않은 한 현재 노드 위치를 제외한 노드 스트림의 다른 모든 측면은 표시되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-125">The node stream has a "current" position, but unless you have stored other parts of the stream yourself as references, every aspect of the node stream other than the current node position is out of view.</span></span>  
  
 <span data-ttu-id="79b66-126">XAML 노드 스트림 개념에는 전체 노드 스트림을 통과할 경우 전체 XAML 표현을 처리했음을 확신할 수 있다는 장점이 있습니다. 쿼리, DOM 작업 또는 정보 처리에 대한 기타 비선형 접근 방식이 전체 XAML 표현의 일부분에서 누락되지 않았는지 걱정할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-126">The XAML node stream concept has the notable advantage that if you go through the entire node stream, you are assured that you have processed the entire XAML representation; you do not need to worry that a query, a DOM operation, or some other nonlinear approach to processing information has missed some part of the complete XAML representation.</span></span> <span data-ttu-id="79b66-127">이러한 이유로, XAML 노드 스트림 표현은 XAML 판독기와 XAML 작성기를 연결하고 XAML 처리 작업의 읽기 및 쓰기 단계 사이에 작동하는 고유한 프로세스를 삽입할 수 있는 시스템을 제공하는 데 적합합니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-127">For this reason, the XAML node stream representation is ideal both for connecting XAML readers and XAML writers, and for providing a system where you can insert your own process that acts between the read and write phases of a XAML processing operation.</span></span> <span data-ttu-id="79b66-128">대부분의 경우 XAML 노드 스트림의 노드 순서는 XAML 판독기에 의해 의도적으로 소스 텍스트, 이진 또는 개체 그래프에 표시될 수 있는 순서와 반대로 최적화되거나 다시 정렬됩니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-128">In many cases, the ordering of nodes in the XAML node stream is deliberately optimized or reordered by XAML readers versus how the order might appear in the source text, binary, or object graph.</span></span> <span data-ttu-id="79b66-129">이 동작은 XAML 작성기가 노드 스트림에서 "뒤로" 이동해야 하는 위치에 있지 않도록 하는 XAML 처리 아키텍처를 적용하기 위한 것입니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-129">This behavior is intended to enforce a XAML processing architecture whereby XAML writers are never in a position where they have to go "back" in the node stream.</span></span> <span data-ttu-id="79b66-130">이상적일 경우, 모든 XAML 쓰기 작업은 스키마 컨텍스트와 노드 스트림의 현재 위치에 따라 작동할 수 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-130">Ideally, all XAML write operations should be able to act based on schema context plus the current position of the node stream.</span></span>  
  
<a name="a_basic_reading_node_loop"></a>   
## <a name="a-basic-reading-node-loop"></a><span data-ttu-id="79b66-131">기본 읽기 노드 루프</span><span class="sxs-lookup"><span data-stu-id="79b66-131">A Basic Reading Node Loop</span></span>  
 <span data-ttu-id="79b66-132">XAML 노드 스트림을 검사하기 위한 기본 읽기 노드 루프는 다음과 같은 개념으로 구성됩니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-132">A basic reading node loop for examining a XAML node stream consists of the following concepts.</span></span> <span data-ttu-id="79b66-133">이 항목에서 설명하는 노드 루프의 목적을 위해 <xref:System.Xaml.XamlXmlReader>를 사용하여 사람이 읽을 수 있는 텍스트 기반 XAML 파일을 읽고 있다고 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-133">For purposes of node loops as discussed in this topic, assume that you are reading a text-based, human-readable XAML file using <xref:System.Xaml.XamlXmlReader>.</span></span> <span data-ttu-id="79b66-134">이 섹션의 링크는 <xref:System.Xaml.XamlXmlReader>에서 구현된 특정 XAML 노드 루프 API를 참조합니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-134">The links in this section refer to the particular XAML node loop API implemented by <xref:System.Xaml.XamlXmlReader>.</span></span>  
  
-   <span data-ttu-id="79b66-135">XAML 노드 스트림의 끝에 있지 않은지 확인합니다( <xref:System.Xaml.XamlXmlReader.IsEof%2A>확인 또는 <xref:System.Xaml.XamlXmlReader.Read%2A> 반환 값 사용).</span><span class="sxs-lookup"><span data-stu-id="79b66-135">Make sure that you are not at the end of the XAML node stream (check <xref:System.Xaml.XamlXmlReader.IsEof%2A>, or use the <xref:System.Xaml.XamlXmlReader.Read%2A> return value).</span></span> <span data-ttu-id="79b66-136">스트림의 끝에 있는 경우 현재 노드가 없으며 종료해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-136">If you are at the end of the stream, there is no current node and you should exit.</span></span>  
  
-   <span data-ttu-id="79b66-137"><xref:System.Xaml.XamlXmlReader.NodeType%2A>을 호출하여 XAML 노드 스트림이 현재 노출하는 노드 형식을 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-137">Check what type of node the XAML node stream currently exposes by calling <xref:System.Xaml.XamlXmlReader.NodeType%2A>.</span></span>  
  
-   <span data-ttu-id="79b66-138">직접 연결된 관련 XAML 개체 작성기가 있는 경우 일반적으로 이때 <xref:System.Xaml.XamlWriter.WriteNode%2A> 를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-138">If you have an associated XAML object writer that is connected directly, you generally call <xref:System.Xaml.XamlWriter.WriteNode%2A> at this point.</span></span>  
  
-   <span data-ttu-id="79b66-139">현재 노드 또는 현재 레코드로 보고된 <xref:System.Xaml.XamlNodeType> 에 따라 다음 중 하나를 호출하여 노드 내용에 대한 정보를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-139">Based on which <xref:System.Xaml.XamlNodeType> is reported as the current node or current record, call one of the following to obtain information about the node contents:</span></span>  
  
    -   <span data-ttu-id="79b66-140"><xref:System.Xaml.XamlXmlReader.NodeType%2A> 이 <xref:System.Xaml.XamlNodeType.StartMember> 또는 <xref:System.Xaml.XamlNodeType.EndMember>인 경우 <xref:System.Xaml.XamlXmlReader.Member%2A> 를 호출하여 멤버에 대한 <xref:System.Xaml.XamlMember> 정보를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-140">For a <xref:System.Xaml.XamlXmlReader.NodeType%2A> of <xref:System.Xaml.XamlNodeType.StartMember> or <xref:System.Xaml.XamlNodeType.EndMember>, call <xref:System.Xaml.XamlXmlReader.Member%2A> to obtain <xref:System.Xaml.XamlMember> information about a member.</span></span> <span data-ttu-id="79b66-141">멤버가 <xref:System.Xaml.XamlDirective>일 수도 있으므로 이전 개체의 형식이 정의된 기존 멤버가 아닐 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-141">Note that the member might be a <xref:System.Xaml.XamlDirective>, and thus might not necessarily be a conventional type-defined member of the preceding object.</span></span> <span data-ttu-id="79b66-142">예를 들어 개체에 적용된 `x:Name` 은 <xref:System.Xaml.XamlMember.IsDirective%2A> 가 true이고 멤버의 <xref:System.Xaml.XamlMember.Name%2A> 이 `Name`이며 이 지시문이 XAML 언어 XAML 네임스페이스 아래에 있음을 나타내는 기타 속성이 있는 XAML 멤버로 나타납니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-142">For example, `x:Name` applied to an object appears as a XAML member where <xref:System.Xaml.XamlMember.IsDirective%2A> is true and the <xref:System.Xaml.XamlMember.Name%2A> of the member is `Name`, with other properties indicating that this directive is under the XAML language XAML namespace.</span></span>  
  
    -   <span data-ttu-id="79b66-143"><xref:System.Xaml.XamlXmlReader.NodeType%2A> 이 <xref:System.Xaml.XamlNodeType.StartObject> 또는 <xref:System.Xaml.XamlNodeType.EndObject>인 경우 <xref:System.Xaml.XamlXmlReader.Type%2A> 를 호출하여 개체에 대한 <xref:System.Xaml.XamlType> 정보를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-143">For a <xref:System.Xaml.XamlXmlReader.NodeType%2A> of <xref:System.Xaml.XamlNodeType.StartObject> or <xref:System.Xaml.XamlNodeType.EndObject>, call <xref:System.Xaml.XamlXmlReader.Type%2A> to obtain <xref:System.Xaml.XamlType> information about an object.</span></span>  
  
    -   <span data-ttu-id="79b66-144"><xref:System.Xaml.XamlXmlReader.NodeType%2A> 이 <xref:System.Xaml.XamlNodeType.Value>인 경우 <xref:System.Xaml.XamlXmlReader.Value%2A>를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-144">For a <xref:System.Xaml.XamlXmlReader.NodeType%2A> of <xref:System.Xaml.XamlNodeType.Value>, call <xref:System.Xaml.XamlXmlReader.Value%2A>.</span></span> <span data-ttu-id="79b66-145">멤버에 대한 가장 간단한 값 식이거나 개체에 대한 초기화 텍스트인 경우에만 노드가 값입니다(그러나 이 항목의 이후 섹션에서 설명하는 형식 변환 동작에 주의해야 함).</span><span class="sxs-lookup"><span data-stu-id="79b66-145">A node is a value only if it is the simplest expression of a value for a member, or the initialization text for an object (however, you should be aware of type conversion behavior as documented in an upcoming section of this topic).</span></span>  
  
    -   <span data-ttu-id="79b66-146"><xref:System.Xaml.XamlXmlReader.NodeType%2A> 이 <xref:System.Xaml.XamlNodeType.NamespaceDeclaration>인 경우 <xref:System.Xaml.XamlXmlReader.Namespace%2A> 를 호출하여 네임스페이스 노드에 대한 네임스페이스 정보를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-146">For a <xref:System.Xaml.XamlXmlReader.NodeType%2A> of <xref:System.Xaml.XamlNodeType.NamespaceDeclaration>, call <xref:System.Xaml.XamlXmlReader.Namespace%2A> to obtain namespace information for a namespace node.</span></span>  
  
-   <span data-ttu-id="79b66-147"><xref:System.Xaml.XamlXmlReader.Read%2A> 를 호출하여 XAML 판독기를 XAML 노드 스트림의 다음 노드로 진행하고 다시 단계를 반복합니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-147">Call <xref:System.Xaml.XamlXmlReader.Read%2A> to advance the XAML reader to the next node in the XAML node stream, and repeat the steps again.</span></span>  
  
 <span data-ttu-id="79b66-148">.NET Framework XAML 서비스 XAML 판독기에서 제공하는 XAML 노드 스트림은 항상 가능한 모든 노드의 전체 순회를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-148">The XAML node stream provided by .NET Framework XAML Services XAML readers always provides a full, deep traversal of all possible nodes.</span></span> <span data-ttu-id="79b66-149">XAML 노드 루프에 대한 일반적인 흐름 제어 기술에는 `while (reader.Read())`내에서 본문을 정의하고 노드 루프의 각 노드 지점에서 <xref:System.Xaml.XamlXmlReader.NodeType%2A> 으로 전환하는 작업이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-149">Typical flow-control techniques for a XAML node loop include defining a body within `while (reader.Read())`, and switching on <xref:System.Xaml.XamlXmlReader.NodeType%2A> at each node point in the node loop.</span></span>  
  
 <span data-ttu-id="79b66-150">노드 스트림이 파일의 끝에 있는 경우 현재 노드는 null입니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-150">If the node stream is at end of file, the current node is null.</span></span>  
  
 <span data-ttu-id="79b66-151">판독기 및 작성기를 사용하는 가장 간단한 루프는 다음 예제와 유사합니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-151">The simplest loop that uses a reader and writer resembles the following example.</span></span>  
  
```  
XamlXmlReader xxr = new XamlXmlReader(new StringReader(xamlStringToLoad));  
//where xamlStringToLoad is a string of well formed XAML  
XamlObjectWriter xow = new XamlObjectWriter(xxr.SchemaContext);  
while (xxr.Read()) {  
  xow.WriteNode(xxr);  
}  
```  
  
 <span data-ttu-id="79b66-152">로드 경로 XAML 노드 루프의 기본 예제에서는 XAML 판독기 및 XAML 작성기를 투명하게 연결하고 <xref:System.Xaml.XamlServices.Parse%2A?displayProperty=nameWithType>를 사용한 경우와 다른 아무 작업도 수행하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-152">This basic example of a load path XAML node loop transparently connects the XAML reader and XAML writer, doing nothing different than if you had used <xref:System.Xaml.XamlServices.Parse%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="79b66-153">그러나 이 기본 구조는 읽기 또는 쓰기 시나리오에 적용하기 위해 확장됩니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-153">But this basic structure is then expanded to apply to your reading or writing scenario.</span></span> <span data-ttu-id="79b66-154">가능한 몇 가지 시나리오는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-154">Some possible scenarios are as follows:</span></span>  
  
-   <span data-ttu-id="79b66-155"><xref:System.Xaml.XamlXmlReader.NodeType%2A>으로 전환합니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-155">Switch on <xref:System.Xaml.XamlXmlReader.NodeType%2A>.</span></span> <span data-ttu-id="79b66-156">읽고 있는 노드 형식에 따라 다른 작업을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-156">Perform different actions depending on which node type is being read.</span></span>  
  
-   <span data-ttu-id="79b66-157">모든 경우에서 <xref:System.Xaml.XamlWriter.WriteNode%2A> 를 호출하지는 마세요.</span><span class="sxs-lookup"><span data-stu-id="79b66-157">Do not call <xref:System.Xaml.XamlWriter.WriteNode%2A> in all cases.</span></span> <span data-ttu-id="79b66-158">일부 <xref:System.Xaml.XamlWriter.WriteNode%2A> 경우에서만 <xref:System.Xaml.XamlXmlReader.NodeType%2A> 를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-158">Only call <xref:System.Xaml.XamlWriter.WriteNode%2A> in some <xref:System.Xaml.XamlXmlReader.NodeType%2A> cases.</span></span>  
  
-   <span data-ttu-id="79b66-159">특정 노드 형식에 대한 논리 내에서 해당 노드의 고유 정보를 분석하고 작업을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-159">Within the logic for a particular node type, analyze the specifics of that node and act on them.</span></span> <span data-ttu-id="79b66-160">예를 들어 특정 XAML 네임스페이스에서 제공된 개체만 쓰고 해당 XAML 네임스페이스에서 제공되지 않은 개체는 모두 삭제하거나 지연할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-160">For example, you could write only objects that come from a particular XAML namespace, and then drop or defer any objects not from that XAML namespace.</span></span> <span data-ttu-id="79b66-161">또는 XAML 시스템에서 멤버 처리의 일부로 지원하지 않는 XAML 지시문을 모두 삭제하거나 다른 방식으로 다시 처리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-161">Or you could drop or otherwise reprocess any XAML directives that your XAML system does not support as part of your member processing.</span></span>  
  
-   <span data-ttu-id="79b66-162"><xref:System.Xaml.XamlObjectWriter> 메서드를 재정의하고 XAML 스키마 컨텍스트를 건너뛰는 형식 매핑을 수행할 수 있는 사용자 지정 `Write*` 를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-162">Define a custom <xref:System.Xaml.XamlObjectWriter> that overrides `Write*` methods, possibly performing type mapping that bypasses XAML schema context.</span></span>  
  
-   <span data-ttu-id="79b66-163">XAML 동작의 사용자 지정 차이가 판독기와 작성기 둘 다에서 사용되도록 기본이 아닌 XAML 스키마 컨텍스트를 사용하는 <xref:System.Xaml.XamlXmlReader> 를 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-163">Construct the <xref:System.Xaml.XamlXmlReader> to use a nondefault XAML schema context, so that customized differences in XAML behavior are used both by the reader and the writer.</span></span>  
  
### <a name="accessing-xaml-beyond-the-node-loop-concept"></a><span data-ttu-id="79b66-164">노드 루프 개념을 벗어난 XAML 액세스</span><span class="sxs-lookup"><span data-stu-id="79b66-164">Accessing XAML Beyond the Node Loop Concept</span></span>  
 <span data-ttu-id="79b66-165">XAML 노드 루프가 아닌 다른 방법으로 XAML 표현을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-165">There are potentially other ways to work with a XAML representation other than as a XAML node loop.</span></span> <span data-ttu-id="79b66-166">예를 들어 인덱싱된 노드를 읽을 수 있거나 특히 `x:Name`, `x:Uid`또는 다른 식별자를 통해 노드에 직접 액세스하는 XAML 판독기가 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-166">For example, there could exist a XAML reader that can read an indexed node, or in particular accesses nodes directly by `x:Name`, by `x:Uid`, or through other identifiers.</span></span> <span data-ttu-id="79b66-167">.NET framework XAML 서비스는 전체 구현을 제공하지 않고 서비스 및 지원 형식을 통해 제안 패턴을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-167">.NET Framework XAML Services does not provide a full implementation, but provides a suggested pattern through services and support types.</span></span> <span data-ttu-id="79b66-168">자세한 내용은 <xref:System.Xaml.IXamlIndexingReader> 및 <xref:System.Xaml.XamlNodeList>를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="79b66-168">For more information, see <xref:System.Xaml.IXamlIndexingReader> and <xref:System.Xaml.XamlNodeList>.</span></span>  
  
> [!TIP]
>  <span data-ttu-id="79b66-169">Microsoft는 Microsoft XAML Toolkit이라는 번외 릴리스도 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-169">Microsoft also produces an out-of-band release known as the Microsoft XAML Toolkit.</span></span> <span data-ttu-id="79b66-170">이 번외 릴리스는 아직 시험판 단계입니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-170">This out-of-band release is still in its pre-release stages.</span></span> <span data-ttu-id="79b66-171">그러나 시험판 구성 요소를 사용하려는 경우 Microsoft XAML Toolkit에서 XAML 도구 및 XAML 정적 분석을 위한 몇 가지 흥미로운 리소스를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-171">However, if you are willing to work with pre-release components, the Microsoft XAML Toolkit provides some interesting resources for XAML tooling and static analysis of XAML.</span></span> <span data-ttu-id="79b66-172">Microsoft XAML Toolkit에는 XAML DOM API, FxCop 분석 지원 및 Silverlight용 XAML 스키마 컨텍스트가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-172">The Microsoft XAML Toolkit includes a XAML DOM API, support for FxCop analysis, and a XAML schema context for Silverlight.</span></span> <span data-ttu-id="79b66-173">자세한 내용은 [Microsoft XAML Toolkit](http://code.msdn.microsoft.com/XAML)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="79b66-173">For more information, see [Microsoft XAML Toolkit](http://code.msdn.microsoft.com/XAML).</span></span>  
  
<a name="working_with_the_current_node"></a>   
## <a name="working-with-the-current-node"></a><span data-ttu-id="79b66-174">현재 노드 작업</span><span class="sxs-lookup"><span data-stu-id="79b66-174">Working with the Current Node</span></span>  
 <span data-ttu-id="79b66-175">XAML 노드 루프를 사용하는 대부분의 시나리오는 노드 읽기 이상의 작업을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-175">Most scenarios that use a XAML node loop do not only read the nodes.</span></span> <span data-ttu-id="79b66-176">대부분의 시나리오에서는 현재 노드를 처리하고 한번에 하나씩 각 노드를 <xref:System.Xaml.XamlWriter>구현에 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-176">Most scenarios process current nodes and pass each node one at a time to an implementation of <xref:System.Xaml.XamlWriter>.</span></span>  
  
 <span data-ttu-id="79b66-177">일반적인 로드 경로 시나리오에서 <xref:System.Xaml.XamlXmlReader> 는 XAML 노드 스트림을 생성합니다. XAML 노드는 해당 논리 및 XAML 스키마 컨텍스트에 따라 처리되고 노드가 <xref:System.Xaml.XamlObjectWriter>에 전달됩니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-177">In the typical load path scenario, a <xref:System.Xaml.XamlXmlReader> produces a XAML node stream; the XAML nodes are processed according to your logic and XAML schema context; and the nodes are passed to a <xref:System.Xaml.XamlObjectWriter>.</span></span> <span data-ttu-id="79b66-178">그런 다음 결과 개체 그래프를 응용 프로그램 또는 프레임워크에 통합합니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-178">You then integrate the resulting object graph into your application or framework.</span></span>  
  
 <span data-ttu-id="79b66-179">일반적인 저장 경로 시나리오에서 <xref:System.Xaml.XamlObjectReader> 는 개체 그래프를 읽고, 개별 XAML 노드가 처리되며, <xref:System.Xaml.XamlXmlWriter> 가 직렬화된 결과를 XAML 텍스트 파일로 출력합니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-179">In a typical save path scenario, a <xref:System.Xaml.XamlObjectReader> reads the object graph, individual XAML nodes are processed, and a <xref:System.Xaml.XamlXmlWriter> outputs the serialized result as a XAML text file.</span></span> <span data-ttu-id="79b66-180">핵심은 경로 및 시나리오 둘 다에서 한 번에 정확히 하나의 XAML 노드 작업이 포함되며 XAML 형식 시스템 및 .NET Framework XAML 서비스 API에서 정의된 표준화된 방식으로 XAML 노드를 처리할 수 있다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-180">The key is that both paths and scenarios involve working with exactly one XAML node at a time, and the XAML nodes are available for treatment in a standardized way that is defined by the XAML type system and the.NET Framework XAML Services APIs.</span></span>  
  
### <a name="frames-and-scope"></a><span data-ttu-id="79b66-181">프레임 및 범위</span><span class="sxs-lookup"><span data-stu-id="79b66-181">Frames and Scope</span></span>  
 <span data-ttu-id="79b66-182">XAML 노드 루프는 선형 방식으로 XAML 노드 스트림을 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-182">A XAML node loop walks through a XAML node stream in a linear way.</span></span> <span data-ttu-id="79b66-183">노드 스트림은 개체, 다른 개체를 포함하는 멤버 등으로 트래버스합니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-183">The node stream traverses into objects, into members that contain other objects, and so on.</span></span> <span data-ttu-id="79b66-184">프레임 및 스택 개념을 구현하여 XAML 노드 스트림 내에서 범위를 추적하면 유용한 경우가 많습니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-184">It is often useful to keep track of scope within the XAML node stream by implementing a frame and stack concept.</span></span> <span data-ttu-id="79b66-185">노드 스트림에 있는 동안 노드 스트림을 적극적으로 조정하는 경우에 특히 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-185">This is particularly true if you are actively adjusting the node stream while you are in it.</span></span> <span data-ttu-id="79b66-186">DOM 측면에서 구조를 고려할 경우 XAML 노드 구조를 깊이 탐색할 때 노드 루프 논리의 일부로 구현된 프레임 및 스택 지원에서 `StartObject` (또는 `GetObject`) 및 `EndObject` 범위 수를 계산할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-186">The frame and stack support that you implement as part of your node loop logic could count `StartObject` (or `GetObject`) and `EndObject` scopes as you descend into a XAML node structure if the structure is thought of from a DOM perspective.</span></span>  
  
<a name="traversing_and_entering_object_nodes"></a>   
## <a name="traversing-and-entering-object-nodes"></a><span data-ttu-id="79b66-187">개체 노드 트래버스 및 진입</span><span class="sxs-lookup"><span data-stu-id="79b66-187">Traversing and Entering Object Nodes</span></span>  
 <span data-ttu-id="79b66-188">XAML 판독기에서 열릴 때 노드 스트림의 첫 번째 노드는 루트 개체의 시작 개체 노드입니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-188">The first node in a node stream when it is opened by a XAML reader is the start-object node of the root object.</span></span> <span data-ttu-id="79b66-189">정의상, 이 개체는 항상 단일 개체 노드이며 피어가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-189">By definition, this object is always a single object node and has no peers.</span></span> <span data-ttu-id="79b66-190">실제 XAML 예제에서는 루트 개체가 추가 개체를 포함하는 하나 이상의 속성을 가진 것으로 정의되며, 이러한 속성에는 멤버 노드가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-190">In any real-world XAML example, the root object is defined to have one or more properties that hold more objects, and these properties have member nodes.</span></span> <span data-ttu-id="79b66-191">멤버 노드는 하나 이상의 개체 노드를 포함하거나 대신 값 노드에서 종료될 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-191">The member nodes then have one or more object nodes, or might also terminate in a value node instead.</span></span> <span data-ttu-id="79b66-192">일반적으로 루트 개체는 구문상 XAML 텍스트 태그에서 특성으로 할당되지만 XAML 노드 스트림 표현에서 `Namescope` 노드 유형에 매핑되는 XAML 이름 범위를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-192">The root object typically defines XAML namescopes, which are syntactically assigned as attributes in the XAML text markup but map to a `Namescope` node type in the XAML node stream representation.</span></span>  
  
 <span data-ttu-id="79b66-193">다음 XAML 예제를 고려해 보세요(.NET Framework의 기존 형식에서 지원되지 않는 임의 XAML임).</span><span class="sxs-lookup"><span data-stu-id="79b66-193">Consider the following XAML example (this is arbitrary XAML, not backed by existing types in the .NET Framework).</span></span> <span data-ttu-id="79b66-194">이 개체 모델에서 `FavorCollection` 은 `List<T>` 의 `Favor`이고, `Balloon` 및 `NoiseMaker` 는 `Favor`에 할당될 수 있고, `Balloon.Color` 속성은 WPF에서 색을 알려진 색 이름으로 정의하는 방법과 비슷하게 `Color` 개체에 의해 지원되며, `Color` 는 특성 구문에 대해 형식 변환기를 지원한다고 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-194">Assume that in this object model, `FavorCollection` is `List<T>` of `Favor`, `Balloon` and `NoiseMaker` are assignable to `Favor`, the `Balloon.Color` property is backed by a `Color` object similar to how WPF defines colors as known color names, and `Color` supports a type converter for attribute syntax.</span></span>  
  
|<span data-ttu-id="79b66-195">XAML 태그</span><span class="sxs-lookup"><span data-stu-id="79b66-195">XAML markup</span></span>|<span data-ttu-id="79b66-196">결과로 생성되는 XAML 노드 스트림</span><span class="sxs-lookup"><span data-stu-id="79b66-196">Resulting XAML node stream</span></span>|  
|-----------------|--------------------------------|  
|`<Party`|<span data-ttu-id="79b66-197">`Namespace` 에 대한 `Party`</span><span class="sxs-lookup"><span data-stu-id="79b66-197">`Namespace` node for `Party`</span></span>|  
|`xmlns="PartyXamlNamespace">`|<span data-ttu-id="79b66-198">`StartObject` 에 대한 `Party`</span><span class="sxs-lookup"><span data-stu-id="79b66-198">`StartObject` node for `Party`</span></span>|  
|`<Party.Favors>`|<span data-ttu-id="79b66-199">`StartMember` 에 대한 `Party.Favors`</span><span class="sxs-lookup"><span data-stu-id="79b66-199">`StartMember` node for `Party.Favors`</span></span>|  
||<span data-ttu-id="79b66-200">암시적`StartObject` 에 대한 `FavorCollection`노드</span><span class="sxs-lookup"><span data-stu-id="79b66-200">`StartObject` node for implicit `FavorCollection`</span></span>|  
||<span data-ttu-id="79b66-201">암시적`StartMember` 속성 항목에 대한 `FavorCollection` 노드입니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-201">`StartMember` node for implicit `FavorCollection` items property.</span></span>|  
|`<Balloon`|<span data-ttu-id="79b66-202">`StartObject` 에 대한 `Balloon`</span><span class="sxs-lookup"><span data-stu-id="79b66-202">`StartObject` node for `Balloon`</span></span>|  
|`Color="Red"`|<span data-ttu-id="79b66-203">`StartMember` 에 대한 `Color`</span><span class="sxs-lookup"><span data-stu-id="79b66-203">`StartMember` node for `Color`</span></span><br /><br /> <span data-ttu-id="79b66-204">특성 값 문자열`Value` 에 대한 `"Red"`노드</span><span class="sxs-lookup"><span data-stu-id="79b66-204">`Value` node for the attribute value string `"Red"`</span></span><br /><br /> <span data-ttu-id="79b66-205">`EndMember` 에 대한 `Color`</span><span class="sxs-lookup"><span data-stu-id="79b66-205">`EndMember` for `Color`</span></span>|  
|`HasHelium="True"`|<span data-ttu-id="79b66-206">`StartMember` 에 대한 `HasHelium`</span><span class="sxs-lookup"><span data-stu-id="79b66-206">`StartMember` node for `HasHelium`</span></span><br /><br /> <span data-ttu-id="79b66-207">특성 값 문자열`Value` 에 대한 `"True"`노드</span><span class="sxs-lookup"><span data-stu-id="79b66-207">`Value` node for the attribute value string `"True"`</span></span><br /><br /> <span data-ttu-id="79b66-208">`EndMember` 에 대한 `HasHelium`</span><span class="sxs-lookup"><span data-stu-id="79b66-208">`EndMember` for `HasHelium`</span></span>|  
|`>`|<span data-ttu-id="79b66-209">`EndObject` 에 대한 `Balloon`</span><span class="sxs-lookup"><span data-stu-id="79b66-209">`EndObject` for `Balloon`</span></span>|  
|`<NoiseMaker>Loudest</NoiseMaker>`|<span data-ttu-id="79b66-210">`StartObject` 에 대한 `NoiseMaker`</span><span class="sxs-lookup"><span data-stu-id="79b66-210">`StartObject` node for `NoiseMaker`</span></span><br /><br /> <span data-ttu-id="79b66-211">`StartMember` 에 대한 `_Initialization`</span><span class="sxs-lookup"><span data-stu-id="79b66-211">`StartMember` node for `_Initialization`</span></span><br /><br /> <span data-ttu-id="79b66-212">초기화 값 문자열`Value` 에 대한 `"Loudest"`노드</span><span class="sxs-lookup"><span data-stu-id="79b66-212">`Value` node for the initialization value string `"Loudest"`</span></span><br /><br /> <span data-ttu-id="79b66-213">`EndMember` 에 대한 `_Initialization`</span><span class="sxs-lookup"><span data-stu-id="79b66-213">`EndMember` node for `_Initialization`</span></span><br /><br /> <span data-ttu-id="79b66-214">`EndObject` 에 대한 `NoiseMaker`</span><span class="sxs-lookup"><span data-stu-id="79b66-214">`EndObject` for `NoiseMaker`</span></span>|  
||<span data-ttu-id="79b66-215">암시적`EndMember` 속성 항목에 대한 `FavorCollection` 노드입니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-215">`EndMember` node for implicit `FavorCollection` items property.</span></span>|  
||<span data-ttu-id="79b66-216">암시적`EndObject` 에 대한 `FavorCollection`노드</span><span class="sxs-lookup"><span data-stu-id="79b66-216">`EndObject` node for implicit `FavorCollection`</span></span>|  
|`</Party.Favors>`|<span data-ttu-id="79b66-217">`EndMember` 에 대한 `Favors`</span><span class="sxs-lookup"><span data-stu-id="79b66-217">`EndMember` for `Favors`</span></span>|  
|`</Party>`|<span data-ttu-id="79b66-218">`EndObject` 에 대한 `Party`</span><span class="sxs-lookup"><span data-stu-id="79b66-218">`EndObject` for `Party`</span></span>|  
  
 <span data-ttu-id="79b66-219">XAML 노드 스트림에서 다음 동작에 의존할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-219">In the XAML node stream, you can rely on the following behavior:</span></span>  
  
-   <span data-ttu-id="79b66-220">`Namespace` 노드가 있는 경우 스트림에서 `StartObject` 로 XAML 네임스페이스를 선언한 `xmlns`바로 앞에 추가됩니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-220">If a `Namespace` node exists, it is added to the stream immediately before the `StartObject` that declared the XAML namespace with `xmlns`.</span></span> <span data-ttu-id="79b66-221">XAML 및 예제 노드 스트림이 포함된 앞의 표를 다시 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-221">Look at the previous table with the XAML and example node stream again.</span></span> <span data-ttu-id="79b66-222">`StartObject` 및 `Namespace` 노드가 텍스트 태그에서의 선언 위치와 반대로 배치된 것 같습니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-222">Notice how the `StartObject` and `Namespace` nodes seem to be transposed versus their declaration positions in text markup.</span></span> <span data-ttu-id="79b66-223">이는 네임스페이스 노드가 항상 노드 스트림에서 적용되는 노드 앞에 표시되는 동작을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-223">This is representative of the behavior where the namespace nodes always appear ahead of the node they apply to in the node stream.</span></span> <span data-ttu-id="79b66-224">이 디자인의 목적은 네임스페이스 정보가 개체 작성기에 필수적이며 개체 작성기가 형식 매핑을 수행하거나 다른 방식으로 개체를 처리하기 전에 알고 있어야 한다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-224">The purpose of this design is that the namespace information is vital to object writers and must be known before the object writer attempts to perform type mapping or otherwise process the object.</span></span> <span data-ttu-id="79b66-225">스트림에서 해당 응용 프로그램 범위 앞에 XAML 네임스페이스 정보를 배치하면 항상 노드 스트림을 표시된 순서대로 간단하게 처리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-225">Placing the XAML namespace information ahead of its application scope in the stream makes it simpler to always process the node stream in its presented order.</span></span>  
  
-   <span data-ttu-id="79b66-226">위의 고려 사항으로 인해 루트의 `Namespace` 가 아니라 시작부터 노드를 트래버스할 때 대부분의 실제 태그 경우에서는 하나 이상의 `StartObject` 노드를 먼저 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-226">Because of the above consideration, it is one or more `Namespace` nodes that you read first in most real-world markup cases when traversing nodes from the start, not the `StartObject` of the root.</span></span>  
  
-   <span data-ttu-id="79b66-227">`StartObject` 노드 뒤에는 `StartMember`, `Value`또는 즉시 실행 `EndObject`가 올 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-227">A `StartObject` node can be followed by `StartMember`, `Value`, or an immediate `EndObject`.</span></span> <span data-ttu-id="79b66-228">다른 `StartObject`가 바로 뒤에 오는 경우는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-228">It is never followed immediately by another `StartObject`.</span></span>  
  
-   <span data-ttu-id="79b66-229">`StartMember` 뒤에는 `StartObject`, `Value`또는 즉시 실행 `EndMember`가 올 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-229">A `StartMember` can be followed by a `StartObject`, `Value`, or an immediate `EndMember`.</span></span> <span data-ttu-id="79b66-230">값이 새 값을 인스턴스화하는 `GetObject`가 아니라 부모 개체의 기존 값에서 제공되어야 하는 멤버의 경우 `StartObject` 가 뒤에 올 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-230">It can be followed by `GetObject`, for members where the value is supposed to come from an existing value of the parent object rather than a `StartObject` that would instantiate a new value.</span></span> <span data-ttu-id="79b66-231">이후의 `Namespace` 에 적용되는 `StartObject`노드가 뒤에 올 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-231">It can also be followed by a `Namespace` node, which applies to an upcoming `StartObject`.</span></span> <span data-ttu-id="79b66-232">다른 `StartMember`가 바로 뒤에 오는 경우는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-232">It is never followed immediately by another `StartMember`.</span></span>  
  
-   <span data-ttu-id="79b66-233">`Value` 노드는 값 자체를 나타내며 "EndValue"가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-233">A `Value` node represents the value itself; there is no "EndValue".</span></span> <span data-ttu-id="79b66-234">`EndMember`만 뒤에 올 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-234">It can be followed only by an `EndMember`.</span></span>  
  
    -   <span data-ttu-id="79b66-235">구문에서 사용할 수 있는 개체의 XAML 초기화 텍스트는 개체-값 구조를 생성하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-235">XAML initialization text of the object as might be used by construction does not result in an Object-Value structure.</span></span> <span data-ttu-id="79b66-236">대신, `_Initialization` 이라는 멤버에 대한 전용 멤버 노드가 만들어지고</span><span class="sxs-lookup"><span data-stu-id="79b66-236">Instead, a dedicated member node for a member named `_Initialization` is created.</span></span> <span data-ttu-id="79b66-237">해당 멤버 노드에 초기화 값 문자열이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-237">and that member node contains the initialization value string.</span></span> <span data-ttu-id="79b66-238">있는 경우 `_Initialization` 은 항상 첫 번째 `StartMember`입니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-238">If it exists, `_Initialization` is always the first `StartMember`.</span></span> <span data-ttu-id="79b66-239">일부 XAML 서비스 표현에서는 XAML 언어 XAML 이름 범위로`_Initialization` 을 정규화하여 `_Initialization` 이 지원 형식에서 정의된 속성이 아님을 명확히 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-239">`_Initialization` may be qualified in some XAML services representations with the XAML language XAML namescope, to clarify that `_Initialization` is not a defined property in backing types.</span></span>  
  
    -   <span data-ttu-id="79b66-240">멤버-값 조합은 값의 특성 설정을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-240">A Member-Value combination represents an attribute setting of the value.</span></span> <span data-ttu-id="79b66-241">결국 이 값을 처리하는 데 값 변환기가 사용될 수 있으며 값은 일반 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-241">There might eventually be a value converter involved in processing this value, and the value is a plain string.</span></span> <span data-ttu-id="79b66-242">그러나 XAML 개체 작성기에서 이 노드 스트림을 처리할 때까지는 평가되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-242">However, that is not evaluated until a XAML object writer processes this node stream.</span></span> <span data-ttu-id="79b66-243">XAML 개체 작성기는 필요한 XAML 스키마 컨텍스트, 형식 시스템 매핑 및 값 변환에 필요한 기타 지원을 소유합니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-243">The XAML object writer possesses the necessary XAML schema context, type system mapping, and other support needed for value conversions.</span></span>  
  
-   <span data-ttu-id="79b66-244">`EndMember` 노드 뒤에는 이후 멤버에 대한 `StartMember` 노드 또는 멤버 소유자에 대한 `EndObject` 노드가 올 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-244">An `EndMember` node can be followed by a `StartMember` node for a subsequent member, or by an `EndObject` node for the member owner.</span></span>  
  
-   <span data-ttu-id="79b66-245">`EndObject` 노드 뒤에는 `EndMember` 노드가 올 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-245">An `EndObject` node can be followed by an `EndMember` node.</span></span> <span data-ttu-id="79b66-246">개체가 컬렉션 항목의 피어인 경우 `StartObject` 가 뒤에 올 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-246">It can also be followed by a `StartObject` node for cases where the objects are peers in a collection's items.</span></span> <span data-ttu-id="79b66-247">또는 이후의 `Namespace` 에 적용되는 `StartObject`노드가 뒤에 올 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-247">Or it can be followed by a `Namespace` node, which applies to an upcoming `StartObject`.</span></span>  
  
    -   <span data-ttu-id="79b66-248">전체 노드 스트림을 닫는 고유한 경우 루트의 `EndObject` 뒤에는 아무것도 오지 않습니다. 이제 판독기가 파일의 끝이며 <xref:System.Xaml.XamlReader.Read%2A> 에서 `false`를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-248">For the unique case of closing the entire node stream, the `EndObject` of the root is not followed by anything; the reader is now end-of-file, and <xref:System.Xaml.XamlReader.Read%2A> returns `false`.</span></span>  
  
<a name="value_converters_and_the_xaml_node_stream"></a>   
## <a name="value-converters-and-the-xaml-node-stream"></a><span data-ttu-id="79b66-249">값 변환기 및 XAML 노드 스트림</span><span class="sxs-lookup"><span data-stu-id="79b66-249">Value Converters and the XAML Node Stream</span></span>  
 <span data-ttu-id="79b66-250">값 변환기는 태그 확장, 형식 변환기(값 직렬화기 포함) 또는 XAML 형식 시스템을 통해 값 변환기로 보고되는 다른 전용 클래스를 가리키는 일반적인 용어입니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-250">A value converter is a general term for a markup extension, a type converter (including value serializers) or another dedicated class that is reported as a value converter through the XAML type system.</span></span> <span data-ttu-id="79b66-251">XAML 노드 스트림에서 형식 변환기 사용과 태그 확장 사용은 전혀 다른 표현을 갖습니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-251">In the XAML node stream, a type converter usage and a markup extension usage have very different representations.</span></span>  
  
### <a name="type-converters-in-the-xaml-node-stream"></a><span data-ttu-id="79b66-252">XAML 노드 스트림의 형식 변환기</span><span class="sxs-lookup"><span data-stu-id="79b66-252">Type Converters in the XAML Node Stream</span></span>  
 <span data-ttu-id="79b66-253">결국 형식 변환기가 사용되는 특성 집합은 XAML 노드 스트림에서 멤버의 값으로 보고됩니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-253">An attribute set that eventually results in a type converter usage is reported in the XAML node stream as a value of a member.</span></span> <span data-ttu-id="79b66-254">XAML 노드 스트림은 형식 변환기 인스턴스 개체를 생성하고 값을 전달하려고 시도하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-254">The XAML node stream does not attempt to produce a type converter instance object and pass the value to it.</span></span> <span data-ttu-id="79b66-255">형식 변환기의 변환 구현을 사용하려면 XAML 스키마 컨텍스트를 호출하고 형식 매핑에 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-255">Using a type converter's conversion implementation requires invoking the XAML schema context and using it for type-mapping.</span></span> <span data-ttu-id="79b66-256">값을 처리하는 데 사용해야 하는 형식 변환기 클래스를 확인할 때에도 간접적으로 XAML 스키마 컨텍스트가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-256">Even determining which type converter class should be used to process the value requires the XAML schema context indirectly.</span></span> <span data-ttu-id="79b66-257">기본 XAML 스키마 컨텍스트를 사용하는 경우 해당 정보는 XAML 형식 시스템에서 제공됩니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-257">When you use the default XAML schema context, that information is available from the XAML type system.</span></span> <span data-ttu-id="79b66-258">XAML 작성기에 연결하기 전에 XAML 노드 스트림 수준의 형식 변환기 클래스 정보가 필요한 경우 설정되는 멤버의 <xref:System.Xaml.XamlMember> 정보에서 가져올 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-258">If you need the type converter class information at the XAML node stream level before connection to a XAML writer, you can obtain it from the <xref:System.Xaml.XamlMember> information of the member being set.</span></span> <span data-ttu-id="79b66-259">하지만 그러지 않은 경우 형식 매핑 시스템 및 XAML 스키마 컨텍스트가 필요한 나머지 작업(예: XAML 개체 작성기에 의한 개체 생성)이 수행될 때까지 형식 변환기 입력을 XAML 노드 스트림에 일반 값으로 유지해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-259">But otherwise, type converter input should be preserved in the XAML node stream as a plain value until the remainder of operations that require the type mapping system and XAML schema context are performed, for example the object creation by a XAML object writer.</span></span>  
  
 <span data-ttu-id="79b66-260">예를 들어 다음과 같은 클래스 정의 개요와 XAML 사용을 고려해 보세요.</span><span class="sxs-lookup"><span data-stu-id="79b66-260">For example, consider the following class definition outline and XAML usage for it:</span></span>  
  
```  
public class BoardSizeConverter : TypeConverter {  
  //converts from string to an int[2] by splitting on an "x" char  
}  
public class GameBoard {  
  [TypeConverter(typeof(BoardSizeConverter))]  
  public int[] BoardSize; //2x2 array, initialization not shown  
}  
```  
  
```xaml  
<GameBoard BoardSize="8x8"/>  
```  
  
 <span data-ttu-id="79b66-261">이 사용을 위한 XAML 노드 스트림의 텍스트 표현은 다음과 같이 표현될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-261">A text representation of the XAML node stream for this usage could be expressed as the following:</span></span>  
  
 <span data-ttu-id="79b66-262">`StartObject` 이 <xref:System.Xaml.XamlType> 를 나타내는 `GameBoard`</span><span class="sxs-lookup"><span data-stu-id="79b66-262">`StartObject` with <xref:System.Xaml.XamlType> representing `GameBoard`</span></span>  
  
 <span data-ttu-id="79b66-263">`StartMember` 이 <xref:System.Xaml.XamlMember> 를 나타내는 `BoardSize`</span><span class="sxs-lookup"><span data-stu-id="79b66-263">`StartMember` with <xref:System.Xaml.XamlMember> representing `BoardSize`</span></span>  
  
 <span data-ttu-id="79b66-264">텍스트 문자열 "`Value` "을 포함하는`8x8`노드</span><span class="sxs-lookup"><span data-stu-id="79b66-264">`Value` node, with text string "`8x8`"</span></span>  
  
 <span data-ttu-id="79b66-265">`EndMember` 가 `BoardSize`</span><span class="sxs-lookup"><span data-stu-id="79b66-265">`EndMember` matches `BoardSize`</span></span>  
  
 <span data-ttu-id="79b66-266">`EndObject` 가 `GameBoard`</span><span class="sxs-lookup"><span data-stu-id="79b66-266">`EndObject` matches `GameBoard`</span></span>  
  
 <span data-ttu-id="79b66-267">이 노드 스트림에는 형식 변환기 인스턴스가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-267">Notice that there is no type converter instance in this node stream.</span></span> <span data-ttu-id="79b66-268">그러나 `BoardSize`에 대한 <xref:System.Xaml.XamlMember>에서 <xref:System.Xaml.XamlMember.TypeConverter%2A?displayProperty=nameWithType>를 호출하여 형식 변환기 정보를 가져올 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-268">But you can get type converter information by calling <xref:System.Xaml.XamlMember.TypeConverter%2A?displayProperty=nameWithType> on the <xref:System.Xaml.XamlMember> for `BoardSize`.</span></span> <span data-ttu-id="79b66-269">유효한 XAML 스키마 컨텍스트가 있는 경우 <xref:System.Xaml.Schema.XamlValueConverter%601.ConverterInstance%2A>에서 인스턴스를 가져와 변환기 메서드를 호출할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-269">If you have a valid XAML schema context, you can also invoke the converter methods by obtaining an instance from <xref:System.Xaml.Schema.XamlValueConverter%601.ConverterInstance%2A>.</span></span>  
  
### <a name="markup-extensions-in-the-xaml-node-stream"></a><span data-ttu-id="79b66-270">XAML 노드 스트림의 태그 확장</span><span class="sxs-lookup"><span data-stu-id="79b66-270">Markup Extensions in the XAML Node Stream</span></span>  
 <span data-ttu-id="79b66-271">태그 확장 사용은 XAML 노드 스트림에서 멤버 내의 개체 노드로 보고됩니다. 여기서 개체는 태그 확장 인스턴스를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-271">A markup extension usage is reported in the XAML node stream as an object node within a member, where the object represents a markup extension instance.</span></span> <span data-ttu-id="79b66-272">따라서 태그 확장 사용은 노드 스트림 표현에서 형식 변환기 사용보다 더 명시적으로 표시되며 자세한 정보를 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-272">Thus a markup extension usage is presented more explicitly in the node stream representation than a type converter usage is, and carries more information.</span></span> <span data-ttu-id="79b66-273">사용이 상황에 따라 결정되고 가능한 각 태그의 경우에서 달라지므로<xref:System.Xaml.XamlMember> 정보에서 태그 확장에 대한 정보를 제공하지 못할 수도 있습니다. 형식 변환기의 경우처럼 형식 또는 멤버별로 전용 및 암시적이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-273"><xref:System.Xaml.XamlMember> information could not have told you anything about the markup extension, because the usage is situational and varies in each possible markup case; it is not dedicated and implicit per type or member as is the case with type converters.</span></span>  
  
 <span data-ttu-id="79b66-274">XAML 텍스트 태그에서 특성 형태로 태그 확장 사용이 수행된 경우에도 태그 확장을 개체 노드로 표현하는 노드 스트림 표현이 이러한 경우에 해당합니다(자주 발생함).</span><span class="sxs-lookup"><span data-stu-id="79b66-274">The node stream representation of markup extensions as object nodes is the case even if the markup extension usage was made in attribute form in the XAML text markup (which is often the case).</span></span> <span data-ttu-id="79b66-275">명시적 개체 요소 형태를 사용한 태그 확장 사용은 동일한 방식으로 처리됩니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-275">Markup extension usages that used an explicit object element form are treated the same way.</span></span>  
  
 <span data-ttu-id="79b66-276">태그 확장 개체 노드 내에 해당 태그 확장의 멤버가 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-276">Within a markup extension object node, there may be members of that markup extension.</span></span> <span data-ttu-id="79b66-277">XAML 노드 스트림 표현은 위치 매개 변수 사용인지 또는 명명된 명시적 매개 변수를 통한 사용인지에 관계없이 해당 태그 확장의 사용을 유지합니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-277">The XAML node stream representation preserves the usage of that markup extension, whether that be a positional parameter usage or a usage with explicit named parameters.</span></span>  
  
 <span data-ttu-id="79b66-278">위치 매개 변수 사용의 경우 XAML 노드 스트림에 사용을 기록하는 XAML 언어로 정의된 속성 `_PositionalParameters` 가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-278">For a positional parameter usage, the XAML node stream contains a XAML language-defined property `_PositionalParameters` that records the usage.</span></span> <span data-ttu-id="79b66-279">이 속성은 <xref:System.Collections.Generic.List%601> 제약 조건이 있는 제네릭 <xref:System.Object> 입니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-279">This property is a generic <xref:System.Collections.Generic.List%601> with <xref:System.Object> constraint.</span></span> <span data-ttu-id="79b66-280">위치 매개 변수 사용 내에 중첩된 태그 확장 사용이 포함될 수 있으므로 제약 조건은 문자열이 아니라 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-280">The constraint is object and not string because conceivably a positional parameter usage could contain nested markup extension usages within it.</span></span> <span data-ttu-id="79b66-281">사용에서 위치 매개 변수에 액세스하려면 목록을 반복하고 개별 목록 값의 인덱서를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-281">To access the positional parameters from the usage, you could iterate through the list and use the indexers for individual list values.</span></span>  
  
 <span data-ttu-id="79b66-282">명명된 매개 변수 사용의 경우 명명된 각 매개 변수가 노드 스트림에서 해당 이름의 멤버 노드로 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-282">For a named parameter usage, each named parameter is represented as a member node of that name in the node stream.</span></span> <span data-ttu-id="79b66-283">중첩된 태그 확장 사용이 있을 수 있으므로 멤버 값은 문자열이 아닐 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-283">The member values are not necessarily strings, because there could be a nested markup extension usage.</span></span>  
  
 <span data-ttu-id="79b66-284">태그 확장의`ProvideValue` 가 아직 호출되지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-284">`ProvideValue` from the markup extension is not yet invoked.</span></span> <span data-ttu-id="79b66-285">그러나 노드 스트림에서 검사할 때 태그 확장 노드에서 `WriteEndObject` 가 호출되도록 XAML 판독기 및 XAML 작성기를 연결하면 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-285">However, it is invoked if you connect a XAML reader and XAML writer so that `WriteEndObject` is invoked on the markup extension node when you examine it in the node stream.</span></span> <span data-ttu-id="79b66-286">이러한 이유로, 일반적으로 로드 경로에서 개체 그래프를 형성하기 위해 사용되는 것과 동일한 XAML 스키마 컨텍스트를 사용할 수 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-286">For this reason, you generally need the same XAML schema context available as would be used in order to form the object graph on the load path.</span></span> <span data-ttu-id="79b66-287">그러지 않으면 필요한 서비스를 사용할 수 없기 때문에 태그 확장의 `ProvideValue` 에서 예외가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-287">Otherwise, `ProvideValue` from any markup extension can throw exceptions here, because it does not have expected services available.</span></span>  
  
<a name="xaml_and_xml_languagedefined_members_in_the_xaml_node_stream"></a>   
## <a name="xaml-and-xml-language-defined-members-in-the-xaml-node-stream"></a><span data-ttu-id="79b66-288">XAML 노드 스트림의 XAML 및 XML 언어로 정의된 멤버</span><span class="sxs-lookup"><span data-stu-id="79b66-288">XAML and XML Language-Defined Members in the XAML Node Stream</span></span>  
 <span data-ttu-id="79b66-289">명시적 <xref:System.Xaml.XamlMember> 조회 또는 생성을 사용하는 대신 XAML 판독기의 해석과 규칙으로 인해 특정 멤버가 XAML 노드 스트림에 소개됩니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-289">Certain members are introduced to a XAML node stream because of interpretations and conventions of a XAML reader, instead of through an explicit <xref:System.Xaml.XamlMember> lookup or construction.</span></span> <span data-ttu-id="79b66-290">대개 이러한 멤버는 XAML 지시문입니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-290">Often, these members are XAML directives.</span></span> <span data-ttu-id="79b66-291">경우에 따라 XAML 노드 스트림에 지시문을 소개하는 XAML 읽기 동작입니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-291">In some cases, it is the act of reading the XAML that introduces the directive into the XAML node stream.</span></span> <span data-ttu-id="79b66-292">즉, 원래 입력 XAML 텍스트는 멤버 지시문을 명시적으로 지정하지 않았지만 XAML 판독기가 구조적 XAML 규칙을 충족하고 정보가 손실되기 전에 XAML 노드 스트림의 정보를 보고하기 위해 지시문을 삽입합니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-292">In other words, the original input XAML text did not explictly specify the member directive, but the XAML reader inserts the directive in order to satisfy a structural XAML convention and report information in the XAML node stream before that information is lost.</span></span>  
  
 <span data-ttu-id="79b66-293">다음 목록에서는 XAML 판독기가 지시문 XAML 멤버 노드를 소개해야 하는 모든 경우 및 .NET Framework XAML 서비스 구현에서 해당 멤버 노드가 식별되는 방식을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-293">The following list notes all cases where a XAML reader is expected to introduce a directive XAML member node, and how that member node is identified in the .NET Framework XAML Services implementations.</span></span>  
  
-   <span data-ttu-id="79b66-294">**개체 노드에 대한 초기화 텍스트:** 이 멤버 노드의 이름은 `_Initialization`이고, XAML 지시문을 나타내며, XAML 언어 XAML 네임스페이스에서 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-294">**Initialization text for an object node:** The name of this member node is `_Initialization`, it represents a XAML directive, and it is defined in the XAML language XAML namespace.</span></span> <span data-ttu-id="79b66-295"><xref:System.Xaml.XamlLanguage.Initialization%2A>에서 해당 정적 엔터티를 가져올 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-295">You can get a static entity for it from <xref:System.Xaml.XamlLanguage.Initialization%2A>.</span></span>  
  
-   <span data-ttu-id="79b66-296">**태그 확장에 대한 위치 매개 변수:** 이 멤버 노드의 이름은 `_PositionalParameters`이고 XAML 언어 XAML 네임스페이스에서 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-296">**Positional parameters for a markup extension:** The name of this member node is `_PositionalParameters`, and it is defined in the XAML language XAML namespace.</span></span> <span data-ttu-id="79b66-297">각각 입력 XAML에서 제공될 때 `,` 구분 기호 문자에서 분할하여 미리 구분된 위치 매개 변수인 개체의 제네릭 목록을 항상 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-297">It always contains a generic list of objects, each of which is a positional parameter pre-separated by splitting on the `,` delimiter character as supplied in the input XAML.</span></span> <span data-ttu-id="79b66-298"><xref:System.Xaml.XamlLanguage.PositionalParameters%2A>에서 위치 매개 변수 지시문에 대한 정적 엔터티를 가져올 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-298">You can get a static entity for the positional parameters directive from <xref:System.Xaml.XamlLanguage.PositionalParameters%2A>.</span></span>  
  
-   <span data-ttu-id="79b66-299">**알 수 없는 콘텐츠:** 이 멤버 노드의 이름은 `_UnknownContent`입니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-299">**Unknown content:** The name of this member node is `_UnknownContent`.</span></span> <span data-ttu-id="79b66-300">엄격히 말해서, <xref:System.Xaml.XamlDirective>이며 XAML 언어 XAML 네임스페이스에서 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-300">Strictly speaking, it is a <xref:System.Xaml.XamlDirective>, and it is defined in the XAML language XAML namespace.</span></span> <span data-ttu-id="79b66-301">이 지시문은 XAML 개체 요소에 소스 XAML의 콘텐츠가 포함되지만 현재 사용할 수 있는 XAML 스키마 컨텍스트에서 콘텐츠 속성을 확인할 수 없는 경우에 대한 센티널로 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-301">This directive is used as a sentinel for cases where a XAML object element contains content in the source XAML but no content property can be determined under the currently available XAML schema context.</span></span> <span data-ttu-id="79b66-302">XAML 노드 스트림에서 `_UnknownContent`라는 멤버를 확인하여 이러한 경우를 검색할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-302">You can detect this case in a XAML node stream by checking for members named `_UnknownContent`.</span></span> <span data-ttu-id="79b66-303">로드 경로 XAML 노드 스트림에서 다른 작업을 수행하지 않는 경우 임의 개체에서 <xref:System.Xaml.XamlObjectWriter> 멤버를 발견하면 시도된 `WriteEndObject` 에서 기본 `_UnknownContent` 가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-303">If no other action is taken in a load path XAML node stream, the default <xref:System.Xaml.XamlObjectWriter> throws on attempted `WriteEndObject` when it encounters the `_UnknownContent` member on any object.</span></span> <span data-ttu-id="79b66-304">기본 <xref:System.Xaml.XamlXmlWriter> 가 발생하지 않고 멤버를 암시적으로 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-304">The default <xref:System.Xaml.XamlXmlWriter> does not throw, and treats the member as implicit.</span></span> <span data-ttu-id="79b66-305">`_UnknownContent` 에서 <xref:System.Xaml.XamlLanguage.UnknownContent%2A>에 대한 정적 엔터티를 가져올 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-305">You can get a static entity for `_UnknownContent` from <xref:System.Xaml.XamlLanguage.UnknownContent%2A>.</span></span>  
  
-   <span data-ttu-id="79b66-306">**컬렉션의 컬렉션 속성:**일반적으로 XAML에 사용되는 컬렉션 클래스의 지원 CLR 형식에는 컬렉션 항목을 포함하는 명명된 전용 속성이 있지만 지원 형식을 확인할 때까지 XAML 형식 시스템에서 해당 속성을 알 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-306">**Collection property of a collection:**Although the backing CLR type of a collection class that is used for XAML usually has a dedicated named property that holds the collection items, that property is not known to a XAML type system prior to backing type resolution.</span></span> <span data-ttu-id="79b66-307">대신, XAML 노드 스트림은 `Items` 자리 표시자를 컬렉션 XAML 형식의 멤버로 소개합니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-307">Instead, the XAML node stream introduces an `Items` placeholder as a member of the collection XAML type.</span></span> <span data-ttu-id="79b66-308">.NET Framework XAML 서비스 구현의 노드 스트림에서 이 지시문/멤버의 이름은 `_Items`입니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-308">In the .NET Framework XAML Services implementation the name of this directive / member in the node stream is `_Items`.</span></span> <span data-ttu-id="79b66-309">이 지시문에 대한 상수는 <xref:System.Xaml.XamlLanguage.Items%2A>에서 가져올 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-309">A constant for this directive can be obtained from <xref:System.Xaml.XamlLanguage.Items%2A>.</span></span>  
  
     <span data-ttu-id="79b66-310">XAML 노드 스트림에는 지원 형식 확인 및 XAML 스키마 컨텍스트를 기준으로 구문 분석할 수 없는 항목이 있는 Items 속성이 포함될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-310">Note that a XAML node stream might contain an Items property with items that turn out to not be parseable based on the backing type resolution and XAML schema context.</span></span> <span data-ttu-id="79b66-311">예를 들어 개체에 적용된</span><span class="sxs-lookup"><span data-stu-id="79b66-311">For example,</span></span>  
  
-   <span data-ttu-id="79b66-312">**XML로 정의된 멤버:** XML로 정의된 `xml:base`, `xml:lang` 및 `xml:space` 멤버는 .NET Framework XAML 서비스 구현에서 `base`, `lang`및 `space` 라는 XAML 지시문으로 보고됩니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-312">**XML-defined members:** The XML-defined `xml:base`, `xml:lang` and `xml:space` members are reported as XAML directives named `base`, `lang`, and `space` in the .NET Framework XAML Services implementations.</span></span> <span data-ttu-id="79b66-313">이러한 멤버에 대한 네임스페이스는 XML 네임스페이스 `http://www.w3.org/XML/1998/namespace`입니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-313">The namespace for these is the XML namespace `http://www.w3.org/XML/1998/namespace`.</span></span> <span data-ttu-id="79b66-314">각 멤버에 대한 상수는 <xref:System.Xaml.XamlLanguage>에서 가져올 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-314">Constants for each of these can be obtained from <xref:System.Xaml.XamlLanguage>.</span></span>  
  
## <a name="node-order"></a><span data-ttu-id="79b66-315">노드 순서</span><span class="sxs-lookup"><span data-stu-id="79b66-315">Node Order</span></span>  
 <span data-ttu-id="79b66-316">경우에 따라 <xref:System.Xaml.XamlXmlReader> 는 태그에서 보는 경우 또는 XML로 처리되는 경우 노드가 나타나는 순서와 반대로 XAML 노드 스트림의 XAML 노드 순서를 변경합니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-316">In some cases, <xref:System.Xaml.XamlXmlReader> changes the order of XAML nodes in the XAML node stream, versus the order the nodes appear if viewed in the markup or if processed as XML.</span></span> <span data-ttu-id="79b66-317">이 작업은 <xref:System.Xaml.XamlObjectWriter> 가 정방향으로만 노드 스트림을 처리할 수 있도록 노드를 정렬하기 위해 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-317">This is done in order to order the nodes such that a <xref:System.Xaml.XamlObjectWriter> can process the node stream in a forward-only manner.</span></span>  <span data-ttu-id="79b66-318">.NET Framework XAML 서비스에서 XAML 판독기는 노드 스트림의 XAML 개체 작성기 소비자에 대한 성능 최적화로 XAML 작성기에 이 작업을 맡기지 않고 노드를 다시 정렬합니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-318">In .NET Framework XAML Services, the XAML reader reorders nodes rather than leaving this task to the XAML writer, as a performance optimization for XAML object writer consumers of the node stream.</span></span>  
  
 <span data-ttu-id="79b66-319">특정 지시문은 특히 object 요소에서 개체를 만들기 위한 자세한 정보를 제공하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-319">Certain directives are intended specifically to provide more information for the creation of an object from an object element.</span></span> <span data-ttu-id="79b66-320">해당 지시문은 `Initialization`, `PositionalParameters`, `TypeArguments`, `FactoryMethod`, `Arguments`입니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-320">These directives are: `Initialization`, `PositionalParameters`, `TypeArguments`, `FactoryMethod`, `Arguments`.</span></span> <span data-ttu-id="79b66-321">.NET Framework XAML 서비스 XAML 판독기는 다음 섹션에서 설명하는 이유로 이러한 지시문을 개체의 `StartObject`뒤에 노드 스트림의 첫 번째 멤버로 배치하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-321">The .NET Framework XAML Services XAML readers attempt to place these directives as the first members in the node stream following an object's `StartObject`, for reasons that are explained in the next section.</span></span>  
  
### <a name="xamlobjectwriter-behavior-and-node-order"></a><span data-ttu-id="79b66-322">XamlObjectWriter 동작 및 노드 순서</span><span class="sxs-lookup"><span data-stu-id="79b66-322">XamlObjectWriter Behavior and Node Order</span></span>  
 <span data-ttu-id="79b66-323">`StartObject` 에 대한 <xref:System.Xaml.XamlObjectWriter> 는 XAML 개체 작성기에 개체 인스턴스를 즉시 생성하라는 신호가 아닐 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-323">`StartObject` to a <xref:System.Xaml.XamlObjectWriter> is not necessarily a signal to the XAML object writer to immediately construct the object instance.</span></span> <span data-ttu-id="79b66-324">XAML에는 추가 입력으로 개체를 초기화하고 전적으로 기본 생성자를 호출하여 초기 개체를 생성한 다음 속성을 설정하는 방법에 의존하지 않게 해주는 여러 언어 기능이 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-324">XAML includes several language features that make it possible to initialize an object with additional input, and to not rely entirely on invoking a default constructor to produce the initial object, and only then setting properties.</span></span> <span data-ttu-id="79b66-325">이러한 기능에는 <xref:System.Windows.Markup.XamlDeferLoadAttribute>초기화 텍스트, [x:TypeArguments](../../../docs/framework/xaml-services/x-typearguments-directive.md), 태그 확장의 위치 매개 변수, 팩터리 메서드 및 연결된 [x:Arguments](../../../docs/framework/xaml-services/x-arguments-directive.md) 노드(XAML 2009)가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-325">These features include: <xref:System.Windows.Markup.XamlDeferLoadAttribute>; initialization text; [x:TypeArguments](../../../docs/framework/xaml-services/x-typearguments-directive.md); positional parameters of a markup extension; factory methods and associated [x:Arguments](../../../docs/framework/xaml-services/x-arguments-directive.md) nodes (XAML 2009).</span></span> <span data-ttu-id="79b66-326">이러한 각 경우에서는 실제 개체 생성이 지연되며 노드 스트림이 다시 정렬되므로, XAML 개체 작성기가 구체적으로 해당 개체 유형에 대한 생성 지시문이 아닌 시작 멤버를 발견할 때마다 인스턴스를 실제로 생성하는 동작에 의존할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-326">Each of these cases delay the actual object construction, and because the node stream is reordered, the XAML object writer can rely on a behavior of actually constructing the instance whenever a start member is encountered that is not specifically a construction directive for that object type.</span></span>  
  
### <a name="getobject"></a><span data-ttu-id="79b66-327">GetObject</span><span class="sxs-lookup"><span data-stu-id="79b66-327">GetObject</span></span>  
 <span data-ttu-id="79b66-328">`GetObject` 는 새 개체를 생성하는 대신 XAML 개체 작성기가 개체의 포함 속성 값을 가져와야 하는 XAML 노드를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-328">`GetObject` represents a XAML node where rather than constructing a new object, a XAML object writer should instead get the value of the object's containing property.</span></span> <span data-ttu-id="79b66-329">`GetObject` 노드가 XAML 노드 스트림에서 발견되는 일반적인 경우는 컬렉션 개체 또는 사전 개체에 대해 지원 형식의 개체 모델에서 포함 속성이 의도적으로 읽기 전용일 때입니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-329">A typical  case where a `GetObject` node is encountered in a XAML node stream is for a collection object or a dictionary object, when the containing property is deliberately read-only in the backing type's object model.</span></span> <span data-ttu-id="79b66-330">이 시나리오에서는 컬렉션 또는 사전이 소유 형식의 초기화 논리에 의해 만들어지고 초기화(일반적으로 비어 있음)되는 경우가 많습니다.</span><span class="sxs-lookup"><span data-stu-id="79b66-330">In this scenario, the collection or dictionary often is created and initialized (usually empty) by the initialization logic of an owning type.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="79b66-331">참고 항목</span><span class="sxs-lookup"><span data-stu-id="79b66-331">See Also</span></span>  
 <xref:System.Xaml.XamlObjectReader>  
 [<span data-ttu-id="79b66-332">XAML 서비스</span><span class="sxs-lookup"><span data-stu-id="79b66-332">XAML Services</span></span>](../../../docs/framework/xaml-services/index.md)  
 [<span data-ttu-id="79b66-333">XAML 네임스페이스</span><span class="sxs-lookup"><span data-stu-id="79b66-333">XAML Namespaces</span></span>](../../../docs/framework/xaml-services/xaml-namespaces-for-net-framework-xaml-services.md)

---
title: .NET Framework XAML 서비스에서 사용할 사용자 지정 형식 정의
ms.date: 03/30/2017
helpviewer_keywords:
- defining custom types [XAML Services]
ms.assetid: c2667cbd-2f46-4a7f-9dfc-53696e35e8e4
ms.openlocfilehash: 672660f73e9e6faf25985a651290e979f9deb9f4
ms.sourcegitcommit: 6b308cf6d627d78ee36dbbae8972a310ac7fd6c8
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 01/23/2019
ms.locfileid: "54492509"
---
# <a name="defining-custom-types-for-use-with-net-framework-xaml-services"></a><span data-ttu-id="d2f1a-102">.NET Framework XAML 서비스에서 사용할 사용자 지정 형식 정의</span><span class="sxs-lookup"><span data-stu-id="d2f1a-102">Defining Custom Types for Use with .NET Framework XAML Services</span></span>
<span data-ttu-id="d2f1a-103">비즈니스 개체는 사용자 지정 형식을 정의 하거나 특정 프레임 워크에서 종속성을 갖지 않는 형식은 따르면 XAML에 대 한 몇 가지 최상의 방법이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d2f1a-103">When you define custom types that are business objects or are types that do not have a dependency on specific frameworks, there are certain best practices for XAML you can follow.</span></span> <span data-ttu-id="d2f1a-104">이러한 사례를 따르는 경우.NET Framework XAML 서비스 XAML 판독기 및 XAML 작성기 수 형식의 XAML 특성을 검색 하 고 XAML 노드 스트림의 XAML 형식 시스템을 사용 하 여 적절 한 표현 합니다.</span><span class="sxs-lookup"><span data-stu-id="d2f1a-104">If you follow these practices, .NET Framework XAML Services and its XAML readers and XAML writers can discover the XAML characteristics of your type and give it appropriate representation in a XAML node stream using the XAML type system.</span></span> <span data-ttu-id="d2f1a-105">이 항목에서는 형식 정의 멤버 정의 및 CLR 형식 또는 멤버의 특성에 대 한 모범 사례를 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="d2f1a-105">This topic describes best practices for type definitions, member definitions, and CLR attributing of types or members.</span></span>  
  
## <a name="constructor-patterns-and-type-definitions-for-xaml"></a><span data-ttu-id="d2f1a-106">XAML에 대 한 형식 정의와 생성자 패턴</span><span class="sxs-lookup"><span data-stu-id="d2f1a-106">Constructor Patterns and Type Definitions for XAML</span></span>  
 <span data-ttu-id="d2f1a-107">XAML에서 개체 요소로 인스턴스화하려면 사용자 지정 클래스에는 다음 요구 사항을 충족 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d2f1a-107">To be instantiated as an object element in XAML, a custom class must meet the following requirements:</span></span>  
  
-   <span data-ttu-id="d2f1a-108">사용자 지정 클래스는 public 이어야 하며 기본 (매개 변수가 없는) public 생성자를 노출 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d2f1a-108">The custom class must be public and must expose a default (parameterless) public constructor.</span></span> <span data-ttu-id="d2f1a-109">구조체에 대한 자세한 내용은 다음 섹션을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="d2f1a-109">(See following section for notes regarding structures.)</span></span>  
  
-   <span data-ttu-id="d2f1a-110">사용자 지정 클래스에는 중첩된 클래스가 아니어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d2f1a-110">The custom class must not be a nested class.</span></span> <span data-ttu-id="d2f1a-111">"점" 전체 이름 경로에 추가 클래스 네임 스페이스 나누기 모호 하 고 연결 된 속성과 같은 기타 XAML 기능을 방해 합니다.</span><span class="sxs-lookup"><span data-stu-id="d2f1a-111">The extra "dot" in the full-name path makes the class-namespace division ambiguous, and interferes with other XAML features such as attached properties.</span></span>  
  
 <span data-ttu-id="d2f1a-112">개체 요소로 개체를 인스턴스화할 수 있습니다, 하는 경우 생성된 된 개체 수 속성 요소 형식의 기본 형식으로 개체를 사용 하는 모든 속성을 입력 합니다.</span><span class="sxs-lookup"><span data-stu-id="d2f1a-112">If an object can be instantiated as an object element, the created object can fill the property element form of any properties that take the object as their underlying type.</span></span>  
  
 <span data-ttu-id="d2f1a-113">값 변환기를 사용 하는 경우 이러한 기준을 충족 하지 않는 형식에 대 한 개체 값을 계속 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d2f1a-113">You can still provide object values for types that do not meet these criteria, if you enable a value converter.</span></span> <span data-ttu-id="d2f1a-114">자세한 내용은 [Type Converters and Markup Extensions for XAML](../../../docs/framework/xaml-services/type-converters-and-markup-extensions-for-xaml.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="d2f1a-114">For more information, see [Type Converters and Markup Extensions for XAML](../../../docs/framework/xaml-services/type-converters-and-markup-extensions-for-xaml.md).</span></span>  
  
### <a name="structures"></a><span data-ttu-id="d2f1a-115">구조체</span><span class="sxs-lookup"><span data-stu-id="d2f1a-115">Structures</span></span>  
 <span data-ttu-id="d2f1a-116">구조는 항상 XAML에서 CLR 정의 의해 생성 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d2f1a-116">Structures are always able to be constructed in XAML, by CLR definition.</span></span> <span data-ttu-id="d2f1a-117">즉, CLR 컴파일러는 구조에 대 한 기본 생성자를 암시적으로 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="d2f1a-117">This is because a CLR compiler implicitly creates a default constructor for a structure.</span></span> <span data-ttu-id="d2f1a-118">이 생성자는 모든 속성 값을 기본값으로 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="d2f1a-118">This constructor initializes all property values to their defaults.</span></span>  
  
 <span data-ttu-id="d2f1a-119">일부 경우에는 구조에 대 한 기본 생성 동작 바람직하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="d2f1a-119">In some cases, the default construction behavior for a structure is not desirable.</span></span> <span data-ttu-id="d2f1a-120">구조 개념적으로 공용 구조체의 값 및 함수를 채우는 것 때문일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d2f1a-120">This might be because the structure is intended to fill values and function conceptually as a union.</span></span> <span data-ttu-id="d2f1a-121">공용 구조체의 경우 포함 된 값을 상호 배타적인 해석을 하며 따라서 해당 속성은 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d2f1a-121">As a union, the contained values might have mutually exclusive interpretations, and therefore, none of its properties are settable.</span></span> <span data-ttu-id="d2f1a-122">WPF 어휘의 이러한 구조체의 예로 <xref:System.Windows.GridLength>합니다.</span><span class="sxs-lookup"><span data-stu-id="d2f1a-122">An example of such a structure in the WPF vocabulary is <xref:System.Windows.GridLength>.</span></span> <span data-ttu-id="d2f1a-123">이러한 구조체는 값 서로 다른 해석 이나 모드는 구조체의 값을 만드는 문자열 규칙을 사용 하 여 특성 형식으로 표현할 수 있도록 형식 변환기를 구현 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d2f1a-123">Such structures should implement a type converter so that the values can be expressed in attribute form, by using string conventions that create the different interpretations or modes of the structure values.</span></span> <span data-ttu-id="d2f1a-124">이러한 구조체는 기본값이 아닌 생성자를 통해 코드를 생성하는 경우에도 이와 유사한 동작을 노출해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d2f1a-124">The structure should also expose similar behavior for code construction through a non-default constructor.</span></span>  
  
### <a name="interfaces"></a><span data-ttu-id="d2f1a-125">인터페이스</span><span class="sxs-lookup"><span data-stu-id="d2f1a-125">Interfaces</span></span>  
 <span data-ttu-id="d2f1a-126">인터페이스 멤버의 기본 형식으로 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d2f1a-126">Interfaces can be used as underlying types of members.</span></span> <span data-ttu-id="d2f1a-127">할당 가능한 목록을 검사 하 고 값으로 제공 되는 개체 인터페이스에 할당 될 수는 예상 하는 XAML 형식 시스템.</span><span class="sxs-lookup"><span data-stu-id="d2f1a-127">The XAML type system checks the assignable list and expects that the object that is provided as the value can be assigned to the interface.</span></span> <span data-ttu-id="d2f1a-128">어떻게 인터페이스 표시 되어야 하는 XAML 형식으로 할당할 수 있는 관련 형식 XAML 생성 요구 사항을 지 원하는 개념은 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d2f1a-128">There is no concept of how the interface must be presented as a XAML type as long as a relevant assignable type supports the XAML construction requirements.</span></span>  
  
### <a name="factory-methods"></a><span data-ttu-id="d2f1a-129">팩터리 메서드</span><span class="sxs-lookup"><span data-stu-id="d2f1a-129">Factory Methods</span></span>  
 <span data-ttu-id="d2f1a-130">팩터리 메서드는 XAML 2009 기능.</span><span class="sxs-lookup"><span data-stu-id="d2f1a-130">Factory methods are a XAML 2009 feature.</span></span> <span data-ttu-id="d2f1a-131">개체에 기본 생성자가 있어야 하는 XAML 원칙을 수정 합니다.</span><span class="sxs-lookup"><span data-stu-id="d2f1a-131">They modify the XAML principle that objects must have default constructors.</span></span> <span data-ttu-id="d2f1a-132">팩터리 메서드는이 항목에서 설명 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="d2f1a-132">Factory methods are not documented in this topic.</span></span> <span data-ttu-id="d2f1a-133">참조 [X:factorymethod 지시문](../../../docs/framework/xaml-services/x-factorymethod-directive.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="d2f1a-133">See [x:FactoryMethod Directive](../../../docs/framework/xaml-services/x-factorymethod-directive.md).</span></span>  
  
## <a name="enumerations"></a><span data-ttu-id="d2f1a-134">열거형</span><span class="sxs-lookup"><span data-stu-id="d2f1a-134">Enumerations</span></span>  
 <span data-ttu-id="d2f1a-135">열거형에는 XAML 네이티브 형식 변환 작동 합니다.</span><span class="sxs-lookup"><span data-stu-id="d2f1a-135">Enumerations have XAML native type conversion behavior.</span></span> <span data-ttu-id="d2f1a-136">XAML에 지정 된 열거형 상수 이름을 기본 열거형 형식에 대해 확인 되며 및 XAML 개체 작성기에 열거 값을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="d2f1a-136">Enumeration constant names specified in XAML are resolved against the underlying enumeration type, and return the enumeration value to a XAML object writer.</span></span>  
  
 <span data-ttu-id="d2f1a-137">XAML 사용 하 여 열거형에 대 한 플래그 스타일 사용 지원 <xref:System.FlagsAttribute> 적용 합니다.</span><span class="sxs-lookup"><span data-stu-id="d2f1a-137">XAML supports a flags-style usage for enumerations with <xref:System.FlagsAttribute> applied.</span></span> <span data-ttu-id="d2f1a-138">자세한 내용은 [XAML 구문 정보](../../../docs/framework/wpf/advanced/xaml-syntax-in-detail.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="d2f1a-138">For more information, see [XAML Syntax In Detail](../../../docs/framework/wpf/advanced/xaml-syntax-in-detail.md).</span></span> <span data-ttu-id="d2f1a-139">([XAML 구문 정보](../../../docs/framework/wpf/advanced/xaml-syntax-in-detail.md) WPF 대상 작성 되지만 해당 항목의 정보는 대부분은 특정 프레임 워크 구현에 한정 되지 않은 XAML에 대 한 관련.)</span><span class="sxs-lookup"><span data-stu-id="d2f1a-139">([XAML Syntax In Detail](../../../docs/framework/wpf/advanced/xaml-syntax-in-detail.md) is written for the WPF audience, but most of the information in that topic is relevant for XAML that is not specific to a particular implementing framework.)</span></span>  
  
## <a name="member-definitions"></a><span data-ttu-id="d2f1a-140">멤버 정의</span><span class="sxs-lookup"><span data-stu-id="d2f1a-140">Member Definitions</span></span>  
 <span data-ttu-id="d2f1a-141">형식은은 XAML 사용에 대 한 멤버를 정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d2f1a-141">Types can define members for XAML usage.</span></span> <span data-ttu-id="d2f1a-142">XAML에서 사용할 수 없는 형식이 해당 하는 경우에 XAML에서 사용할 수 있는 멤버를 정의 하는 형식에 대 한 것 같습니다.</span><span class="sxs-lookup"><span data-stu-id="d2f1a-142">It is possible for types that define members that are XAML-usable even if that specific type is not XAML-usable.</span></span> <span data-ttu-id="d2f1a-143">이것이 가능한 것은 CLR 상속 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="d2f1a-143">This is possible because of CLR inheritance.</span></span> <span data-ttu-id="d2f1a-144">있도록 멤버를 상속 하는 일부 형식을 형식으로 XAML 사용을 지원 하 고 구성원 해당 기본 형식에 대 한 XAML 사용을 지원 하거나 사용할 수 있는 기본 XAML 구문에 해당 멤버는 XAML에서 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d2f1a-144">So long as some type that inherits the member supports XAML usage as a type, and the member supports XAML usage for its underlying type or has a native XAML syntax available, that member is XAML-usable.</span></span>  
  
### <a name="properties"></a><span data-ttu-id="d2f1a-145">속성</span><span class="sxs-lookup"><span data-stu-id="d2f1a-145">Properties</span></span>  
 <span data-ttu-id="d2f1a-146">일반적인 CLR을 사용 하 여 공용 CLR 속성으로 속성을 정의 하는 경우 `get` 고 `set` 접근자 패턴 및 언어에 적합 한 키워드는 XAML 형식 시스템에 대 한 적절 한 정보를 사용 하 여 멤버 속성을 제공 보고할 수 <xref:System.Xaml.XamlMember> 속성을 같은 <xref:System.Xaml.XamlMember.IsReadPublic%2A> 고 <xref:System.Xaml.XamlMember.IsWritePublic%2A>입니다.</span><span class="sxs-lookup"><span data-stu-id="d2f1a-146">If you define properties as a public CLR property using the typical CLR `get` and `set` accessor patterns and language-appropriate keywording, the XAML type system can report the property as a member with appropriate information provided for <xref:System.Xaml.XamlMember> properties, such as <xref:System.Xaml.XamlMember.IsReadPublic%2A> and <xref:System.Xaml.XamlMember.IsWritePublic%2A>.</span></span>  
  
 <span data-ttu-id="d2f1a-147">특정 속성을 적용 하 여 텍스트 구문 가능 <xref:System.ComponentModel.TypeConverterAttribute>합니다.</span><span class="sxs-lookup"><span data-stu-id="d2f1a-147">Specific properties can enable a text syntax by applying <xref:System.ComponentModel.TypeConverterAttribute>.</span></span> <span data-ttu-id="d2f1a-148">자세한 내용은 [Type Converters and Markup Extensions for XAML](../../../docs/framework/xaml-services/type-converters-and-markup-extensions-for-xaml.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="d2f1a-148">For more information, see [Type Converters and Markup Extensions for XAML](../../../docs/framework/xaml-services/type-converters-and-markup-extensions-for-xaml.md).</span></span>  
  
 <span data-ttu-id="d2f1a-149">텍스트 구문 또는 네이티브 XAML 변환에 추가 간접 참조를 태그 확장 사용에는 속성의 형식 예: 없는 경우 (<xref:System.Xaml.XamlMember.TargetType%2A> 는 XAML의 형식 시스템) t를 처리 하 여 XAML 개체 작성기에 인스턴스를 반환할 수 있어야 합니다 CLR 형식으로 arget 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="d2f1a-149">In the absence of a text syntax or native XAML conversion and in the absence of further indirection, such as a markup extension usage, the type of a property (<xref:System.Xaml.XamlMember.TargetType%2A> in the XAML type system) must be able to return an instance to a XAML object writer by treating the target type as a CLR type.</span></span>  
  
 <span data-ttu-id="d2f1a-150">그러나 XAML 2009를 사용 하는 경우 [X:reference 태그 확장명](../../../docs/framework/xaml-services/x-reference-markup-extension.md) 위의 고려 사항은 충족 되지 않으면 값을 제공 하기 사용할 수 있습니다. 즉 형식 정의 문제를 보다 사용 문제를 더 합니다.</span><span class="sxs-lookup"><span data-stu-id="d2f1a-150">If using XAML 2009, [x:Reference Markup Extension](../../../docs/framework/xaml-services/x-reference-markup-extension.md) can be used to provide values if the previous considerations are not met; however, that is more of a usage issue than a type definition issue.</span></span>  
  
### <a name="events"></a><span data-ttu-id="d2f1a-151">이벤트</span><span class="sxs-lookup"><span data-stu-id="d2f1a-151">Events</span></span>  
 <span data-ttu-id="d2f1a-152">공용 CLR 이벤트로 이벤트를 정의 하는 경우 XAML 형식 시스템 멤버로 사용 하 여 이벤트를 보고할 수 있습니다 <xref:System.Xaml.XamlMember.IsEvent%2A> 으로 `true`입니다.</span><span class="sxs-lookup"><span data-stu-id="d2f1a-152">If you define events as a public CLR event, the XAML type system can report the event as a member with <xref:System.Xaml.XamlMember.IsEvent%2A> as `true`.</span></span> <span data-ttu-id="d2f1a-153">.NET Framework XAML 서비스 기능의; 범위 내에서 없으면 이벤트 처리기를 연결 합니다. 이 구현에서는 특정 프레임 워크를 그대로 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="d2f1a-153">Wiring the event handlers is not within the scope of .NET Framework XAML Services capabilities; this is left to specific frameworks and implementations.</span></span>  
  
### <a name="methods"></a><span data-ttu-id="d2f1a-154">메서드</span><span class="sxs-lookup"><span data-stu-id="d2f1a-154">Methods</span></span>  
 <span data-ttu-id="d2f1a-155">메서드에 대 한 인라인 코드는 기본 XAML 기능이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="d2f1a-155">Inline code for methods is not a default XAML capability.</span></span> <span data-ttu-id="d2f1a-156">대부분의 경우에서 직접 참조 하지 메서드 멤버를 XAML에서 및 XAML의 메서드는 역할은 특정 XAML 패턴에 대 한 지원을 제공 하기 위해서만 합니다.</span><span class="sxs-lookup"><span data-stu-id="d2f1a-156">In most cases you do not directly reference method members from XAML, and the role of methods in XAML is only to provide support for specific XAML patterns.</span></span> <span data-ttu-id="d2f1a-157">[X:factorymethod 지시문](../../../docs/framework/xaml-services/x-factorymethod-directive.md) 예외가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d2f1a-157">[x:FactoryMethod Directive](../../../docs/framework/xaml-services/x-factorymethod-directive.md) is an exception.</span></span>  
  
### <a name="fields"></a><span data-ttu-id="d2f1a-158">필드</span><span class="sxs-lookup"><span data-stu-id="d2f1a-158">Fields</span></span>  
 <span data-ttu-id="d2f1a-159">CLR 디자인 지침 비정적 필드를 억제 합니다.</span><span class="sxs-lookup"><span data-stu-id="d2f1a-159">CLR design guidelines discourage nonstatic fields.</span></span> <span data-ttu-id="d2f1a-160">정적 필드에 대 한 정적 필드 값에 액세스할 수 있습니다 통해서만 [X:static 태그 확장](../../../docs/framework/xaml-services/x-static-markup-extension.md);이 경우에 수행 하지 않습니다에 대 한 필드를 노출 하기 위해 CLR 정의에서 특별히 [X:static](../../../docs/framework/xaml-services/x-static-markup-extension.md) 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="d2f1a-160">For static fields, you can access static field values only through [x:Static Markup Extension](../../../docs/framework/xaml-services/x-static-markup-extension.md); in this case you are not doing anything special in the CLR definition to expose a field for [x:Static](../../../docs/framework/xaml-services/x-static-markup-extension.md) usages.</span></span>  
  
## <a name="attachable-members"></a><span data-ttu-id="d2f1a-161">연결 가능한 멤버</span><span class="sxs-lookup"><span data-stu-id="d2f1a-161">Attachable Members</span></span>  
 <span data-ttu-id="d2f1a-162">연결 가능한 멤버 XAML 정의 형식에 대 한 접근자 메서드 패턴을 통해 노출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="d2f1a-162">Attachable members are exposed to XAML through an accessor method pattern on a defining type.</span></span> <span data-ttu-id="d2f1a-163">정의 형식 자체 XAML에서 사용 가능한 개체로 될 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="d2f1a-163">The defining type itself does not need to be XAML-usable as an object.</span></span> <span data-ttu-id="d2f1a-164">역할이 서비스 클래스를 선언 하려면 일반적인 패턴은 실제로 연결 가능한 멤버를 소유 하 고 관련된 동작을 구현 하지만 UI 표현 같은 없는 다른 기능을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="d2f1a-164">In fact, a common pattern is to declare a service class whose role is to own the attachable member and implement the related behaviors, but serve no other function such as a UI representation.</span></span> <span data-ttu-id="d2f1a-165">다음 섹션에서는 자리 표시자에 대 한 *PropertyName* 연결 가능한 멤버의 이름을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="d2f1a-165">For the following sections, the placeholder *PropertyName* represents the name of your attachable member.</span></span> <span data-ttu-id="d2f1a-166">해당 이름에서 유효 해야 합니다 [XamlName 문법](../../../docs/framework/xaml-services/xamlname-grammar.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="d2f1a-166">That name must be valid in the [XamlName Grammar](../../../docs/framework/xaml-services/xamlname-grammar.md).</span></span>  
  
 <span data-ttu-id="d2f1a-167">이러한 패턴 및 기타 메서드에 형식 간의 이름 충돌 주의 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d2f1a-167">Be cautious of name collisions between these patterns and other methods of a type.</span></span> <span data-ttu-id="d2f1a-168">패턴 중 하 나와 일치 하는 멤버가 있으면 해석 될 수는 연결 가능한 멤버 사용 경로를 XAML 프로세서에서 의도 된 경우에 합니다.</span><span class="sxs-lookup"><span data-stu-id="d2f1a-168">If a member exists that matches one of the patterns, it can be interpreted as an attachable member usage pathway by a XAML processor even if that was not your intention.</span></span>  
  
#### <a name="the-getpropertyname-accessor"></a><span data-ttu-id="d2f1a-169">GetPropertyName 접근자</span><span class="sxs-lookup"><span data-stu-id="d2f1a-169">The GetPropertyName Accessor</span></span>  
 <span data-ttu-id="d2f1a-170">`Get`*PropertyName* 접근자에 대한 서명은 다음과 같아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d2f1a-170">The signature for the `Get`*PropertyName* accessor must be:</span></span>  
  
 <span data-ttu-id="d2f1a-171">`public static object Get`*PropertyName* `(object`  `target` `)`</span><span class="sxs-lookup"><span data-stu-id="d2f1a-171">`public static object Get` *PropertyName* `(object`  `target` `)`</span></span>  
  
-   <span data-ttu-id="d2f1a-172">구현에서 보다 구체적인 형식으로 `target` 개체를 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d2f1a-172">The `target` object can be specified as a more specific type in your implementation.</span></span> <span data-ttu-id="d2f1a-173">범위에 연결 가능 멤버를 사용 하는 데 사용할 수 있습니다. 원하는 범위를 벗어나는 사용량에는 XAML 구문 분석 오류가 발생 한 후 표시 되는 잘못 된 캐스팅 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="d2f1a-173">You can use this to scope the usage of your attachable member; usages outside your intended scope will throw invalid cast exceptions that are then surfaced by a XAML parse error.</span></span> <span data-ttu-id="d2f1a-174">매개 변수 이름을 `target` 요구 되지 않지만 라는 `target` 대부분의 구현에서 규칙에 따라 합니다.</span><span class="sxs-lookup"><span data-stu-id="d2f1a-174">The parameter name `target` is not a requirement, but is named `target` by convention in most implementations.</span></span>  
  
-   <span data-ttu-id="d2f1a-175">구현에서 보다 구체적인 형식으로 반환 값을 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d2f1a-175">The return value can be specified as a more specific type in your implementation.</span></span>  
  
 <span data-ttu-id="d2f1a-176">지원에 <xref:System.ComponentModel.TypeConverter> 연결 가능한 멤버의 특성 사용에 대 한 사용 가능한 텍스트 구문을 적용 <xref:System.ComponentModel.TypeConverterAttribute> 에 `Get` *PropertyName* 접근자 합니다.</span><span class="sxs-lookup"><span data-stu-id="d2f1a-176">To support a <xref:System.ComponentModel.TypeConverter> enabled text syntax for attribute usage of the attachable member, apply <xref:System.ComponentModel.TypeConverterAttribute> to the `Get`*PropertyName* accessor.</span></span> <span data-ttu-id="d2f1a-177">적용 합니다 `get` 대신는 `set` 임의의; 보일 수 있습니다이 규칙 개념을 지원할 수 있지만 직렬화 할 수 있는 읽기 전용 연결 가능한 멤버에는 디자이너 시나리오에서 유용 합니다.</span><span class="sxs-lookup"><span data-stu-id="d2f1a-177">Applying to the `get` instead of the `set` may seem nonintuitive; however, this convention can support the concept of read-only attachable members that are serializable, which is useful in designer scenarios.</span></span>  
  
#### <a name="the-setpropertyname-accessor"></a><span data-ttu-id="d2f1a-178">SetPropertyName 접근자</span><span class="sxs-lookup"><span data-stu-id="d2f1a-178">The SetPropertyName Accessor</span></span>  
 <span data-ttu-id="d2f1a-179">집합에 대 한 서명을*PropertyName* 접근자 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d2f1a-179">The signature for the Set*PropertyName* accessor must be:</span></span>  
  
 <span data-ttu-id="d2f1a-180">`public static void Set` *PropertyName* `(object`  `target` `, object`  `value` `)`</span><span class="sxs-lookup"><span data-stu-id="d2f1a-180">`public static void Set` *PropertyName* `(object`  `target` `, object`  `value` `)`</span></span>  
  
-   <span data-ttu-id="d2f1a-181">`target` 이전 섹션에 설명 된 대로 동일한 논리와 결과 사용 하 여 구현에서 보다 구체적인 형식으로 개체를 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d2f1a-181">The `target` object can be specified as a more specific type in your implementation, with same logic and consequences as described in the previous section.</span></span>  
  
-   <span data-ttu-id="d2f1a-182">구현에서 보다 구체적인 형식으로 `value` 개체를 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d2f1a-182">The `value` object can be specified as a more specific type in your implementation.</span></span>  
  
 <span data-ttu-id="d2f1a-183">이 메서드에 대 한 값이 XAML 사용 특성 양식에서 일반적으로 입력 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d2f1a-183">Remember that the value for this method is the input coming from the XAML usage, typically in attribute form.</span></span> <span data-ttu-id="d2f1a-184">특성 및 특성 양식에서 값 변환기 지원이 있어야 텍스트 구문에 대 한 합니다 `Get` *PropertyName* 접근자입니다.</span><span class="sxs-lookup"><span data-stu-id="d2f1a-184">From attribute form there must be value converter support for a text syntax, and you attribute on the `Get`*PropertyName* accessor.</span></span>  
  
### <a name="attachable-member-stores"></a><span data-ttu-id="d2f1a-185">연결 가능한 멤버 저장소</span><span class="sxs-lookup"><span data-stu-id="d2f1a-185">Attachable Member Stores</span></span>  
 <span data-ttu-id="d2f1a-186">접근자 메서드는 일반적으로 아닙니다 연결 가능한 멤버 값을 개체 그래프를 배치할 또는 개체 그래프에서 값을 검색 하 고 제대로 serialize 할 수 있는 방법을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="d2f1a-186">The accessor methods are typically not enough to provide a means to place attachable member values into an object graph, or to retrieve values out of the object graph and serialize them properly.</span></span> <span data-ttu-id="d2f1a-187">이 기능을 제공 하는 `target` 이전 접근자 서명에서 개체 값을 저장할 수 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d2f1a-187">To provide this functionality, the `target` objects in the previous accessor signatures must be capable of storing values.</span></span> <span data-ttu-id="d2f1a-188">저장소 메커니즘 연결 가능한 멤버 있지 않은 멤버 목록에서 대상에 연결할 수 있는 멤버는 연결 가능한 멤버 원칙와 일치 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d2f1a-188">The storage mechanism should be consistent with the attachable member principle that the member is attachable to targets where the attachable member is not in the members list.</span></span> <span data-ttu-id="d2f1a-189">연결 가능한 멤버 저장소 Api를 통해.NET framework XAML 서비스 제공 구현 하는 기법 <xref:System.Xaml.IAttachedPropertyStore> 고 <xref:System.Xaml.AttachablePropertyServices>입니다.</span><span class="sxs-lookup"><span data-stu-id="d2f1a-189">.NET Framework XAML Services provides an implementation technique for attachable member stores through the APIs <xref:System.Xaml.IAttachedPropertyStore> and <xref:System.Xaml.AttachablePropertyServices>.</span></span> <span data-ttu-id="d2f1a-190"><xref:System.Xaml.IAttachedPropertyStore> XAML 작성기를 사용 하 여 저장소 구현을 검색 하는 데 사용 되 고 형식을에 구현 해야 합니다 `target` 접근자입니다.</span><span class="sxs-lookup"><span data-stu-id="d2f1a-190"><xref:System.Xaml.IAttachedPropertyStore> is used by the XAML writers to discover the store implementation, and should be implemented on the type that is the `target` of the accessors.</span></span> <span data-ttu-id="d2f1a-191">정적 <xref:System.Xaml.AttachablePropertyServices> Api는 접근자의 본문 내에서 사용 되 고에서 연결 가능한 멤버를 참조 해당 <xref:System.Xaml.AttachableMemberIdentifier>합니다.</span><span class="sxs-lookup"><span data-stu-id="d2f1a-191">The static <xref:System.Xaml.AttachablePropertyServices> APIs are used within the body of the accessors, and refer to the attachable member by its <xref:System.Xaml.AttachableMemberIdentifier>.</span></span>  
  
## <a name="xaml-related-clr-attributes"></a><span data-ttu-id="d2f1a-192">XAML 관련 CLR 특성</span><span class="sxs-lookup"><span data-stu-id="d2f1a-192">XAML-Related CLR Attributes</span></span>  
 <span data-ttu-id="d2f1a-193">올바르게 프로그램 형식, 멤버 및 어셈블리 특성을 지정 하는 것은.NET Framework XAML 서비스 XAML 형식 시스템의 정보를 보고 하기 위해 중요 합니다.</span><span class="sxs-lookup"><span data-stu-id="d2f1a-193">Correctly attributing your types, members, and assemblies is important in order to report XAML type system information to .NET Framework XAML Services.</span></span> <span data-ttu-id="d2f1a-194">이 형식을 기반으로 하는 직접.NET Framework XAML 서비스 XAML 판독기 및 XAML 작성기는 XAML 시스템 사용 하려는 경우 또는 정의 하거나 해당 XAML 판독기 및 XAML 작성기를 기반으로 하는 XAML을 활용 하 여 프레임 워크를 사용 하는 경우에 관련이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d2f1a-194">This is relevant if you intend your types for use with XAML systems that are directly based on .NET Framework XAML Services XAML readers and XAML writers, or if you define or use a XAML-utilizing framework that is based on those XAML readers and XAML writers.</span></span>  
  
 <span data-ttu-id="d2f1a-195">사용자 지정 형식 XAML 지원에 대 한 관련 된 각 XAML 관련 특성의 나열을 참조 하세요 [사용자 지정 형식 및 라이브러리에 대 한 CLR 특성 XAML-Related](../../../docs/framework/xaml-services/xaml-related-clr-attributes-for-custom-types-and-libraries.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="d2f1a-195">For a listing of each XAML-related attribute that is relevant for XAML support of your custom types, see [XAML-Related CLR Attributes for Custom Types and Libraries](../../../docs/framework/xaml-services/xaml-related-clr-attributes-for-custom-types-and-libraries.md).</span></span>  
  
## <a name="usage"></a><span data-ttu-id="d2f1a-196">사용법</span><span class="sxs-lookup"><span data-stu-id="d2f1a-196">Usage</span></span>  
 <span data-ttu-id="d2f1a-197">사용자 지정 형식 사용 해야 태그 작성자가 사용자 지정 형식을 포함 하는 어셈블리 및 CLR 네임 스페이스에 대 한 접두사를 매핑해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d2f1a-197">Usage of custom types requires that the markup author must map a prefix for the assembly and CLR namespace that contain the custom type.</span></span> <span data-ttu-id="d2f1a-198">이 절차는이 항목에서 설명 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="d2f1a-198">This procedure is not documented in this topic.</span></span>  
  
## <a name="access-level"></a><span data-ttu-id="d2f1a-199">액세스 수준</span><span class="sxs-lookup"><span data-stu-id="d2f1a-199">Access Level</span></span>  
 <span data-ttu-id="d2f1a-200">XAML을 로드 하는 형식을 인스턴스화하는 방법을 제공는 `internal` 액세스 수준입니다.</span><span class="sxs-lookup"><span data-stu-id="d2f1a-200">XAML provides a means to load and instantiate types that have an `internal` access level.</span></span> <span data-ttu-id="d2f1a-201">이 기능은 사용자 코드는 고유한 형식을 정의 하 고 다음 동일한 사용자 코드 범위에 포함 되는 태그에서 해당 클래스를 인스턴스화할 수 있도록 제공 됩니다.</span><span class="sxs-lookup"><span data-stu-id="d2f1a-201">This capability is provided so that user code can define its own types, and then instantiate those classes from markup that is also part of the same user code scope.</span></span>  
  
 <span data-ttu-id="d2f1a-202">WPF의 예제는 사용자 코드에서 정의 될 때마다를 <xref:System.Windows.Controls.UserControl> UI 동작을 리팩터링 하는 방법으로 사용 하 여 지원 클래스를 선언 하 여 사용 권한에 포함 된 수는 모든 가능한 확장 메커니즘의 일부가 아니라 것 `public` 액세스 수준입니다.</span><span class="sxs-lookup"><span data-stu-id="d2f1a-202">An example from WPF is whenever user code defines a <xref:System.Windows.Controls.UserControl> that is intended as a way to refactor a UI behavior, but not as part of any possible extension mechanism that might be implied by declaring the supporting class with `public` access level.</span></span> <span data-ttu-id="d2f1a-203">이러한를 <xref:System.Windows.Controls.UserControl> 으로 선언 될 수 있습니다 `internal` 백업 코드를 XAML 형식으로 참조 되는 동일한 어셈블리로 컴파일되는 경우에 액세스 합니다.</span><span class="sxs-lookup"><span data-stu-id="d2f1a-203">Such a <xref:System.Windows.Controls.UserControl> can be declared with `internal` access if the backing code is compiled into the same assembly from which it is referenced as a XAML type.</span></span>  
  
 <span data-ttu-id="d2f1a-204">완전 신뢰 수준에서 XAML을 로드 하 고 사용 하는 응용 프로그램에 대 한 <xref:System.Xaml.XamlObjectWriter>, 클래스 로드 `internal` 액세스 수준을 항상 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="d2f1a-204">For an application that loads XAML under full trust and uses <xref:System.Xaml.XamlObjectWriter>, loading classes with `internal` access level is always enabled.</span></span>  
  
 <span data-ttu-id="d2f1a-205">부분 신뢰 환경에서 XAML을 로드 하는 응용 프로그램에 대 한 액세스 수준 특성을 사용 하 여 제어할 수 있습니다는 <xref:System.Xaml.Permissions.XamlAccessLevel> API.</span><span class="sxs-lookup"><span data-stu-id="d2f1a-205">For an application that loads XAML under partial trust, you can control the access level characteristics by using the <xref:System.Xaml.Permissions.XamlAccessLevel> API.</span></span> <span data-ttu-id="d2f1a-206">또한 지연 메커니즘 (예: WPF 서식 파일 시스템)를 액세스 수준 권한을 전파 하 여 최종 실행된 시간 평가판;에 대 한 보존 수 있어야 이 값은 전달 하 여 내부적으로 처리 되는 <xref:System.Xaml.Permissions.XamlAccessLevel> 정보입니다.</span><span class="sxs-lookup"><span data-stu-id="d2f1a-206">Also, deferral mechanisms (such as the WPF template system) must be able to propagate any access level permissions and preserve them for the eventual run time evaluations; this is handled internally by passing the <xref:System.Xaml.Permissions.XamlAccessLevel> information.</span></span>  
  
### <a name="wpf-implementation"></a><span data-ttu-id="d2f1a-207">WPF 구현</span><span class="sxs-lookup"><span data-stu-id="d2f1a-207">WPF Implementation</span></span>  
 <span data-ttu-id="d2f1a-208">WPF XAML 모델을 사용 하는 부분 신뢰 액세스 BAML 부분 신뢰 환경에서 로드 되 면 액세스 인 제한 <xref:System.Xaml.Permissions.XamlAccessLevel.AssemblyAccessTo%2A> BAML 소스는 어셈블리에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="d2f1a-208">WPF XAML uses a partial-trust access model where if BAML is loaded under partial trust, access is restricted to <xref:System.Xaml.Permissions.XamlAccessLevel.AssemblyAccessTo%2A> for the assembly that is the BAML source.</span></span> <span data-ttu-id="d2f1a-209">WPF는 지연을 위해 다음을 사용 합니다. <xref:System.Xaml.IXamlObjectWriterFactory.GetParentSettings%2A?displayProperty=nameWithType> 액세스 수준 정보를 전달 하기 위한 메커니즘으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="d2f1a-209">For deferral, WPF uses <xref:System.Xaml.IXamlObjectWriterFactory.GetParentSettings%2A?displayProperty=nameWithType> as a mechanism for passing the access level information.</span></span>  
  
 <span data-ttu-id="d2f1a-210">WPF XAML 용어에서는 *내부 형식* 도 참조 XAML을 포함 하는 동일한 어셈블리에 의해 정의 된 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="d2f1a-210">In WPF XAML terminology, an *internal type* is a type that is defined by the same assembly that also includes the referencing XAML.</span></span> <span data-ttu-id="d2f1a-211">이러한 형식의 어셈블리를 의도적으로 생략 하는 XAML 네임 스페이스를 통해 매핑될 수 = 매핑, 예를 들어, 부분 `xmlns:local="clr-namespace:WPFApplication1"`합니다.</span><span class="sxs-lookup"><span data-stu-id="d2f1a-211">Such a type can be mapped through a XAML namespace that deliberately omits the assembly= portion of a mapping, for example, `xmlns:local="clr-namespace:WPFApplication1"`.</span></span>  <span data-ttu-id="d2f1a-212">BAML 내부 형식을 참조 하는 경우 및 형식에 있는지 `internal` 액세스 수준이 생성을 `GeneratedInternalTypeHelper` 어셈블리에 대 한 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="d2f1a-212">If BAML references an internal type and that type has `internal` access level, this generates a `GeneratedInternalTypeHelper` class for the assembly.</span></span> <span data-ttu-id="d2f1a-213">방지 하려는 경우 `GeneratedInternalTypeHelper`를 사용 하거나 `public` 액세스 수준이 또는 관련 클래스를 별도 어셈블리로 팩터링 하 고 확인 해야 해당 어셈블리가 종속입니다.</span><span class="sxs-lookup"><span data-stu-id="d2f1a-213">If you want to avoid `GeneratedInternalTypeHelper`, you either must use `public` access level, or must factor the relevant class into a separate assembly and make that assembly dependent.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="d2f1a-214">참고자료</span><span class="sxs-lookup"><span data-stu-id="d2f1a-214">See also</span></span>
- [<span data-ttu-id="d2f1a-215">사용자 지정 형식 및 라이브러리에 대한 XAML 관련 CLR 특성</span><span class="sxs-lookup"><span data-stu-id="d2f1a-215">XAML-Related CLR Attributes for Custom Types and Libraries</span></span>](../../../docs/framework/xaml-services/xaml-related-clr-attributes-for-custom-types-and-libraries.md)
- [<span data-ttu-id="d2f1a-216">XAML 서비스</span><span class="sxs-lookup"><span data-stu-id="d2f1a-216">XAML Services</span></span>](../../../docs/framework/xaml-services/index.md)

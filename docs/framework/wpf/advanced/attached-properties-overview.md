---
title: 연결된 속성 개요
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- attached properties [WPF Designer]
ms.assetid: 75928354-dc01-47e8-a018-8409aec1f32d
ms.openlocfilehash: f4e8ea9fb0643a4a434bf20fa719c3fd2d01435b
ms.sourcegitcommit: 7f8eeef060ddeb2cabfa52843776faf652c5a1f5
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 11/14/2019
ms.locfileid: "74089326"
---
# <a name="attached-properties-overview"></a><span data-ttu-id="cec56-102">연결된 속성 개요</span><span class="sxs-lookup"><span data-stu-id="cec56-102">Attached Properties Overview</span></span>

<span data-ttu-id="cec56-103">연결된 속성은 XAML로 정의되는 개념입니다.</span><span class="sxs-lookup"><span data-stu-id="cec56-103">An attached property is a concept defined by XAML.</span></span> <span data-ttu-id="cec56-104">연결된 속성은 모든 개체에 설정할 수 있는 전역 속성의 형식으로 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cec56-104">An attached property is intended to be used as a type of global property that is settable on any object.</span></span> <span data-ttu-id="cec56-105">[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]에서, 연결된 속성은 일반적으로 기존 속성 "래퍼"가 없는 종속성 속성의 특수 형식으로 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="cec56-105">In [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)], attached properties are typically defined as a specialized form of dependency property that does not have the conventional property "wrapper".</span></span>

## <span data-ttu-id="cec56-106">사전<a name="prerequisites"></a></span><span class="sxs-lookup"><span data-stu-id="cec56-106">Prerequisites <a name="prerequisites"></a></span></span>

<span data-ttu-id="cec56-107">이 항목에서는 [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] 클래스에서 기존 종속성 속성의 소비자 관점에서 종속성 속성을 이해하고 [종속성 속성 개요](dependency-properties-overview.md)를 읽었다고 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="cec56-107">This topic assumes that you understand dependency properties from the perspective of a consumer of existing dependency properties on [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] classes, and have read the [Dependency Properties Overview](dependency-properties-overview.md).</span></span> <span data-ttu-id="cec56-108">이 항목의 예제를 따르려면 XAML도 이해 하 고 WPF 응용 프로그램을 작성 하는 방법을 알고 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="cec56-108">To follow the examples in this topic, you should also understand XAML and know how to write WPF applications.</span></span>

## <span data-ttu-id="cec56-109">연결 된 속성을 사용 하는 이유<a name="attached_properties_usage"></a></span><span class="sxs-lookup"><span data-stu-id="cec56-109">Why Use Attached Properties <a name="attached_properties_usage"></a></span></span>

<span data-ttu-id="cec56-110">연결된 속성의 한 가지 목적은 다른 자식 요소가 부모 요소에서 실제로 정의되는 속성의 고유 값을 저장하도록 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="cec56-110">One purpose of an attached property is to allow different child elements to specify unique values for a property that is actually defined in a parent element.</span></span> <span data-ttu-id="cec56-111">이 시나리오의 특정 애플리케이션에서 자식 요소는 부모 요소에 [!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)]에서 표시되는 방법을 알립니다.</span><span class="sxs-lookup"><span data-stu-id="cec56-111">A specific application of this scenario is having child elements inform the parent element of how they are to be presented in the [!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)].</span></span> <span data-ttu-id="cec56-112">한 가지 예는 <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="cec56-112">One example is the <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="cec56-113"><xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> 속성은 <xref:System.Windows.Controls.DockPanel> 자체가 아닌 <xref:System.Windows.Controls.DockPanel>에 포함 된 요소에 대해 설정 되도록 설계 되었으므로 연결 된 속성으로 만들어집니다.</span><span class="sxs-lookup"><span data-stu-id="cec56-113">The <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> property is created as an attached property because it is designed to be set on elements that are contained within a <xref:System.Windows.Controls.DockPanel>, rather than on <xref:System.Windows.Controls.DockPanel> itself.</span></span> <span data-ttu-id="cec56-114"><xref:System.Windows.Controls.DockPanel> 클래스는 <xref:System.Windows.Controls.DockPanel.DockProperty>이라는 정적 <xref:System.Windows.DependencyProperty> 필드를 정의한 다음 연결 된 속성에 대 한 public 접근자로 <xref:System.Windows.Controls.DockPanel.GetDock%2A> 및 <xref:System.Windows.Controls.DockPanel.SetDock%2A> 메서드를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="cec56-114">The <xref:System.Windows.Controls.DockPanel> class defines the static <xref:System.Windows.DependencyProperty> field named <xref:System.Windows.Controls.DockPanel.DockProperty>, and then provides the <xref:System.Windows.Controls.DockPanel.GetDock%2A> and <xref:System.Windows.Controls.DockPanel.SetDock%2A> methods as public accessors for the attached property.</span></span>

## <span data-ttu-id="cec56-115">XAML의 연결 된 속성<a name="attached_properties_xaml"></a></span><span class="sxs-lookup"><span data-stu-id="cec56-115">Attached Properties in XAML <a name="attached_properties_xaml"></a></span></span>

<span data-ttu-id="cec56-116">XAML에서 구문 *AttachedPropertyProvider*. *PropertyName*을 사용하여 연결된 속성을 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="cec56-116">In XAML, you set attached properties by using the syntax *AttachedPropertyProvider*.*PropertyName*</span></span>

<span data-ttu-id="cec56-117">다음은 XAML에서 <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType>를 설정 하는 방법에 대 한 예제입니다.</span><span class="sxs-lookup"><span data-stu-id="cec56-117">The following is an example of how you can set <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> in XAML:</span></span>

[!code-xaml[PropertiesOvwSupport#APBasicUsage](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertiesOvwSupport/CSharp/page4.xaml#apbasicusage)]

<span data-ttu-id="cec56-118">사용법은 정적 속성과 약간 비슷합니다. 항상 이름으로 지정 된 인스턴스를 참조 하는 대신 연결 된 속성을 소유 하 고 등록 하는 <xref:System.Windows.Controls.DockPanel> 유형을 참조 합니다.</span><span class="sxs-lookup"><span data-stu-id="cec56-118">Note that the usage is somewhat similar to a static property; you always reference the type <xref:System.Windows.Controls.DockPanel> that owns and registers the attached property, rather than referring to any instance specified by name.</span></span>

<span data-ttu-id="cec56-119">또한 XAML에서 연결된 속성은 표시로 설정한 특성이므로 집합 작업만 관련됩니다.</span><span class="sxs-lookup"><span data-stu-id="cec56-119">Also, because an attached property in XAML is an attribute that you set in markup, only the set operation has any relevance.</span></span> <span data-ttu-id="cec56-120">스타일의 트리거와 같은 값을 비교하기 위한 일부 간접 메커니즘이 있더라도 XAML에서 속성을 직접 가져올 수 없습니다(자세한 내용은 [스타일 및 템플릿](../controls/styling-and-templating.md) 참조).</span><span class="sxs-lookup"><span data-stu-id="cec56-120">You cannot directly get a property in XAML, although there are some indirect mechanisms for comparing values, such as triggers in styles (for details, see [Styling and Templating](../controls/styling-and-templating.md)).</span></span>

### <a name="attached-property-implementation-in-wpf"></a><span data-ttu-id="cec56-121">WPF에서 연결된 속성 구현</span><span class="sxs-lookup"><span data-stu-id="cec56-121">Attached Property Implementation in WPF</span></span>

<span data-ttu-id="cec56-122">[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]에서 UI 프레젠테이션과 관련 된 WPF 형식에 있는 대부분의 연결 된 속성은 종속성 속성으로 구현 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cec56-122">In [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)], most of the attached properties that exist on WPF types that are related to UI presentation are implemented as dependency properties.</span></span> <span data-ttu-id="cec56-123">연결 된 속성은 XAML 개념 이지만 종속성 속성은 WPF 개념입니다.</span><span class="sxs-lookup"><span data-stu-id="cec56-123">Attached properties are a XAML concept, whereas dependency properties are a WPF concept.</span></span> <span data-ttu-id="cec56-124">WPF 연결 속성은 종속성 속성 이므로 속성 메타 데이터와 같은 종속성 속성 개념 및 해당 속성 메타 데이터의 기본값을 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="cec56-124">Because WPF attached properties are dependency properties, they support dependency property concepts such as property metadata, and default values from that property metadata.</span></span>

## <span data-ttu-id="cec56-125">소유 하는 형식에서 연결 된 속성을 사용 하는 방법<a name="howused"></a></span><span class="sxs-lookup"><span data-stu-id="cec56-125">How Attached Properties Are Used by the Owning Type <a name="howused"></a></span></span>

<span data-ttu-id="cec56-126">연결된 속성을 개체에 설정할 수 있지만, 속성 설정이 명확한 결과를 생성하거나 다른 개체에서 값을 사용함을 의미하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="cec56-126">Although attached properties are settable on any object, that does not automatically mean that setting the property will produce a tangible result, or that the value will ever be used by another object.</span></span> <span data-ttu-id="cec56-127">일반적으로 다양한 논리적 관계 또는 클래스 계층 구조의 개체가 연결된 속성을 정의하는 형식에 각 보고서 공통 정보를 보고할 수 있도록 연결된 속성이 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="cec56-127">Generally, attached properties are intended so that objects coming from a wide variety of possible class hierarchies or logical relationships can each report common information to the type that defines the attached property.</span></span> <span data-ttu-id="cec56-128">연결된 속성을 정의하는 형식은 이러한 모델 중 하나를 따릅니다.</span><span class="sxs-lookup"><span data-stu-id="cec56-128">The type that defines the attached property typically follows one of these models:</span></span>

- <span data-ttu-id="cec56-129">연결된 속성의 값을 설정하는 요소의 부모 요소가 될 수 있도록 연결된 속성을 정의하는 형식을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cec56-129">The type that defines the attached property is designed so that it can be the parent element of the elements that will set values for the attached property.</span></span> <span data-ttu-id="cec56-130">그러면 형식은 일부 개체 트리 구조에 대조적으로 내부 논리를 통해 자식 개체를 반복하며, 값을 가져오며 다른 방법으로 이러한 값에 작업을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="cec56-130">The type then iterates its child objects through internal logic against some object tree structure, obtains the values, and acts on those values in some manner.</span></span>

- <span data-ttu-id="cec56-131">연결된 속성을 정의하는 형식은 가능한 다양한 부모 요소와 콘텐츠 모델에 대한 자식 요소로 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="cec56-131">The type that defines the attached property will be used as the child element for a variety of possible parent elements and content models.</span></span>

- <span data-ttu-id="cec56-132">연결된 속성을 정의하는 형식은 서비스를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="cec56-132">The type that defines the attached property represents a service.</span></span> <span data-ttu-id="cec56-133">다른 형식은 연결된 속성에 대한 값을 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="cec56-133">Other types set values for the attached property.</span></span> <span data-ttu-id="cec56-134">그런 다음 속성을 설정하는 요소를 서비스의 컨텍스트에서 계산하는 경우, 연결된 속성 값은 서비스 클래스의 내부 논리를 통해 얻습니다.</span><span class="sxs-lookup"><span data-stu-id="cec56-134">Then, when the element that set the property is evaluated in the context of the service, the attached property values are obtained through internal logic of the service class.</span></span>

### <a name="an-example-of-a-parent-defined-attached-property"></a><span data-ttu-id="cec56-135">부모 정의되어 연결된 속성의 예</span><span class="sxs-lookup"><span data-stu-id="cec56-135">An Example of a Parent-Defined Attached Property</span></span>

<span data-ttu-id="cec56-136">WPF에서 연결 된 속성을 정의 하는 가장 일반적인 시나리오는 부모 요소가 자식 요소 컬렉션을 지원 하 고 각 자식 요소에 대해 동작의 세부 사항이 개별적으로 보고 되는 동작을 구현 하는 경우입니다.</span><span class="sxs-lookup"><span data-stu-id="cec56-136">The most typical scenario where WPF defines an attached property is when a parent element supports a child element collection, and also implements a behavior where the specifics of the behavior are reported individually for each child element.</span></span>

<span data-ttu-id="cec56-137"><xref:System.Windows.Controls.DockPanel>는 <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> 연결 된 속성을 정의 하 고 <xref:System.Windows.Controls.DockPanel>는 클래스 수준 코드를 렌더링 논리의 일부로 포함 합니다 (특히 <xref:System.Windows.Controls.DockPanel.MeasureOverride%2A> 및 <xref:System.Windows.Controls.DockPanel.ArrangeOverride%2A>).</span><span class="sxs-lookup"><span data-stu-id="cec56-137"><xref:System.Windows.Controls.DockPanel> defines the <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> attached property, and <xref:System.Windows.Controls.DockPanel> has class-level code as part of its rendering logic (specifically, <xref:System.Windows.Controls.DockPanel.MeasureOverride%2A> and <xref:System.Windows.Controls.DockPanel.ArrangeOverride%2A>).</span></span> <span data-ttu-id="cec56-138"><xref:System.Windows.Controls.DockPanel> 인스턴스는 항상 직계 자식 요소가 <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType>에 대 한 값을 설정 했는지 여부를 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="cec56-138">A <xref:System.Windows.Controls.DockPanel> instance will always check to see whether any of its immediate child elements have set a value for <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="cec56-139">그런 경우, 이 값은 해당 자식 요소에 적용된 렌더링 논리에 대한 입력이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cec56-139">If so, those values become input for the rendering logic applied to that particular child element.</span></span> <span data-ttu-id="cec56-140">중첩 된 <xref:System.Windows.Controls.DockPanel> 인스턴스는 각각 자체 직계 자식 요소 컬렉션을 처리 하지만이 동작은 <xref:System.Windows.Controls.DockPanel> <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> 값을 처리 하는 방법과 관련 하 여 구현 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cec56-140">Nested <xref:System.Windows.Controls.DockPanel> instances each treat their own immediate child element collections, but that behavior is implementation-specific to how <xref:System.Windows.Controls.DockPanel> processes <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> values.</span></span> <span data-ttu-id="cec56-141">이론적으로 직계 부모를 넘어서 요소에 영향을 주는 연결된 속성이 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cec56-141">It is theoretically possible to have attached properties that influence elements beyond the immediate parent.</span></span> <span data-ttu-id="cec56-142"><xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> 연결 된 속성이 해당 요소에 대해 작업을 수행할 <xref:System.Windows.Controls.DockPanel> 부모 요소가 없는 요소에 설정 된 경우에는 오류 또는 예외가 발생 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="cec56-142">If the <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> attached property is set on an element that has no <xref:System.Windows.Controls.DockPanel> parent element to act upon it, no error or exception is raised.</span></span> <span data-ttu-id="cec56-143">이는 단순히 전역 속성 값이 설정 되어 있지만 정보를 사용할 수 있는 현재 <xref:System.Windows.Controls.DockPanel> 부모가 없음을 의미 합니다.</span><span class="sxs-lookup"><span data-stu-id="cec56-143">This simply means that a global property value was set, but it has no current <xref:System.Windows.Controls.DockPanel> parent that could consume the information.</span></span>

## <span data-ttu-id="cec56-144">코드의 연결 된 속성<a name="attached_properties_code"></a></span><span class="sxs-lookup"><span data-stu-id="cec56-144">Attached Properties in Code <a name="attached_properties_code"></a></span></span>

<span data-ttu-id="cec56-145">WPF의 연결 된 속성에는 간편한 get/set 액세스를 위한 일반적인 CLR "래퍼" 메서드가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="cec56-145">Attached properties in WPF do not have the typical CLR "wrapper" methods for easy get/set access.</span></span> <span data-ttu-id="cec56-146">이는 연결 된 속성이 속성이 설정 된 인스턴스의 CLR 네임 스페이스에 포함 될 필요가 없기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="cec56-146">This is because the attached property is not necessarily part of the CLR namespace for instances where the property is set.</span></span> <span data-ttu-id="cec56-147">그러나 XAML 프로세서는 XAML을 구문 분석할 때 이러한 값을 설정할 수 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="cec56-147">However, a XAML processor must be able to set those values when XAML is parsed.</span></span> <span data-ttu-id="cec56-148">효과적인 연결 된 속성 사용을 지원 하려면 연결 된 속성의 소유자 형식이 **Get_PropertyName_** 형식으로 전용 접근자 메서드를 구현 하 고 **Set_PropertyName_** 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="cec56-148">To support an effective attached property usage, the owner type of the attached property must implement dedicated accessor methods in the form **Get_PropertyName_** and **Set_PropertyName_**.</span></span> <span data-ttu-id="cec56-149">이 전용 접근자 메서드는 코드로 연결된 속성을 가져오거나 설정하는 데도 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="cec56-149">These dedicated accessor methods are also useful to get or set the attached property in code.</span></span> <span data-ttu-id="cec56-150">코드의 관점에서 연결된 속성은 속성 접근자 대신 메서드 접근자가 있는 지원 필드와 유사하며, 지원 필드는 구체적으로 정의될 필요 없이 모든 개체에 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cec56-150">From a code perspective, an attached property is similar to a backing field that has method accessors instead of property accessors, and that backing field can exist on any object rather than needing to be specifically defined.</span></span>

<span data-ttu-id="cec56-151">다음 예제에서는 코드에서 연결된 속성을 설정하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="cec56-151">The following example shows how you can set an attached property in code.</span></span> <span data-ttu-id="cec56-152">이 예제에서 `myCheckBox`은 <xref:System.Windows.Controls.CheckBox> 클래스의 인스턴스입니다.</span><span class="sxs-lookup"><span data-stu-id="cec56-152">In this example, `myCheckBox` is an instance of the <xref:System.Windows.Controls.CheckBox> class.</span></span>

[!code-csharp[PropertiesOvwSupport#APCode](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertiesOvwSupport/CSharp/page4.xaml.cs#apcode)]
[!code-vb[PropertiesOvwSupport#APCode](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertiesOvwSupport/visualbasic/page4.xaml.vb#apcode)]

<span data-ttu-id="cec56-153">XAML 사례와 마찬가지로 `myCheckBox` 코드의 세 번째 줄에서 `myDockPanel`의 자식 요소로 아직 추가 되지 않은 경우 코드의 네 번째 줄은 예외를 발생 시 키 지 않지만 속성 값은 <xref:System.Windows.Controls.DockPanel> 부모와 상호 작용 하지 않으므로이 작업을 수행 합니다. 없는지.</span><span class="sxs-lookup"><span data-stu-id="cec56-153">Similar to the XAML case, if `myCheckBox` had not already been added as a child element of `myDockPanel` by the third line of code, the fourth line of code would not raise an exception, but the property value would not interact with a <xref:System.Windows.Controls.DockPanel> parent and thus would do nothing.</span></span> <span data-ttu-id="cec56-154">자식 요소에 설정 된 <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> 값이 <xref:System.Windows.Controls.DockPanel> 부모 요소의 현재 상태와 결합 되어 렌더링 된 응용 프로그램에서 효과적인 동작을 발생 시킵니다.</span><span class="sxs-lookup"><span data-stu-id="cec56-154">Only a <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> value set on a child element combined with the presence of a <xref:System.Windows.Controls.DockPanel> parent element will cause an effective behavior in the rendered application.</span></span> <span data-ttu-id="cec56-155">(이 경우 연결된 속성을 설정한 다음 트리에 연결할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cec56-155">(In this case, you could set the attached property, then attach to the tree.</span></span> <span data-ttu-id="cec56-156">또는 트리에 연결한 다음 연결된 속성을 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cec56-156">Or you could attach to the tree then set the attached property.</span></span> <span data-ttu-id="cec56-157">또는 동작 순서가 동일한 결과를 제공합니다.)</span><span class="sxs-lookup"><span data-stu-id="cec56-157">Either action order provides the same result.)</span></span>

## <span data-ttu-id="cec56-158">연결 된 속성 메타 데이터<a name="attached_properties_metadata"></a></span><span class="sxs-lookup"><span data-stu-id="cec56-158">Attached Property Metadata <a name="attached_properties_metadata"></a></span></span>

<span data-ttu-id="cec56-159">속성을 등록할 때 속성이 렌더링, 측정 등에 영향을 주는지 여부와 같은 속성의 특징을 지정 하도록 <xref:System.Windows.FrameworkPropertyMetadata> 설정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cec56-159">When registering the property, <xref:System.Windows.FrameworkPropertyMetadata> is set to specify characteristics of the property, such as whether the property affects rendering, measurement, and so on.</span></span> <span data-ttu-id="cec56-160">연결된 속성에 대한 메타데이터는 일반적으로 종속성 속성과 차이가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="cec56-160">Metadata for an attached property is generally no different than on a dependency property.</span></span> <span data-ttu-id="cec56-161">연결된 속성 메타데이터 재정의에서 기본값을 지정하는 경우, 해당 값은 재정의 클래스의 인스턴스에서 암시적 연결된 속성의 기본값이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cec56-161">If you specify a default value in an override to attached property metadata, that value becomes the default value of the implicit attached property on instances of the overriding class.</span></span> <span data-ttu-id="cec56-162">특히, 일부 프로세스가 해당 속성에 대한 `Get` 메서드 접근자를 통해 연결된 속성의 값을 쿼리하는 경우 기본값이 보고되어, 메타데이터를 지정한 클래스의 인스턴스 및 연결된 속성이 설정되지 않은 값을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="cec56-162">Specifically, your default value is reported if some process queries for the value of an attached property through the `Get` method accessor for that property, specifying an instance of the class where you specified the metadata, and the value for that attached property was otherwise not set.</span></span>

<span data-ttu-id="cec56-163">속성에 속성 값 상속을 사용하도록 설정하려는 경우, 연결되지 않은 종속성 속성이 아니라 연결된 속성을 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="cec56-163">If you want to enable property value inheritance on a property, you should use attached properties rather than non-attached dependency properties.</span></span> <span data-ttu-id="cec56-164">자세한 내용은 [속성 값 상속](property-value-inheritance.md)을 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="cec56-164">For details, see [Property Value Inheritance](property-value-inheritance.md).</span></span>

## <span data-ttu-id="cec56-165">사용자 지정 연결 된 속성<a name="custom"></a></span><span class="sxs-lookup"><span data-stu-id="cec56-165">Custom Attached Properties <a name="custom"></a></span></span>

### <span data-ttu-id="cec56-166">연결 된 속성을 만들어야 하는 경우<a name="create_attached_properties"></a></span><span class="sxs-lookup"><span data-stu-id="cec56-166">When to Create an Attached Property <a name="create_attached_properties"></a></span></span>

<span data-ttu-id="cec56-167">클래스 정의 외에 클래스에 사용할 수 있는 메커니즘을 설정하는 이유가 있는 경우 연결된 속성을 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cec56-167">You might create an attached property when there is a reason to have a property setting mechanism available for classes other than the defining class.</span></span> <span data-ttu-id="cec56-168">이에 대한 가장 일반적인 시나리오는 레이아웃입니다.</span><span class="sxs-lookup"><span data-stu-id="cec56-168">The most common scenario for this is layout.</span></span> <span data-ttu-id="cec56-169">기존 레이아웃 속성의 예로 <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType>, <xref:System.Windows.Controls.Panel.ZIndex%2A?displayProperty=nameWithType>및 <xref:System.Windows.Controls.Canvas.Top%2A?displayProperty=nameWithType>있습니다.</span><span class="sxs-lookup"><span data-stu-id="cec56-169">Examples of existing layout properties are <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType>, <xref:System.Windows.Controls.Panel.ZIndex%2A?displayProperty=nameWithType>, and <xref:System.Windows.Controls.Canvas.Top%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="cec56-170">여기에서 사용 가능한 시나리오에서는 레이아웃 제어 요소에 대한 자식 요소로 존재하는 요소가 개별적으로 해당 레이아웃 부모 요소에 대한 레이아웃 요구사항을 표현할 수 있으며, 각각은 부모가 연결된 속성으로 정의한 속성 값을 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="cec56-170">The scenario enabled here is that elements that exist as child elements to layout-controlling elements are able to express layout requirements to their layout parent elements individually, each setting a property value that the parent defined as an attached property.</span></span>

<span data-ttu-id="cec56-171">연결된 속성을 사용하기 위한 다른 시나리오는 클래스가 서비스를 나타내는 경우이며, 클래스는 서비스를 더 투명하게 통합할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cec56-171">Another scenario for using an attached property is when your class represents a service, and you want classes to be able to integrate the service more transparently.</span></span>

<span data-ttu-id="cec56-172">또 다른 시나리오는 **속성** 창 편집과 같은 VISUAL Studio WPF 디자이너 지원을 수신 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="cec56-172">Yet another scenario is to receive Visual Studio WPF Designer support, such as **Properties** window editing.</span></span> <span data-ttu-id="cec56-173">자세한 내용은 [컨트롤 제작 개요](../controls/control-authoring-overview.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="cec56-173">For more information, see [Control Authoring Overview](../controls/control-authoring-overview.md).</span></span>

<span data-ttu-id="cec56-174">앞서 언급했듯이, 속성 값 상속을 사용하려는 경우 연결된 속성으로 등록해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="cec56-174">As mentioned before, you should register as an attached property if you want to use property value inheritance.</span></span>

### <span data-ttu-id="cec56-175">연결 된 속성을 만드는 방법<a name="how_do_i_create_attached_properties"></a></span><span class="sxs-lookup"><span data-stu-id="cec56-175">How to Create an Attached Property <a name="how_do_i_create_attached_properties"></a></span></span>

<span data-ttu-id="cec56-176">클래스가 다른 형식에서 사용 하기 위해 연결 된 속성을 엄격 하 게 정의 하는 경우 클래스는 <xref:System.Windows.DependencyObject>에서 파생 될 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="cec56-176">If your class is defining the attached property strictly for use on other types, then the class does not have to derive from <xref:System.Windows.DependencyObject>.</span></span> <span data-ttu-id="cec56-177">하지만 연결 된 속성이 종속성 속성인 경우에도 전체 WPF 모델을 따르는 경우 <xref:System.Windows.DependencyObject>에서 파생 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="cec56-177">But you do need to derive from <xref:System.Windows.DependencyObject> if you follow the overall WPF model of having your attached property also be a dependency property.</span></span>

<span data-ttu-id="cec56-178"><xref:System.Windows.DependencyProperty>형식의 `public static readonly` 필드를 선언 하 여 연결 된 속성을 종속성 속성으로 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="cec56-178">Define your attached property as a dependency property by declaring a `public static readonly` field of type <xref:System.Windows.DependencyProperty>.</span></span> <span data-ttu-id="cec56-179"><xref:System.Windows.DependencyProperty.RegisterAttached%2A> 메서드의 반환 값을 사용 하 여이 필드를 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="cec56-179">You define this field by using the return value of the <xref:System.Windows.DependencyProperty.RegisterAttached%2A> method.</span></span> <span data-ttu-id="cec56-180">필드 이름은 문자열 `Property`와 함께 추가 된 연결 된 속성 이름과 일치 해야 합니다. 표시 되는 속성 및 식별 하는 속성의 이름을 지정 하는 WPF 패턴을 따라야 합니다.</span><span class="sxs-lookup"><span data-stu-id="cec56-180">The field name must match the attached property name, appended with the string `Property`, to follow the established WPF pattern of naming the identifying fields versus the properties that they represent.</span></span> <span data-ttu-id="cec56-181">또한 연결 된 속성 공급자는 정적 **Get_PropertyName_** 및 **Set_PropertyName_** 메서드를 연결 된 속성의 접근자로 제공 해야 합니다. 이 작업을 수행 하지 못하면 속성 시스템이 연결 된 속성을 사용할 수 없게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cec56-181">The attached property provider must also provide static **Get_PropertyName_** and **Set_PropertyName_** methods as accessors for the attached property; failing to do this will result in the property system being unable to use your attached property.</span></span>

> [!NOTE]
> <span data-ttu-id="cec56-182">연결 된 속성의 get 접근자를 생략 하면 속성에 대 한 데이터 바인딩이 Visual Studio 및 Blend for Visual Studio와 같은 디자인 도구에서 작동 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="cec56-182">If you omit the attached property's get accessor, data binding on the property will not work in design tools, such as Visual Studio and Blend for Visual Studio.</span></span>

#### <a name="the-get-accessor"></a><span data-ttu-id="cec56-183">Get 접근자</span><span class="sxs-lookup"><span data-stu-id="cec56-183">The Get Accessor</span></span>

<span data-ttu-id="cec56-184">**Get_PropertyName_** 접근자에 대 한 시그니처는 다음과 같아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="cec56-184">The signature for the **Get_PropertyName_** accessor must be:</span></span>

`public static object GetPropertyName(object target)`

- <span data-ttu-id="cec56-185">구현에서 보다 구체적인 형식으로 `target` 개체를 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cec56-185">The `target` object can be specified as a more specific type in your implementation.</span></span> <span data-ttu-id="cec56-186">예를 들어 <xref:System.Windows.Controls.DockPanel.GetDock%2A?displayProperty=nameWithType> 메서드는 매개 변수를 <xref:System.Windows.UIElement>으로 입력 합니다. 연결 된 속성은 <xref:System.Windows.UIElement> 인스턴스에만 설정 되기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="cec56-186">For example, the <xref:System.Windows.Controls.DockPanel.GetDock%2A?displayProperty=nameWithType> method types the parameter as <xref:System.Windows.UIElement>, because the attached property is only intended to be set on <xref:System.Windows.UIElement> instances.</span></span>

- <span data-ttu-id="cec56-187">구현에서 보다 구체적인 형식으로 반환 값을 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cec56-187">The return value can be specified as a more specific type in your implementation.</span></span> <span data-ttu-id="cec56-188">예를 들어 <xref:System.Windows.Controls.DockPanel.GetDock%2A> 메서드는 값을 해당 열거형 으로만 설정할 수 있으므로이 값을 <xref:System.Windows.Controls.Dock>으로 입력 합니다.</span><span class="sxs-lookup"><span data-stu-id="cec56-188">For example, the <xref:System.Windows.Controls.DockPanel.GetDock%2A> method types it as <xref:System.Windows.Controls.Dock>, because the value can only be set to that enumeration.</span></span>

#### <a name="the-set-accessor"></a><span data-ttu-id="cec56-189">Set 접근자</span><span class="sxs-lookup"><span data-stu-id="cec56-189">The Set Accessor</span></span>

<span data-ttu-id="cec56-190">**Set_PropertyName_** 접근자에 대 한 시그니처는 다음과 같아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="cec56-190">The signature for the **Set_PropertyName_** accessor must be:</span></span>

`public static void SetPropertyName(object target, object value)`

- <span data-ttu-id="cec56-191">구현에서 보다 구체적인 형식으로 `target` 개체를 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cec56-191">The `target` object can be specified as a more specific type in your implementation.</span></span> <span data-ttu-id="cec56-192">예를 들어 <xref:System.Windows.Controls.DockPanel.SetDock%2A> 메서드는 연결 된 속성이 <xref:System.Windows.UIElement> 인스턴스에만 설정 된 것 이기 때문에이를 <xref:System.Windows.UIElement>으로 입력 합니다.</span><span class="sxs-lookup"><span data-stu-id="cec56-192">For example, the <xref:System.Windows.Controls.DockPanel.SetDock%2A> method types it as <xref:System.Windows.UIElement>, because the attached property is only intended to be set on <xref:System.Windows.UIElement> instances.</span></span>

- <span data-ttu-id="cec56-193">구현에서 보다 구체적인 형식으로 `value` 개체를 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cec56-193">The `value` object can be specified as a more specific type in your implementation.</span></span> <span data-ttu-id="cec56-194">예를 들어 <xref:System.Windows.Controls.DockPanel.SetDock%2A> 메서드는 값을 해당 열거형 으로만 설정할 수 있으므로이 값을 <xref:System.Windows.Controls.Dock>으로 입력 합니다.</span><span class="sxs-lookup"><span data-stu-id="cec56-194">For example, the <xref:System.Windows.Controls.DockPanel.SetDock%2A> method types it as <xref:System.Windows.Controls.Dock>, because the value can only be set to that enumeration.</span></span> <span data-ttu-id="cec56-195">태그의 연결된 속성 사용에서 연결된 속성에 있는 경우, 이 메서드의 값은 XAML 로더에서 오는 입력값임을 기억하십시오.</span><span class="sxs-lookup"><span data-stu-id="cec56-195">Remember that the value for this method is the input coming from the XAML loader when it encounters your attached property in an attached property usage in markup.</span></span> <span data-ttu-id="cec56-196">해당 입력값은 태그에는 XAML 특성 값으로 지정된 값입니다.</span><span class="sxs-lookup"><span data-stu-id="cec56-196">That input is the value specified as a XAML attribute value in markup.</span></span> <span data-ttu-id="cec56-197">따라서 형식 변환, 값 직렬 변환기 또는 사용하는 형식에 대한 태그 확장 지원이 있어야, 적절한 형식이 특성 값(궁극적으로 문자열만)에서 생성될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cec56-197">Therefore there must be type conversion, value serializer, or markup extension support for the type you use, such that the appropriate type can be created from the attribute value (which is ultimately just a string).</span></span>

<span data-ttu-id="cec56-198">다음 예제에서는 **Get_PropertyName_** 및 **Set_PropertyName_** 접근자 뿐만 아니라 <xref:System.Windows.DependencyProperty.RegisterAttached%2A> 메서드를 사용 하 여 종속성 속성을 등록 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="cec56-198">The following example shows the dependency property registration (using the <xref:System.Windows.DependencyProperty.RegisterAttached%2A> method), as well as the **Get_PropertyName_** and **Set_PropertyName_** accessors.</span></span> <span data-ttu-id="cec56-199">예제에서 연결된 속성 이름은 `IsBubbleSource`입니다.</span><span class="sxs-lookup"><span data-stu-id="cec56-199">In the example, the attached property name is `IsBubbleSource`.</span></span> <span data-ttu-id="cec56-200">따라서 접근자의 이름은 `GetIsBubbleSource` 및 `SetIsBubbleSource`입니다.</span><span class="sxs-lookup"><span data-stu-id="cec56-200">Therefore, the accessors must be named `GetIsBubbleSource` and `SetIsBubbleSource`.</span></span>

[!code-csharp[WPFAquariumSln#RegisterAttachedBubbler](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#registerattachedbubbler)]
[!code-vb[WPFAquariumSln#RegisterAttachedBubbler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#registerattachedbubbler)]

#### <a name="attached-property-attributes"></a><span data-ttu-id="cec56-201">연결된 속성 특성</span><span class="sxs-lookup"><span data-stu-id="cec56-201">Attached Property Attributes</span></span>

<span data-ttu-id="cec56-202">WPF는 리플렉션 프로세스에 연결 된 속성에 대 한 정보를 제공 하기 위한 여러 가지 .NET 특성과 디자이너와 같은 리플렉션 및 속성 정보에 대 한 일반적인 사용자를 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="cec56-202">WPF defines several .NET attributes that are intended to provide information about attached properties to reflection processes, and to typical users of reflection and property information such as designers.</span></span> <span data-ttu-id="cec56-203">연결된 속성에 제한이 없는 범위의 형식이 있기 때문에 디자이너는 XAML을 사용하는 특정 기술 구현에 정의된 모든 연결된 속성의 전역 목록을 사용하여 사용자의 과부하를 피할 수 있는 방법이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="cec56-203">Because attached properties have a type of unlimited scope, designers need a way to avoid overwhelming users with a global list of all the attached properties that are defined in a particular technology implementation that uses XAML.</span></span> <span data-ttu-id="cec56-204">WPF에서 연결 된 속성에 대해 정의 하는 .NET 특성을 사용 하 여 지정 된 연결 된 속성이 속성 창에 표시 되는 상황을 범위를 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cec56-204">The .NET attributes that WPF defines for attached properties can be used to scope the situations where a given attached property should be shown in a properties window.</span></span> <span data-ttu-id="cec56-205">또한 사용자 고유의 사용자 지정 연결된 속성에 대한 이러한 특성을 적용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="cec56-205">You might consider applying these attributes for your own custom attached properties also.</span></span> <span data-ttu-id="cec56-206">.NET 특성의 목적과 구문은 적절 한 참조 페이지에 설명 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cec56-206">The purpose and syntax of the .NET attributes is described on the appropriate reference pages:</span></span>

- <xref:System.Windows.AttachedPropertyBrowsableAttribute>

- <xref:System.Windows.AttachedPropertyBrowsableForChildrenAttribute>

- <xref:System.Windows.AttachedPropertyBrowsableForTypeAttribute>

- <xref:System.Windows.AttachedPropertyBrowsableWhenAttributePresentAttribute>

## <span data-ttu-id="cec56-207">연결 된 속성에 대해 자세히 알아보기<a name="more"></a></span><span class="sxs-lookup"><span data-stu-id="cec56-207">Learning More About Attached Properties <a name="more"></a></span></span>

- <span data-ttu-id="cec56-208">연결된 속성을 만드는 방법에 대한 자세한 내용은 [연결된 속성 등록](how-to-register-an-attached-property.md)을 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="cec56-208">For more information on creating an attached property, see [Register an Attached Property](how-to-register-an-attached-property.md).</span></span>

- <span data-ttu-id="cec56-209">종속성 속성 및 연결된 속성에 대한 고급 사용 시나리오는 [사용자 지정 종속성 속성](custom-dependency-properties.md)을 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="cec56-209">For more advanced usage scenarios for dependency properties and attached properties, see [Custom Dependency Properties](custom-dependency-properties.md).</span></span>

- <span data-ttu-id="cec56-210">연결된 속성 및 종속성 속성으로 속성을 등록할 수도 있지만 "래퍼" 구현이 여전히 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="cec56-210">You can also register a property as an attached property, and as a dependency property, but then still expose "wrapper" implementations.</span></span> <span data-ttu-id="cec56-211">이 경우 속성은 해당 요소 또는 XAML 연결된 속성 구문을 통해 모든 요소에 설정될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cec56-211">In this case, the property can be set either on that element, or on any element through the XAML attached property syntax.</span></span> <span data-ttu-id="cec56-212">표준 및 연결 된 사용에 대 한 적절 한 시나리오를 포함 하는 속성의 예는 <xref:System.Windows.FrameworkElement.FlowDirection%2A?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="cec56-212">An example of a property with an appropriate scenario for both standard and attached usages is <xref:System.Windows.FrameworkElement.FlowDirection%2A?displayProperty=nameWithType>.</span></span>

## <a name="see-also"></a><span data-ttu-id="cec56-213">참조</span><span class="sxs-lookup"><span data-stu-id="cec56-213">See also</span></span>

- <xref:System.Windows.DependencyProperty>
- [<span data-ttu-id="cec56-214">종속성 속성 개요</span><span class="sxs-lookup"><span data-stu-id="cec56-214">Dependency Properties Overview</span></span>](dependency-properties-overview.md)
- [<span data-ttu-id="cec56-215">사용자 지정 종속성 속성</span><span class="sxs-lookup"><span data-stu-id="cec56-215">Custom Dependency Properties</span></span>](custom-dependency-properties.md)
- [<span data-ttu-id="cec56-216">XAML 개요(WPF)</span><span class="sxs-lookup"><span data-stu-id="cec56-216">XAML Overview (WPF)</span></span>](../../../desktop-wpf/fundamentals/xaml.md)
- [<span data-ttu-id="cec56-217">연결된 속성 등록</span><span class="sxs-lookup"><span data-stu-id="cec56-217">Register an Attached Property</span></span>](how-to-register-an-attached-property.md)

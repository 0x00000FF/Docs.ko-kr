---
title: 코드 숨미기 및 XAML
ms.date: 03/30/2017
helpviewer_keywords:
- XAML [WPF], code-behind
- code-behind files [WPF], XAML
ms.assetid: 9df6d3c9-aed3-471c-af36-6859b19d999f
ms.openlocfilehash: 32283d5b81bf92999a97711ded13a8b533ae3028
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/12/2020
ms.locfileid: "79145347"
---
# <a name="code-behind-and-xaml-in-wpf"></a><span data-ttu-id="a3dd8-102">WPF의 코드 숨김 및 XAML</span><span class="sxs-lookup"><span data-stu-id="a3dd8-102">Code-Behind and XAML in WPF</span></span>
<a name="introduction"></a><span data-ttu-id="a3dd8-103">Code-behind는 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] 페이지가 마크업 컴파일될 때 태그 정의 개체와 결합된 코드를 설명하는 데 사용되는 용어입니다.</span><span class="sxs-lookup"><span data-stu-id="a3dd8-103">Code-behind is a term used to describe the code that is joined with markup-defined objects, when a [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] page is markup-compiled.</span></span> <span data-ttu-id="a3dd8-104">이 항목에서는 코드 숨김에 대한 요구 사항과 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]의 코드에 대한 대체 인라인 코드 메커니즘에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="a3dd8-104">This topic describes requirements for code-behind as well as an alternative inline code mechanism for code in [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)].</span></span>  
  
 <span data-ttu-id="a3dd8-105">이 항목에는 다음과 같은 섹션이 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a3dd8-105">This topic contains the following sections:</span></span>  
  
- [<span data-ttu-id="a3dd8-106">필수 조건</span><span class="sxs-lookup"><span data-stu-id="a3dd8-106">Prerequisites</span></span>](#Prerequisites)  
  
- [<span data-ttu-id="a3dd8-107">코드 숨미기 및 XAML 언어</span><span class="sxs-lookup"><span data-stu-id="a3dd8-107">Code-Behind and the XAML Language</span></span>](#codebehind_and_the_xaml_language)  
  
- [<span data-ttu-id="a3dd8-108">WPF의 코드 숨김, 이벤트 처리기 및 부분 클래스 요구 사항</span><span class="sxs-lookup"><span data-stu-id="a3dd8-108">Code-behind, Event Handler, and Partial Class Requirements in WPF</span></span>](#Code_behind__Event_Handler__and_Partial_Class)  
  
- [<span data-ttu-id="a3dd8-109">X:code</span><span class="sxs-lookup"><span data-stu-id="a3dd8-109">x:Code</span></span>](#x_Code)  
  
- [<span data-ttu-id="a3dd8-110">인라인 코드 제한</span><span class="sxs-lookup"><span data-stu-id="a3dd8-110">Inline Code Limitations</span></span>](#Inline_Code_Limitations)  
  
<a name="Prerequisites"></a>
## <a name="prerequisites"></a><span data-ttu-id="a3dd8-111">전제 조건</span><span class="sxs-lookup"><span data-stu-id="a3dd8-111">Prerequisites</span></span>  
 <span data-ttu-id="a3dd8-112">이 항목에서는 [XAML 개요(WPF)를](../../../desktop-wpf/fundamentals/xaml.md) 읽고 CLR 및 개체 지향 프로그래밍에 대한 몇 가지 기본 지식을 가지고 있다고 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="a3dd8-112">This topic assumes that you have read the [XAML Overview (WPF)](../../../desktop-wpf/fundamentals/xaml.md) and have some basic knowledge of the CLR and object-oriented programming.</span></span>  
  
<a name="codebehind_and_the_xaml_language"></a>
## <a name="code-behind-and-the-xaml-language"></a><span data-ttu-id="a3dd8-113">코드 숨미기 및 XAML 언어</span><span class="sxs-lookup"><span data-stu-id="a3dd8-113">Code-Behind and the XAML Language</span></span>  
 <span data-ttu-id="a3dd8-114">XAML 언어에는 태그 파일 측에서 코드 파일을 태그 파일과 연결할 수 있는 언어 수준 기능이 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a3dd8-114">The XAML language includes language-level features that make it possible to associate code files with markup files, from the markup file side.</span></span> <span data-ttu-id="a3dd8-115">특히 XAML 언어는 언어 기능 [x:Class 지시문](../../../desktop-wpf/xaml-services/xclass-directive.md), [x:하위 클래스 지시문](../../../desktop-wpf/xaml-services/xsubclass-directive.md)및 [x:ClassModifier 지시문을](../../../desktop-wpf/xaml-services/xclassmodifier-directive.md)정의합니다.</span><span class="sxs-lookup"><span data-stu-id="a3dd8-115">Specifically, the XAML language defines the language features [x:Class Directive](../../../desktop-wpf/xaml-services/xclass-directive.md), [x:Subclass Directive](../../../desktop-wpf/xaml-services/xsubclass-directive.md), and [x:ClassModifier Directive](../../../desktop-wpf/xaml-services/xclassmodifier-directive.md).</span></span> <span data-ttu-id="a3dd8-116">코드를 생성하는 방법과 태그 및 코드를 통합하는 방법은 XAML 언어가 지정한 내용의 일부가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="a3dd8-116">Exactly how the code should be produced, and how to integrate markup and code, is not part of what the XAML language specifies.</span></span> <span data-ttu-id="a3dd8-117">코드를 통합하는 방법, 응용 프로그램 및 프로그래밍 모델에서 XAML을 사용하는 방법, 이 모든 것이 필요한 빌드 작업 또는 기타 지원을 결정하는 방법은 WPF와 같은 프레임워크에 달려 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a3dd8-117">It is left up to frameworks such as WPF to determine how to integrate the code, how to use XAML in the application and programming models, and the build actions or other support that all this requires.</span></span>  
  
<a name="Code_behind__Event_Handler__and_Partial_Class"></a>
## <a name="code-behind-event-handler-and-partial-class-requirements-in-wpf"></a><span data-ttu-id="a3dd8-118">WPF의 코드 숨김, 이벤트 처리기 및 부분 클래스 요구 사항</span><span class="sxs-lookup"><span data-stu-id="a3dd8-118">Code-behind, Event Handler, and Partial Class Requirements in WPF</span></span>  
  
- <span data-ttu-id="a3dd8-119">부분 클래스는 루트 요소를 백업하는 형식에서 파생되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a3dd8-119">The partial class must derive from the type that backs the root element.</span></span>  
  
- <span data-ttu-id="a3dd8-120">태그 컴파일 빌드 작업의 기본 동작에서 코드 뒤에 있는 부분 클래스 정의에 파생을 비워 둘 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a3dd8-120">Note that under the default behavior of the markup compile build actions, you can leave the derivation blank in the partial class definition on the code-behind side.</span></span> <span data-ttu-id="a3dd8-121">컴파일된 결과는 페이지 루트의 백업 형식이 지정되지 않은 경우에도 부분 클래스의 기준으로 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="a3dd8-121">The compiled result will assume the page root's backing type to be the basis for the partial class, even if it not specified.</span></span> <span data-ttu-id="a3dd8-122">그러나 이 동작에 의존하는 것이 좋은 방법은 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="a3dd8-122">However, relying on this behavior is not a best practice.</span></span>  
  
- <span data-ttu-id="a3dd8-123">코드 숨김에 쓰는 이벤트 처리기는 인스턴스 메서드여야 하며 정적 메서드일 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="a3dd8-123">The event handlers you write in the code-behind must be instance methods and cannot be static methods.</span></span> <span data-ttu-id="a3dd8-124">이러한 메서드는 에서 식별된 CLR 네임스페이스 `x:Class`내의 부분 클래스에 의해 정의되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a3dd8-124">These methods must be defined by the partial class within the CLR namespace identified by `x:Class`.</span></span> <span data-ttu-id="a3dd8-125">[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] 프로세서가 다른 클래스 범위의 이벤트 배선에 대한 이벤트 처리기를 찾도록 지시하도록 이벤트 처리기의 이름을 한정할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="a3dd8-125">You cannot qualify the name of an event handler to instruct a [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] processor to look for an event handler for event wiring in a different class scope.</span></span>  
  
- <span data-ttu-id="a3dd8-126">처리기는 백업 형식 시스템에서 적절한 이벤트에 대한 대리자를 일치시켜야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a3dd8-126">The handler must match the delegate for the appropriate event in the backing type system.</span></span>  
  
- <span data-ttu-id="a3dd8-127">특히 Microsoft Visual Basic 언어의 경우 언어별 `Handles` 키워드를 사용하여 처리기에서 처리기를 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]에 특성을 가진 처리기를 연결하는 대신 처리기 선언의 인스턴스 및 이벤트와 연결할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a3dd8-127">For the Microsoft Visual Basic language specifically, you can use the language-specific `Handles` keyword to associate handlers with instances and events in the handler declaration, instead of attaching handlers with attributes in [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)].</span></span> <span data-ttu-id="a3dd8-128">그러나 이 기술은 `Handles` 키워드가 특정 라우트된 이벤트 시나리오 또는 연결된 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 이벤트와 같은 이벤트 시스템의 모든 특정 기능을 지원할 수 없기 때문에 몇 가지 제한사항이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a3dd8-128">However, this technique does have some limitations because the `Handles` keyword cannot support all of the specific features of the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] event system, such as certain routed event scenarios or attached events.</span></span> <span data-ttu-id="a3dd8-129">자세한 내용은 [시각적 기본 및 WPF 이벤트 처리를](visual-basic-and-wpf-event-handling.md)참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="a3dd8-129">For details, see [Visual Basic and WPF Event Handling](visual-basic-and-wpf-event-handling.md).</span></span>  
  
<a name="x_Code"></a>
## <a name="xcode"></a><span data-ttu-id="a3dd8-130">X:code</span><span class="sxs-lookup"><span data-stu-id="a3dd8-130">x:Code</span></span>  
 <span data-ttu-id="a3dd8-131">[x:Code는](../../../desktop-wpf/xaml-services/xcode-intrinsic-xaml-type.md) 에 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]정의된 지시문 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="a3dd8-131">[x:Code](../../../desktop-wpf/xaml-services/xcode-intrinsic-xaml-type.md) is a directive element defined in [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)].</span></span> <span data-ttu-id="a3dd8-132">지시문 요소에는 `x:Code` 인라인 프로그래밍 코드가 포함될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a3dd8-132">An `x:Code` directive element can contain inline programming code.</span></span> <span data-ttu-id="a3dd8-133">인라인으로 정의된 코드는 동일한 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] 페이지에서 상호 작용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a3dd8-133">The code that is defined inline can interact with the [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] on the same page.</span></span> <span data-ttu-id="a3dd8-134">다음 예제에서는 인라인 C# 코드를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="a3dd8-134">The following example illustrates inline C# code.</span></span> <span data-ttu-id="a3dd8-135">코드는 `x:Code` 요소 내부에 있으며 코드는 `<CDATA[`다음으로 둘러싸여야 합니다. `]]>` 프로세서(스키마 또는 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 스키마 를 해석하는)가 내용을 문자 그대로 XML로 해석하지 않도록 XML의 내용을 이스케이프합니다.</span><span class="sxs-lookup"><span data-stu-id="a3dd8-135">Notice that the code is inside the `x:Code` element and that the code must be surrounded by `<CDATA[`...`]]>` to escape the contents for XML, so that a [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] processor (interpreting either the [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] schema or the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] schema) will not try to interpret the contents literally as XML.</span></span>  
  
 [!code-xaml[XAMLOvwSupport#ButtonWithInlineCode](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page4.xaml#buttonwithinlinecode)]  
  
<a name="Inline_Code_Limitations"></a>
## <a name="inline-code-limitations"></a><span data-ttu-id="a3dd8-136">인라인 코드 제한</span><span class="sxs-lookup"><span data-stu-id="a3dd8-136">Inline Code Limitations</span></span>  
 <span data-ttu-id="a3dd8-137">인라인 코드 사용을 피하거나 제한하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="a3dd8-137">You should consider avoiding or limiting the use of inline code.</span></span> <span data-ttu-id="a3dd8-138">아키텍처 및 코딩 철학측면에서 태그와 코드 숨김을 구분하여 유지하면 디자이너와 개발자 역할이 훨씬 더 구별됩니다.</span><span class="sxs-lookup"><span data-stu-id="a3dd8-138">In terms of architecture and coding philosophy, maintaining a separation between markup and code-behind keeps the designer and developer roles much more distinct.</span></span> <span data-ttu-id="a3dd8-139">보다 기술적인 수준에서인라인 코드에 대해 작성하는 코드는 항상 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] 생성된 부분 클래스에 쓰고 기본 XML 네임스페이스 매핑만 사용할 수 있기 때문에 작성하기가 어려울 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a3dd8-139">On a more technical level, the code that you write for inline code can be awkward to write, because you are always writing into the [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] generated partial class, and can only use the default XML namespace mappings.</span></span> <span data-ttu-id="a3dd8-140">문을 추가할 `using` 수 없으므로 많은 API 호출을 완전히 한정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a3dd8-140">Because you cannot add `using` statements, you must fully qualify many of the API calls that you make.</span></span> <span data-ttu-id="a3dd8-141">기본 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 매핑에는 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 어셈블리에 있는 대부분의 CLR 네임스페이스가 포함되지만 모든 CLR 네임스페이스는 포함되지 않습니다. 다른 CLR 네임스페이스에 포함된 형식 및 멤버에 대한 호출을 완전히 한정적으로 지정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a3dd8-141">The default [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] mappings include most but not all CLR namespaces that are present in the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] assemblies; you will have to fully qualify calls to types and members contained within the other CLR namespaces.</span></span> <span data-ttu-id="a3dd8-142">또한 인라인 코드의 부분 클래스 를 벗어난 것을 정의할 수 없으며 참조하는 모든 사용자 코드 엔터티는 생성된 부분 클래스 내에 멤버 또는 변수로 존재해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a3dd8-142">You also cannot define anything beyond the partial class in the inline code, and all user code entities you reference must exist as a member or variable within the generated partial class.</span></span> <span data-ttu-id="a3dd8-143">매크로 또는 전역 변수 또는 `#ifdef` 빌드 변수와 같은 다른 언어별 프로그래밍 기능도 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="a3dd8-143">Other language specific programming features, such as macros or `#ifdef` against global variables or build variables, are also not available.</span></span> <span data-ttu-id="a3dd8-144">자세한 내용은 [x:코드 고유 XAML 유형을](../../../desktop-wpf/xaml-services/xcode-intrinsic-xaml-type.md)참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="a3dd8-144">For more information, see [x:Code Intrinsic XAML Type](../../../desktop-wpf/xaml-services/xcode-intrinsic-xaml-type.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="a3dd8-145">참고 항목</span><span class="sxs-lookup"><span data-stu-id="a3dd8-145">See also</span></span>

- [<span data-ttu-id="a3dd8-146">XAML 개요(WPF)</span><span class="sxs-lookup"><span data-stu-id="a3dd8-146">XAML Overview (WPF)</span></span>](../../../desktop-wpf/fundamentals/xaml.md)
- [<span data-ttu-id="a3dd8-147">x:Code 내장 XAML 형식</span><span class="sxs-lookup"><span data-stu-id="a3dd8-147">x:Code Intrinsic XAML Type</span></span>](../../../desktop-wpf/xaml-services/xcode-intrinsic-xaml-type.md)
- [<span data-ttu-id="a3dd8-148">WPF 애플리케이션 빌드</span><span class="sxs-lookup"><span data-stu-id="a3dd8-148">Building a WPF Application</span></span>](../app-development/building-a-wpf-application-wpf.md)
- [<span data-ttu-id="a3dd8-149">XAML 구문 정보</span><span class="sxs-lookup"><span data-stu-id="a3dd8-149">XAML Syntax In Detail</span></span>](xaml-syntax-in-detail.md)

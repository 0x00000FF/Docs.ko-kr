---
title: 코드 숨김과 XAML
ms.date: 03/30/2017
helpviewer_keywords:
- XAML [WPF], code-behind
- code-behind files [WPF], XAML
ms.assetid: 9df6d3c9-aed3-471c-af36-6859b19d999f
ms.openlocfilehash: 212a37fb7fbcb7e66a669d96671333be793956df
ms.sourcegitcommit: de17a7a0a37042f0d4406f5ae5393531caeb25ba
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 01/24/2020
ms.locfileid: "76738097"
---
# <a name="code-behind-and-xaml-in-wpf"></a><span data-ttu-id="c3406-102">WPF의 코드 숨김 및 XAML</span><span class="sxs-lookup"><span data-stu-id="c3406-102">Code-Behind and XAML in WPF</span></span>
<a name="introduction"></a><span data-ttu-id="c3406-103">코드 숨김이 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] 페이지가 태그 컴파일될 때 태그 정의 개체와 조인 된 코드를 설명 하는 데 사용 되는 용어입니다.</span><span class="sxs-lookup"><span data-stu-id="c3406-103">Code-behind is a term used to describe the code that is joined with markup-defined objects, when a [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] page is markup-compiled.</span></span> <span data-ttu-id="c3406-104">이 항목에서는 코드 숨김으로 사용할 요구 사항 뿐만 아니라 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]코드에 대 한 대체 인라인 코드 메커니즘에 대해 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="c3406-104">This topic describes requirements for code-behind as well as an alternative inline code mechanism for code in [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)].</span></span>  
  
 <span data-ttu-id="c3406-105">이 항목에는 다음과 같은 단원이 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c3406-105">This topic contains the following sections:</span></span>  
  
- [<span data-ttu-id="c3406-106">전제 조건</span><span class="sxs-lookup"><span data-stu-id="c3406-106">Prerequisites</span></span>](#Prerequisites)  
  
- [<span data-ttu-id="c3406-107">코드 숨김과 XAML 언어</span><span class="sxs-lookup"><span data-stu-id="c3406-107">Code-Behind and the XAML Language</span></span>](#codebehind_and_the_xaml_language)  
  
- [<span data-ttu-id="c3406-108">WPF의 코드 숨겨진, 이벤트 처리기 및 Partial 클래스 요구 사항</span><span class="sxs-lookup"><span data-stu-id="c3406-108">Code-behind, Event Handler, and Partial Class Requirements in WPF</span></span>](#Code_behind__Event_Handler__and_Partial_Class)  
  
- [<span data-ttu-id="c3406-109">x:Code</span><span class="sxs-lookup"><span data-stu-id="c3406-109">x:Code</span></span>](#x_Code)  
  
- [<span data-ttu-id="c3406-110">인라인 코드 제한 사항</span><span class="sxs-lookup"><span data-stu-id="c3406-110">Inline Code Limitations</span></span>](#Inline_Code_Limitations)  
  
<a name="Prerequisites"></a>   
## <a name="prerequisites"></a><span data-ttu-id="c3406-111">전제 조건</span><span class="sxs-lookup"><span data-stu-id="c3406-111">Prerequisites</span></span>  
 <span data-ttu-id="c3406-112">이 항목에서는 [XAML 개요 (WPF)](../../../desktop-wpf/fundamentals/xaml.md) 를 읽고 CLR 및 개체 지향 프로그래밍에 대 한 기본적인 지식이 있다고 가정 합니다.</span><span class="sxs-lookup"><span data-stu-id="c3406-112">This topic assumes that you have read the [XAML Overview (WPF)](../../../desktop-wpf/fundamentals/xaml.md) and have some basic knowledge of the CLR and object-oriented programming.</span></span>  
  
<a name="codebehind_and_the_xaml_language"></a>   
## <a name="code-behind-and-the-xaml-language"></a><span data-ttu-id="c3406-113">코드 숨김과 XAML 언어</span><span class="sxs-lookup"><span data-stu-id="c3406-113">Code-Behind and the XAML Language</span></span>  
 <span data-ttu-id="c3406-114">XAML 언어에는 태그 파일에서 태그 파일과 코드 파일을 연결할 수 있도록 하는 언어 수준 기능이 포함 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c3406-114">The XAML language includes language-level features that make it possible to associate code files with markup files, from the markup file side.</span></span> <span data-ttu-id="c3406-115">특히 XAML 언어는 언어 기능인 [X:Class 지시문](../../../desktop-wpf/xaml-services/xclass-directive.md), [X:Subclass 지시문](../../../desktop-wpf/xaml-services/xsubclass-directive.md)및 [x:classmodifier 지시문](../../../desktop-wpf/xaml-services/xclassmodifier-directive.md)을 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="c3406-115">Specifically, the XAML language defines the language features [x:Class Directive](../../../desktop-wpf/xaml-services/xclass-directive.md), [x:Subclass Directive](../../../desktop-wpf/xaml-services/xsubclass-directive.md), and [x:ClassModifier Directive](../../../desktop-wpf/xaml-services/xclassmodifier-directive.md).</span></span> <span data-ttu-id="c3406-116">코드를 생성 하는 방법과 태그와 코드를 통합 하는 방법은 XAML 언어가 지정 하는 내용에 포함 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c3406-116">Exactly how the code should be produced, and how to integrate markup and code, is not part of what the XAML language specifies.</span></span> <span data-ttu-id="c3406-117">코드를 통합 하는 방법, 응용 프로그램 및 프로그래밍 모델에서 XAML을 사용 하는 방법, 빌드 작업 또는 모든 작업에 필요한 기타 지원을 결정 하는 WPF와 같은 프레임 워크를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="c3406-117">It is left up to frameworks such as WPF to determine how to integrate the code, how to use XAML in the application and programming models, and the build actions or other support that all this requires.</span></span>  
  
<a name="Code_behind__Event_Handler__and_Partial_Class"></a>   
## <a name="code-behind-event-handler-and-partial-class-requirements-in-wpf"></a><span data-ttu-id="c3406-118">WPF의 코드 숨겨진, 이벤트 처리기 및 Partial 클래스 요구 사항</span><span class="sxs-lookup"><span data-stu-id="c3406-118">Code-behind, Event Handler, and Partial Class Requirements in WPF</span></span>  
  
- <span data-ttu-id="c3406-119">Partial 클래스는 루트 요소를 백업 하는 형식에서 파생 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c3406-119">The partial class must derive from the type that backs the root element.</span></span>  
  
- <span data-ttu-id="c3406-120">태그 컴파일 빌드 작업의 기본 동작에서 파생 된 코드를 partial 클래스의 partial 클래스 정의에서 비워 둘 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c3406-120">Note that under the default behavior of the markup compile build actions, you can leave the derivation blank in the partial class definition on the code-behind side.</span></span> <span data-ttu-id="c3406-121">컴파일된 결과는 지정 되지 않은 경우에도 페이지 루트의 지원 형식이 partial 클래스의 기반이 된다고 가정 합니다.</span><span class="sxs-lookup"><span data-stu-id="c3406-121">The compiled result will assume the page root's backing type to be the basis for the partial class, even if it not specified.</span></span> <span data-ttu-id="c3406-122">그러나이 동작에 의존 하는 것은 좋은 방법이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="c3406-122">However, relying on this behavior is not a best practice.</span></span>  
  
- <span data-ttu-id="c3406-123">코드 숨김으로 작성 하는 이벤트 처리기는 인스턴스 메서드 여야 하며 정적 메서드가 될 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="c3406-123">The event handlers you write in the code-behind must be instance methods and cannot be static methods.</span></span> <span data-ttu-id="c3406-124">이러한 메서드는 `x:Class`로 식별 된 CLR 네임 스페이스 내의 partial 클래스에서 정의 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c3406-124">These methods must be defined by the partial class within the CLR namespace identified by `x:Class`.</span></span> <span data-ttu-id="c3406-125">다른 클래스 범위의 이벤트 연결에 대 한 이벤트 처리기를 찾도록 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] 프로세서에 지시 하는 이벤트 처리기의 이름을 한정할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="c3406-125">You cannot qualify the name of an event handler to instruct a [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] processor to look for an event handler for event wiring in a different class scope.</span></span>  
  
- <span data-ttu-id="c3406-126">처리기는 지원 형식 시스템의 해당 이벤트에 대 한 대리자와 일치 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c3406-126">The handler must match the delegate for the appropriate event in the backing type system.</span></span>  
  
- <span data-ttu-id="c3406-127">특히 Microsoft Visual Basic 언어의 경우 언어별 `Handles` 키워드를 사용 하 여 처리기를 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]특성에 연결 하는 대신 처리기 선언의 인스턴스 및 이벤트와 연결할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c3406-127">For the Microsoft Visual Basic language specifically, you can use the language-specific `Handles` keyword to associate handlers with instances and events in the handler declaration, instead of attaching handlers with attributes in [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)].</span></span> <span data-ttu-id="c3406-128">그러나 `Handles` 키워드는 특정 라우트된 이벤트 시나리오 또는 연결 된 이벤트와 같이 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 이벤트 시스템의 모든 특정 기능을 지원할 수 없기 때문에이 방법에는 몇 가지 제한이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c3406-128">However, this technique does have some limitations because the `Handles` keyword cannot support all of the specific features of the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] event system, such as certain routed event scenarios or attached events.</span></span> <span data-ttu-id="c3406-129">자세한 내용은 [Visual Basic 및 WPF 이벤트 처리](visual-basic-and-wpf-event-handling.md)를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="c3406-129">For details, see [Visual Basic and WPF Event Handling](visual-basic-and-wpf-event-handling.md).</span></span>  
  
<a name="x_Code"></a>   
## <a name="xcode"></a><span data-ttu-id="c3406-130">x:Code</span><span class="sxs-lookup"><span data-stu-id="c3406-130">x:Code</span></span>  
 <span data-ttu-id="c3406-131">[x:Code](../../../desktop-wpf/xaml-services/xcode-intrinsic-xaml-type.md) 는 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]에 정의 된 지시문 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="c3406-131">[x:Code](../../../desktop-wpf/xaml-services/xcode-intrinsic-xaml-type.md) is a directive element defined in [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)].</span></span> <span data-ttu-id="c3406-132">`x:Code` 지시문 요소는 인라인 프로그래밍 코드를 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c3406-132">An `x:Code` directive element can contain inline programming code.</span></span> <span data-ttu-id="c3406-133">인라인으로 정의 된 코드는 같은 페이지의 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] 상호 작용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c3406-133">The code that is defined inline can interact with the [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] on the same page.</span></span> <span data-ttu-id="c3406-134">다음 예제에서는 인라인 C# 코드를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="c3406-134">The following example illustrates inline C# code.</span></span> <span data-ttu-id="c3406-135">코드는 `x:Code` 요소 내에 있으며, [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] 프로세서 ([!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] 스키마 또는 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 스키마를 해석)가 내용을 그대로 XML로 해석 하지 않도록 `<CDATA[`...`]]>`에서 XML의 내용을 이스케이프 처리 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c3406-135">Notice that the code is inside the `x:Code` element and that the code must be surrounded by `<CDATA[`...`]]>` to escape the contents for XML, so that a [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] processor (interpreting either the [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] schema or the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] schema) will not try to interpret the contents literally as XML.</span></span>  
  
 [!code-xaml[XAMLOvwSupport#ButtonWithInlineCode](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page4.xaml#buttonwithinlinecode)]  
  
<a name="Inline_Code_Limitations"></a>   
## <a name="inline-code-limitations"></a><span data-ttu-id="c3406-136">인라인 코드 제한 사항</span><span class="sxs-lookup"><span data-stu-id="c3406-136">Inline Code Limitations</span></span>  
 <span data-ttu-id="c3406-137">인라인 코드 사용을 방지 하거나 제한 하는 것을 고려해 야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c3406-137">You should consider avoiding or limiting the use of inline code.</span></span> <span data-ttu-id="c3406-138">아키텍처 및 코딩 철학 측면에서 태그와 코드 숨김으로 분리를 유지 하면 디자이너와 개발자 역할이 훨씬 더 명확 하 게 유지 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c3406-138">In terms of architecture and coding philosophy, maintaining a separation between markup and code-behind keeps the designer and developer roles much more distinct.</span></span> <span data-ttu-id="c3406-139">좀 더 기술적인 수준에서 인라인 코드에 대해 작성 하는 코드는 항상 생성 되는 partial 클래스 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]에 작성 하 고 기본 XML 네임 스페이스 매핑만 사용할 수 있기 때문에 작성 하기 불편할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c3406-139">On a more technical level, the code that you write for inline code can be awkward to write, because you are always writing into the [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] generated partial class, and can only use the default XML namespace mappings.</span></span> <span data-ttu-id="c3406-140">`using` 문을 추가할 수 없으므로 많은 API 호출을 정규화 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c3406-140">Because you cannot add `using` statements, you must fully qualify many of the API calls that you make.</span></span> <span data-ttu-id="c3406-141">기본 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 매핑은 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 어셈블리에 있는 CLR 네임 스페이스를 모두 포함 하지만 대부분은 포함 하지 않습니다. 다른 CLR 네임 스페이스 내에 포함 된 형식 및 멤버에 대 한 호출을 정규화 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c3406-141">The default [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] mappings include most but not all CLR namespaces that are present in the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] assemblies; you will have to fully qualify calls to types and members contained within the other CLR namespaces.</span></span> <span data-ttu-id="c3406-142">또한 인라인 코드에서 partial 클래스 이외의 모든 항목을 정의할 수 없으며, 사용자가 참조 하는 모든 사용자 코드 엔터티는 생성 된 partial 클래스 내에 멤버 또는 변수로 존재 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c3406-142">You also cannot define anything beyond the partial class in the inline code, and all user code entities you reference must exist as a member or variable within the generated partial class.</span></span> <span data-ttu-id="c3406-143">매크로, 전역 변수 또는 빌드 변수에 대 한 `#ifdef` 같은 다른 언어 관련 프로그래밍 기능을 사용할 수도 없습니다.</span><span class="sxs-lookup"><span data-stu-id="c3406-143">Other language specific programming features, such as macros or `#ifdef` against global variables or build variables, are also not available.</span></span> <span data-ttu-id="c3406-144">자세한 내용은 [X:Code 내장 XAML 형식](../../../desktop-wpf/xaml-services/xcode-intrinsic-xaml-type.md)을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="c3406-144">For more information, see [x:Code Intrinsic XAML Type](../../../desktop-wpf/xaml-services/xcode-intrinsic-xaml-type.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="c3406-145">참조</span><span class="sxs-lookup"><span data-stu-id="c3406-145">See also</span></span>

- [<span data-ttu-id="c3406-146">XAML 개요(WPF)</span><span class="sxs-lookup"><span data-stu-id="c3406-146">XAML Overview (WPF)</span></span>](../../../desktop-wpf/fundamentals/xaml.md)
- [<span data-ttu-id="c3406-147">x:Code 내장 XAML 형식</span><span class="sxs-lookup"><span data-stu-id="c3406-147">x:Code Intrinsic XAML Type</span></span>](../../../desktop-wpf/xaml-services/xcode-intrinsic-xaml-type.md)
- [<span data-ttu-id="c3406-148">WPF 애플리케이션 빌드</span><span class="sxs-lookup"><span data-stu-id="c3406-148">Building a WPF Application</span></span>](../app-development/building-a-wpf-application-wpf.md)
- [<span data-ttu-id="c3406-149">XAML 구문 정보</span><span class="sxs-lookup"><span data-stu-id="c3406-149">XAML Syntax In Detail</span></span>](xaml-syntax-in-detail.md)

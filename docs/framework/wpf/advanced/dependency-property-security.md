---
title: 종속성 속성 보안
ms.date: 03/30/2017
helpviewer_keywords:
- wrappers [WPF], access
- wrappers [WPF], security
- dependency properties [WPF], security
- security [WPF], wrappers
- validation [WPF], dependency properties
- dependency properties [WPF], access
- security [WPF], dependency properties
ms.assetid: d10150ec-90c5-4571-8d35-84bafa2429a4
ms.openlocfilehash: 2f9de32eb8637e58c17aba2309eed33dcfdd42a7
ms.sourcegitcommit: 24a4a8eb6d8cfe7b8549fb6d823076d7c697e0c6
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 07/23/2019
ms.locfileid: "68400761"
---
# <a name="dependency-property-security"></a><span data-ttu-id="cfef6-102">종속성 속성 보안</span><span class="sxs-lookup"><span data-stu-id="cfef6-102">Dependency Property Security</span></span>
<span data-ttu-id="cfef6-103">종속성 속성은 일반적으로 public 속성으로 간주됩니다.</span><span class="sxs-lookup"><span data-stu-id="cfef6-103">Dependency properties should generally be considered to be public properties.</span></span> <span data-ttu-id="cfef6-104">[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] 속성 시스템의 특성으로 인해 종속성 속성 값에 대한 보안을 보장할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="cfef6-104">The nature of the [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] property system prevents the ability to make security guarantees about a dependency property value.</span></span>  

<a name="AccessSecurity"></a>   
## <a name="access-and-security-of-wrappers-and-dependency-properties"></a><span data-ttu-id="cfef6-105">래퍼 및 종속성 속성의 액세스 및 보안</span><span class="sxs-lookup"><span data-stu-id="cfef6-105">Access and Security of Wrappers and Dependency Properties</span></span>  
 <span data-ttu-id="cfef6-106">일반적으로 종속성 속성은 인스턴스에서 속성을 가져오거나 설정 하는 과정을 간소화 하는 "래퍼" CLR (공용 언어 런타임) 속성을 사용 하 여 구현 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cfef6-106">Typically, dependency properties are implemented along with "wrapper" common language runtime (CLR) properties that simplify getting or setting the property from an instance.</span></span> <span data-ttu-id="cfef6-107">그러나 래퍼는 실질적으로 종속성 속성과 상호 작용할 때 사용 되 <xref:System.Windows.DependencyObject.GetValue%2A> 는 <xref:System.Windows.DependencyObject.SetValue%2A> 기본 및 정적 호출을 구현 하는 편리한 메서드입니다.</span><span class="sxs-lookup"><span data-stu-id="cfef6-107">But the wrappers are really just convenience methods that implement the underlying <xref:System.Windows.DependencyObject.GetValue%2A> and <xref:System.Windows.DependencyObject.SetValue%2A> static calls that are used when interacting with dependency properties.</span></span> <span data-ttu-id="cfef6-108">다른 방법으로 생각 하면 속성은 전용 필드가 아니라 종속성 속성에 의해 지원 되는 CLR (공용 언어 런타임) 속성으로 노출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cfef6-108">Thinking of it in another way, the properties are exposed as common language runtime (CLR) properties that happen to be backed by a dependency property rather than by a private field.</span></span> <span data-ttu-id="cfef6-109">래퍼에 적용되는 보안 메커니즘은 속성 시스템 동작 및 기본 종속성 속성의 액세스와 관련이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="cfef6-109">Security mechanisms applied to the wrappers do not parallel the property system behavior and access of the underlying dependency property.</span></span> <span data-ttu-id="cfef6-110">래퍼에 대 한 보안 요구를 설정 하면 편의 메서드를 사용 하는 것만 방지 되며 또는 <xref:System.Windows.DependencyObject.GetValue%2A> <xref:System.Windows.DependencyObject.SetValue%2A>에 대 한 호출을 차단 하지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="cfef6-110">Placing a security demand on the wrapper will only prevent the usage of the convenience method but will not prevent calls to <xref:System.Windows.DependencyObject.GetValue%2A> or <xref:System.Windows.DependencyObject.SetValue%2A>.</span></span> <span data-ttu-id="cfef6-111">마찬가지로 래퍼에 보호된 액세스 또는 개인 액세스 수준을 적용해도 효과적인 보안을 제공하지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="cfef6-111">Similarly, placing protected or private access level on the wrappers does not provide any effective security.</span></span>  
  
 <span data-ttu-id="cfef6-112">사용자 고유의 종속성 속성을 작성 하는 경우 해당 저장소로 인해 호출자가 해당 <xref:System.Windows.DependencyProperty> 속성의 실제 액세스 수준에 대 한 잘못 된 정보를 얻지 못하도록 래퍼 및 식별자 필드를 public 멤버로 선언 해야 합니다. 종속성 속성으로 구현 됩니다.</span><span class="sxs-lookup"><span data-stu-id="cfef6-112">If you are writing your own dependency properties, you should declare the wrappers and the <xref:System.Windows.DependencyProperty> identifier field as public members, so that callers do not get misleading information about the true access level of that property (because of its store being implemented as a dependency property).</span></span>  
  
 <span data-ttu-id="cfef6-113">사용자 지정 종속성 속성의 경우 속성을 읽기 전용 종속성 속성으로 등록할 수 있으며,이는 해당 속성 <xref:System.Windows.DependencyPropertyKey> 에 대 한 참조를 보유 하지 않는 사용자가 속성을 설정 하는 것을 방지 하는 효과적인 방법을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="cfef6-113">For a custom dependency property, you can register your property as a read-only dependency property, and this does provide an effective means of preventing a property being set by anyone that does not hold a reference to the <xref:System.Windows.DependencyPropertyKey> for that property.</span></span> <span data-ttu-id="cfef6-114">자세한 내용은 [읽기 전용 종속성 속성](read-only-dependency-properties.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="cfef6-114">For more information, see [Read-Only Dependency Properties](read-only-dependency-properties.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="cfef6-115"><xref:System.Windows.DependencyProperty> 식별자 필드 private를 선언 하는 것은 사용할 수 없으며, 사용자 지정 클래스의 즉시 노출 되는 네임 스페이스를 줄이는 데 사용할 수 있습니다. 그러나 이러한 속성은 공용 언어와 동일한 의미에서 "private"으로 간주 되어서는 안 됩니다. 런타임 (CLR) 언어 정의는 다음 섹션에 설명 된 이유로 해당 액세스 수준을 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="cfef6-115">Declaring a <xref:System.Windows.DependencyProperty> identifier field private is not forbidden, and it can conceivably be used to help reduce the immediately exposed namespace of a custom class, but such a property should not be considered "private" in the same sense as the common language runtime (CLR) language definitions define that access level, for reasons described in the next section.</span></span>  
  
<a name="PropertySystemExposure"></a>   
## <a name="property-system-exposure-of-dependency-properties"></a><span data-ttu-id="cfef6-116">종속성 속성의 속성 시스템 노출</span><span class="sxs-lookup"><span data-stu-id="cfef6-116">Property System Exposure of Dependency Properties</span></span>  
 <span data-ttu-id="cfef6-117">일반적으로는 유용 하지 않으며, public이 아닌 모든 액세스 수준으로을 <xref:System.Windows.DependencyProperty> 선언 하는 것은 잠재적으로 잘못 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cfef6-117">It is not generally useful, and it is potentially misleading, to declare a <xref:System.Windows.DependencyProperty> as any access level other than public.</span></span> <span data-ttu-id="cfef6-118">해당 액세스 수준 설정은 다른 사용자가 선언하는 클래스에서 인스턴스에 대한 참조를 가져올 수 없도록만 합니다.</span><span class="sxs-lookup"><span data-stu-id="cfef6-118">That access level setting only prevents someone from being able to get a reference to the instance from the declaring class.</span></span> <span data-ttu-id="cfef6-119">그러나 클래스 또는 파생 클래스 인스턴스의 특정 속성을 식별 하는 수단 <xref:System.Windows.DependencyProperty> 으로를 반환 하는 속성 시스템의 여러 측면이 있으며,이 식별자는 여전히 <xref:System.Windows.DependencyObject.SetValue%2A> 호출에서 사용할 수 있습니다. 원래 정적 식별자가 public이 아닌 것으로 선언 된 경우입니다.</span><span class="sxs-lookup"><span data-stu-id="cfef6-119">But there are several aspects of the property system that will return a <xref:System.Windows.DependencyProperty> as the means of identifying a particular property as it exists on an instance of a class or a derived class instance, and this identifier is still usable in a <xref:System.Windows.DependencyObject.SetValue%2A> call even if the original static identifier is declared as nonpublic.</span></span> <span data-ttu-id="cfef6-120">또한 가상 <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> 메서드는 값이 변경 된 모든 기존 종속성 속성의 정보를 수신 합니다.</span><span class="sxs-lookup"><span data-stu-id="cfef6-120">Also, <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> virtual methods receive information of any existing dependency property that changed value.</span></span> <span data-ttu-id="cfef6-121">또한 메서드는 <xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A> 로컬로 설정 된 값이 있는 인스턴스의 속성에 대 한 식별자를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="cfef6-121">In addition, the <xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A> method returns identifiers for any property on instances with a locally set value.</span></span>  
  
### <a name="validation-and-security"></a><span data-ttu-id="cfef6-122">유효성 검사 및 보안</span><span class="sxs-lookup"><span data-stu-id="cfef6-122">Validation and Security</span></span>  
 <span data-ttu-id="cfef6-123">에 수요 <xref:System.Windows.DependencyProperty.ValidateValueCallback%2A> 를 적용 하 고 속성을 설정 하는 것을 방지 하기 위해 요청 실패에 대 한 유효성 검사 오류를 예상 하는 것은 적절 한 보안 메커니즘이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="cfef6-123">Applying a demand to a <xref:System.Windows.DependencyProperty.ValidateValueCallback%2A> and expecting the validation failure on a demand failure to prevent a property from being set is not an adequate security mechanism.</span></span> <span data-ttu-id="cfef6-124">이러한 호출자가 응용 프로그램 도메인 <xref:System.Windows.DependencyProperty.ValidateValueCallback%2A> 내에서 작동 하는 경우를 통해 적용 되는 집합 값 무효화도 억제 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="cfef6-124">Set-value invalidation enforced through <xref:System.Windows.DependencyProperty.ValidateValueCallback%2A> could also be suppressed by malicious callers, if those callers are operating within the application domain.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="cfef6-125">참고자료</span><span class="sxs-lookup"><span data-stu-id="cfef6-125">See also</span></span>

- [<span data-ttu-id="cfef6-126">사용자 지정 종속성 속성</span><span class="sxs-lookup"><span data-stu-id="cfef6-126">Custom Dependency Properties</span></span>](custom-dependency-properties.md)

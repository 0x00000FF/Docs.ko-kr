---
title: 종속성 속성 메타데이터
ms.date: 03/30/2017
helpviewer_keywords:
- APIs [WPF], metadata
- dependency properties [WPF], metadata
- metadata [WPF], for dependency properties
- overriding metadata [WPF]
ms.assetid: d01ed009-b722-41bf-b82f-fe1a8cdc50dd
ms.openlocfilehash: 3d84510fce69e81929cbe9b6088e12aaf3409769
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/12/2020
ms.locfileid: "79186363"
---
# <a name="dependency-property-metadata"></a><span data-ttu-id="c538e-102">종속성 속성 메타데이터</span><span class="sxs-lookup"><span data-stu-id="c538e-102">Dependency Property Metadata</span></span>
<span data-ttu-id="c538e-103">속성 [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] 시스템에는 리플렉션 또는 일반적인 공통 언어 런타임(CLR) 특성을 통해 속성에 대해 보고할 수 있는 것 이상으로 메타데이터 보고 시스템이 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c538e-103">The [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] property system includes a metadata reporting system that goes beyond what can be reported about a property through reflection or general common language runtime (CLR) characteristics.</span></span> <span data-ttu-id="c538e-104">또한 종속성 속성에 대한 메타데이터는 종속성 속성을 정의하는 클래스에서 고유하게 할당하고, 종속성 속성이 다른 클래스에 추가될 때 변경하며, 정의하는 기본 클래스에서 종속성 속성을 상속하는 모든 파생 클래스에서 구체적으로 재정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c538e-104">Metadata for a dependency property can also be assigned uniquely by the class that defines a dependency property, can be changed when the dependency property is added to a different class, and can be specifically overridden by all derived classes that inherit the dependency property from the defining base class.</span></span>  

<a name="prerequisites"></a>
## <a name="prerequisites"></a><span data-ttu-id="c538e-105">전제 조건</span><span class="sxs-lookup"><span data-stu-id="c538e-105">Prerequisites</span></span>  
 <span data-ttu-id="c538e-106">이 항목에서는 [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] 클래스에서 기존 종속성 속성의 이용자 관점에서 종속성 속성을 이해하고 [종속성 속성 개요](dependency-properties-overview.md)를 읽었다고 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="c538e-106">This topic assumes that you understand dependency properties from the perspective of a consumer of existing dependency properties on [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] classes, and have read the [Dependency Properties Overview](dependency-properties-overview.md).</span></span> <span data-ttu-id="c538e-107">이 항목의 예제를 따르려면 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]를 이해하고 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 애플리케이션을 작성하는 방법도 알아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c538e-107">In order to follow the examples in this topic, you should also understand [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] and know how to write [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications.</span></span>  
  
<a name="dp_metadata_contents"></a>
## <a name="how-dependency-property-metadata-is-used"></a><span data-ttu-id="c538e-108">종속성 속성 메타데이터를 사용하는 방법</span><span class="sxs-lookup"><span data-stu-id="c538e-108">How Dependency Property Metadata is Used</span></span>  
 <span data-ttu-id="c538e-109">종속성 속성 메타데이터는 종속성 속성의 특성을 검사하기 위해 쿼리할 수 있는 개체로 존재합니다.</span><span class="sxs-lookup"><span data-stu-id="c538e-109">Dependency property metadata exists as an object that can be queried to examine the characteristics of a dependency property.</span></span> <span data-ttu-id="c538e-110">또한 이 메타데이터는 속성 시스템에서 제공된 종속성 속성을 처리할 때 자주 액세스합니다.</span><span class="sxs-lookup"><span data-stu-id="c538e-110">This metadata is also accessed frequently by the property system as it processes any given dependency property.</span></span> <span data-ttu-id="c538e-111">종속성 속성에 대한 메타데이터 개체에는 다음과 같은 유형의 정보가 포함될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c538e-111">The metadata object for a dependency property can contain the following types of information:</span></span>  
  
- <span data-ttu-id="c538e-112">종속성 속성에 대한 기본값(로컬 값, 스타일, 상속 등으로 종속성 속성에 대해 다른 값을 결정할 수 없는 경우). 종속성 속성에 대한 값을 할당할 때 속성 시스템에서 사용하는 우선 순위에 기본값이 참여하는 방법에 대한 자세한 내용은 [종속성 속성 값 우선 순위를](dependency-property-value-precedence.md)참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="c538e-112">Default value for the dependency property, if no other value can be determined for the dependency property by local value, style, inheritance, etc. For a thorough discussion of how default values participate in the precedence used by the property system when assigning values for dependency properties, see [Dependency Property Value Precedence](dependency-property-value-precedence.md).</span></span>  
  
- <span data-ttu-id="c538e-113">소유자 유형별로 강제 변환 또는 변경 알림 동작에 영향을 주는 콜백 구현에 대한 참조.</span><span class="sxs-lookup"><span data-stu-id="c538e-113">References to callback implementations that affect coercion or change-notification behaviors on a per-owner-type basis.</span></span> <span data-ttu-id="c538e-114">이러한 콜백은 종종 public이 아닌 액세스 수준으로 정의되므로 일반적으로 참조가 허용된 액세스 범위 내에 있지 않으면 메타데이터에서 실제 참조를 가져올 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="c538e-114">Note that these callbacks are often defined with a nonpublic access level, so obtaining the actual references from metadata is generally not possible unless the references are within your permitted access scope.</span></span> <span data-ttu-id="c538e-115">종속성 속성 콜백에 대한 자세한 내용은 [종속성 속성 콜백 및 유효성 검사](dependency-property-callbacks-and-validation.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="c538e-115">For more information on dependency property callbacks, see [Dependency Property Callbacks and Validation](dependency-property-callbacks-and-validation.md).</span></span>  
  
- <span data-ttu-id="c538e-116">해당 종속성 속성이 WPF 프레임워크 수준 속성으로 간주되는 경우 메타데이터에는 WPF 프레임워크 수준 레이아웃 엔진 및 속성 상속 논리 같은 서비스에 대한 정보 및 상태를 보고하는 WPF 프레임워크 수준 종속성 속성 특성이 포함될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c538e-116">If the dependency property in question is considered to be a WPF framework-level property, the metadata might contain WPF framework-level dependency property characteristics, which report information and state for services such as the WPF framework-level layout engine and property inheritance logic.</span></span> <span data-ttu-id="c538e-117">이러한 측면의 종속성 속성 메타데이터에 대한 자세한 내용은 [프레임워크 속성 메타데이터](framework-property-metadata.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="c538e-117">For more information on this aspect of dependency property metadata, see [Framework Property Metadata](framework-property-metadata.md).</span></span>  
  
<a name="APIs"></a>
## <a name="metadata-apis"></a><span data-ttu-id="c538e-118">메타데이터 API</span><span class="sxs-lookup"><span data-stu-id="c538e-118">Metadata APIs</span></span>  
 <span data-ttu-id="c538e-119">속성 시스템에서 사용하는 대부분의 메타데이터 정보를 보고하는 <xref:System.Windows.PropertyMetadata> 형식은 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="c538e-119">The type that reports most of the metadata information used by the property system is the <xref:System.Windows.PropertyMetadata> class.</span></span> <span data-ttu-id="c538e-120">메타데이터 인스턴스는 종속성 속성이 속성 시스템에 등록될 때 필요에 따라 지정되며 소유자로 자신을 추가하거나 기본 클래스 종속성 속성 정의에서 상속되는 메타데이터를 재정의하는 추가 형식에 대해 다시 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c538e-120">Metadata instances are optionally specified when dependency properties are registered with the property system, and can be specified again for additional types that either add themselves as owners or override metadata they inherit from the base class dependency property definition.</span></span> <span data-ttu-id="c538e-121">속성 등록에서 메타데이터를 지정하지 않는 경우 <xref:System.Windows.PropertyMetadata> 해당 클래스의 기본값으로 기본값이 만들어집니다. 등록된 메타데이터는 인스턴스의 종속성 <xref:System.Windows.DependencyProperty.GetMetadata%2A> 속성에서 메타데이터를 가져오는 다양한 오버로드를 <xref:System.Windows.DependencyObject> 호출할 때와 같이 <xref:System.Windows.PropertyMetadata> 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="c538e-121">(For cases where a property registration does not specify metadata, a default <xref:System.Windows.PropertyMetadata> is created with default values for that class.)The registered metadata is returned as <xref:System.Windows.PropertyMetadata> when you call the various <xref:System.Windows.DependencyProperty.GetMetadata%2A> overloads that get metadata from a dependency property on a <xref:System.Windows.DependencyObject> instance.</span></span>  
  
 <span data-ttu-id="c538e-122">그런 <xref:System.Windows.PropertyMetadata> 다음 클래스는 WPF 프레임워크 수준 클래스와 같은 아키텍처 부서에 대해 보다 구체적인 메타데이터를 제공하기 위해 파생됩니다.</span><span class="sxs-lookup"><span data-stu-id="c538e-122">The <xref:System.Windows.PropertyMetadata> class is then derived from to provide more specific metadata for architectural divisions such as the WPF framework-level classes.</span></span> <span data-ttu-id="c538e-123"><xref:System.Windows.UIPropertyMetadata>은 애니메이션 보고를 <xref:System.Windows.FrameworkPropertyMetadata> 추가하고 이전 섹션에서 언급한 WPF 프레임워크 수준 속성을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="c538e-123"><xref:System.Windows.UIPropertyMetadata> adds animation reporting, and <xref:System.Windows.FrameworkPropertyMetadata> provides the WPF framework-level properties mentioned in the previous section.</span></span> <span data-ttu-id="c538e-124">종속성 속성이 등록되면 이러한 <xref:System.Windows.PropertyMetadata> 파생 클래스에 등록할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c538e-124">When dependency properties are registered, they can be registered with these <xref:System.Windows.PropertyMetadata> derived classes.</span></span> <span data-ttu-id="c538e-125">메타데이터를 검사할 때 <xref:System.Windows.PropertyMetadata> 기본 형식을 파생 된 클래스에 캐스팅 할 수 있으므로 보다 구체적인 속성을 검사할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c538e-125">When the metadata is examined, the base <xref:System.Windows.PropertyMetadata> type can potentially be cast to the derived classes so that you can examine the more specific properties.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="c538e-126">에 지정할 수 있는 <xref:System.Windows.FrameworkPropertyMetadata> 속성 특성은 이 설명서에서 "플래그"라고도 합니다.</span><span class="sxs-lookup"><span data-stu-id="c538e-126">The property characteristics that can be specified in <xref:System.Windows.FrameworkPropertyMetadata> are sometimes referred to in this documentation as "flags".</span></span> <span data-ttu-id="c538e-127">종속성 속성 등록 또는 메타데이터 재정의에 사용할 새 메타데이터 인스턴스를 만들 때 플래그지정 <xref:System.Windows.FrameworkPropertyMetadataOptions> 열거를 사용하여 이러한 값을 지정한 다음 생성자에 열거형의 <xref:System.Windows.FrameworkPropertyMetadata> 연결 가능한 값을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="c538e-127">When you create new metadata instances for use in dependency property registrations or metadata overrides, you specify these values using the flagwise enumeration <xref:System.Windows.FrameworkPropertyMetadataOptions> and then you supply possibly concatenated values of the enumeration to the <xref:System.Windows.FrameworkPropertyMetadata> constructor.</span></span> <span data-ttu-id="c538e-128">그러나 일단 생성되면 이러한 옵션 특성은 생성 열거 값이 아닌 일련의 부울 <xref:System.Windows.FrameworkPropertyMetadata> 속성으로 노출됩니다.</span><span class="sxs-lookup"><span data-stu-id="c538e-128">However, once constructed, these option characteristics are exposed within a <xref:System.Windows.FrameworkPropertyMetadata> as a series of Boolean properties rather than the constructing enumeration value.</span></span> <span data-ttu-id="c538e-129">부울 속성을 사용하면 플래그 열거형 값에 마스크를 적용하여 관심 있는 정보를 가져오는 대신 각 조건을 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c538e-129">The Boolean properties enable you to check each conditional, rather than requiring you to apply a mask to a flagwise enumeration value to get the information you are interested in.</span></span> <span data-ttu-id="c538e-130">생성자는 생성자 서명의 <xref:System.Windows.FrameworkPropertyMetadataOptions> 길이를 합리적으로 유지하기 위해 연결된 것을 사용하지만 실제 생성된 메타데이터는 불연속 속성을 노출하여 메타데이터를 보다 직관적으로 쿼리합니다.</span><span class="sxs-lookup"><span data-stu-id="c538e-130">The constructor uses the concatenated <xref:System.Windows.FrameworkPropertyMetadataOptions> in order to keep the length of the constructor signature reasonable, whereas the actual constructed metadata exposes the discrete properties to make querying the metadata more intuitive.</span></span>  
  
<a name="override_or_subclass"></a>
## <a name="when-to-override-metadata-when-to-derive-a-class"></a><span data-ttu-id="c538e-131">메타데이터를 재정의하는 경우, 클래스를 파생시키는 경우</span><span class="sxs-lookup"><span data-stu-id="c538e-131">When to Override Metadata, When to Derive a Class</span></span>  
 <span data-ttu-id="c538e-132">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 속성 시스템은 종속성 속성의 일부 특성을 완전히 다시 구현할 필요 없이 변경하는 기능을 설정했습니다.</span><span class="sxs-lookup"><span data-stu-id="c538e-132">The [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] property system has established capabilities for changing some characteristics of dependency properties without requiring them to be entirely re-implemented.</span></span> <span data-ttu-id="c538e-133">이 기능은 특정 형식에 있는 종속성 속성에 대한 속성 메타데이터의 다른 인스턴스를 생성하여 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="c538e-133">This is accomplished by constructing a different instance of property metadata for the dependency property as it exists on a particular type.</span></span> <span data-ttu-id="c538e-134">대부분의 기존 종속성 속성은 가상 속성이 아닙니다. 따라서 엄밀히 말해 상속된 클래스에서 "다시 구현"하려면 기존 멤버를 숨겨야만 합니다.</span><span class="sxs-lookup"><span data-stu-id="c538e-134">Note that most existing dependency properties are not virtual properties, so strictly speaking "re-implementing" them on inherited classes could only be accomplished by shadowing the existing member.</span></span>  
  
 <span data-ttu-id="c538e-135">특정 형식에 있는 종속성 속성에 대해 사용하려는 시나리오를 기존 종속성 속성의 특성을 수정하여 수행할 수 없는 경우 파생 클래스를 만든 다음 해당 파생 클래스에서 사용자 지정 종속성 속성을 선언해야 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c538e-135">If the scenario you are trying to enable for a dependency property on a type cannot be accomplished by modifying characteristics of existing dependency properties, it might then be necessary to create a derived class, and then to declare a custom dependency property on your derived class.</span></span> <span data-ttu-id="c538e-136">사용자 지정 종속성 속성은 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] API에 의해 정의된 종속성 속성과 동일하게 동작합니다.</span><span class="sxs-lookup"><span data-stu-id="c538e-136">A custom dependency property behaves identically to dependency properties defined by the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] APIs.</span></span> <span data-ttu-id="c538e-137">사용자 지정 종속성 속성에 대한 자세한 내용은 [사용자 지정 종속성 속성](custom-dependency-properties.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="c538e-137">For more details about custom dependency properties, see [Custom Dependency Properties](custom-dependency-properties.md).</span></span>  
  
 <span data-ttu-id="c538e-138">재정의할 수 없는 종속성 속성의 주요 특성 한 가지는 해당 값 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="c538e-138">One notable characteristic of a dependency property that you cannot override is its value type.</span></span> <span data-ttu-id="c538e-139">필요한 유사한 동작을 수행하는 종속성 속성을 상속하려고 하는데 다른 형식이 필요한 경우 사용자 지정 종속성 속성을 구현하고 사용자 지정 클래스에서 형식 변환이나 다른 구현을 통해 속성을 연결해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c538e-139">If you are inheriting a dependency property that has the approximate behavior you require, but you require a different type for it, you will have to implement a custom dependency property and perhaps link the properties through type conversion or other implementation on your custom class.</span></span> <span data-ttu-id="c538e-140">또한 이 콜백은 <xref:System.Windows.ValidateValueCallback>메타데이터 내에 있지 않고 등록 필드 자체에 존재하므로 기존 을 바꿀 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="c538e-140">Also, you cannot replace an existing <xref:System.Windows.ValidateValueCallback>, because this callback exists in the registration field itself and not within its metadata.</span></span>  
  
<a name="scenarios"></a>
## <a name="scenarios-for-changing-existing-metadata"></a><span data-ttu-id="c538e-141">기존 메타데이터 변경 시나리오</span><span class="sxs-lookup"><span data-stu-id="c538e-141">Scenarios for Changing Existing Metadata</span></span>  
 <span data-ttu-id="c538e-142">기존 종속성 속성의 메타데이터를 사용하여 작업하는 경우 종속성 속성 메타데이터를 변경하는 한 가지 일반적인 시나리오는 기본값을 변경하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="c538e-142">If you are working with metadata of an existing dependency property, one common scenario for changing dependency property metadata is to change the default value.</span></span> <span data-ttu-id="c538e-143">속성 시스템 콜백 변경 또는 추가는 고급 시나리오입니다.</span><span class="sxs-lookup"><span data-stu-id="c538e-143">Changing or adding property system callbacks is a more advanced scenario.</span></span> <span data-ttu-id="c538e-144">파생 클래스의 구현이 종속성 속성 간에 다른 상관 관계를 갖는 경우 이 작업을 수행하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="c538e-144">You might want to do this if your implementation of a derived class has different interrelationships between dependency properties.</span></span> <span data-ttu-id="c538e-145">코드와 선언적 사용을 모두 지원하는 프로그래밍 모델의 조건 중 하나는 순서에 관계없이 속성을 설정할 수 있어야 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="c538e-145">One of the conditionals of having a programming model that supports both code and declarative usage is that properties must enable being set in any order.</span></span> <span data-ttu-id="c538e-146">따라서 모든 종속 속성은 컨텍스트 없이 적시에 설정해야 하며 생성자에서 찾을 수 있는 설정 순서를 사용할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="c538e-146">Thus any dependent properties need to be set just-in-time without context and cannot rely on knowing a setting order such as might be found in a constructor.</span></span> <span data-ttu-id="c538e-147">속성 시스템의 이러한 측면에 대한 자세한 내용은 [종속성 속성 콜백 및 유효성 검사](dependency-property-callbacks-and-validation.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="c538e-147">For more information on this aspect of the property system, see [Dependency Property Callbacks and Validation](dependency-property-callbacks-and-validation.md).</span></span> <span data-ttu-id="c538e-148">유효성 검사 콜백은 메타데이터의 일부가 아니라 종속성 속성 식별자의 일부입니다.</span><span class="sxs-lookup"><span data-stu-id="c538e-148">Note that validation callbacks are not part of the metadata; they are part of the dependency property identifier.</span></span> <span data-ttu-id="c538e-149">따라서 유효성 검사 콜백은 메타데이터를 재정의하여 변경할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="c538e-149">Therefore, validation callbacks cannot be changed by overriding the metadata.</span></span>  
  
 <span data-ttu-id="c538e-150">경우에 따라 기존 종속성 속성에서 WPF 프레임워크 수준 속성 메타데이터 옵션을 변경하려고 할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c538e-150">In some cases you might also want to alter the WPF framework-level property metadata options on existing dependency properties.</span></span> <span data-ttu-id="c538e-151">이러한 옵션은 WPF 프레임워크 수준 속성에 대한 알려진 특정 조건을 레이아웃 시스템 같은 다른 WPF 프레임워크 수준 프로세스에 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="c538e-151">These options communicate certain known conditionals about WPF framework-level properties to other WPF framework-level processes such as the layout system.</span></span>  <span data-ttu-id="c538e-152">옵션 설정은 일반적으로 새 종속성 속성을 등록할 때만 수행되지만 <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> WPF 프레임워크 수준 속성 메타데이터를 또는 <xref:System.Windows.DependencyProperty.AddOwner%2A> 호출의 일부로 변경할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c538e-152">Setting the options is generally done only when registering a new dependency property, but it is also possible to change the WPF framework-level property metadata as part of a <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> or <xref:System.Windows.DependencyProperty.AddOwner%2A> call.</span></span> <span data-ttu-id="c538e-153">사용할 특정 값 및 자세한 내용은 [프레임워크 속성 메타데이터](framework-property-metadata.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="c538e-153">For the specific values to use and more information, see [Framework Property Metadata](framework-property-metadata.md).</span></span> <span data-ttu-id="c538e-154">새로 등록된 종속성 속성에 대해 이러한 옵션을 설정하는 방법과 관련된 자세한 내용은 [사용자 지정 종속성 속성](custom-dependency-properties.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="c538e-154">For more information that is pertinent to how these options should be set for a newly registered dependency property, see [Custom Dependency Properties](custom-dependency-properties.md).</span></span>  
  
<a name="dp_override_metadata"></a>
### <a name="overriding-metadata"></a><span data-ttu-id="c538e-155">메타데이터 재정의</span><span class="sxs-lookup"><span data-stu-id="c538e-155">Overriding Metadata</span></span>  
 <span data-ttu-id="c538e-156">메타데이터 재정의의 용도는 특정 형식에 있는 종속성 속성에 적용되는 다양한 메타데이터 파생 동작을 변경할 수 있도록 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="c538e-156">The purpose of overriding metadata is primarily so that you have the opportunity to change the various metadata-derived behaviors that are applied to the dependency property as it exists on your type.</span></span> <span data-ttu-id="c538e-157">그 이유는 [메타데이터](#dp_metadata_contents) 섹션에 자세히 설명되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c538e-157">The reasons for this are explained in more detail in the [Metadata](#dp_metadata_contents) section.</span></span> <span data-ttu-id="c538e-158">몇 가지 코드 예제를 비롯한 자세한 내용은 [종속성 속성의 메타데이터 재정의](how-to-override-metadata-for-a-dependency-property.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="c538e-158">For more information including some code examples, see [Override Metadata for a Dependency Property](how-to-override-metadata-for-a-dependency-property.md).</span></span>  
  
 <span data-ttu-id="c538e-159">등록 호출()동안<xref:System.Windows.DependencyProperty.Register%2A>종속성 속성에 대해 속성 메타데이터를 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c538e-159">Property metadata can be supplied for a dependency property during the registration call (<xref:System.Windows.DependencyProperty.Register%2A>).</span></span> <span data-ttu-id="c538e-160">그러나 대부분의 경우 해당 종속성 속성을 상속하는 클래스에 대해 형식별 메타데이터를 제공하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="c538e-160">However, in many cases, you might want to provide type-specific metadata for your class when it inherits that dependency property.</span></span> <span data-ttu-id="c538e-161">메서드를 <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> 호출하여 이 작업을 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c538e-161">You can do this by calling the <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> method.</span></span>  <span data-ttu-id="c538e-162">API의 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 예제에서 <xref:System.Windows.FrameworkElement> 클래스는 <xref:System.Windows.UIElement.Focusable%2A> 종속성 속성을 먼저 등록하는 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="c538e-162">For an example from the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] APIs, the <xref:System.Windows.FrameworkElement> class is the type that first registers the <xref:System.Windows.UIElement.Focusable%2A> dependency property.</span></span> <span data-ttu-id="c538e-163">그러나 <xref:System.Windows.Controls.Control> 클래스는 종속성 속성에 대한 메타데이터를 재정의하여 자체 초기 `false` `true`기본값을 제공하고 원래 <xref:System.Windows.UIElement.Focusable%2A> 구현을 에서 로 변경하고 다시 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="c538e-163">But the <xref:System.Windows.Controls.Control> class overrides metadata for the dependency property to provide its own initial default value, changing it from `false` to `true`, and otherwise re-uses the original <xref:System.Windows.UIElement.Focusable%2A> implementation.</span></span>  
  
 <span data-ttu-id="c538e-164">메타데이터를 재정의하는 경우 서로 다른 메타데이터 특성이 병합되거나 대체됩니다.</span><span class="sxs-lookup"><span data-stu-id="c538e-164">When you override metadata, the different metadata characteristics are either merged or replaced.</span></span>  
  
- <span data-ttu-id="c538e-165"><xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A>병합됩니다.</span><span class="sxs-lookup"><span data-stu-id="c538e-165"><xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> is merged.</span></span> <span data-ttu-id="c538e-166">새 <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A>를 추가 하는 경우 해당 콜백 메타 데이터에 저장 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c538e-166">If you add a new <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A>, that callback is stored in the metadata.</span></span> <span data-ttu-id="c538e-167">재정의에서 a를 <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> 지정하지 않으면 메타데이터에 <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> 지정한 가장 가까운 상위 항목의 참조로 값이 승격됩니다.</span><span class="sxs-lookup"><span data-stu-id="c538e-167">If you do not specify a <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> in the override, the value of <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> is promoted as a reference from the nearest ancestor that specified it in metadata.</span></span>  
  
- <span data-ttu-id="c538e-168">실제 속성 시스템 <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> 동작은 계층 구조의 모든 메타데이터 소유자에 대한 구현이 유지되고 테이블에 추가되며, 속성 시스템에서 실행 순서를 수행하면 가장 파생된 클래스의 콜백이 먼저 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="c538e-168">The actual property system behavior for <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> is that implementations for all metadata owners in the hierarchy are retained and added to a table, with order of execution by the property system being that the most derived class's callbacks are invoked first.</span></span>  
  
- <span data-ttu-id="c538e-169"><xref:System.Windows.PropertyMetadata.DefaultValue%2A>교체됩니다.</span><span class="sxs-lookup"><span data-stu-id="c538e-169"><xref:System.Windows.PropertyMetadata.DefaultValue%2A> is replaced.</span></span> <span data-ttu-id="c538e-170">재정의에서 a를 <xref:System.Windows.PropertyMetadata.DefaultValue%2A> 지정하지 않으면 메타데이터에 <xref:System.Windows.PropertyMetadata.DefaultValue%2A> 지정한 가장 가까운 조상에서 값이 생성됩니다.</span><span class="sxs-lookup"><span data-stu-id="c538e-170">If you do not specify a <xref:System.Windows.PropertyMetadata.DefaultValue%2A> in the override, the value of <xref:System.Windows.PropertyMetadata.DefaultValue%2A> comes from the nearest ancestor that specified it in metadata.</span></span>  
  
- <span data-ttu-id="c538e-171"><xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>구현이 대체됩니다.</span><span class="sxs-lookup"><span data-stu-id="c538e-171"><xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> implementations are replaced.</span></span> <span data-ttu-id="c538e-172">새 <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>를 추가 하는 경우 해당 콜백 메타 데이터에 저장 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c538e-172">If you add a new <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>, that callback is stored in the metadata.</span></span> <span data-ttu-id="c538e-173">재정의에서 a를 <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> 지정하지 않으면 메타데이터에 <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> 지정한 가장 가까운 상위 항목의 참조로 값이 승격됩니다.</span><span class="sxs-lookup"><span data-stu-id="c538e-173">If you do not specify a <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> in the override, the value of <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> is promoted as a reference from the nearest ancestor that specified it in metadata.</span></span>  
  
- <span data-ttu-id="c538e-174">속성 시스템 동작은 바로 <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> 메타데이터에 있는 메타데이터만 호출된다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="c538e-174">The property system behavior is that only the <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> in the immediate metadata is invoked.</span></span> <span data-ttu-id="c538e-175">계층 구조의 <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> 다른 구현에 대한 참조는 유지되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c538e-175">No references to other <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> implementations in the hierarchy are retained.</span></span>  
  
 <span data-ttu-id="c538e-176">이 동작은 <xref:System.Windows.PropertyMetadata.Merge%2A>에서 구현되며 파생 된 메타 데이터 클래스에서 재정의 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c538e-176">This behavior is implemented by <xref:System.Windows.PropertyMetadata.Merge%2A>, and can be overridden on derived metadata classes.</span></span>  
  
#### <a name="overriding-attached-property-metadata"></a><span data-ttu-id="c538e-177">연결된 속성 메타데이터 재정의</span><span class="sxs-lookup"><span data-stu-id="c538e-177">Overriding Attached Property Metadata</span></span>  
 <span data-ttu-id="c538e-178">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]에서 연결된 속성은 종속성 속성으로 구현됩니다.</span><span class="sxs-lookup"><span data-stu-id="c538e-178">In [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], attached properties are implemented as dependency properties.</span></span> <span data-ttu-id="c538e-179">즉, 이러한 속성에는 개별 클래스에서 재정의할 수 있는 속성 메타데이터도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c538e-179">This means that they also have property metadata, which individual classes can override.</span></span> <span data-ttu-id="c538e-180">연결된 속성에 대한 범위 지정 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 고려 사항은 <xref:System.Windows.DependencyObject> 일반적으로 연결된 속성이 설정된 속성을 가질 수 있다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="c538e-180">The scoping considerations for an attached property in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] are generally that any <xref:System.Windows.DependencyObject> can have an attached property set on them.</span></span> <span data-ttu-id="c538e-181">따라서 파생된 클래스는 <xref:System.Windows.DependencyObject> 클래스의 인스턴스에 설정될 수 있으므로 연결된 속성에 대한 메타데이터를 재정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c538e-181">Therefore, any <xref:System.Windows.DependencyObject> derived class can override the metadata for any attached property, as it might be set on an instance of the class.</span></span> <span data-ttu-id="c538e-182">기본값, 콜백 또는 WPF 프레임워크 수준 특성 보고 속성을 재정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c538e-182">You can override default values, callbacks, or WPF framework-level characteristic-reporting properties.</span></span> <span data-ttu-id="c538e-183">연결된 속성이 클래스의 인스턴스에서 설정된 경우 해당 속성 메타데이터 재정의 특성이 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="c538e-183">If the attached property is set on an instance of your class, those override property metadata characteristics apply.</span></span> <span data-ttu-id="c538e-184">예를 들어 재정의 값이 클래스의 인스턴스에서 연결된 속성의 값으로 보고되도록 속성이 다르게 설정되지 않을 때마다 기본값을 재정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c538e-184">For instance, you can override the default value, such that your override value is reported as the value of the attached property on instances of your class, whenever the property is not otherwise set.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="c538e-185">속성은 <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> 연결된 속성과 관련이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="c538e-185">The <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> property is not relevant for attached properties.</span></span>  
  
<a name="dp_add_owner"></a>
### <a name="adding-a-class-as-an-owner-of-an-existing-dependency-property"></a><span data-ttu-id="c538e-186">기존 종속성 속성의 소유자로 클래스 추가</span><span class="sxs-lookup"><span data-stu-id="c538e-186">Adding a Class as an Owner of an Existing Dependency Property</span></span>  
 <span data-ttu-id="c538e-187">클래스는 <xref:System.Windows.DependencyProperty.AddOwner%2A> 메서드를 사용하여 이미 등록된 종속성 속성의 소유자로 자신을 추가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c538e-187">A class can add itself as an owner of a dependency property that has already been registered, by using the <xref:System.Windows.DependencyProperty.AddOwner%2A> method.</span></span> <span data-ttu-id="c538e-188">이렇게 하면 클래스에서 처음에 다른 형식으로 등록된 종속성 속성을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c538e-188">This enables the class to use a dependency property that was originally registered for a different type.</span></span> <span data-ttu-id="c538e-189">일반적으로 추가하는 클래스는 해당 종속성 속성을 소유자로 처음 등록한 형식의 파생 클래스가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="c538e-189">The adding class is typically not a derived class of the type that first registered that dependency property as owner.</span></span> <span data-ttu-id="c538e-190">효과적으로 이렇게 하면 동일한 실제 클래스 계층 구조에 원래 소유자 클래스와 추가하는 클래스가 없어도 클래스와 해당 파생 클래스에서 종속성 속성 구현을 "상속"할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c538e-190">Effectively, this allows your class and its derived classes to "inherit" a dependency property implementation without the original owner class and the adding class being in the same true class hierarchy.</span></span> <span data-ttu-id="c538e-191">또한 추가하는 클래스와 모든 파생 클래스도 원래 종속성 속성에 대해 형식별 메타데이터를 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c538e-191">In addition, the adding class (and all derived classes as well) can then provide type-specific metadata for the original dependency property.</span></span>  
  
 <span data-ttu-id="c538e-192">추가하는 클래스는 코드와 태그에 모두 노출하여 종속성 속성을 속성 시스템의 전체 참가자로 만들려면 속성 시스템 유틸리티 메서드를 통해 자신을 소유자로 추가할 뿐만 아니라 클래스 자체에 추가 public 멤버를 선언해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c538e-192">As well as adding itself as owner through the property system utility methods, the adding class should declare additional public members on itself in order to make the dependency property] a full participant in the property system with exposure to both code and markup.</span></span> <span data-ttu-id="c538e-193">새 사용자 지정 종속성 속성을 정의하는 클래스와 마찬가지로 기존 종속성 속성을 추가하는 클래스는 해당 종속성 속성에 대한 개체 모델을 노출하는 한 동일한 책임이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c538e-193">A class that adds an existing dependency property has the same responsibilities as far as exposing the object model for that dependency property as does a class that defines a new custom dependency property.</span></span> <span data-ttu-id="c538e-194">첫 번째로 노출할 멤버는 종속성 속성 식별자 필드입니다.</span><span class="sxs-lookup"><span data-stu-id="c538e-194">The first such member to expose is a dependency property identifier field.</span></span> <span data-ttu-id="c538e-195">이 필드는 `public static readonly` <xref:System.Windows.DependencyProperty> <xref:System.Windows.DependencyProperty.AddOwner%2A> 호출의 반환 값에 할당된 형식 필드여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c538e-195">This field should be a `public static readonly` field of type <xref:System.Windows.DependencyProperty>, which is assigned to the return value of the <xref:System.Windows.DependencyProperty.AddOwner%2A> call.</span></span> <span data-ttu-id="c538e-196">정의할 두 번째 멤버는 공통 언어 런타임(CLR) "래퍼" 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="c538e-196">The second member to define is the common language runtime (CLR) "wrapper" property.</span></span> <span data-ttu-id="c538e-197">래퍼를 사용하면 코드에서 종속성 속성을 훨씬 더 편리하게 조작할 <xref:System.Windows.DependencyObject.SetValue%2A> 수 있습니다(매번 호출을 피하고 래퍼 자체에서 한 번만 호출할 수 있음).</span><span class="sxs-lookup"><span data-stu-id="c538e-197">The wrapper makes it much more convenient to manipulate your dependency property in code (you avoid calls to <xref:System.Windows.DependencyObject.SetValue%2A> each time, and can make that call only once in the wrapper itself).</span></span> <span data-ttu-id="c538e-198">래퍼는 사용자 지정 종속성 속성을 등록할 때의 구현 방법과 동일하게 구현됩니다.</span><span class="sxs-lookup"><span data-stu-id="c538e-198">The wrapper is implemented identically to how it would be implemented if you were registering a custom dependency property.</span></span> <span data-ttu-id="c538e-199">종속성 속성 구현에 대한 자세한 내용은 [사용자 지정 종속성 속성](custom-dependency-properties.md) 및 [종속성 속성의 소유자 형식 추가](how-to-add-an-owner-type-for-a-dependency-property.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="c538e-199">For more information about implementing a dependency property, see [Custom Dependency Properties](custom-dependency-properties.md) and [Add an Owner Type for a Dependency Property](how-to-add-an-owner-type-for-a-dependency-property.md).</span></span>  
  
#### <a name="addowner-and-attached-properties"></a><span data-ttu-id="c538e-200">AddOwner 및 연결된 속성</span><span class="sxs-lookup"><span data-stu-id="c538e-200">AddOwner and Attached Properties</span></span>  
 <span data-ttu-id="c538e-201">소유자 클래스에서 연결된 속성으로 정의된 종속성 속성을 호출할 <xref:System.Windows.DependencyProperty.AddOwner%2A> 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c538e-201">You can call <xref:System.Windows.DependencyProperty.AddOwner%2A> for a dependency property that is defined as an attached property by the owner class.</span></span> <span data-ttu-id="c538e-202">일반적으로 이 작업은 이전에 연결된 속성을 연결되지 않은 종속성 속성으로 노출하기 위해 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="c538e-202">Generally the reason for doing this is to expose the previously attached property as a non-attached dependency property.</span></span> <span data-ttu-id="c538e-203">그런 다음 <xref:System.Windows.DependencyProperty.AddOwner%2A> return 값을 종속성 속성 식별자로 사용할 `public static readonly` 필드로 노출하고 속성이 멤버 테이블에 나타나고 클래스에서 연결되지 않은 속성 사용을 지원되도록 적절한 "래퍼" 속성을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="c538e-203">You then will expose the <xref:System.Windows.DependencyProperty.AddOwner%2A> return value as a `public static readonly` field for use as the dependency property identifier, and will define appropriate "wrapper" properties so that the property appears in the members table and supports a non-attached property usage in your class.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="c538e-204">참고 항목</span><span class="sxs-lookup"><span data-stu-id="c538e-204">See also</span></span>

- <xref:System.Windows.PropertyMetadata>
- <xref:System.Windows.DependencyObject>
- <xref:System.Windows.DependencyProperty>
- <xref:System.Windows.DependencyProperty.GetMetadata%2A>
- [<span data-ttu-id="c538e-205">종속성 속성 개요</span><span class="sxs-lookup"><span data-stu-id="c538e-205">Dependency Properties Overview</span></span>](dependency-properties-overview.md)
- [<span data-ttu-id="c538e-206">프레임워크 속성 메타데이터</span><span class="sxs-lookup"><span data-stu-id="c538e-206">Framework Property Metadata</span></span>](framework-property-metadata.md)

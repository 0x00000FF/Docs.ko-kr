---
title: 애플리케이션 시작 시간
ms.date: 03/30/2017
helpviewer_keywords:
- splash screen [WPF], startup time
- WPF [WPF], startup time
- startup time [WPF]
- application startup [WPF]
- performance [WPF], startup time
ms.assetid: f0ec58d8-626f-4d8a-9873-c20f95e08b96
ms.openlocfilehash: 72207861850875f08786401aacf7b911b2a5b1f6
ms.sourcegitcommit: 0be8a279af6d8a43e03141e349d3efd5d35f8767
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 04/18/2019
ms.locfileid: "59173032"
---
# <a name="application-startup-time"></a><span data-ttu-id="43929-102">애플리케이션 시작 시간</span><span class="sxs-lookup"><span data-stu-id="43929-102">Application Startup Time</span></span>
<span data-ttu-id="43929-103">WPF 애플리케이션을 시작하는 데 필요한 시간은 크게 다를 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="43929-103">The amount of time that is required for a WPF application to start can vary greatly.</span></span> <span data-ttu-id="43929-104">이 항목에서는 WPF(Windows Presentation Foundation) 애플리케이션의 체감 시작 시간과 실제 시작 시간을 줄일 수 있는 다양한 기술에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="43929-104">This topic describes various techniques for reducing the perceived and actual startup time for a Windows Presentation Foundation (WPF) application.</span></span>  
  
## <a name="understanding-cold-startup-and-warm-startup"></a><span data-ttu-id="43929-105">콜드 시작과 웜 시작 이해</span><span class="sxs-lookup"><span data-stu-id="43929-105">Understanding Cold Startup and Warm Startup</span></span>  
 <span data-ttu-id="43929-106">콜드 시작은 시스템을 다시 부팅한 후 애플리케이션을 처음 시작하거나 애플리케이션을 시작한 다음 닫았다가 오랜 시간이 지난 후에 다시 시작하는 경우에 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="43929-106">Cold startup occurs when your application starts for the first time after a system reboot, or when you start your application, close it, and then start it again after a long period of time.</span></span> <span data-ttu-id="43929-107">애플리케이션을 시작할 때 코드, 정적 데이터, 레지스트리 등 필요한 페이지가 Windows 메모리 관리자의 대기 목록에 없으면 페이지 오류가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="43929-107">When an application starts, if the required pages (code, static data, registry, etc) are not present in the Windows memory manager's standby list, page faults occur.</span></span> <span data-ttu-id="43929-108">페이지를 메모리로 가져오려면 디스크에 액세스해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="43929-108">Disk access is required to bring the pages into memory.</span></span>  
  
 <span data-ttu-id="43929-109">웜 시작은 주 CLR(공용 언어 런타임) 구성 요소의 페이지 대부분이 메모리에 이미 로드되어 있을 때 발생하며, 이 경우 비용이 많이 드는 디스크 액세스 시간을 줄일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="43929-109">Warm startup occurs when most of the pages for the main common language runtime (CLR) components are already loaded in memory, which saves expensive disk access time.</span></span> <span data-ttu-id="43929-110">이에 따라 관리되는 애플리케이션을 다시 실행할 때 더 빠르게 시작됩니다.</span><span class="sxs-lookup"><span data-stu-id="43929-110">That is why a managed application starts faster when it runs a second time.</span></span>  
  
## <a name="implement-a-splash-screen"></a><span data-ttu-id="43929-111">시작 화면 구현</span><span class="sxs-lookup"><span data-stu-id="43929-111">Implement a Splash Screen</span></span>  
 <span data-ttu-id="43929-112">애플리케이션을 시작한 후 첫 번째 UI가 표시될 때까지 어쩔 수 없이 상당히 지연될 경우 *시작 화면*을 사용하여 체감 시작 시간을 최적화합니다.</span><span class="sxs-lookup"><span data-stu-id="43929-112">In cases where there is a significant, unavoidable delay between starting an application and displaying the first UI, optimize the perceived startup time by using a *splash screen*.</span></span> <span data-ttu-id="43929-113">이 방법을 사용하면 사용자가 애플리케이션을 시작한 직후에 이미지가 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="43929-113">This approach displays an image almost immediately after the user starts the application.</span></span> <span data-ttu-id="43929-114">애플리케이션에서 첫 번째 UI를 표시할 준비가 되면 시작 화면이 사라집니다.</span><span class="sxs-lookup"><span data-stu-id="43929-114">When the application is ready to display its first UI, the splash screen fades.</span></span> <span data-ttu-id="43929-115">부터 합니다 [!INCLUDE[net_v35SP1_short](../../../../includes/net-v35sp1-short-md.md)]를 사용할 수는 <xref:System.Windows.SplashScreen> 시작 화면을 구현 하는 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="43929-115">Starting in the [!INCLUDE[net_v35SP1_short](../../../../includes/net-v35sp1-short-md.md)], you can use the <xref:System.Windows.SplashScreen> class to implement a splash screen.</span></span> <span data-ttu-id="43929-116">자세한 내용은 [WPF 애플리케이션에 시작 화면 추가](../app-development/how-to-add-a-splash-screen-to-a-wpf-application.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="43929-116">For more information, see [Add a Splash Screen to a WPF Application](../app-development/how-to-add-a-splash-screen-to-a-wpf-application.md).</span></span>  
  
 <span data-ttu-id="43929-117">네이티브 Win32 그래픽을 사용하여 사용자 고유의 시작 화면을 구현할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="43929-117">You can also implement your own splash screen by using native Win32 graphics.</span></span> <span data-ttu-id="43929-118">구현 하기 전에 표시 된 <xref:System.Windows.Application.Run%2A> 메서드가 호출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="43929-118">Display your implementation before the <xref:System.Windows.Application.Run%2A> method is called.</span></span>  
  
## <a name="analyze-the-startup-code"></a><span data-ttu-id="43929-119">시작 코드 분석</span><span class="sxs-lookup"><span data-stu-id="43929-119">Analyze the Startup Code</span></span>  
 <span data-ttu-id="43929-120">콜드 시작이 느린 이유를 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="43929-120">Determine the reason for a slow cold startup.</span></span> <span data-ttu-id="43929-121">디스크 I/O 때문일 수 있지만 항상 그렇지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="43929-121">Disk I/O may be responsible, but this is not always the case.</span></span> <span data-ttu-id="43929-122">일반적으로 네트워크, 웹 서비스 또는 디스크와 같은 외부 리소스의 사용을 최소화해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="43929-122">In general, you should minimize the use of external resources, such as network, Web services, or disk.</span></span>  
  
 <span data-ttu-id="43929-123">테스트하기 전에 실행 중인 다른 애플리케이션이나 서비스에서 관리 코드나 WPF 코드를 사용하고 있는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="43929-123">Before you test, verify that no other running applications or services use managed code or WPF code.</span></span>  
  
 <span data-ttu-id="43929-124">다시 부팅한 즉시 WPF 애플리케이션을 시작하고 표시하는 데 걸리는 시간을 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="43929-124">Start your WPF application immediately after a reboot, and determine how long it takes to display.</span></span> <span data-ttu-id="43929-125">애플리케이션의 모든 후속 실행(웜 시작)이 훨씬 빠르면 콜드 시작 문제는 I/O로 인해 발생될 가능성이 큽니다.</span><span class="sxs-lookup"><span data-stu-id="43929-125">If all subsequent launches of your application (warm startup) are much faster, your cold startup issue is most likely caused by I/O.</span></span>  
  
 <span data-ttu-id="43929-126">애플리케이션의 콜드 시작 문제가 I/O와 관련이 없는 경우 애플리케이션에서 시간이 오래 소요되는 초기화 또는 계산을 수행하거나, 특정 이벤트가 완료될 때까지 기다리거나, 시작 시 많은 양의 JIT 컴파일이 필요한 것일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="43929-126">If your application's cold startup issue is not related to I/O, it is likely that your application performs some lengthy initialization or computation, waits for some event to complete, or requires a lot of JIT compilation at startup.</span></span> <span data-ttu-id="43929-127">다음 섹션에서는 이러한 경우 중 일부에 대해 자세히 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="43929-127">The following sections describe some of these situations in more detail.</span></span>  
  
## <a name="optimize-module-loading"></a><span data-ttu-id="43929-128">모듈 로드 최적화</span><span class="sxs-lookup"><span data-stu-id="43929-128">Optimize Module Loading</span></span>  
 <span data-ttu-id="43929-129">Process Explorer(Procexp.exe) 및 Tlist.exe와 같은 도구를 사용하여 애플리케이션에서 로드하는 모듈을 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="43929-129">Use tools such as Process Explorer (Procexp.exe) and Tlist.exe to determine which modules your application loads.</span></span> <span data-ttu-id="43929-130">`Tlist <pid>` 명령은 프로세스에서 로드하는 모든 모듈을 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="43929-130">The command `Tlist <pid>` shows all the modules that are loaded by a process.</span></span>  
  
 <span data-ttu-id="43929-131">예를 들어 웹에 연결하지 않았지만 System.Web.dll이 로드되었다면 애플리케이션에 이 어셈블리를 참조하는 모듈이 있는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="43929-131">For example, if you are not connecting to the Web and you see that System.Web.dll is loaded, then there is a module in your application that references this assembly.</span></span> <span data-ttu-id="43929-132">이 경우 해당 참조가 필요한지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="43929-132">Check to make sure that the reference is necessary.</span></span>  
  
 <span data-ttu-id="43929-133">애플리케이션에 여러 모듈이 있는 경우 단일 모듈로 병합합니다.</span><span class="sxs-lookup"><span data-stu-id="43929-133">If your application has multiple modules, merge them into a single module.</span></span> <span data-ttu-id="43929-134">이렇게 하면 CLR 어셈블리 로드 오버헤드를 줄일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="43929-134">This approach requires less CLR assembly-loading overhead.</span></span> <span data-ttu-id="43929-135">어셈블리 수가 적을수록 CLR에서 상태를 더 적게 유지 관리하게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="43929-135">Fewer assemblies also mean that the CLR maintains less state.</span></span>  
  
## <a name="defer-initialization-operations"></a><span data-ttu-id="43929-136">초기화 작업 지연</span><span class="sxs-lookup"><span data-stu-id="43929-136">Defer Initialization Operations</span></span>  
 <span data-ttu-id="43929-137">주 애플리케이션 창이 렌더링될 때까지 초기화 코드를 연기하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="43929-137">Consider postponing initialization code until after the main application window is rendered.</span></span>  
  
 <span data-ttu-id="43929-138">초기화는 클래스 생성자 내에서 수행 될 수 있으며, 초기화 코드에서 다른 클래스들을 참조하면 계단식 효과(cascading effect)로 인해 많은 클래스 생성자가 실행될 수 있음에 주의해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="43929-138">Be aware that initialization may be performed inside a class constructor, and if the initialization code references other classes, it can cause a cascading effect in which many class constructors are executed.</span></span>  
  
## <a name="avoid-application-configuration"></a><span data-ttu-id="43929-139">애플리케이션 구성 금지</span><span class="sxs-lookup"><span data-stu-id="43929-139">Avoid Application Configuration</span></span>  
 <span data-ttu-id="43929-140">애플리케이션을 구성하지 않는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="43929-140">Consider avoiding application configuration.</span></span> <span data-ttu-id="43929-141">예를 들어 애플리케이션에 대한 구성 요구 사항이 간단하고, 시작 시간 목표가 명확한 경우 레지스트리 항목이나 간단한 INI 파일을 사용하여 시작하는 것이 더 빠를 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="43929-141">For example, if an application has simple configuration requirements and has strict startup time goals, registry entries or a simple INI file may be a faster startup alternative.</span></span>  
  
## <a name="utilize-the-gac"></a><span data-ttu-id="43929-142">GAC 사용</span><span class="sxs-lookup"><span data-stu-id="43929-142">Utilize the GAC</span></span>  
 <span data-ttu-id="43929-143">어셈블리가 GAC(전역 어셈블리 캐시)에 설치되어 있지 않으면 강력한 이름의 어셈블리에 대한 해시 확인 및 컴퓨터에서 해당 어셈블리의 네이티브 이미지를 사용할 수 있는 경우의 Ngen 이미지 유효성 검사로 인해 지연이 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="43929-143">If an assembly is not installed in the Global Assembly Cache (GAC), there are delays caused by hash verification of strong-named assemblies and by Ngen image validation if a native image for that assembly is available on the computer.</span></span> <span data-ttu-id="43929-144">GAC에 설치된 모든 어셈블리에서는 강력한 이름 확인을 건너뜁니다.</span><span class="sxs-lookup"><span data-stu-id="43929-144">Strong-name verification is skipped for all assemblies installed in the GAC.</span></span> <span data-ttu-id="43929-145">자세한 내용은 [Gacutil.exe(전역 어셈블리 캐시 도구)](../../tools/gacutil-exe-gac-tool.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="43929-145">For more information, see [Gacutil.exe (Global Assembly Cache Tool)](../../tools/gacutil-exe-gac-tool.md).</span></span>  
  
## <a name="use-ngenexe"></a><span data-ttu-id="43929-146">Ngen.exe 사용</span><span class="sxs-lookup"><span data-stu-id="43929-146">Use Ngen.exe</span></span>  
 <span data-ttu-id="43929-147">애플리케이션에서 네이티브 이미지 생성기(Ngen.exe)를 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="43929-147">Consider using the Native Image Generator (Ngen.exe) on your application.</span></span> <span data-ttu-id="43929-148">Ngen.exe에서 생성하는 네이티브 이미지가 일반적으로 MSIL 이미지보다 클 수 있기 때문에 Ngen.exe를 사용하면 CPU 사용량이 줄어드는 대신 디스크 액세스가 많아질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="43929-148">Using Ngen.exe means trading CPU consumption for more disk access because the native image generated by Ngen.exe is likely to be larger than the MSIL image.</span></span>  
  
 <span data-ttu-id="43929-149">웜 시작 시간을 줄이려면 Ngen.exe에서 애플리케이션 코드의 JIT 컴파일로 인한 CPU 비용 발생을 방지하므로 애플리케이션에서 항상 Ngen.exe를 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="43929-149">To improve the warm startup time, you should always use Ngen.exe on your application, because this avoids the CPU cost of JIT compilation of the application code.</span></span>  
  
 <span data-ttu-id="43929-150">일부 콜드 시작 시나리오에서도 Ngen.exe를 사용하면 도움이 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="43929-150">In some cold startup scenarios, using Ngen.exe can also be helpful.</span></span> <span data-ttu-id="43929-151">이는 JIT 컴파일러(mscorjit.dll)를 로드할 필요가 없기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="43929-151">This is because the JIT compiler (mscorjit.dll) does not have to be loaded.</span></span>  
  
 <span data-ttu-id="43929-152">Ngen과 JIT 모듈을 모두 사용하면 최악의 효과가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="43929-152">Having both Ngen and JIT modules can have the worst effect.</span></span> <span data-ttu-id="43929-153">이는 mscorjit.dll을 로드해야 하고, JIT 컴파일러가 코드에서 작동하여 어셈블리의 메타데이터를 읽을 때 Ngen 이미지의 많은 페이지에 액세스해야 하기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="43929-153">This is because mscorjit.dll must be loaded, and when the JIT compiler works on your code, many pages in the Ngen images must be accessed when the JIT compiler reads the assemblies' metadata.</span></span>  
  
### <a name="ngen-and-clickonce"></a><span data-ttu-id="43929-154">Ngen 및 ClickOnce</span><span class="sxs-lookup"><span data-stu-id="43929-154">Ngen and ClickOnce</span></span>  
 <span data-ttu-id="43929-155">애플리케이션 배포 계획에 따라서도 로드 시간이 달라질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="43929-155">The way you plan to deploy your application can also make a difference in load time.</span></span> [!INCLUDE[ndptecclick](../../../../includes/ndptecclick-md.md)] <span data-ttu-id="43929-156">응용 프로그램 배포는 Ngen을 지원하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="43929-156">application deployment does not support Ngen.</span></span> <span data-ttu-id="43929-157">애플리케이션에 Ngen.exe를 사용하려면 Windows Installer와 같은 다른 배포 메커니즘을 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="43929-157">If you decide to use Ngen.exe for your application, you will have to use another deployment mechanism, such as Windows Installer.</span></span>  
  
 <span data-ttu-id="43929-158">자세한 내용은 [Ngen.exe(네이티브 이미지 생성기)](../../tools/ngen-exe-native-image-generator.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="43929-158">For more information, see [Ngen.exe (Native Image Generator)](../../tools/ngen-exe-native-image-generator.md).</span></span>  
  
### <a name="rebasing-and-dll-address-collisions"></a><span data-ttu-id="43929-159">기준 주소 다시 지정 및 DLL 주소 충돌</span><span class="sxs-lookup"><span data-stu-id="43929-159">Rebasing and DLL Address Collisions</span></span>  
 <span data-ttu-id="43929-160">Ngen.exe를 사용하는 경우 네이티브 이미지가 메모리에 로드될 때 기준 주소 다시 지정이 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="43929-160">If you use Ngen.exe, be aware that rebasing can occur when the native images are loaded in memory.</span></span> <span data-ttu-id="43929-161">해당 주소 범위가 이미 할당되어 있어 기본 설정된 기준 주소에 DLL을 로드할 수 없으면, Windows 로더에서 다른 주소에 DLL을 로드하지만 이 작업에는 시간이 오래 걸릴 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="43929-161">If a DLL is not loaded at its preferred base address because that address range is already allocated, the Windows loader will load it at another address, which can be a time-consuming operation.</span></span>  
  
 <span data-ttu-id="43929-162">가상 주소 덤프 도구(Vadump.exe)를 사용하여 모든 페이지가 전용(private)으로 된 모듈이 있는지 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="43929-162">You can use the Virtual Address Dump (Vadump.exe) tool to check if there are modules in which all the pages are private.</span></span> <span data-ttu-id="43929-163">이러한 모듈이 있는 경우 해당 모듈은 다른 주소로 다시 지정되며,</span><span class="sxs-lookup"><span data-stu-id="43929-163">If this is the case, the module may have been rebased to a different address.</span></span> <span data-ttu-id="43929-164">이로 인해 해당 페이지를 공유할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="43929-164">Therefore, its pages cannot be shared.</span></span>  
  
 <span data-ttu-id="43929-165">기준 주소 설정 방법에 대한 자세한 내용은 [Ngen.exe(네이티브 이미지 생성기)](../../tools/ngen-exe-native-image-generator.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="43929-165">For more information about how to set the base address, see [Ngen.exe (Native Image Generator)](../../tools/ngen-exe-native-image-generator.md).</span></span>  
  
## <a name="optimize-authenticode"></a><span data-ttu-id="43929-166">Authenticode 최적화</span><span class="sxs-lookup"><span data-stu-id="43929-166">Optimize Authenticode</span></span>  
 <span data-ttu-id="43929-167">Authenticode 확인으로 인해 시작 시간이 길어질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="43929-167">Authenticode verification adds to the startup time.</span></span> <span data-ttu-id="43929-168">Authenticode로 서명된 어셈블리는 CA(인증 기관)에서 확인해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="43929-168">Authenticode-signed assemblies have to be verified with the certification authority (CA).</span></span> <span data-ttu-id="43929-169">이 확인 작업을 수행하는 경우 현재 인증서 해지 목록을 다운로드하기 위해 네트워크에 여러 번 연결해야 하므로 시간이 오래 걸릴 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="43929-169">This verification can be time consuming, because it can require connecting to the network several times to download current certificate revocation lists.</span></span> <span data-ttu-id="43929-170">또한 신뢰할 수 있는 루트에 대한 경로에 유효한 인증서의 전체 체인이 있는지도 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="43929-170">It also makes sure that there is a full chain of valid certificates on the path to a trusted root.</span></span> <span data-ttu-id="43929-171">이로 인해 어셈블리가 로드되는 동안 몇 초 정도 지연될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="43929-171">This can translate to several seconds of delay while the assembly is being loaded.</span></span>  
  
 <span data-ttu-id="43929-172">클라이언트 컴퓨터에 CA 인증서를 설치하거나, 가능한 경우 Authenticode를 사용하지 않는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="43929-172">Consider installing the CA certificate on the client computer, or avoid using Authenticode when it is possible.</span></span> <span data-ttu-id="43929-173">애플리케이션에 게시자 증명 정보가 필요하지 않은 경우 서명 확인에 비용을 들일 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="43929-173">If you know that your application does not need the publisher evidence, you do not have to pay the cost of signature verification.</span></span>  
  
 <span data-ttu-id="43929-174">[!INCLUDE[net_v35_short](../../../../includes/net-v35-short-md.md)]부터는 Authenticode 확인을 무시할 수 있는 구성 옵션이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="43929-174">Starting in [!INCLUDE[net_v35_short](../../../../includes/net-v35-short-md.md)], there is a configuration option that allows the Authenticode verification to be bypassed.</span></span> <span data-ttu-id="43929-175">이렇게 하려면 app.exe.config 파일에 다음 설정을 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="43929-175">To do this, add the following setting to the app.exe.config file:</span></span>  
  
```xml  
<configuration>  
    <runtime>  
        <generatePublisherEvidence enabled="false"/>   
    </runtime>  
</configuration>  
```  
  
 <span data-ttu-id="43929-176">자세한 내용은 [\<generatePublisherEvidence> 요소](../../configure-apps/file-schema/runtime/generatepublisherevidence-element.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="43929-176">For more information, see [\<generatePublisherEvidence> Element](../../configure-apps/file-schema/runtime/generatepublisherevidence-element.md).</span></span>  
  
## <a name="compare-performance-on-windows-vista"></a><span data-ttu-id="43929-177">Windows Vista에서 성능 비교</span><span class="sxs-lookup"><span data-stu-id="43929-177">Compare Performance on Windows Vista</span></span>  
 <span data-ttu-id="43929-178">Windows Vista의 메모리 관리자에는 SuperFetch라는 기술이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="43929-178">The memory manager in Windows Vista has a technology called SuperFetch.</span></span> <span data-ttu-id="43929-179">SuperFetch는 시간의 경과에 따른 메모리 사용 패턴을 분석하여 특정 사용자에 맞는 최적의 메모리 콘텐츠를 결정하며,</span><span class="sxs-lookup"><span data-stu-id="43929-179">SuperFetch analyzes memory usage patterns over time to determine the optimal memory content for a specific user.</span></span> <span data-ttu-id="43929-180">해당 콘텐츠를 항상 유지하기 위해 지속적으로 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="43929-180">It works continuously to maintain that content at all times.</span></span>  
  
 <span data-ttu-id="43929-181">이 방법은 Windows XP에서 사용 패턴을 분석하지 않고 메모리에 데이터를 미리 로드하는 Windows XP에서 사용되는 프리페치 기술과 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="43929-181">This approach differs from the pre-fetch technique used in Windows XP, which preloads data into memory without analyzing usage patterns.</span></span> <span data-ttu-id="43929-182">시간이 지남에 따라 사용자가 Windows Vista에서 WPF 애플리케이션을 자주 사용하면 애플리케이션의 콜드 시작 시간이 줄어들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="43929-182">Over time, if the user uses your WPF application frequently on Windows Vista, the cold startup time of your application may improve.</span></span>  
  
## <a name="use-appdomains-efficiently"></a><span data-ttu-id="43929-183">효율적인 AppDomain 사용</span><span class="sxs-lookup"><span data-stu-id="43929-183">Use AppDomains Efficiently</span></span>  
 <span data-ttu-id="43929-184">가능한 경우 어셈블리를 도메인 중립 코드 영역에 로드하여 네이티브 이미지(있는 경우)가 애플리케이션에서 만든 모든 AppDomain에서 사용되는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="43929-184">If possible, load assemblies into a domain-neutral code area to make sure that the native image, if one exists, is used in all AppDomains created in the application.</span></span>  
  
 <span data-ttu-id="43929-185">최상의 성능을 위해 도메인 간 호출을 줄여 도메인 간 통신의 효율성을 높입니다.</span><span class="sxs-lookup"><span data-stu-id="43929-185">For the best performance, enforce efficient cross-domain communication by reducing cross-domain calls.</span></span> <span data-ttu-id="43929-186">가능한 경우 인수를 사용하지 않거나 기본 형식 인수를 사용하여 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="43929-186">When possible, use calls without arguments or with primitive type arguments.</span></span>  
  
## <a name="use-the-neutralresourceslanguage-attribute"></a><span data-ttu-id="43929-187">NeutralResourcesLanguage 특성 사용</span><span class="sxs-lookup"><span data-stu-id="43929-187">Use the NeutralResourcesLanguage Attribute</span></span>  
 <span data-ttu-id="43929-188">사용 합니다 <xref:System.Resources.NeutralResourcesLanguageAttribute> 에 대 한 중립 문화권을 지정 하는 <xref:System.Resources.ResourceManager>합니다.</span><span class="sxs-lookup"><span data-stu-id="43929-188">Use the <xref:System.Resources.NeutralResourcesLanguageAttribute> to specify the neutral culture for the <xref:System.Resources.ResourceManager>.</span></span> <span data-ttu-id="43929-189">이렇게 하면 실패한 어셈블리 조회를 방지합니다.</span><span class="sxs-lookup"><span data-stu-id="43929-189">This approach avoids unsuccessful assembly lookups.</span></span>  
  
## <a name="use-the-binaryformatter-class-for-serialization"></a><span data-ttu-id="43929-190">serialization에 BinaryFormatter 클래스 사용</span><span class="sxs-lookup"><span data-stu-id="43929-190">Use the BinaryFormatter Class for Serialization</span></span>  
 <span data-ttu-id="43929-191">Serialization을 사용 해야 하는 경우 사용 합니다 <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> 클래스 대신는 <xref:System.Xml.Serialization.XmlSerializer> 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="43929-191">If you must use serialization, use the <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> class instead of the <xref:System.Xml.Serialization.XmlSerializer> class.</span></span> <span data-ttu-id="43929-192"><xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> 클래스에서 클래스 라이브러리 BCL (기본) mscorlib.dll 어셈블리에서 구현 됩니다.</span><span class="sxs-lookup"><span data-stu-id="43929-192">The <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> class is implemented in the Base Class Library (BCL) in the mscorlib.dll assembly.</span></span> <span data-ttu-id="43929-193"><xref:System.Xml.Serialization.XmlSerializer> 로드할 추가 DLL 일 수 있는 System.Xml.dll 어셈블리에서 구현 됩니다.</span><span class="sxs-lookup"><span data-stu-id="43929-193">The <xref:System.Xml.Serialization.XmlSerializer> is implemented in the System.Xml.dll assembly, which might be an additional DLL to load.</span></span>  
  
 <span data-ttu-id="43929-194">사용 해야 하는 경우는 <xref:System.Xml.Serialization.XmlSerializer> 클래스 serialization 어셈블리를 미리 생성 하는 경우 성능의 높일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="43929-194">If you must use the <xref:System.Xml.Serialization.XmlSerializer> class, you can achieve better performance if you pre-generate the serialization assembly.</span></span>  
  
## <a name="configure-clickonce-to-check-for-updates-after-startup"></a><span data-ttu-id="43929-195">시작 후 업데이트를 확인하도록 ClickOnce 구성</span><span class="sxs-lookup"><span data-stu-id="43929-195">Configure ClickOnce to Check for Updates After Startup</span></span>  
 <span data-ttu-id="43929-196">애플리케이션에서 [!INCLUDE[ndptecclick](../../../../includes/ndptecclick-md.md)]를 사용하는 경우 애플리케이션을 시작한 후에 배포 사이트에서 업데이트를 확인하도록 [!INCLUDE[ndptecclick](../../../../includes/ndptecclick-md.md)]를 구성하여 애플리케이션 시작 시 네트워크를 액세스하지 않도록 방지합니다.</span><span class="sxs-lookup"><span data-stu-id="43929-196">If your application uses [!INCLUDE[ndptecclick](../../../../includes/ndptecclick-md.md)], avoid network access on startup by configuring [!INCLUDE[ndptecclick](../../../../includes/ndptecclick-md.md)] to check the deployment site for updates after the application starts.</span></span>  
  
 <span data-ttu-id="43929-197">XBAP(XAML 브라우저 애플리케이션) 모델을 사용하면 XBAP가 이미 [!INCLUDE[ndptecclick](../../../../includes/ndptecclick-md.md)] 캐시에 있는 경우에도 [!INCLUDE[ndptecclick](../../../../includes/ndptecclick-md.md)]는 배포 사이트에서 업데이트를 확인한다는 점에 주의합니다.</span><span class="sxs-lookup"><span data-stu-id="43929-197">If you use the XAML browser application (XBAP) model, keep in mind that [!INCLUDE[ndptecclick](../../../../includes/ndptecclick-md.md)] checks the deployment site for updates even if the XBAP is already in the [!INCLUDE[ndptecclick](../../../../includes/ndptecclick-md.md)] cache.</span></span> <span data-ttu-id="43929-198">자세한 내용은 [ClickOnce Security and Deployment](/visualstudio/deployment/clickonce-security-and-deployment)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="43929-198">For more information, see [ClickOnce Security and Deployment](/visualstudio/deployment/clickonce-security-and-deployment).</span></span>  
  
## <a name="configure-the-presentationfontcache-service-to-start-automatically"></a><span data-ttu-id="43929-199">자동으로 시작되도록 PresentationFontCache 서비스 구성</span><span class="sxs-lookup"><span data-stu-id="43929-199">Configure the PresentationFontCache Service to Start Automatically</span></span>  
 <span data-ttu-id="43929-200">다시 부팅한 후에 실행할 첫 번째 WPF 애플리케이션은 PresentationFontCache 서비스입니다.</span><span class="sxs-lookup"><span data-stu-id="43929-200">The first WPF application to run after a reboot is the PresentationFontCache service.</span></span> <span data-ttu-id="43929-201">이 서비스는 시스템 글꼴을 캐시하고, 글꼴 액세스를 향상시키며 전반적인 성능을 높입니다.</span><span class="sxs-lookup"><span data-stu-id="43929-201">The service caches the system fonts, improves font access, and improves overall performance.</span></span> <span data-ttu-id="43929-202">이 서비스를 시작하는 데 있어 오버헤드가 발생하며, 제어된 일부 환경에서는 시스템을 다시 부팅할 때 이 서비스가 자동으로 시작되도록 구성하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="43929-202">There is an overhead in starting the service, and in some controlled environments, consider configuring the service to start automatically when the system reboots.</span></span>  
  
## <a name="set-data-binding-programmatically"></a><span data-ttu-id="43929-203">프로그래밍 방식으로 데이터 바인딩 설정</span><span class="sxs-lookup"><span data-stu-id="43929-203">Set Data Binding Programmatically</span></span>  
 <span data-ttu-id="43929-204">XAML을 사용 하 여 설정 하는 대신 합니다 <xref:System.Windows.FrameworkElement.DataContext%2A> 선언적으로 주 창에 대 한 프로그래밍 방식으로 설정 고려해 야는 <xref:System.Windows.Application.OnActivated%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="43929-204">Instead of using XAML to set the <xref:System.Windows.FrameworkElement.DataContext%2A> declaratively for the main window, consider setting it programmatically in the <xref:System.Windows.Application.OnActivated%2A> method.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="43929-205">참고자료</span><span class="sxs-lookup"><span data-stu-id="43929-205">See also</span></span>

- <xref:System.Windows.SplashScreen>
- <xref:System.AppDomain>
- <xref:System.Resources.NeutralResourcesLanguageAttribute>
- <xref:System.Resources.ResourceManager>
- [<span data-ttu-id="43929-206">WPF 응용 프로그램에 시작 화면 추가</span><span class="sxs-lookup"><span data-stu-id="43929-206">Add a Splash Screen to a WPF Application</span></span>](../app-development/how-to-add-a-splash-screen-to-a-wpf-application.md)
- [<span data-ttu-id="43929-207">Ngen.exe(네이티브 이미지 생성기)</span><span class="sxs-lookup"><span data-stu-id="43929-207">Ngen.exe (Native Image Generator)</span></span>](../../tools/ngen-exe-native-image-generator.md)
- [<span data-ttu-id="43929-208">\<generatePublisherEvidence> 요소</span><span class="sxs-lookup"><span data-stu-id="43929-208">\<generatePublisherEvidence> Element</span></span>](../../configure-apps/file-schema/runtime/generatepublisherevidence-element.md)

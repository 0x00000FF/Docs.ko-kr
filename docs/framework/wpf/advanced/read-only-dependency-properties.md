---
title: 읽기 전용 종속성 속성
ms.date: 03/30/2017
helpviewer_keywords:
- dependency properties [WPF], read-only
- read-only dependency properties [WPF]
ms.assetid: f23d6ec9-3780-4c09-a2ff-b2f0a2deddf1
ms.openlocfilehash: 9aeeab95342bce94c53e89229003f55009118f96
ms.sourcegitcommit: 0c48191d6d641ce88d7510e319cf38c0e35697d0
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/05/2019
ms.locfileid: "57379009"
---
# <a name="read-only-dependency-properties"></a><span data-ttu-id="146aa-102">읽기 전용 종속성 속성</span><span class="sxs-lookup"><span data-stu-id="146aa-102">Read-Only Dependency Properties</span></span>
<span data-ttu-id="146aa-103">이 항목에서는 기존 읽기 전용 종속성 속성과 사용자 지정 읽기 전용 종속성 속성을 만드는 시나리오 및 방법을 포함하여 읽기 전용 종속성 속성을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="146aa-103">This topic describes read-only dependency properties, including existing read-only dependency properties and the scenarios and techniques for creating a custom read-only dependency property.</span></span>  
  

  
<a name="prerequisites"></a>   
## <a name="prerequisites"></a><span data-ttu-id="146aa-104">전제 조건</span><span class="sxs-lookup"><span data-stu-id="146aa-104">Prerequisites</span></span>  
 <span data-ttu-id="146aa-105">이 항목에서는 종속성 속성을 구현하는 기본 시나리오와 메타데이터가 사용자 지정 종속성 속성에 적용되는 방법을 이해하고 있다고 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="146aa-105">This topic assumes that you understand the basic scenarios of implementing a dependency property, and how metadata is applied to a custom dependency property.</span></span> <span data-ttu-id="146aa-106">컨텍스트는 [사용자 지정 종속성 속성](custom-dependency-properties.md) 및 [종속성 속성 메타데이터](dependency-property-metadata.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="146aa-106">See [Custom Dependency Properties](custom-dependency-properties.md) and [Dependency Property Metadata](dependency-property-metadata.md) for context.</span></span>  
  
<a name="existing"></a>   
## <a name="existing-read-only-dependency-properties"></a><span data-ttu-id="146aa-107">기존 읽기 전용 종속성 속성</span><span class="sxs-lookup"><span data-stu-id="146aa-107">Existing Read-Only Dependency Properties</span></span>  
 <span data-ttu-id="146aa-108">[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] 프레임워크에 정의된 일부 종속성 속성은 읽기 전용입니다.</span><span class="sxs-lookup"><span data-stu-id="146aa-108">Some of the dependency properties defined in the [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] framework are read-only.</span></span> <span data-ttu-id="146aa-109">일반적으로 읽기 전용 종속성 속성을 지정하는 이유는 상태 결정에 이러한 속성을 사용해야 하지만 많은 요소가 해당 상태에 영향을 미치는 경우 속성을 해당 상태로 설정하는 것은 사용자 인터페이스 디자인 측면에서 바람직하지 않기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="146aa-109">The typical reason for specifying a read-only dependency property is that these are properties that should be used for state determination, but where that state is influenced by a multitude of factors, but just setting the property to that state isn't desirable from a user interface design perspective.</span></span> <span data-ttu-id="146aa-110">예를 들어 속성 <xref:System.Windows.UIElement.IsMouseOver%2A> 마우스 입력에 따라 결정 되는 상태를 표시 실제로 됩니다.</span><span class="sxs-lookup"><span data-stu-id="146aa-110">For example, the property <xref:System.Windows.UIElement.IsMouseOver%2A> is really just surfacing state as determined from the mouse input.</span></span> <span data-ttu-id="146aa-111">실제 마우스 입력을 우회하여 프로그래밍 방식으로 이 값을 설정하는 시도는 예측이 불가능하고 이로 인해 불일치가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="146aa-111">Any attempt to set this value programmatically by circumventing the true mouse input would be unpredictable and would cause inconsistency.</span></span>  
  
 <span data-ttu-id="146aa-112">설정이 불가능하기 때문에 읽기 전용 종속성 속성은 정상적으로는 종속성 속성이 솔루션(값, 유효성 검사, 애니메이션, 상속에 직접 스타일 지정 가능한 데이터 바인딩)을 제공하는 많은 시나리오에 적절하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="146aa-112">By virtue of not being settable, read-only dependency properties aren't appropriate for many of the scenarios for which dependency properties normally offer a solution (namely: data binding, directly stylable to a value, validation, animation, inheritance).</span></span> <span data-ttu-id="146aa-113">설정 불가능하지만 읽기 전용 종속성 속성에는 속성 시스템의 종속성 시스템을 통해 지원되는 몇 가지 추가 기능이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="146aa-113">Despite not being settable, read-only dependency properties still have some of the additional capabilities supported by dependency properties in the property system.</span></span> <span data-ttu-id="146aa-114">가장 중요한 나머지 기능은 읽기 전용 종속성 속성은 속성 트리거로 사용될 수 있다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="146aa-114">The most important remaining capability is that the read-only dependency property can still be used as a property trigger in a style.</span></span> <span data-ttu-id="146aa-115">일반 [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] 속성을 사용하여 트리거를 사용하도록 설정할 수는 없습니다. 종속성 속성이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="146aa-115">You can't enable triggers with a normal [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] property; it needs to be a dependency property.</span></span> <span data-ttu-id="146aa-116">앞서 언급 한 <xref:System.Windows.UIElement.IsMouseOver%2A> 속성이 유용할 수 있는 매우 전체 컨트롤에 대 한 스타일을 정의 하는 시나리오의 대표적인 예로 배경, 전경 또는 비슷한 속성 내에서 합성 요소와 같은 visible 속성을 컨트롤은 컨트롤의 정의 된 영역 위로 마우스를 이동할 때 변경 됩니다.</span><span class="sxs-lookup"><span data-stu-id="146aa-116">The aforementioned <xref:System.Windows.UIElement.IsMouseOver%2A> property is a perfect example of a scenario where it might be quite useful to define a style for a control, where some visible property such as a background, foreground, or similar properties of composited elements within the control will change when the user places a mouse over some defined region of your control.</span></span> <span data-ttu-id="146aa-117">읽기 전용 종속성 속성의 변경 내용은 속성 시스템의 기본 무효화 프로세스를 통해 검색 및 보고할 수 있고, 실제로 속성 트리거 기능을 내부적으로 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="146aa-117">Changes in a read-only dependency property can also be detected and reported by the property system's inherent invalidation processes, and this in fact supports the property trigger functionality internally.</span></span>  
  
<a name="new"></a>   
## <a name="creating-custom-read-only-dependency-properties"></a><span data-ttu-id="146aa-118">사용자 지정 읽기 전용 종속성 속성 만들기</span><span class="sxs-lookup"><span data-stu-id="146aa-118">Creating Custom Read-Only Dependency Properties</span></span>  
 <span data-ttu-id="146aa-119">위 섹션에서 읽기 전용 종속성 속성이 많은 일반적인 종속성 속성 시나리오에 적용되지 않는 이유를 확인해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="146aa-119">Make sure to read the section above regarding why read-only dependency properties won't work for many typical dependency-property scenarios.</span></span> <span data-ttu-id="146aa-120">하지만 적절한 시나리오가 있는 경우 자체 읽기 전용 종속성 속성을 만들려고 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="146aa-120">But if you have an appropriate scenario, you may wish to create your own read-only dependency property.</span></span>  
  
 <span data-ttu-id="146aa-121">읽기 전용 종속성 속성을 만드는 프로세스의 많은 부분은 [사용자 지정 종속성 속성](custom-dependency-properties.md) 및 [종속성 속성 구현](how-to-implement-a-dependency-property.md) 항목에 설명된 것과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="146aa-121">Much of the process of creating a read-only dependency property is the same as is described in the [Custom Dependency Properties](custom-dependency-properties.md) and [Implement a Dependency Property](how-to-implement-a-dependency-property.md) topics.</span></span> <span data-ttu-id="146aa-122">세 가지 중요한 차이점이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="146aa-122">There are three important differences:</span></span>  
  
-   <span data-ttu-id="146aa-123">속성을 등록할 때 호출 합니다 <xref:System.Windows.DependencyProperty.RegisterReadOnly%2A> 메서드는 보통 대신 <xref:System.Windows.DependencyProperty.Register%2A> 속성 등록에 대 한 메서드.</span><span class="sxs-lookup"><span data-stu-id="146aa-123">When registering your property, call the <xref:System.Windows.DependencyProperty.RegisterReadOnly%2A> method instead of the normal <xref:System.Windows.DependencyProperty.Register%2A> method for property registration.</span></span>  
  
-   <span data-ttu-id="146aa-124">[!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] "래퍼" 속성을 구현할 때 래퍼에도 집합 구현이 없는지 확인하세요. 그래야 읽기 전용 상태에서 표시하는 public 래퍼에 대한 불일치가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="146aa-124">When implementing the [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] "wrapper" property, make sure that the wrapper too doesn't have a set implementation, so that there is no inconsistency in read-only state for the public wrapper you expose.</span></span>  
  
-   <span data-ttu-id="146aa-125">읽기 전용 등록에서 반환 되는 개체 <xref:System.Windows.DependencyPropertyKey> 대신 <xref:System.Windows.DependencyProperty>합니다.</span><span class="sxs-lookup"><span data-stu-id="146aa-125">The object returned by the read-only registration is <xref:System.Windows.DependencyPropertyKey> rather than <xref:System.Windows.DependencyProperty>.</span></span> <span data-ttu-id="146aa-126">이 필드는 멤버로 저장해야 하지만 일반적으로 형식의 public 멤버로 설정하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="146aa-126">You should still store this field as a member but typically you would not make it a public member of the type.</span></span>  
  
 <span data-ttu-id="146aa-127">지원하는 private 필드 또는 값이 무엇이든 관계없이 읽기 전용 종속성 속성은 결정한 논리가 무엇이든 이를 사용하여 충분히 쓰기 가능합니다.</span><span class="sxs-lookup"><span data-stu-id="146aa-127">Whatever private field or value you have backing your read-only dependency property can of course be fully writable using whatever logic you decide.</span></span> <span data-ttu-id="146aa-128">하지만 처음에 또는 런타임 논리의 일부로 속성을 설정하는 가장 직관적인 방법은 속성 시스템을 우회하고 private 지원 필드를 직접 설정하는 것이 아니라 속성 시스템의 [!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)]를 사용하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="146aa-128">However, the most straightforward way to set the property either initially or as part of runtime logic is to use the property system's [!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)], rather than circumventing the property system and setting the private backing field directly.</span></span> <span data-ttu-id="146aa-129">특히는의 시그니처 <xref:System.Windows.DependencyObject.SetValue%2A> 형식의 매개 변수를 받아들이는 <xref:System.Windows.DependencyPropertyKey>합니다.</span><span class="sxs-lookup"><span data-stu-id="146aa-129">In particular, there is a signature of <xref:System.Windows.DependencyObject.SetValue%2A> that accepts a parameter of type <xref:System.Windows.DependencyPropertyKey>.</span></span> <span data-ttu-id="146aa-130">에 대 한 액세스를 설정 하려고 하는 방법에 영향이 방법 및 위치이 값을 설정한이 프로그래밍 방식으로 응용 프로그램 논리 내에서 <xref:System.Windows.DependencyPropertyKey> 종속성 속성을 처음 등록할 때 만들어집니다.</span><span class="sxs-lookup"><span data-stu-id="146aa-130">How and where you set this value programmatically within your application logic will affect how you may wish to set access on the <xref:System.Windows.DependencyPropertyKey> created when you first registered the dependency property.</span></span> <span data-ttu-id="146aa-131">private로 설정할 수 있는 클래스 내에서 이 논리를 모두 처리할 경우 또는 어셈블리의 다른 부분에서 클래스를 설정해야 하는 경우 이 클래스를 internal로 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="146aa-131">If you handle this logic all within the class you could make it private, or if you require it to be set from other portions of the assembly you might set it internal.</span></span> <span data-ttu-id="146aa-132">호출 하는 한 가지 방법은 <xref:System.Windows.DependencyObject.SetValue%2A> 저장된 된 속성 값을 변경 해야 하는 클래스 인스턴스에 알리는 관련 이벤트의 클래스 이벤트 처리기 내에서.</span><span class="sxs-lookup"><span data-stu-id="146aa-132">One approach is to call <xref:System.Windows.DependencyObject.SetValue%2A> within a class event handler of a relevant event that informs a class instance that the stored property value needs to be changed.</span></span> <span data-ttu-id="146aa-133">쌍을 이루는 사용 하 여 종속성 속성을 함께 연결 하는 또 다른 방법은 <xref:System.Windows.PropertyChangedCallback> 고 <xref:System.Windows.CoerceValueCallback> 등록 하는 동안 이러한 속성의 메타 데이터의 일부로 콜백 합니다.</span><span class="sxs-lookup"><span data-stu-id="146aa-133">Another approach is to tie dependency properties together by using paired <xref:System.Windows.PropertyChangedCallback> and <xref:System.Windows.CoerceValueCallback> callbacks as part of those properties' metadata during registration.</span></span>  
  
 <span data-ttu-id="146aa-134">때문에 <xref:System.Windows.DependencyPropertyKey> 은 개인 프로필이 며 전파 되지 않습니다 코드 외부에서 속성 시스템에서 읽기 전용 종속성 속성에는 더 읽기-쓰기 종속성 속성 보다 보안을 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="146aa-134">Because the <xref:System.Windows.DependencyPropertyKey> is private, and is not propagated by the property system outside of your code, a read-only dependency property does have better setting security than a read-write dependency property.</span></span> <span data-ttu-id="146aa-135">읽기-쓰기 종속성 속성의 경우 식별 필드는 명시적 또는 암시적으로 public이므로 속성을 광범위하게 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="146aa-135">For a read-write dependency property, the identifying field is explicitly or implicitly public and thus the property is widely settable.</span></span> <span data-ttu-id="146aa-136">자세한 내용은 [종속성 속성 보안](dependency-property-security.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="146aa-136">For more specifics, see [Dependency Property Security](dependency-property-security.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="146aa-137">참고자료</span><span class="sxs-lookup"><span data-stu-id="146aa-137">See also</span></span>
- [<span data-ttu-id="146aa-138">종속성 속성 개요</span><span class="sxs-lookup"><span data-stu-id="146aa-138">Dependency Properties Overview</span></span>](dependency-properties-overview.md)
- [<span data-ttu-id="146aa-139">사용자 지정 종속성 속성</span><span class="sxs-lookup"><span data-stu-id="146aa-139">Custom Dependency Properties</span></span>](custom-dependency-properties.md)
- [<span data-ttu-id="146aa-140">스타일 지정 및 템플릿</span><span class="sxs-lookup"><span data-stu-id="146aa-140">Styling and Templating</span></span>](../controls/styling-and-templating.md)

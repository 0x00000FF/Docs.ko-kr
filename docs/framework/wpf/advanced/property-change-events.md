---
title: 속성 변경 이벤트
ms.date: 03/30/2017
helpviewer_keywords:
- dependency properties [WPF], change events
- property value changes [WPF]
- change events [WPF], property
- events [WPF], change in property values
- creating property triggers [WPF]
- property change events [WPF], types of
- property change events [WPF]
- property triggers [WPF]
- identifying changed property events [WPF]
- property triggers [WPF], definition of
ms.assetid: 0a7989df-9674-4cc1-bc50-5d8ef5d9c055
ms.openlocfilehash: f8d0d5e65101ffda0edaaeabdea2870287ba0f1f
ms.sourcegitcommit: 24a4a8eb6d8cfe7b8549fb6d823076d7c697e0c6
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 07/23/2019
ms.locfileid: "68400847"
---
# <a name="property-change-events"></a><span data-ttu-id="4eaeb-102">속성 변경 이벤트</span><span class="sxs-lookup"><span data-stu-id="4eaeb-102">Property Change Events</span></span>
[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]<span data-ttu-id="4eaeb-103">는 속성 값 변경에 대한 응답으로 발생하는 여러 이벤트를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="4eaeb-103">defines several events that are raised in response to a change in the value of a property.</span></span> <span data-ttu-id="4eaeb-104">일반적으로 속성은 종속성 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="4eaeb-104">Often the property is a dependency property.</span></span> <span data-ttu-id="4eaeb-105">이벤트 자체는 때때로 라우트된 이벤트 이며 표준 CLR (공용 언어 런타임) 이벤트입니다.</span><span class="sxs-lookup"><span data-stu-id="4eaeb-105">The event itself is sometimes a routed event and is sometimes a standard common language runtime (CLR) event.</span></span> <span data-ttu-id="4eaeb-106">이벤트 정의는 시나리오에 따라 달라집니다. 일부 속성 변경은 요소 트리를 통해 더 적절하게 라우트되지만 다른 속성 변경은 일반적으로 해당 속성이 변경한 개체에만 영향을 미치기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="4eaeb-106">The definition of the event varies depending on the scenario, because some property changes are more appropriately routed through an element tree, whereas other property changes are generally only of concern to the object where the property changed.</span></span>  
  
## <a name="identifying-a-property-change-event"></a><span data-ttu-id="4eaeb-107">속성 변경 이벤트 식별</span><span class="sxs-lookup"><span data-stu-id="4eaeb-107">Identifying a Property Change Event</span></span>  
 <span data-ttu-id="4eaeb-108">속성 변경을 보고하는 일부 이벤트는 시그니처 패턴 또는 명명 패턴 덕분에 속성 변경 이벤트로 명시적으로 식별되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="4eaeb-108">Not all events that report a property change are explicitly identified as a property changed event, either by virtue of a signature pattern or a naming pattern.</span></span> <span data-ttu-id="4eaeb-109">일반적으로 [!INCLUDE[TLA#tla_sdk](../../../../includes/tlasharptla-sdk-md.md)] 문서의 이벤트 설명은 이벤트가 속성 값 변경에 직접 연결되고 속성과 이벤트 간의 상호 참조를 제공하는지 여부를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="4eaeb-109">Generally, the description of the event in the [!INCLUDE[TLA#tla_sdk](../../../../includes/tlasharptla-sdk-md.md)] documentation indicates whether the event is directly tied to a property value change and provides cross-references between the property and event.</span></span>  
  
### <a name="routedpropertychanged-events"></a><span data-ttu-id="4eaeb-110">RoutedPropertyChanged 이벤트</span><span class="sxs-lookup"><span data-stu-id="4eaeb-110">RoutedPropertyChanged Events</span></span>  
 <span data-ttu-id="4eaeb-111">특정 이벤트에서는 속성 변경 이벤트에 명시적으로 사용되는 이벤트 데이터 형식 및 대리자를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="4eaeb-111">Certain events use an event data type and delegate that are explicitly used for property change events.</span></span> <span data-ttu-id="4eaeb-112">이벤트 데이터 형식이이 <xref:System.Windows.RoutedPropertyChangedEventArgs%601>고 대리자가 <xref:System.Windows.RoutedPropertyChangedEventHandler%601>입니다.</span><span class="sxs-lookup"><span data-stu-id="4eaeb-112">The event data type is <xref:System.Windows.RoutedPropertyChangedEventArgs%601>, and the delegate is <xref:System.Windows.RoutedPropertyChangedEventHandler%601>.</span></span> <span data-ttu-id="4eaeb-113">이벤트 데이터와 대리자는 둘 다 처리기를 정의할 때 변경 중인 속성의 실제 형식을 지정하는 데 사용되는 제네릭 형식 매개 변수를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="4eaeb-113">The event data and delegate both have a generic type parameter that is used to specify the actual type of the changing property when you define the handler.</span></span> <span data-ttu-id="4eaeb-114">이벤트 데이터에는 이벤트 데이터의 <xref:System.Windows.RoutedPropertyChangedEventArgs%601.OldValue%2A> 형식 <xref:System.Windows.RoutedPropertyChangedEventArgs%601.NewValue%2A>인수로 전달 되는 및 라는 두 개의 속성이 포함 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4eaeb-114">The event data contains two properties, <xref:System.Windows.RoutedPropertyChangedEventArgs%601.OldValue%2A> and <xref:System.Windows.RoutedPropertyChangedEventArgs%601.NewValue%2A>, which are both then passed as the type argument in the event data.</span></span>  
  
 <span data-ttu-id="4eaeb-115">이름의 "Routed" 부분은 속성 변경 이벤트가 라우트된 이벤트로 등록되었음을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="4eaeb-115">The "Routed" part of the name indicates that the property changed event is registered as a routed event.</span></span> <span data-ttu-id="4eaeb-116">속성 변경 이벤트를 라우트하는 방법의 장점은 자식 요소의 속성(컨트롤의 복합 부분) 값이 변경될 경우 최상위 컨트롤이 속성 변경 이벤트를 수신할 수 있다는 점입니다.</span><span class="sxs-lookup"><span data-stu-id="4eaeb-116">The advantage of routing a property changed event is that the top level of a control can receive property changed events if properties on the child elements (the control's composite parts) change values.</span></span> <span data-ttu-id="4eaeb-117">예를 들어 <xref:System.Windows.Controls.Primitives.RangeBase> <xref:System.Windows.Controls.Slider>와 같은 컨트롤을 통합 하는 컨트롤을 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4eaeb-117">For instance, you might create a control that incorporates a <xref:System.Windows.Controls.Primitives.RangeBase> control such as a <xref:System.Windows.Controls.Slider>.</span></span> <span data-ttu-id="4eaeb-118">슬라이더 부분에서 <xref:System.Windows.Controls.Primitives.RangeBase.Value%2A> 속성 값이 변경 되 면 해당 변경 내용이 파트가 아닌 부모 컨트롤에서 처리 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="4eaeb-118">If the value of the <xref:System.Windows.Controls.Primitives.RangeBase.Value%2A> property changes on the slider part, you might want to handle that change on the parent control rather than on the part.</span></span>  
  
 <span data-ttu-id="4eaeb-119">이전 값과 새 값이 있으므로 이 이벤트 처리기를 속성 값에 대한 유효성 검사기로 사용하려고 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4eaeb-119">Because you have an old value and a new value, it might be tempting to use this event handler as a validator for the property value.</span></span> <span data-ttu-id="4eaeb-120">하지만 이 방법은 대부분 속성 변경 이벤트의 디자인 의도가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="4eaeb-120">However, that is not the design intention of most property changed events.</span></span> <span data-ttu-id="4eaeb-121">일반적으로 코드의 다른 논리 영역에서 값에 대한 작업을 수행할 수 있도록 해당 값이 제공되지만, 실제로 이벤트 처리기 내의 값을 변경하는 것은 좋지 않고 이로 인해 처리기 구현 방식에 따라 의도치 않은 재귀가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4eaeb-121">Generally, the values are provided so that you can act on those values in other logic areas of your code, but actually changing the values from within the event handler is not advisable, and may cause unintentional recursion depending on how your handler is implemented.</span></span>  
  
 <span data-ttu-id="4eaeb-122">속성이 사용자 지정 종속성 속성 이거나 인스턴스화 코드를 정의한 파생 클래스를 사용 하는 경우 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 속성 시스템에 기본 제공 되는 속성 변경을 추적 하는 데 훨씬 더 나은 메커니즘이 있습니다. 속성 시스템 콜백 <xref:System.Windows.CoerceValueCallback> 및 <xref:System.Windows.PropertyChangedCallback>입니다.</span><span class="sxs-lookup"><span data-stu-id="4eaeb-122">If your property is a custom dependency property, or if you are working with a derived class where you have defined the instantiation code, there is a much better mechanism for tracking property changes that is built in to the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] property system: the property system callbacks <xref:System.Windows.CoerceValueCallback> and <xref:System.Windows.PropertyChangedCallback>.</span></span> <span data-ttu-id="4eaeb-123">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 속성 시스템을 유효성 검사 및 강제 변환에 사용하는 방법에 대한 자세한 내용은 [종속성 속성 콜백 및 유효성 검사](dependency-property-callbacks-and-validation.md) 및 [사용자 지정 종속성 속성](custom-dependency-properties.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="4eaeb-123">For more details about how you can use the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] property system for validation and coercion, see [Dependency Property Callbacks and Validation](dependency-property-callbacks-and-validation.md) and [Custom Dependency Properties](custom-dependency-properties.md).</span></span>  
  
### <a name="dependencypropertychanged-events"></a><span data-ttu-id="4eaeb-124">DependencyPropertyChanged 이벤트</span><span class="sxs-lookup"><span data-stu-id="4eaeb-124">DependencyPropertyChanged Events</span></span>  
 <span data-ttu-id="4eaeb-125">속성 변경 이벤트 시나리오의 일부인 다른 형식의 쌍은 <xref:System.Windows.DependencyPropertyChangedEventArgs> 및 <xref:System.Windows.DependencyPropertyChangedEventHandler>입니다.</span><span class="sxs-lookup"><span data-stu-id="4eaeb-125">Another pair of types that are part of a property changed event scenario is <xref:System.Windows.DependencyPropertyChangedEventArgs> and <xref:System.Windows.DependencyPropertyChangedEventHandler>.</span></span> <span data-ttu-id="4eaeb-126">이러한 속성 변경에 대 한 이벤트는 라우팅되지 않습니다. 표준 CLR 이벤트입니다.</span><span class="sxs-lookup"><span data-stu-id="4eaeb-126">Events for these property changes are not routed; they are standard CLR events.</span></span> <span data-ttu-id="4eaeb-127"><xref:System.Windows.DependencyPropertyChangedEventArgs>는에서 <xref:System.EventArgs>파생 되지 않으므로 비정상적인 이벤트 데이터 보고 형식입니다. <xref:System.Windows.DependencyPropertyChangedEventArgs> 는 클래스가 아니라 구조체입니다.</span><span class="sxs-lookup"><span data-stu-id="4eaeb-127"><xref:System.Windows.DependencyPropertyChangedEventArgs> is an unusual event data reporting type because it does not derive from <xref:System.EventArgs>; <xref:System.Windows.DependencyPropertyChangedEventArgs> is a structure, not a class.</span></span>  
  
 <span data-ttu-id="4eaeb-128">`RoutedPropertyChanged` 및 <xref:System.Windows.DependencyPropertyChangedEventArgs> 를사용하는이벤트는이벤트보다약간더일반적입니다.<xref:System.Windows.DependencyPropertyChangedEventHandler></span><span class="sxs-lookup"><span data-stu-id="4eaeb-128">Events that use <xref:System.Windows.DependencyPropertyChangedEventArgs> and <xref:System.Windows.DependencyPropertyChangedEventHandler> are slightly more common than `RoutedPropertyChanged` events.</span></span> <span data-ttu-id="4eaeb-129">이러한 형식을 <xref:System.Windows.UIElement.IsMouseCapturedChanged>사용 하는 이벤트의 예는입니다.</span><span class="sxs-lookup"><span data-stu-id="4eaeb-129">An example of an event that uses these types is <xref:System.Windows.UIElement.IsMouseCapturedChanged>.</span></span>  
  
 <span data-ttu-id="4eaeb-130">와 마찬가지로 <xref:System.Windows.RoutedPropertyChangedEventArgs%601>는 속성의 이전 값과 새 값 도보고합니다.<xref:System.Windows.DependencyPropertyChangedEventArgs></span><span class="sxs-lookup"><span data-stu-id="4eaeb-130">Like <xref:System.Windows.RoutedPropertyChangedEventArgs%601>, <xref:System.Windows.DependencyPropertyChangedEventArgs> also reports an old and new value for the property.</span></span> <span data-ttu-id="4eaeb-131">또한 이러한 값으로 수행할 작업에 대해 같은 사항을 고려해야 합니다. 일반적으로 이벤트에 대한 응답으로 sender에서 값을 다시 변경하지 않는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="4eaeb-131">Also, the same considerations about what you can do with the values apply; it is generally not recommended that you attempt to change the values again on the sender in response to the event.</span></span>  
  
## <a name="property-triggers"></a><span data-ttu-id="4eaeb-132">속성 트리거</span><span class="sxs-lookup"><span data-stu-id="4eaeb-132">Property Triggers</span></span>  
 <span data-ttu-id="4eaeb-133">속성 트리거는 속성 변경 이벤트와 밀접한 관계가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4eaeb-133">A closely related concept to a property changed event is a property trigger.</span></span> <span data-ttu-id="4eaeb-134">속성 트리거는 스타일 또는 템플릿 내에서 만들어지고 이를 통해 속성 트리거에 할당된 속성 값에 따라 조건부 동작을 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4eaeb-134">A property trigger is created within a style or template and enables you to create a conditional behavior based on the value of the property where the property trigger is assigned.</span></span>  
  
 <span data-ttu-id="4eaeb-135">속성 트리거의 속성은 종속성 속성이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4eaeb-135">The property for a property trigger must be a dependency property.</span></span> <span data-ttu-id="4eaeb-136">읽기 전용 종속성 속성일 수 있고 대부분 이러한 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="4eaeb-136">It can be (and frequently is) a read-only dependency property.</span></span> <span data-ttu-id="4eaeb-137">컨트롤이 표시하는 종속성 속성이 최소한 부분적으로 속성 트리거로 디자인된 경우를 나타내는 좋은 지표는 속성 이름이 "Is"로 시작되는 경우입니다.</span><span class="sxs-lookup"><span data-stu-id="4eaeb-137">A good indicator for when a dependency property exposed by a control is at least partially designed to be a property trigger is if the property name begins with "Is".</span></span> <span data-ttu-id="4eaeb-138">일반적으로 이렇게 이름이 지정된 속성은 읽기 전용 부울 종속성 속성입니다. 이 종속성 속성에 대한 기본 시나리오는 실시간 UI에 대한 결과를 생성할 수 있는 컨트롤 상태를 보고하므로 속성 트리거의 후보가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="4eaeb-138">Properties that have this naming are often a read-only Boolean dependency property where the primary scenario for the property is reporting control state that might have consequences to the real-time UI and is thus a property trigger candidate.</span></span>  
  
 <span data-ttu-id="4eaeb-139">이러한 속성 중 일부에는 전용 속성 변경 이벤트도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4eaeb-139">Some of these properties also have a dedicated property changed event.</span></span> <span data-ttu-id="4eaeb-140">예를 들어 속성 <xref:System.Windows.UIElement.IsMouseCaptured%2A> 에는 속성이 변경 된 이벤트가 <xref:System.Windows.UIElement.IsMouseCapturedChanged>있습니다.</span><span class="sxs-lookup"><span data-stu-id="4eaeb-140">For instance, the property <xref:System.Windows.UIElement.IsMouseCaptured%2A> has a property changed event <xref:System.Windows.UIElement.IsMouseCapturedChanged>.</span></span> <span data-ttu-id="4eaeb-141">속성 자체는 읽기 전용 이며, 해당 값은 입력 시스템에 의해 조정 되며, 입력 시스템은 실시간으로 <xref:System.Windows.UIElement.IsMouseCapturedChanged> 변경 될 때마다 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="4eaeb-141">The property itself is read-only, with its value adjusted by the input system, and the input system raises <xref:System.Windows.UIElement.IsMouseCapturedChanged> on each real-time change.</span></span>  
  
 <span data-ttu-id="4eaeb-142">실제 속성 변경 이벤트에 비해 속성 변경에 대한 작업을 수행하는 속성 트리거 사용에는 몇 가지 제한 사항이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4eaeb-142">Compared to a true property changed event, using a property trigger to act on a property change has some limitations.</span></span>  
  
 <span data-ttu-id="4eaeb-143">속성 트리거는 정확한 일치 논리를 진행합니다.</span><span class="sxs-lookup"><span data-stu-id="4eaeb-143">Property triggers work through an exact match logic.</span></span> <span data-ttu-id="4eaeb-144">속성과 함께 트리거가 작업을 수행할 특정 값을 지정합니다. 예: `<Setter Property="IsMouseCaptured" Value="true"> ... </Setter>`.</span><span class="sxs-lookup"><span data-stu-id="4eaeb-144">You specify a property and a value that indicates the specific value for which the trigger will act. For instance: `<Setter Property="IsMouseCaptured" Value="true"> ... </Setter>`.</span></span> <span data-ttu-id="4eaeb-145">이 제한 사항 때문에 대부분의 속성 트리거는 부울 속성 또는 전용 열거형 값을 사용하는 속성에 사용됩니다. 여기서 가능한 값 범위는 각 경우에 대한 트리거를 정의할 만큼 충분히 관리하기 쉽습니다.</span><span class="sxs-lookup"><span data-stu-id="4eaeb-145">Because of this limitation, the majority of property trigger usages will be for Boolean properties, or properties that take a dedicated enumeration value, where the possible value range is manageable enough to define a trigger for each case.</span></span> <span data-ttu-id="4eaeb-146">또는 속성 트리거는 항목 개수가 0에 도달하는데 속성 값이 다시 0이 아닌 수로 변경될 때 이를 처리할 트리거가 없는 경우와 같은 특수 값에 대해서만 존재할 수 있습니다. 모든 경우에 대한 트리거 대신에 여기에는 코드 이벤트 처리기가 필요하거나 값이 0이 아닐 때 다시 트리거 상태에서 전환되는 기본 동작이 필요할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4eaeb-146">Or property triggers might exist only for special values, such as when an items count reaches zero, and there would be no trigger that accounts for the cases when the property value changes away from zero again (instead of triggers for all cases, you might need a code event handler here, or a default behavior that toggles back from the trigger state again when the value is nonzero).</span></span>  
  
 <span data-ttu-id="4eaeb-147">속성 트리거 구문은 프로그래밍의 "if" 문과 비슷합니다.</span><span class="sxs-lookup"><span data-stu-id="4eaeb-147">The property trigger syntax is analogous to an "if" statement in programming.</span></span> <span data-ttu-id="4eaeb-148">트리거 조건이 true이면 속성 트리거의 “본문”이 “실행”됩니다.</span><span class="sxs-lookup"><span data-stu-id="4eaeb-148">If the trigger condition is true, then the "body" of the property trigger is "executed".</span></span> <span data-ttu-id="4eaeb-149">속성 트리거의 “본문”은 코드가 아니라 태”그입니다.</span><span class="sxs-lookup"><span data-stu-id="4eaeb-149">The "body" of a property trigger is not code, it is markup.</span></span> <span data-ttu-id="4eaeb-150">이 태그는 하나 <xref:System.Windows.Setter> 이상의 요소를 사용 하 여 스타일 또는 템플릿이 적용 되는 개체의 다른 속성을 설정 하는 것으로 제한 됩니다.</span><span class="sxs-lookup"><span data-stu-id="4eaeb-150">That markup is limited to using one or more <xref:System.Windows.Setter> elements to set other properties of the object where the style or template is being applied.</span></span>  
  
 <span data-ttu-id="4eaeb-151">다양 한 값이 있는 속성 트리거의 "if" 조건을 오프셋 하려면 일반적으로을 <xref:System.Windows.Setter>사용 하 여 동일한 속성 값을 기본값으로 설정 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="4eaeb-151">To offset the "if" condition of a property trigger that has a wide variety of possible values, it is generally advisable to set that same property value to a default by using a <xref:System.Windows.Setter>.</span></span> <span data-ttu-id="4eaeb-152">이러한 방식으로 트리거 <xref:System.Windows.Trigger> 조건이 true 인 경우 포함 된 setter는 우선 순위가 지정 되 고, <xref:System.Windows.Setter> 내 <xref:System.Windows.Trigger> 에 없는는 트리거 조건이 false 일 때마다 우선 순위가 지정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="4eaeb-152">This way, the <xref:System.Windows.Trigger> contained setter will have precedence when the trigger condition is true, and the <xref:System.Windows.Setter> that is not within a <xref:System.Windows.Trigger> will have precedence whenever the trigger condition is false.</span></span>  
  
 <span data-ttu-id="4eaeb-153">일반적으로 속성 트리거는 같은 요소에서 또 다른 속성 상태에 따라 하나 이상의 모양 속성을 변경해야 하는 시나리오에 적합합니다.</span><span class="sxs-lookup"><span data-stu-id="4eaeb-153">Property triggers are generally appropriate for scenarios where one or more appearance properties should change, based on the state of another property on the same element.</span></span>  
  
 <span data-ttu-id="4eaeb-154">속성 트리거에 대한 자세한 내용은 [스타일 지정 및 템플릿](../controls/styling-and-templating.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="4eaeb-154">To learn more about property triggers, see [Styling and Templating](../controls/styling-and-templating.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="4eaeb-155">참고자료</span><span class="sxs-lookup"><span data-stu-id="4eaeb-155">See also</span></span>

- [<span data-ttu-id="4eaeb-156">라우트된 이벤트 개요</span><span class="sxs-lookup"><span data-stu-id="4eaeb-156">Routed Events Overview</span></span>](routed-events-overview.md)
- [<span data-ttu-id="4eaeb-157">종속성 속성 개요</span><span class="sxs-lookup"><span data-stu-id="4eaeb-157">Dependency Properties Overview</span></span>](dependency-properties-overview.md)

---
title: WPF에 대한 XAML 및 사용자 지정 클래스
ms.date: 03/30/2017
helpviewer_keywords:
- custom classes in XAML [WPF]
- XAML [WPF], custom classes
- classes [WPF], custom classes in XAML
ms.assetid: e7313137-581e-4a64-8453-d44e15a6164a
ms.openlocfilehash: e71946ec06eb1b4c75f30084dfdb863d8e3b093e
ms.sourcegitcommit: 0be8a279af6d8a43e03141e349d3efd5d35f8767
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 04/18/2019
ms.locfileid: "59122358"
---
# <a name="xaml-and-custom-classes-for-wpf"></a><span data-ttu-id="43cb0-102">WPF에 대한 XAML 및 사용자 지정 클래스</span><span class="sxs-lookup"><span data-stu-id="43cb0-102">XAML and Custom Classes for WPF</span></span>
<span data-ttu-id="43cb0-103">[!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] 프레임워크에서 구현된 XAML은 모든 [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] 언어로 사용자 지정 클래스 또는 구조체를 정의한 다음 XAML 태그를 사용하여 해당 클래스에 액세스하는 기능을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="43cb0-103">XAML as implemented in [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] frameworks supports the ability to define a custom class or structure in any [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] language, and then access that class using XAML markup.</span></span> <span data-ttu-id="43cb0-104">일반적으로 사용자 지정 형식을 XAML 네임스페이스 접두사에 매핑하여 [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] 정의 형식과 사용자 지정 형식의 혼합을 동일한 태그 파일에서 함께 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="43cb0-104">You can use a mixture of [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]-defined types and your custom types within the same markup file, typically by mapping the custom types to a XAML namespace prefix.</span></span> <span data-ttu-id="43cb0-105">이 항목에서는 사용자 지정 클래스를 XAML 요소로 사용 가능하기 위해 만족해야 하는 요구 사항을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="43cb0-105">This topic discusses the requirements that a custom class must satisfy to be usable as a XAML element.</span></span>  

<a name="Custom_Classes_in_Applications_vs__in_Assemblies"></a>   
## <a name="custom-classes-in-applications-or-assemblies"></a><span data-ttu-id="43cb0-106">애플리케이션 또는 어셈블리의 사용자 지정 클래스</span><span class="sxs-lookup"><span data-stu-id="43cb0-106">Custom Classes in Applications or Assemblies</span></span>  
 <span data-ttu-id="43cb0-107">XAML에서 사용되는 사용자 지정 클래스는 두 가지 방법으로 정의할 수 있습니다. 즉, 기본 [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] 애플리케이션을 생성하는 다른 코드 또는 코드 숨김 파일에서 정의하거나, 클래스 라이브러리로 사용되는 DLL 또는 실행 파일과 같은 별도 어셈블리의 클래스로 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="43cb0-107">Custom classes that are used in XAML can be defined in two distinct ways: within the code-behind or other code that produces the primary [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] application, or as a class in a separate assembly, such as an executable or DLL used as a class library.</span></span> <span data-ttu-id="43cb0-108">각 방법에는 고유한 장점과 단점이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="43cb0-108">Each of these approaches has particular advantages and disadvantages.</span></span>  
  
-   <span data-ttu-id="43cb0-109">클래스 라이브러리를 만드는 경우 사용자 지정 클래스를 서로 다른 여러 애플리케이션에서 공유할 수 있다는 장점이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="43cb0-109">The advantage of creating a class library is that any such custom classes can be shared across many different possible applications.</span></span> <span data-ttu-id="43cb0-110">또한 별도 라이브러리 애플리케이션의 버전 관리 문제를 더 쉽게 컨트롤하고 클래스를 XAML 페이지의 루트 요소로 사용하는 클래스를 간단하게 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="43cb0-110">A separate library also makes versioning issues of applications easier to control, and simplifies creating a class where the intended class usage is as a root element on a XAML page.</span></span>  
  
-   <span data-ttu-id="43cb0-111">사용자 지정 클래스를 애플리케이션에 정의하는 방법은 비교적 간단하며 기본 애플리케이션 실행 파일이 아닌 별도의 어셈블리를 사용할 때 발생하는 배포 및 테스트 문제를 최소화할 수 있다는 장점이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="43cb0-111">The advantage of defining the custom classes in the application is that this technique is relatively lightweight and minimizes the deployment and testing issues encountered when you introduce separate assemblies beyond the main application executable.</span></span>  
  
-   <span data-ttu-id="43cb0-112">동일한 어셈블리에 정의되어 있는지 다른 어셈블리에 정의되어 있는지에 상관없이, 사용자 지정 클래스를 XAML에서 요소로 사용하려면 CLR 네임스페이스와 XML 네임스페이스 간에 매핑해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="43cb0-112">Whether defined in the same or different assembly, custom classes need to be mapped between CLR  namespace and XML  namespace in order to be used in XAML as elements.</span></span> <span data-ttu-id="43cb0-113">[WPF XAML을 위한 XAML 네임스페이스 및 네임스페이스 매핑](xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="43cb0-113">See [XAML Namespaces and Namespace Mapping for WPF XAML](xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md).</span></span>  
  
<a name="Requirements_for_a_Custom_Class_as_a_XAML_Element"></a>   
## <a name="requirements-for-a-custom-class-as-a-xaml-element"></a><span data-ttu-id="43cb0-114">사용자 지정 클래스를 XAML 요소로 사용하기 위한 요구 사항</span><span class="sxs-lookup"><span data-stu-id="43cb0-114">Requirements for a Custom Class as a XAML Element</span></span>  
 <span data-ttu-id="43cb0-115">클래스를 개체 요소로 인스턴스화하려면 클래스가 다음 요구 사항을 충족해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="43cb0-115">In order to be able to be instantiated as an object element, your class must meet the following requirements:</span></span>  
  
-   <span data-ttu-id="43cb0-116">사용자 지정 클래스가 공용 클래스여야 하고 매개 변수가 없는 기본 공용 생성자를 지원해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="43cb0-116">Your custom class must be public and support a default (parameterless) public constructor.</span></span> <span data-ttu-id="43cb0-117">구조체에 대한 자세한 내용은 다음 섹션을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="43cb0-117">(See following section for notes regarding structures.)</span></span>  
  
-   <span data-ttu-id="43cb0-118">사용자 지정 클래스가 중첩 클래스가 아니어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="43cb0-118">Your custom class must not be a nested class.</span></span> <span data-ttu-id="43cb0-119">중첩 클래스 및 일반 CLR 사용 구문의 "점"은 연결된 속성과 같은 다른 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 및/또는 XAML의 기능을 방해합니다.</span><span class="sxs-lookup"><span data-stu-id="43cb0-119">Nested classes and the "dot" in their general CLR usage syntax interfere with other [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] and/or XAML features such as attached properties.</span></span>  
  
 <span data-ttu-id="43cb0-120">개체 요소 구문을 사용하는 것 외에도 개체 정의에서 해당 개체를 값 형식으로 사용하는 다른 공용 속성에 대해서는 속성 요소 구문을 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="43cb0-120">In addition to enabling object element syntax, your object definition also enables property element syntax for any other public properties that take that object as the value type.</span></span> <span data-ttu-id="43cb0-121">그 이유는 이제 개체가 개체 요소로 인스턴스화되어 이러한 속성의 속성 요소 값을 채울 수 있기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="43cb0-121">This is because the object can now be instantiated as an object element and can fill the property element value of such a property.</span></span>  
  
### <a name="structures"></a><span data-ttu-id="43cb0-122">구조체</span><span class="sxs-lookup"><span data-stu-id="43cb0-122">Structures</span></span>  
 <span data-ttu-id="43cb0-123">사용자 지정 형식으로 정의하는 구조체는 항상 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]의 XAML로 생성될 수 있어야 합니다. [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] 컴파일러에서는 모드 속성 값을 기본값으로 초기화하는 구조체의 기본 생성자를 내재적으로 만들기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="43cb0-123">Structures that you define as custom types are always able to be constructed in XAML  in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] .This is because the [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] compilers implicitly create a default constructor for a structure that initializes all property values to their defaults.</span></span> <span data-ttu-id="43cb0-124">경우에 따라서는 구조체의 기본 생성 동작 및/또는 개체 요소를 사용하는 것이 바람직하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="43cb0-124">In some cases, the default construction behavior and/or object element usage for a structure is not desirable.</span></span> <span data-ttu-id="43cb0-125">구조체가 값을 채우고 개념적으로 공용 구조체로 작동하기 때문일 수 있습니다. 이 경우 포함된 값의 해석이 서로 달라서 어느 속성도 설정할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="43cb0-125">This might be because the structure is intended to fill values and function conceptually as a union, where the values contained might have mutually exclusive interpretations and thus none of its properties are settable.</span></span> <span data-ttu-id="43cb0-126">A [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 이러한 구조체의 예로 <xref:System.Windows.GridLength>합니다.</span><span class="sxs-lookup"><span data-stu-id="43cb0-126">A [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] example of such a structure is <xref:System.Windows.GridLength>.</span></span> <span data-ttu-id="43cb0-127">일반적으로 이러한 구조체는 구조체의 값에 대해 서로 다른 해석이나 모드를 만드는 문자열 규칙을 사용하여 값을 특성 형식으로 표현할 수 있도록 형식 변환기를 구현합니다.</span><span class="sxs-lookup"><span data-stu-id="43cb0-127">Generally, such structures should implement a type converter such that the values can be expressed in attribute form, using string conventions that create the different interpretations or modes of the structure's values.</span></span> <span data-ttu-id="43cb0-128">이러한 구조체는 기본값이 아닌 생성자를 통해 코드를 생성하는 경우에도 이와 유사한 동작을 노출해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="43cb0-128">The structure should also expose similar behavior for code construction through a non-default constructor.</span></span>  
  
<a name="Requirements_for_Properties_of_a_Custom_Class_as_XAML"></a>   
## <a name="requirements-for-properties-of-a-custom-class-as-xaml-attributes"></a><span data-ttu-id="43cb0-129">사용자 지정 클래스의 속성을 XAML 특성으로 사용하기 위한 요구 사항</span><span class="sxs-lookup"><span data-stu-id="43cb0-129">Requirements for Properties of a Custom Class as XAML Attributes</span></span>  
 <span data-ttu-id="43cb0-130">속성이 값 기준 형식(예: 기본 형식)을 참조하거나 XAML 프로세서에서 액세스할 수 있는 기본 생성자나 전용 형식 변환기를 가지고 있는 형식에 대한 클래스를 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="43cb0-130">Properties must reference a by-value type (such as a primitive), or use a class for type that has either a default constructor or a dedicated type converter that a XAML processor can access.</span></span> <span data-ttu-id="43cb0-131">CLR XAML 구현에서 XAML 프로세서 이러한 변환기를 찾습니다 또는 응용 프로그램의 언어 기본 형식에 대 한 기본 지원을 통해 <xref:System.ComponentModel.TypeConverterAttribute> 형식 또는 멤버의 형식 정의 백업 하려면</span><span class="sxs-lookup"><span data-stu-id="43cb0-131">In the CLR XAML implementation, XAML processors either find such converters through native support for language primitives, or through application of <xref:System.ComponentModel.TypeConverterAttribute> to a type or member in backing type definitions</span></span>  
  
 <span data-ttu-id="43cb0-132">또는 속성이 추상 클래스 형식 또는 인터페이스를 참조할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="43cb0-132">Alternatively, the property may reference an abstract class type, or an interface.</span></span> <span data-ttu-id="43cb0-133">추상 클래스나 인터페이스의 경우에는 XAML 구문 분석 시 해당 인터페이스를 구현하는 실제 클래스 인스턴스로 또는 추상 클래스에서 파생되는 형식의 인스턴스로 속성 값을 채워야 합니다.</span><span class="sxs-lookup"><span data-stu-id="43cb0-133">For abstract classes or interfaces, the expectation for XAML parsing is that the property value must be filled with practical class instances that implement the interface, or instances of types that derive from the abstract class.</span></span>  
  
 <span data-ttu-id="43cb0-134">속성을 추상 클래스에서 선언할 수 있지만 해당 속성은 추상 클래스에서 파생되는 실제 클래스에서만 설정될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="43cb0-134">Properties can be declared on an abstract class, but can only be set on practical classes that derive from the abstract class.</span></span> <span data-ttu-id="43cb0-135">클래스에 대한 개체 요소를 만들려면 클래스에 공용 기본 생성자가 필요하기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="43cb0-135">This is because creating the object element for the class at all requires a public default constructor on the class.</span></span>  
  
### <a name="typeconverter-enabled-attribute-syntax"></a><span data-ttu-id="43cb0-136">TypeConverter 사용 특성 구문</span><span class="sxs-lookup"><span data-stu-id="43cb0-136">TypeConverter Enabled Attribute Syntax</span></span>  
 <span data-ttu-id="43cb0-137">클래스 수준에서 전용 특성 사용 형식 변환기를 제공한 경우 적용된 형식 변환을 사용하면 해당 형식을 인스턴스화해야 하는 모든 속성에 특성 구문을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="43cb0-137">If you provide a dedicated, attributed type converter at the class level, the applied type conversion enables attribute syntax for any property that needs to instantiate that type.</span></span> <span data-ttu-id="43cb0-138">형식 변환기는 해당 형식의 개체 요소를 사용하지 않습니다. 해당 형식에 대한 기본 생성자가 있는 경우에만 개체 요소를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="43cb0-138">A type converter does not enable object element usage of the type; only the presence of a default constructor for that type enables object element usage.</span></span> <span data-ttu-id="43cb0-139">따라서 형식 변환기가 사용하는 속성은 일반적으로 속성 구문에서 사용할 수 없습니다. 단, 형식 자체가 개체 요소 구문도 지원하는 경우는 예외입니다.</span><span class="sxs-lookup"><span data-stu-id="43cb0-139">Therefore, properties that are type-converter enabled are generally speaking not usable in property syntax, unless the type itself also supports object element syntax.</span></span> <span data-ttu-id="43cb0-140">한 가지 예외적인 경우로 속성 요소에 문자열을 포함하여 속성 요소 구문을 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="43cb0-140">The exception to this is that you can specify a property element syntax, but have the property element contain a string.</span></span> <span data-ttu-id="43cb0-141">기본적으로 해당 특성 구문 사용 하는 및 특성 값의 보다 강력한 공백 처리가 필요 없는 것이 일반적입니다.</span><span class="sxs-lookup"><span data-stu-id="43cb0-141">That usage is really essentially equivalent to an attribute syntax usage, and such a usage is not common unless there is a need for more robust white-space handling of the attribute value.</span></span> <span data-ttu-id="43cb0-142">예를 들어 다음은 문자열을 사용하는 속성 요소를 사용하는 방법을 보여 주며 이는 특성을 사용하는 것과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="43cb0-142">For example, the following is a property element usage that takes a string, and the attribute usage equivalent:</span></span>  
  
 [!code-xaml[XamlOvwSupport#GoofyTCPE](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#goofytcpe)]  
  
 [!code-xaml[XamlOvwSupport#GoofyTCPE2](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#goofytcpe2)]  
  
 <span data-ttu-id="43cb0-143">여기서 특성 구문은 허용 되지만 개체 요소를 포함 하는 속성 요소 구문을 통해 XAML 스트링에 속성의 예로 사용 하는 다양 한 속성을 <xref:System.Windows.Input.Cursor> 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="43cb0-143">Examples of properties where attribute syntax is allowed but property element syntax that contains an object element is disallowed through XAML are various properties that take the <xref:System.Windows.Input.Cursor> type.</span></span> <span data-ttu-id="43cb0-144"><xref:System.Windows.Input.Cursor> 클래스에는 전용된 형식 변환기 <xref:System.Windows.Input.CursorConverter>, 하지만 기본 생성자를 노출 하지 않습니다 하므로 <xref:System.Windows.FrameworkElement.Cursor%2A> 만 속성 특성 구문을 통해도 실제 <xref:System.Windows.Input.Cursor> 형식은 참조 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="43cb0-144">The <xref:System.Windows.Input.Cursor> class has a dedicated type converter <xref:System.Windows.Input.CursorConverter>, but does not expose a default constructor, so the <xref:System.Windows.FrameworkElement.Cursor%2A> property can only be set through attribute syntax even though the actual <xref:System.Windows.Input.Cursor> type is a reference type.</span></span>  
  
### <a name="per-property-type-converters"></a><span data-ttu-id="43cb0-145">속성별 형식 변환기</span><span class="sxs-lookup"><span data-stu-id="43cb0-145">Per-Property Type Converters</span></span>  
 <span data-ttu-id="43cb0-146">또는 속성 자체가 속성 수준에서 형식 변환기를 선언할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="43cb0-146">Alternatively, the property itself may declare a type converter at the property level.</span></span> <span data-ttu-id="43cb0-147">이렇게 하면 "미니 언어" 특성의 들어오는 문자열 값에 대 한 입력으로 처리 하 여 속성 인라인 형식의 개체를 인스턴스화하는 <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> 적절 한 형식에 따라 작업 합니다.</span><span class="sxs-lookup"><span data-stu-id="43cb0-147">This enables a "mini language" that instantiates objects of the type of the property inline, by processing incoming string values of the attribute as input for a <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> operation based on the appropriate type.</span></span> <span data-ttu-id="43cb0-148">일반적으로 이 작업은 XAML에서 속성을 설정할 수 있는 유일한 방법이 아니라 편리한 접근자를 제공하기 위해 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="43cb0-148">Typically this is done to provide a convenience accessor, and not as the sole means to enable setting a property in XAML.</span></span> <span data-ttu-id="43cb0-149">그러나 기본 생성자나 특성 사용 형식 변환기를 제공하지 않는 기존 [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] 형식을 사용하려는 특성에 대해서도 형식 변환기를 사용할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="43cb0-149">However, it is also possible to use type converters for attributes where you want to use existing [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] types that do not supply either a default constructor or an attributed type converter.</span></span> <span data-ttu-id="43cb0-150">예제는 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] API는 사용 하는 특정 속성을 <xref:System.Globalization.CultureInfo> 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="43cb0-150">Examples from the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] API are certain properties that take the <xref:System.Globalization.CultureInfo> type.</span></span> <span data-ttu-id="43cb0-151">이 예에서 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 기존 Microsoft.NET Framework를 사용 <xref:System.Globalization.CultureInfo> 프레임 워크의 이전 버전에 사용 된 호환성 및 마이그레이션 시나리오를 해결 하기 위해 형식 하지만 <xref:System.Globalization.CultureInfo> 형식에 필요한 지원 하지 않았습니다 생성자 또는 형식 수준 형식 변환을 XAML 속성 값으로 직접.</span><span class="sxs-lookup"><span data-stu-id="43cb0-151">In this case, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] used the existing Microsoft .NET Framework <xref:System.Globalization.CultureInfo> type to better address compatibility and migration scenarios that were used in earlier versions of frameworks, but the <xref:System.Globalization.CultureInfo> type did not support the necessary constructors or type-level type conversion to be usable as a XAML property value directly.</span></span>  
  
 <span data-ttu-id="43cb0-152">따라서 컨트롤 작성자는 XAML을 사용하는 속성을 노출할 때마다 해당 속성에 종속성 속성을 지원하는 방법을 고려해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="43cb0-152">Whenever you expose a property that has a XAML usage, particularly if you are a control author, you should strongly consider backing that property with a dependency property.</span></span> <span data-ttu-id="43cb0-153">기존 사용 하는 경우에 특히 그렇습니다 [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] XAML 프로세서의 구현을 사용 하 여 성능을 향상 시킬 수 있으므로 <xref:System.Windows.DependencyProperty> 백업 합니다.</span><span class="sxs-lookup"><span data-stu-id="43cb0-153">This is particularly true if you use the existing [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] implementation of the XAML processor, because you can improve performance by using <xref:System.Windows.DependencyProperty> backing.</span></span> <span data-ttu-id="43cb0-154">종속성 속성은 XAML 액세스 가능 속성이 제공할 것으로 예상되는 속성 시스템의 기능을 노출합니다.</span><span class="sxs-lookup"><span data-stu-id="43cb0-154">A dependency property will expose property system features for your property that users will come to expect for a XAML accessible property.</span></span> <span data-ttu-id="43cb0-155">이러한 기능에는 애니메이션, 데이터 바인딩 및 스타일 지원 등이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="43cb0-155">This includes features such as animation, data binding, and style support.</span></span> <span data-ttu-id="43cb0-156">자세한 내용은 [사용자 지정 종속성 속성](custom-dependency-properties.md) 및 [XAML 로드 및 종속성 속성](xaml-loading-and-dependency-properties.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="43cb0-156">For more information, see [Custom Dependency Properties](custom-dependency-properties.md) and [XAML Loading and Dependency Properties](xaml-loading-and-dependency-properties.md).</span></span>  
  
### <a name="writing-and-attributing-a-type-converter"></a><span data-ttu-id="43cb0-157">형식 변환기 작성 및 특성 설정</span><span class="sxs-lookup"><span data-stu-id="43cb0-157">Writing and Attributing a Type Converter</span></span>  
 <span data-ttu-id="43cb0-158">경우에 따라 사용자 지정 작성 해야 합니다 <xref:System.ComponentModel.TypeConverter> 속성 유형에 대 한 형식 변환을 제공 하는 클래스를 파생 합니다.</span><span class="sxs-lookup"><span data-stu-id="43cb0-158">You occasionally will need to write a custom <xref:System.ComponentModel.TypeConverter> derived class to provide type conversion for your property type.</span></span> <span data-ttu-id="43cb0-159">파생 되며 XAML 사용을 지원할 수 있는 형식 변환기를 만드는 방법 및 적용 하는 방법에 대 한 지침은 합니다 <xref:System.ComponentModel.TypeConverterAttribute>를 참조 하세요 [Typeconverter 및 XAML](typeconverters-and-xaml.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="43cb0-159">For instructions on how to derive from and create a type converter that can support XAML usages, and how to apply the <xref:System.ComponentModel.TypeConverterAttribute>, see [TypeConverters and XAML](typeconverters-and-xaml.md).</span></span>  
  
<a name="Requirements_for_Events_of_a_Custom_Class_as_XAML"></a>   
## <a name="requirements-for-xaml-event-handler-attribute-syntax-on-events-of-a-custom-class"></a><span data-ttu-id="43cb0-160">사용자 지정 클래스의 이벤트에 XAML 이벤트 처리기 특성 구문을 사용하기 위한 요구 사항</span><span class="sxs-lookup"><span data-stu-id="43cb0-160">Requirements for XAML Event Handler Attribute Syntax on Events of a Custom Class</span></span>  
 <span data-ttu-id="43cb0-161">[!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] 이벤트로 사용할 이벤트는 파생 클래스에서 이벤트 액세스가 가능한 추상 클래스 또는 기본 생성자를 지원하는 클래스에 공용 이벤트로 노출되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="43cb0-161">To be usable as a [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] event, the event must be exposed as a public event on a class that supports a default constructor, or on an abstract class where the event can be accessed on derived classes.</span></span> <span data-ttu-id="43cb0-162">라우트된 이벤트로 편리 하 게 사용할 수 있도록 프로그램 [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] 이벤트는 명시적 구현 해야 `add` 및 `remove` 메서드를 추가 및 제거에 대 한 처리기를 [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] 이벤트 서명의 하며 이러한 처리기에는 <xref:System.Windows.UIElement.AddHandler%2A>및 <xref:System.Windows.UIElement.RemoveHandler%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="43cb0-162">In order to be used conveniently as a routed event, your [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] event should implement explicit `add` and `remove` methods, which add and remove handlers for the [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] event signature and forward those handlers to the <xref:System.Windows.UIElement.AddHandler%2A> and <xref:System.Windows.UIElement.RemoveHandler%2A> methods.</span></span> <span data-ttu-id="43cb0-163">이 두 메서드는 이벤트가 연결된 인스턴스의 라우트된 이벤트 처리기 저장소에 처리기를 추가하거나 제거합니다.</span><span class="sxs-lookup"><span data-stu-id="43cb0-163">These methods add or remove the handlers to the routed event handler store on the instance that the event is attached to.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="43cb0-164">직접 사용 하 여 라우트된 이벤트에 대 한 처리기를 등록 하는 것이 불가능 <xref:System.Windows.UIElement.AddHandler%2A>, 및 의도적으로 정의 하는 [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] 라우트된 이벤트를 노출 하는 이벤트입니다.</span><span class="sxs-lookup"><span data-stu-id="43cb0-164">It is possible to register handlers directly for routed events using <xref:System.Windows.UIElement.AddHandler%2A>, and to deliberately not define a [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] event that exposes the routed event.</span></span> <span data-ttu-id="43cb0-165">이벤트에서 연결 처리기에 대해 XAML 특성 구문을 사용하지 않으며 결과 클래스에서 해당 형식의 기능에 대해 투명도가 떨어지는 XAML 보기를 제공하므로, 이 방법은 일반적으로 권장되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="43cb0-165">This is not generally recommended because the event will not enable XAML attribute syntax for attaching handlers, and your resulting class will offer a less transparent XAML view of that type's capabilities.</span></span>  
  
<a name="Collection_Properties"></a>   
## <a name="writing-collection-properties"></a><span data-ttu-id="43cb0-166">컬렉션 속성 작성</span><span class="sxs-lookup"><span data-stu-id="43cb0-166">Writing Collection Properties</span></span>  
 <span data-ttu-id="43cb0-167">컬렉션 형식을 사용하는 속성에는 컬렉션에 추가할 개체를 지정하는 데 사용할 수 있는 XAML 구문이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="43cb0-167">Properties that take a collection type have a XAML syntax that enables you to specify objects that are added to the collection.</span></span> <span data-ttu-id="43cb0-168">이 구문은 다음과 같은 두 가지 중요한 기능을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="43cb0-168">This syntax has two notable features.</span></span>  
  
-   <span data-ttu-id="43cb0-169">컬렉션 개체인 개체를 개체 요소 구문에 지정할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="43cb0-169">The object that is the collection object does not need to be specified in object element syntax.</span></span> <span data-ttu-id="43cb0-170">컬렉션 형식을 사용하는 XAML에 속성을 지정할 때마다 컬렉션 형식이 항상 암시적으로 존재합니다.</span><span class="sxs-lookup"><span data-stu-id="43cb0-170">The presence of that collection type is implicit whenever you specify a property in XAML that takes a collection type.</span></span>  
  
-   <span data-ttu-id="43cb0-171">태그에서 컬렉션 속성의 자식 요소는 컬렉션의 멤버로 처리됩니다.</span><span class="sxs-lookup"><span data-stu-id="43cb0-171">Child elements of the collection property in markup are processed to become members of the collection.</span></span> <span data-ttu-id="43cb0-172">일반적으로 컬렉션 멤버에 대한 코드 액세스는 `Add`와 같은 목록/사전 메서드를 통해 또는 인덱서를 통해 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="43cb0-172">Ordinarily, the code access to the members of a collection is performed through list/dictionary methods such as `Add`, or through an indexer.</span></span> <span data-ttu-id="43cb0-173">하지만 XAML 구문은 메서드나 인덱서를 지원 하지 않습니다 (예외: XAML 2009는 메서드를 지원할 수 있지만 XAML 2009를 사용 하면 가능한 WPF 사용; 제한 참조 [XAML 2009 언어 기능](../../xaml-services/xaml-2009-language-features.md)).</span><span class="sxs-lookup"><span data-stu-id="43cb0-173">But XAML syntax does not support methods or indexers (exception: XAML 2009 can support methods, but using XAML 2009 restricts the possible WPF usages; see [XAML 2009 Language Features](../../xaml-services/xaml-2009-language-features.md)).</span></span> <span data-ttu-id="43cb0-174">컬렉션은 요소 트리를 구성하는 데 있어 공통된 요구 사항이므로 선언적 XAML에서 이러한 컬렉션을 채우는 데 사용할 몇 가지 방법이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="43cb0-174">Collections are obviously a very common requirement for building a tree of elements, and you need some way to populate these collections in declarative XAML.</span></span> <span data-ttu-id="43cb0-175">따라서 컬렉션 속성의 자식 요소는 컬렉션 속성 형식 값인 컬렉션에 추가하여 처리됩니다.</span><span class="sxs-lookup"><span data-stu-id="43cb0-175">Therefore, child elements of a collection property are processed by adding them to the collection that is the collection property type value.</span></span>  
  
 <span data-ttu-id="43cb0-176">.NET Framework XAML 서비스 구현과 WPF XAML 프로세서에서 컬렉션 속성을 구성하는 사항에 대한 다음 정의를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="43cb0-176">The .NET Framework XAML Services implementation and thus the WPF XAML processor uses the following definition for what constitutes a collection property.</span></span> <span data-ttu-id="43cb0-177">속성의 형식은 다음 중 하나를 구현해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="43cb0-177">The property type of the property must implement one of the following:</span></span>  
  
-   <span data-ttu-id="43cb0-178">구현 <xref:System.Collections.IList>합니다.</span><span class="sxs-lookup"><span data-stu-id="43cb0-178">Implements <xref:System.Collections.IList>.</span></span>  
  
-   <span data-ttu-id="43cb0-179">구현 <xref:System.Collections.IDictionary> 또는 해당 제네릭 (<xref:System.Collections.Generic.IDictionary%602>).</span><span class="sxs-lookup"><span data-stu-id="43cb0-179">Implements <xref:System.Collections.IDictionary> or the generic equivalent (<xref:System.Collections.Generic.IDictionary%602>).</span></span>  
  
-   <span data-ttu-id="43cb0-180">파생 <xref:System.Array> (XAML의 배열에 대 한 자세한 내용은 참조 하세요. [X:array 태그 확장](../../xaml-services/x-array-markup-extension.md).)</span><span class="sxs-lookup"><span data-stu-id="43cb0-180">Derives from <xref:System.Array> (for more information about arrays in XAML, see [x:Array Markup Extension](../../xaml-services/x-array-markup-extension.md).)</span></span>  
  
-   <span data-ttu-id="43cb0-181">구현 <xref:System.Windows.Markup.IAddChild> (정의한 인터페이스 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]).</span><span class="sxs-lookup"><span data-stu-id="43cb0-181">Implements <xref:System.Windows.Markup.IAddChild> (an interface defined by [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]).</span></span>  
  
 <span data-ttu-id="43cb0-182">CLR의 각 형식에는 개체 그래프를 만들 때 XAML 프로세서에서 기본 컬렉션에 항목을 추가하는 데 사용하는 `Add` 메서드가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="43cb0-182">Each of these types in CLR has an `Add` method, which is used by the XAML processor to add items to the underlying collection when creating the object graph.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="43cb0-183">제네릭 `List` 하 고 `Dictionary` 인터페이스 (<xref:System.Collections.Generic.IList%601> 및 <xref:System.Collections.Generic.IDictionary%602>)에서 컬렉션 검색에 지원 되지 않습니다는 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] XAML 프로세서.</span><span class="sxs-lookup"><span data-stu-id="43cb0-183">The generic `List` and `Dictionary` interfaces (<xref:System.Collections.Generic.IList%601> and <xref:System.Collections.Generic.IDictionary%602>) are not supported for collection detection by the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] XAML processor.</span></span> <span data-ttu-id="43cb0-184">사용할 수 있습니다는 <xref:System.Collections.Generic.List%601> 구현 하기 때문에 기본 클래스로 클래스 <xref:System.Collections.IList> 직접, 또는 <xref:System.Collections.Generic.Dictionary%602> 기본 클래스로 구현 하기 때문에 <xref:System.Collections.IDictionary> 직접.</span><span class="sxs-lookup"><span data-stu-id="43cb0-184">However, you can use the <xref:System.Collections.Generic.List%601> class as a base class, because it implements <xref:System.Collections.IList> directly, or <xref:System.Collections.Generic.Dictionary%602> as a base class, because it implements <xref:System.Collections.IDictionary> directly.</span></span>  
  
 <span data-ttu-id="43cb0-185">컬렉션을 사용하는 속성을 선언하는 경우 해당 형식의 새 인스턴스에서 속성 값이 초기화되는 방법에 유의하세요.</span><span class="sxs-lookup"><span data-stu-id="43cb0-185">When you declare a property that takes a collection, be cautious about how that property value is initialized in new instances of the type.</span></span> <span data-ttu-id="43cb0-186">속성을 종속성 속성으로 구현하지 않는 경우에는 속성이 컬렉션 형식 생성자를 호출하는 지원 필드를 사용하도록 설정하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="43cb0-186">If you are not implementing the property as a dependency property, then having the property use a backing field that calls the collection type constructor is adequate.</span></span> <span data-ttu-id="43cb0-187">속성이 종속성 속성인 경우에는 기본 형식 생성자의 일부로 컬렉션 속성을 초기화해야 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="43cb0-187">If your property is a dependency property, then you may need to initialize the collection property as part of the default type constructor.</span></span> <span data-ttu-id="43cb0-188">그 이유는 종속성 속성이 속성의 기본값을 메타데이터에서 가져오는데, 개발자는 일반적으로 컬렉션 속성의 초기 값을 정적 공유 컬렉션에 사용하지 않으려고 하기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="43cb0-188">This is because a dependency property takes its default value from metadata, and you typically do not want the initial value of a collection property to be a static, shared collection.</span></span> <span data-ttu-id="43cb0-189">형식 인스턴스를 포함하는 경우마다 컬렉션 인스턴스가 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="43cb0-189">There should be a collection instance per each containing type instance.</span></span> <span data-ttu-id="43cb0-190">자세한 내용은 [사용자 지정 종속성 속성](custom-dependency-properties.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="43cb0-190">For more information, see [Custom Dependency Properties](custom-dependency-properties.md).</span></span>  
  
 <span data-ttu-id="43cb0-191">컬렉션 속성에 대해 사용자 지정 컬렉션 형식을 구현할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="43cb0-191">You can implement a custom collection type for your collection property.</span></span> <span data-ttu-id="43cb0-192">암시적 컬렉션 속성 처리로 인해 사용자 지정 컬렉션 형식은 기본 생성자를 제공하지 않아도 XAML에서 암시적으로 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="43cb0-192">Because of implicit collection property treatment, the custom collection type does not need to provide a default constructor in order to be used in XAML implicitly.</span></span> <span data-ttu-id="43cb0-193">하지만 필요한 경우 컬렉션 형식에 대한 기본 생성자를 제공할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="43cb0-193">However, you can optionally provide a default constructor for the collection type.</span></span> <span data-ttu-id="43cb0-194">이 방법은 유용한 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="43cb0-194">This can be a worthwhile practice.</span></span> <span data-ttu-id="43cb0-195">기본 생성자를 제공하지 않으면 컬렉션을 개체 요소로 명시적으로 선언할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="43cb0-195">Unless you do provide a default constructor, you cannot explicitly declare the collection as an object element.</span></span> <span data-ttu-id="43cb0-196">명시적 컬렉션을 태그 스타일의 문제로 보는 태그 작성자도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="43cb0-196">Some markup authors might prefer to see the explicit collection as a matter of markup style.</span></span> <span data-ttu-id="43cb0-197">기본 생성자를 사용하면 컬렉션 형식을 속성 값으로 사용하는 새 개체를 만들 때 초기화 요구 사항을 줄일 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="43cb0-197">Also, a default constructor can simplify the initialization requirements when you create new objects that use your collection type as a property value.</span></span>  
  
<a name="XAMLCONtent"></a>   
## <a name="declaring-xaml-content-properties"></a><span data-ttu-id="43cb0-198">XAML 콘텐츠 속성 선언</span><span class="sxs-lookup"><span data-stu-id="43cb0-198">Declaring XAML Content Properties</span></span>  
 <span data-ttu-id="43cb0-199">XAML 언어를 통해 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] 콘텐츠 속성의 개념을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="43cb0-199">The XAML language defines the concept of a [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] content property.</span></span> <span data-ttu-id="43cb0-200">개체 구문에서 사용할 수 있는 각 클래스에는 정확히 하나의 XAML 콘텐츠 속성만 포함될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="43cb0-200">Each class that is usable in object syntax can have exactly one XAML content property.</span></span> <span data-ttu-id="43cb0-201">클래스에 대 한 XAML 콘텐츠 속성으로 속성을 선언 하려면 적용 된 <xref:System.Windows.Markup.ContentPropertyAttribute> 클래스 정의의 일부로.</span><span class="sxs-lookup"><span data-stu-id="43cb0-201">To declare a property to be the XAML content property for your class, apply the <xref:System.Windows.Markup.ContentPropertyAttribute> as part of the class definition.</span></span> <span data-ttu-id="43cb0-202">의도 한 XAML 콘텐츠 속성의 이름을 지정 합니다 <xref:System.Windows.Markup.ContentPropertyAttribute.Name%2A> 특성에서입니다.</span><span class="sxs-lookup"><span data-stu-id="43cb0-202">Specify the name of the intended XAML content property as the <xref:System.Windows.Markup.ContentPropertyAttribute.Name%2A> in the attribute.</span></span> <span data-ttu-id="43cb0-203">속성은 문자열로 지정 된 이름으로는 리플렉션 구문이 아니라와 같은 <xref:System.Reflection.PropertyInfo>합니다.</span><span class="sxs-lookup"><span data-stu-id="43cb0-203">The property is specified as a string by name, not as a reflection construct such as <xref:System.Reflection.PropertyInfo>.</span></span>  
  
 <span data-ttu-id="43cb0-204">컬렉션 속성을 XAML 콘텐츠 속성으로 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="43cb0-204">You can specify a collection property to be the XAML content property.</span></span> <span data-ttu-id="43cb0-205">이 경우 중간의 컬렉션 개체 요소나 속성 요소 태그 없이도 개체 요소가 하나 이상의 자식 요소를 가질 수 있는 상황에서 해당 속성이 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="43cb0-205">This results in a usage for that property whereby the object element can have one or more child elements, without any intervening collection object elements or property element tags.</span></span> <span data-ttu-id="43cb0-206">그러면 이러한 요소가 XAML 콘텐츠 속성에 대한 값으로 처리되어 지원 컬렉션 인스턴스에 추가됩니다.</span><span class="sxs-lookup"><span data-stu-id="43cb0-206">These elements are then treated as the value for the XAML content property and added to the backing collection instance.</span></span>  
  
 <span data-ttu-id="43cb0-207">기존 XAML 콘텐츠 속성 중 일부에서는 `Object`의 속성 형식을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="43cb0-207">Some existing XAML content properties use the property type of `Object`.</span></span> <span data-ttu-id="43cb0-208">이렇게 하면 기본을 사용할 수 있는 속성 값이 같은 콘텐츠는 XAML을 <xref:System.String> 외에도 단일 참조 개체 값입니다.</span><span class="sxs-lookup"><span data-stu-id="43cb0-208">This enables a XAML content property that can take primitive values such as a <xref:System.String> as well as taking a single reference object value.</span></span> <span data-ttu-id="43cb0-209">이 모델을 따르는 경우 사용자의 형식을 통해 형식을 결정하고 가능한 형식을 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="43cb0-209">If you follow this model, your type is responsible for type determination as well as the handling of possible types.</span></span> <span data-ttu-id="43cb0-210">에 대 한 일반적인 이유는 <xref:System.Object> 형식은 모두는 단순한 방법과 개체 콘텐츠를 문자열 (기본 표현 처리를 받습니다.)를로 추가 지원 하기 위해 또는 개체를 기본이 아닌 표현을 지정 하는 콘텐츠를 추가 하는 고급 방법을 콘텐츠 또는 추가 데이터입니다.</span><span class="sxs-lookup"><span data-stu-id="43cb0-210">The typical reason for an <xref:System.Object> content type is to support both a simple means of adding object content as a string (which receives a default presentation treatment), or an advanced means of adding object content that specifies a non-default presentation or additional data.</span></span>  
  
<a name="Serializing"></a>   
## <a name="serializing-xaml"></a><span data-ttu-id="43cb0-211">XAML Serialize</span><span class="sxs-lookup"><span data-stu-id="43cb0-211">Serializing XAML</span></span>  
 <span data-ttu-id="43cb0-212">예를 들어 컨트롤 작성자인 경우 XAML에서 인스턴스화할 수 있는 개체 표현도 해당 XAML 태그로 다시 serialize할 수 있도록 하려는 경우가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="43cb0-212">For certain scenarios, such as if you are a control author, you may also want to assure that any object representation that can be instantiated in XAML can also be serialized back to equivalent XAML markup.</span></span> <span data-ttu-id="43cb0-213">Serialization 요구 사항은 이 항목에서 설명하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="43cb0-213">Serialization requirements are not described in this topic.</span></span> <span data-ttu-id="43cb0-214">[컨트롤 작성 개요](../controls/control-authoring-overview.md) 및 [요소 트리 및 Serialization](element-tree-and-serialization.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="43cb0-214">See [Control Authoring Overview](../controls/control-authoring-overview.md) and [Element Tree and Serialization](element-tree-and-serialization.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="43cb0-215">참고자료</span><span class="sxs-lookup"><span data-stu-id="43cb0-215">See also</span></span>

- [<span data-ttu-id="43cb0-216">XAML 개요(WPF)</span><span class="sxs-lookup"><span data-stu-id="43cb0-216">XAML Overview (WPF)</span></span>](xaml-overview-wpf.md)
- [<span data-ttu-id="43cb0-217">사용자 지정 종속성 속성</span><span class="sxs-lookup"><span data-stu-id="43cb0-217">Custom Dependency Properties</span></span>](custom-dependency-properties.md)
- [<span data-ttu-id="43cb0-218">컨트롤 제작 개요</span><span class="sxs-lookup"><span data-stu-id="43cb0-218">Control Authoring Overview</span></span>](../controls/control-authoring-overview.md)
- [<span data-ttu-id="43cb0-219">기본 요소 개요</span><span class="sxs-lookup"><span data-stu-id="43cb0-219">Base Elements Overview</span></span>](base-elements-overview.md)
- [<span data-ttu-id="43cb0-220">XAML 로드 및 종속성 속성</span><span class="sxs-lookup"><span data-stu-id="43cb0-220">XAML Loading and Dependency Properties</span></span>](xaml-loading-and-dependency-properties.md)

---
title: Win32와 WPF 간에 메시지 루프 공유
titleSuffix: ''
ms.date: 03/30/2017
helpviewer_keywords:
- Win32 code [WPF], sharing message loops
- message loops [WPF]
- sharing message loops [WPF]
- interoperability [WPF], Win32
ms.assetid: 39ee888c-e5ec-41c8-b11f-7b851a554442
ms.openlocfilehash: e1b96284d69645876d3e383beb03a2cc540d8b7b
ms.sourcegitcommit: de17a7a0a37042f0d4406f5ae5393531caeb25ba
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 01/24/2020
ms.locfileid: "76731715"
---
# <a name="sharing-message-loops-between-win32-and-wpf"></a><span data-ttu-id="5ab11-102">Win32와 WPF 간에 메시지 루프 공유</span><span class="sxs-lookup"><span data-stu-id="5ab11-102">Sharing Message Loops Between Win32 and WPF</span></span>
<span data-ttu-id="5ab11-103">이 항목에서는 <xref:System.Windows.Threading.Dispatcher>의 기존 메시지 루프 노출을 사용 하거나 상호 운용 코드의 Win32 쪽에서 별도의 메시지 루프를 만들어 [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]와의 상호 운용을 위한 메시지 루프를 구현 하는 방법에 대해 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="5ab11-103">This topic describes how to implement a message loop for interoperation with [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)], either by using existing message loop exposure in <xref:System.Windows.Threading.Dispatcher> or by creating a separate message loop on the Win32 side of your interoperation code.</span></span>  
  
## <a name="componentdispatcher-and-the-message-loop"></a><span data-ttu-id="5ab11-104">ComponentDispatcher 및 메시지 루프</span><span class="sxs-lookup"><span data-stu-id="5ab11-104">ComponentDispatcher and the Message Loop</span></span>  
 <span data-ttu-id="5ab11-105">상호 운용성 및 키보드 이벤트 지원에 대 한 일반적인 시나리오는 <xref:System.Windows.Interop.IKeyboardInputSink>를 구현 하거나 이미 <xref:System.Windows.Interop.IKeyboardInputSink>를 구현 하는 클래스 (예: <xref:System.Windows.Interop.HwndSource> 또는 <xref:System.Windows.Interop.HwndHost>)에서 서브 클래스를 구현 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="5ab11-105">A normal scenario for interoperation and keyboard event support is to implement <xref:System.Windows.Interop.IKeyboardInputSink>, or to subclass from classes that already implement <xref:System.Windows.Interop.IKeyboardInputSink>, such as <xref:System.Windows.Interop.HwndSource> or <xref:System.Windows.Interop.HwndHost>.</span></span> <span data-ttu-id="5ab11-106">그러나 키보드 싱크 지원에서는 상호 운용 경계를 넘어 메시지를 보내고 받을 때 발생할 수 있는 모든 메시지 루프 요구를 해결 하지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="5ab11-106">However, keyboard sink support does not address all possible message loop needs you might have when sending and receiving messages across your interoperation boundaries.</span></span> <span data-ttu-id="5ab11-107">응용 프로그램 메시지 루프 아키텍처를 공식화 하는 데 도움이 되도록 [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]는 메시지 루프에서 수행할 단순 프로토콜을 정의 하는 <xref:System.Windows.Interop.ComponentDispatcher> 클래스를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="5ab11-107">To help formalize an application message loop architecture, [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] provides the <xref:System.Windows.Interop.ComponentDispatcher> class, which defines a simple protocol for a message loop to follow.</span></span>  
  
 <span data-ttu-id="5ab11-108"><xref:System.Windows.Interop.ComponentDispatcher>는 여러 멤버를 노출 하는 정적 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="5ab11-108"><xref:System.Windows.Interop.ComponentDispatcher> is a static class that exposes several members.</span></span> <span data-ttu-id="5ab11-109">각 메서드의 범위는 암시적으로 호출 스레드에 연결 됩니다.</span><span class="sxs-lookup"><span data-stu-id="5ab11-109">The scope of each method is implicitly tied to the calling thread.</span></span> <span data-ttu-id="5ab11-110">메시지 루프는 다음 섹션에 정의 된 대로 중요 한 시간에 이러한 Api 중 일부를 호출 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5ab11-110">A message loop must call some of those APIs at critical times (as defined in the next section).</span></span>  
  
 <span data-ttu-id="5ab11-111"><xref:System.Windows.Interop.ComponentDispatcher>는 다른 구성 요소 (예: 키보드 싱크)가 수신할 수 있는 이벤트를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="5ab11-111"><xref:System.Windows.Interop.ComponentDispatcher> provides events that other components (such as the keyboard sink) can listen for.</span></span> <span data-ttu-id="5ab11-112"><xref:System.Windows.Threading.Dispatcher> 클래스는 적절 한 시퀀스에서 적절 한 <xref:System.Windows.Interop.ComponentDispatcher> 메서드를 모두 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="5ab11-112">The <xref:System.Windows.Threading.Dispatcher> class calls all the appropriate <xref:System.Windows.Interop.ComponentDispatcher> methods in an appropriate sequence.</span></span> <span data-ttu-id="5ab11-113">사용자 고유의 메시지 루프를 구현 하는 경우 코드는 비슷한 방식으로 <xref:System.Windows.Interop.ComponentDispatcher> 메서드를 호출 하는 일을 담당 합니다.</span><span class="sxs-lookup"><span data-stu-id="5ab11-113">If you are implementing your own message loop, your code is responsible for calling <xref:System.Windows.Interop.ComponentDispatcher> methods in a similar fashion.</span></span>  
  
 <span data-ttu-id="5ab11-114">스레드에서 <xref:System.Windows.Interop.ComponentDispatcher> 메서드를 호출 하면 해당 스레드에 등록 된 이벤트 처리기만 호출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="5ab11-114">Calling <xref:System.Windows.Interop.ComponentDispatcher> methods on a thread will only invoke event handlers that were registered on that thread.</span></span>  
  
## <a name="writing-message-loops"></a><span data-ttu-id="5ab11-115">메시지 루프 작성</span><span class="sxs-lookup"><span data-stu-id="5ab11-115">Writing Message Loops</span></span>  
 <span data-ttu-id="5ab11-116">다음은 고유한 메시지 루프를 작성 하는 경우 사용 하는 <xref:System.Windows.Interop.ComponentDispatcher> 멤버에 대 한 검사 목록입니다.</span><span class="sxs-lookup"><span data-stu-id="5ab11-116">The following is a checklist of <xref:System.Windows.Interop.ComponentDispatcher> members you will use if you write your own message loop:</span></span>  
  
- <span data-ttu-id="5ab11-117"><xref:System.Windows.Interop.ComponentDispatcher.PushModal%2A>: 메시지 루프가이를 호출 하 여 스레드가 모달 임을 나타내야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5ab11-117"><xref:System.Windows.Interop.ComponentDispatcher.PushModal%2A>: your message loop should call this to indicate that the thread is modal.</span></span>  
  
- <span data-ttu-id="5ab11-118"><xref:System.Windows.Interop.ComponentDispatcher.PopModal%2A>: 메시지 루프에서이를 호출 하 여 스레드가 모달이 아닌 상태로 되돌아간 것을 나타내야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5ab11-118"><xref:System.Windows.Interop.ComponentDispatcher.PopModal%2A>:your message loop should call this to indicate that the thread has reverted to nonmodal.</span></span>  
  
- <span data-ttu-id="5ab11-119"><xref:System.Windows.Interop.ComponentDispatcher.RaiseIdle%2A>: 메시지 루프에서이를 호출 하 여 <xref:System.Windows.Interop.ComponentDispatcher>에서 <xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle> 이벤트를 발생 시켜야 함을 나타내야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5ab11-119"><xref:System.Windows.Interop.ComponentDispatcher.RaiseIdle%2A>: your message loop should call this to indicate that <xref:System.Windows.Interop.ComponentDispatcher> should raise the <xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle> event.</span></span> <span data-ttu-id="5ab11-120"><xref:System.Windows.Interop.ComponentDispatcher.IsThreadModal%2A> `true`경우에는 <xref:System.Windows.Interop.ComponentDispatcher> <xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle> 발생 하지 않지만 모달 상태에서 <xref:System.Windows.Interop.ComponentDispatcher.RaiseIdle%2A>에 응답할 수 없는 경우에도 메시지 루프에서 <xref:System.Windows.Interop.ComponentDispatcher>를 호출 하도록 선택할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5ab11-120"><xref:System.Windows.Interop.ComponentDispatcher> will not raise <xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle> if <xref:System.Windows.Interop.ComponentDispatcher.IsThreadModal%2A> is `true`, but message loops may choose to call <xref:System.Windows.Interop.ComponentDispatcher.RaiseIdle%2A> even if <xref:System.Windows.Interop.ComponentDispatcher> cannot respond to it while in modal state.</span></span>  
  
- <span data-ttu-id="5ab11-121"><xref:System.Windows.Interop.ComponentDispatcher.RaiseThreadMessage%2A>: 메시지 루프에서이를 호출 하 여 새 메시지를 사용할 수 있음을 나타내야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5ab11-121"><xref:System.Windows.Interop.ComponentDispatcher.RaiseThreadMessage%2A>: your message loop should call this to indicate that a new message is available.</span></span> <span data-ttu-id="5ab11-122">반환 값은 <xref:System.Windows.Interop.ComponentDispatcher> 이벤트에 대 한 수신기가 메시지를 처리 했는지 여부를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="5ab11-122">The return value indicates whether a listener to a <xref:System.Windows.Interop.ComponentDispatcher> event handled the message.</span></span> <span data-ttu-id="5ab11-123"><xref:System.Windows.Interop.ComponentDispatcher.RaiseThreadMessage%2A>에서 `true` (처리 됨)를 반환 하는 경우 디스패처는 메시지를 사용 하 여 아무런 작업도 수행 하지 않아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5ab11-123">If <xref:System.Windows.Interop.ComponentDispatcher.RaiseThreadMessage%2A> returns `true` (handled), the dispatcher should do nothing further with the message.</span></span> <span data-ttu-id="5ab11-124">반환 값이 `false`이면 디스패처가 `TranslateMessage`Win32 함수를 호출한 다음 `DispatchMessage`를 호출 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5ab11-124">If the return value is `false`, the dispatcher is expected to call the Win32 function `TranslateMessage`, then call `DispatchMessage`.</span></span>  
  
## <a name="using-componentdispatcher-and-existing-message-handling"></a><span data-ttu-id="5ab11-125">ComponentDispatcher 및 기존 메시지 처리 사용</span><span class="sxs-lookup"><span data-stu-id="5ab11-125">Using ComponentDispatcher and Existing Message Handling</span></span>  
 <span data-ttu-id="5ab11-126">다음은 고유 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 메시지 루프를 사용 하는 경우 사용 하는 <xref:System.Windows.Interop.ComponentDispatcher> 멤버에 대 한 검사 목록입니다.</span><span class="sxs-lookup"><span data-stu-id="5ab11-126">The following is a checklist of <xref:System.Windows.Interop.ComponentDispatcher> members you will use if you rely on the inherent [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] message loop.</span></span>  
  
- <span data-ttu-id="5ab11-127"><xref:System.Windows.Interop.ComponentDispatcher.IsThreadModal%2A>: 응용 프로그램에 모달이 있는지 여부를 반환 합니다 (예: 모달 메시지 루프가 푸시되 었는 지).</span><span class="sxs-lookup"><span data-stu-id="5ab11-127"><xref:System.Windows.Interop.ComponentDispatcher.IsThreadModal%2A>: returns whether the application has gone modal (e.g., a modal message loop has been pushed).</span></span> <span data-ttu-id="5ab11-128">클래스가 메시지 루프의 <xref:System.Windows.Interop.ComponentDispatcher.PushModal%2A> 및 <xref:System.Windows.Interop.ComponentDispatcher.PopModal%2A> 호출 수를 유지 관리 하기 때문에 <xref:System.Windows.Interop.ComponentDispatcher>이 상태를 추적할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5ab11-128"><xref:System.Windows.Interop.ComponentDispatcher> can track this state because the class maintains a count of <xref:System.Windows.Interop.ComponentDispatcher.PushModal%2A> and <xref:System.Windows.Interop.ComponentDispatcher.PopModal%2A> calls from the message loop.</span></span>  
  
- <span data-ttu-id="5ab11-129"><xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage> 및 <xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> 이벤트는 대리자 호출에 대 한 표준 규칙을 따릅니다.</span><span class="sxs-lookup"><span data-stu-id="5ab11-129"><xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage> and <xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> events follow the standard rules for delegate invocations.</span></span> <span data-ttu-id="5ab11-130">대리자는 지정 되지 않은 순서로 호출 되며, 첫 번째 대리자가 메시지를 처리 된 것으로 표시 한 경우에도 모든 대리자가 호출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="5ab11-130">Delegates are invoked in an unspecified order, and all delegates are invoked even if the first one marks the message as handled.</span></span>  
  
- <span data-ttu-id="5ab11-131"><xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle>: 유휴 처리를 수행 하는 데 적절 하 고 효율적인 시간을 나타냅니다 (스레드에 대해 보류 중인 다른 메시지가 없음).</span><span class="sxs-lookup"><span data-stu-id="5ab11-131"><xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle>: indicates an appropriate and efficient time to do idle processing (there are no other pending messages for the thread).</span></span> <span data-ttu-id="5ab11-132">스레드가 모달이 면 <xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle> 발생 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="5ab11-132"><xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle> will not be raised if the thread is modal.</span></span>  
  
- <span data-ttu-id="5ab11-133"><xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage>: 메시지 펌프가 처리 하는 모든 메시지에 대해 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="5ab11-133"><xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage>: raised for all messages that the message pump processes.</span></span>  
  
- <span data-ttu-id="5ab11-134"><xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage>: <xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage>중에 처리 되지 않은 모든 메시지에 대해 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="5ab11-134"><xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage>: raised for all messages that were not handled during <xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage>.</span></span>  
  
 <span data-ttu-id="5ab11-135"><xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage> 이벤트 나 <xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> 이벤트가 발생 한 후 이벤트 데이터에서 참조로 전달 되는 `handled` 매개 변수가 `true`경우 메시지가 처리 된 것으로 간주 됩니다.</span><span class="sxs-lookup"><span data-stu-id="5ab11-135">A message is considered handled if after the <xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage> event or <xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> event, the `handled` parameter passed by reference in event data is `true`.</span></span> <span data-ttu-id="5ab11-136">`handled` `true`되는 경우 이벤트 처리기는 메시지를 무시 해야 합니다. 즉, 다른 처리기가 메시지를 먼저 처리 했기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="5ab11-136">Event handlers should ignore the message if `handled` is `true`, because that means the different handler handled the message first.</span></span> <span data-ttu-id="5ab11-137">두 이벤트 모두에 대 한 이벤트 처리기에서 메시지를 수정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5ab11-137">Event handlers to both events may modify the message.</span></span> <span data-ttu-id="5ab11-138">디스패처는 변경 되지 않은 원래 메시지를 전달 하는 것이 아니라 수정 된 메시지를 디스패치합니다.</span><span class="sxs-lookup"><span data-stu-id="5ab11-138">The dispatcher should dispatch the modified message and not the original unchanged message.</span></span> <span data-ttu-id="5ab11-139"><xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage>은 모든 수신기로 전달 되지만 아키텍처는 대상 메시지가 메시지에 응답 하 여 코드를 호출 해야 하는 HWND를 포함 하는 최상위 창만 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5ab11-139"><xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> is delivered to all listeners, but the architectural intention is that only the top-level window containing the HWND at which the messages targeted should invoke code in response to the message.</span></span>  
  
## <a name="how-hwndsource-treats-componentdispatcher-events"></a><span data-ttu-id="5ab11-140">System.windows.interop.hwndsource>에서 ComponentDispatcher 이벤트를 처리 하는 방법</span><span class="sxs-lookup"><span data-stu-id="5ab11-140">How HwndSource Treats ComponentDispatcher Events</span></span>  
 <span data-ttu-id="5ab11-141"><xref:System.Windows.Interop.HwndSource> 최상위 창인 경우 (부모 HWND가 없는 경우) <xref:System.Windows.Interop.ComponentDispatcher>에 등록 됩니다.</span><span class="sxs-lookup"><span data-stu-id="5ab11-141">If the <xref:System.Windows.Interop.HwndSource> is a top-level window (no parent HWND), it will register with <xref:System.Windows.Interop.ComponentDispatcher>.</span></span> <span data-ttu-id="5ab11-142"><xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> 발생 하 고 메시지가 <xref:System.Windows.Interop.HwndSource> 또는 자식 창에 대해 만들어진 경우 <xref:System.Windows.Interop.HwndSource>는 <xref:System.Windows.Interop.HwndSource.System%23Windows%23Interop%23IKeyboardInputSink%23TranslateAccelerator%2A>, <xref:System.Windows.Interop.IKeyboardInputSink.TranslateChar%2A>, <xref:System.Windows.Interop.IKeyboardInputSink.OnMnemonic%2A> 키보드 싱크 시퀀스를 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="5ab11-142">If <xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> is raised, and if the message is intended for the <xref:System.Windows.Interop.HwndSource> or child windows, <xref:System.Windows.Interop.HwndSource> calls its <xref:System.Windows.Interop.HwndSource.System%23Windows%23Interop%23IKeyboardInputSink%23TranslateAccelerator%2A>, <xref:System.Windows.Interop.IKeyboardInputSink.TranslateChar%2A>, <xref:System.Windows.Interop.IKeyboardInputSink.OnMnemonic%2A> keyboard sink sequence.</span></span>  
  
 <span data-ttu-id="5ab11-143"><xref:System.Windows.Interop.HwndSource> 최상위 창이 아닌 경우 (부모 HWND가 있는 경우) 처리 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="5ab11-143">If the <xref:System.Windows.Interop.HwndSource> is not a top-level window (has a parent HWND), there will be no handling.</span></span> <span data-ttu-id="5ab11-144">최상위 창만 처리를 수행 하 고, 상호 운용 시나리오의 일부로 키보드 싱크를 지 원하는 최상위 창이 될 것으로 예상 됩니다.</span><span class="sxs-lookup"><span data-stu-id="5ab11-144">Only the top level window is expected to do the handling, and there is expected to be a top level window with keyboard sink support as part of any interoperation scenario.</span></span>  
  
 <span data-ttu-id="5ab11-145">적절 한 키보드 싱크 메서드를 먼저 호출 하지 않고 <xref:System.Windows.Interop.HwndSource> <xref:System.Windows.Interop.HwndHost.WndProc%2A>를 호출 하면 응용 프로그램에서 <xref:System.Windows.UIElement.KeyDown>같은 더 높은 수준의 키보드 이벤트를 받게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="5ab11-145">If <xref:System.Windows.Interop.HwndHost.WndProc%2A> on an <xref:System.Windows.Interop.HwndSource> is called without an appropriate keyboard sink method being called first, your application will receive the higher level keyboard events such as <xref:System.Windows.UIElement.KeyDown>.</span></span> <span data-ttu-id="5ab11-146">그러나 액세스 키 지원과 같은 바람직한 키보드 입력 모델 기능을 우회 하는 키보드 싱크 메서드는 호출 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="5ab11-146">However, no keyboard sink methods will be called, which circumvents desirable keyboard input model features such as access key support.</span></span> <span data-ttu-id="5ab11-147">이 문제는 메시지 루프가 <xref:System.Windows.Interop.ComponentDispatcher>에서 관련 스레드를 제대로 알리거나 부모 HWND가 적절 한 키보드 싱크 응답을 호출 하지 않았기 때문에 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5ab11-147">This might happen because the message loop did not properly notify the relevant thread on the <xref:System.Windows.Interop.ComponentDispatcher>, or because the parent HWND did not invoke the proper keyboard sink responses.</span></span>  
  
 <span data-ttu-id="5ab11-148"><xref:System.Windows.Interop.HwndSource.AddHook%2A> 메서드를 사용 하 여 해당 메시지에 대 한 후크를 추가한 경우 키보드 싱크로 이동 하는 메시지를 HWND로 보낼 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="5ab11-148">A message that goes to the keyboard sink might not be sent to the HWND if you added hooks for that message by using the <xref:System.Windows.Interop.HwndSource.AddHook%2A> method.</span></span> <span data-ttu-id="5ab11-149">메시지가 메시지 펌프 수준에서 직접 처리 되 고 `DispatchMessage` 함수에 전송 되지 않았을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5ab11-149">The message might have been handled at the message pump level directly and not submitted to the `DispatchMessage` function.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="5ab11-150">참고 항목</span><span class="sxs-lookup"><span data-stu-id="5ab11-150">See also</span></span>

- <xref:System.Windows.Interop.ComponentDispatcher>
- <xref:System.Windows.Interop.IKeyboardInputSink>
- [<span data-ttu-id="5ab11-151">WPF 및 Win32 상호 운용성</span><span class="sxs-lookup"><span data-stu-id="5ab11-151">WPF and Win32 Interoperation</span></span>](wpf-and-win32-interoperation.md)
- [<span data-ttu-id="5ab11-152">스레딩 모델</span><span class="sxs-lookup"><span data-stu-id="5ab11-152">Threading Model</span></span>](threading-model.md)
- [<span data-ttu-id="5ab11-153">입력 개요</span><span class="sxs-lookup"><span data-stu-id="5ab11-153">Input Overview</span></span>](input-overview.md)

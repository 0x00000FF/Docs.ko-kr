---
title: WPF 아키텍처
ms.date: 03/30/2017
helpviewer_keywords:
- properties [WPF], attached
- attached properties [WPF]
- architecture [WPF]
- unmanaged components [WPF]
- affinity thread [WPF]
- Storyboards [WPF]
- milcore [WPF]
- components [WPF], unmanaged
- painter's algorithm
- interfaces [WPF], INotifyPropertyChange
- CommandBindings [WPF]
- data templates [WPF]
- thread [WPF], affinity
ms.assetid: 8579c10b-76ab-4c52-9691-195ce02333c8
ms.openlocfilehash: f4a6e6c2a63e58c40e0cca9c67b12d1f65af0d2e
ms.sourcegitcommit: 5b6d778ebb269ee6684fb57ad69a8c28b06235b9
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 04/08/2019
ms.locfileid: "59199429"
---
# <a name="wpf-architecture"></a><span data-ttu-id="ea665-102">WPF 아키텍처</span><span class="sxs-lookup"><span data-stu-id="ea665-102">WPF Architecture</span></span>
<span data-ttu-id="ea665-103">이 항목에서는 Windows Presentation Foundation (WPF) 클래스 계층의 둘러보기를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-103">This topic provides a guided tour of the Windows Presentation Foundation (WPF) class hierarchy.</span></span> <span data-ttu-id="ea665-104">이 항목은 대부분의 [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] 주요 하위 시스템을 다루며 이들이 어떻게 상호 작용하는지를 설명하고,</span><span class="sxs-lookup"><span data-stu-id="ea665-104">It covers most of the major subsystems of [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)], and describes how they interact.</span></span> <span data-ttu-id="ea665-105">[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)]의 설계자가 선택한 몇 가지 사항에 대해서 자세히 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-105">It also details some of the choices made by the architects of [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)].</span></span>  

<a name="System_Object"></a>   
## <a name="systemobject"></a><span data-ttu-id="ea665-106">System.Object</span><span class="sxs-lookup"><span data-stu-id="ea665-106">System.Object</span></span>  
 <span data-ttu-id="ea665-107">기본 [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] 프로그래밍 모델은 관리 코드를 통해 노출됩니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-107">The primary [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] programming model is exposed through managed code.</span></span> <span data-ttu-id="ea665-108">[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)]의 초기 디자인 단계에서는 시스템의 관리되는 구성 요소와 관리되지 않는 구성 요소를 정확하게 구분하는 방법에 대한 많은 논쟁이 있었습니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-108">Early in the design phase of [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] there were a number of debates about where the line should be drawn between the managed components of the system and the unmanaged ones.</span></span> <span data-ttu-id="ea665-109">[!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)]에서는 보다 생산적이며 강력한 개발 작업을 수행하는 데 유용한 여러 기능(메모리 관리, 오류 처리, 공용 형식 시스템 등)을 제공하지만 이러한 이점에는 대가가 따릅니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-109">The [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] provides a number of features that make development more productive and robust (including memory management, error handling, common type system, etc.) but they come at a cost.</span></span>  
  
 <span data-ttu-id="ea665-110">[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)]의 주요 구성 요소는 아래 그림에 설명되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-110">The major components of [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] are illustrated in the figure below.</span></span> <span data-ttu-id="ea665-111">다이어그램의 빨간색 섹션(PresentationFramework, PresentationCore 및 milcore)은 [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)]의 주요 코드 부분입니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-111">The red sections of the diagram (PresentationFramework, PresentationCore, and milcore) are the major code portions of [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)].</span></span> <span data-ttu-id="ea665-112">이 중에서 하나(milcore)만 관리되지 않는 구성 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-112">Of these, only one is an unmanaged component – milcore.</span></span> <span data-ttu-id="ea665-113">Milcore는 [!INCLUDE[TLA2#tla_dx](../../../../includes/tla2sharptla-dx-md.md)]와의 긴밀한 통합을 위해 비관리 코드로 작성되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-113">Milcore is written in unmanaged code in order to enable tight integration with [!INCLUDE[TLA2#tla_dx](../../../../includes/tla2sharptla-dx-md.md)].</span></span> <span data-ttu-id="ea665-114">[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)]에서의 모든 디스플레이는 [!INCLUDE[TLA2#tla_dx](../../../../includes/tla2sharptla-dx-md.md)] 엔진을 통해 수행되므로 효율적인 하드웨어 및 소프트웨어 렌더링을 허용합니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-114">All display in [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] is done through the [!INCLUDE[TLA2#tla_dx](../../../../includes/tla2sharptla-dx-md.md)] engine, allowing for efficient hardware and software rendering.</span></span> [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] <span data-ttu-id="ea665-115">메모리 및 실행 세부적으로 제어할도 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-115">also required fine control over memory and execution.</span></span> <span data-ttu-id="ea665-116">milcore에 있는 컴포지션 엔진은 성능의 영향을 크게 받으므로 성능을 높이기 위해 [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)]의 여러 이점을 포기해야 했습니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-116">The composition engine in milcore is extremely performance sensitive, and required giving up many advantages of the [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] to gain performance.</span></span>  
  
 <span data-ttu-id="ea665-117">![.NET Framework 내 WPF의 위치.](./media/wpf-architect1.PNG "wpf_architect1")</span><span class="sxs-lookup"><span data-stu-id="ea665-117">![The position of WPF within the .NET Framework.](./media/wpf-architect1.PNG "wpf_architect1")</span></span>  
  
 <span data-ttu-id="ea665-118">[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)]의 관리되는 부분과 관리되지 않는 부분 간 통신에 대해서는 이 항목의 뒷부분에서 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-118">Communication between the managed and unmanaged portions of [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] is discussed later in this topic.</span></span> <span data-ttu-id="ea665-119">관리되는 프로그래밍 모델의 나머지 부분은 아래에 설명되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-119">The remainder of the managed programming model is described below.</span></span>  
  
<a name="System_Threading_DispatcherObject"></a>   
## <a name="systemthreadingdispatcherobject"></a><span data-ttu-id="ea665-120">System.Threading.DispatcherObject</span><span class="sxs-lookup"><span data-stu-id="ea665-120">System.Threading.DispatcherObject</span></span>  
 <span data-ttu-id="ea665-121">대부분의 개체 [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] 에서 파생 <xref:System.Windows.Threading.DispatcherObject>, 스레딩 및 동시성 처리에 대 한 기본 생성자를 제공 하는 합니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-121">Most objects in [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] derive from <xref:System.Windows.Threading.DispatcherObject>, which provides the basic constructs for dealing with concurrency and threading.</span></span> [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] <span data-ttu-id="ea665-122">디스패처로 구현 된 메시징 시스템에 기반 합니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-122">is based on a messaging system implemented by the dispatcher.</span></span> <span data-ttu-id="ea665-123">이는 친숙한 [!INCLUDE[TLA#tla_win32](../../../../includes/tlasharptla-win32-md.md)] 메시지 펌프와 유사하게 작동합니다. 사실 [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] 디스패처는 User32 메시지를 사용하여 크로스 스레드 호출을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-123">This works much like the familiar [!INCLUDE[TLA#tla_win32](../../../../includes/tlasharptla-win32-md.md)] message pump; in fact, the [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] dispatcher uses User32 messages for performing cross thread calls.</span></span>  
  
 <span data-ttu-id="ea665-124">[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)]에서 동시성을 논의할 때는 두 가지 핵심 개념인 디스패처와 스레드 선호도를 반드시 이해해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-124">There are really two core concepts to understand when discussing concurrency in [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] – the dispatcher and thread affinity.</span></span>  
  
 <span data-ttu-id="ea665-125">[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)]의 디자인 단계에서 목표는 단일 실행 스레드로 이동하되 스레드가 아닌 "선호" 모델로 이동하는 것이었습니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-125">During the design phase of [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)], the goal was to move to a single thread of execution, but a non-thread "affinitized" model.</span></span> <span data-ttu-id="ea665-126">스레드 선호도는 일부 형식의 상태를 저장하기 위해 구성 요소가 실행 스레드의 ID를 사용할 때 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-126">Thread affinity happens when a component uses the identity of the executing thread to store some type of state.</span></span> <span data-ttu-id="ea665-127">이에 대한 가장 일반적인 형태는 TLS(스레드 로컬 저장소)를 사용하여 상태를 저장하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-127">The most common form of this is to use the thread local store (TLS) to store state.</span></span> <span data-ttu-id="ea665-128">스레드 선호도는 각 논리적 실행 스레드가 운영 체제에서 하나의 실제 스레드에만 소속될 수 있도록 합니다. 따라서 메모리를 많이 소비할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-128">Thread affinity requires that each logical thread of execution be owned by only one physical thread in the operating system, which can become memory intensive.</span></span> <span data-ttu-id="ea665-129">결국 WPF의 스레딩 모델은 스레드 선호도가 있는 단일 스레딩된 실행의 기존 User32 스레딩 모델과 계속 동기화됩니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-129">In the end, WPF’s threading model was kept in sync with the existing User32 threading model of single threaded execution with thread affinity.</span></span> <span data-ttu-id="ea665-130">이에 대한 주요 이유는 상호 운용성 때문입니다. [!INCLUDE[TLA2#tla_ole2.0](../../../../includes/tla2sharptla-ole2-0-md.md)], 클립보드, Internet Explorer 등의 시스템의 경우 모두 STA(단일 스레드 선호도) 실행이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-130">The primary reason for this was interoperability – systems like [!INCLUDE[TLA2#tla_ole2.0](../../../../includes/tla2sharptla-ole2-0-md.md)], the clipboard, and Internet Explorer all require single thread affinity (STA) execution.</span></span>  
  
 <span data-ttu-id="ea665-131">STA 스레딩이 포함된 개체가 있다면 스레드 간에 통신하고 올바른 스레드에 있는지를 확인할 수 있는 방법이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-131">Given that you have objects with STA threading, you need a way to communicate between threads, and validate that you are on the correct thread.</span></span> <span data-ttu-id="ea665-132">여기에서 디스패처의 역할이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-132">Herein lies the role of the dispatcher.</span></span> <span data-ttu-id="ea665-133">디스패처는 우선 순위가 지정된 여러 개의 큐가 있는 기본 메시지 디스패치 시스템입니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-133">The dispatcher is a basic message dispatching system, with multiple prioritized queues.</span></span> <span data-ttu-id="ea665-134">메시지의 예로 원시 입력 알림(마우스 이동), 프레임워크 기능(레이아웃) 또는 사용자 명령(이 메서드 실행)을 들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-134">Examples of messages include raw input notifications (mouse moved), framework functions (layout), or user commands (execute this method).</span></span> <span data-ttu-id="ea665-135">파생 시켜 <xref:System.Windows.Threading.DispatcherObject>를 만든를 [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] STA 동작이 있는 개체 및 지정 될 대 한 포인터는 디스패처를 만들 때.</span><span class="sxs-lookup"><span data-stu-id="ea665-135">By deriving from <xref:System.Windows.Threading.DispatcherObject>, you create a [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] object that has STA behavior, and will be given a pointer to a dispatcher at creation time.</span></span>  
  
<a name="System_Windows_DependencyObject"></a>   
## <a name="systemwindowsdependencyobject"></a><span data-ttu-id="ea665-136">System.Windows.DependencyObject</span><span class="sxs-lookup"><span data-stu-id="ea665-136">System.Windows.DependencyObject</span></span>  
 <span data-ttu-id="ea665-137">[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)]를 빌드하는 데 사용된 기본 아키텍처 방법 중 하나는 메서드나 이벤트보다 속성을 선호하는 것이었습니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-137">One of the primary architectural philosophies used in building [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] was a preference for properties over methods or events.</span></span> <span data-ttu-id="ea665-138">속성은 선언적이며 작업 대신 의도를 보다 쉽게 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-138">Properties are declarative and allow you to more easily specify intent instead of action.</span></span> <span data-ttu-id="ea665-139">또한 모델 중심 또는 데이터 중심의 시스템을 지원하여 사용자 인터페이스 콘텐츠를 표시했습니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-139">This also supported a model driven, or data driven, system for displaying user interface content.</span></span> <span data-ttu-id="ea665-140">이 방법을 통해 애플리케이션의 동작을 보다 효과적으로 제어하기 위해 사용자가 바인딩할 수 있는 것보다 더 많은 속성을 의도적으로 만들 수 있었습니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-140">This philosophy had the intended effect of creating more properties that you could bind to, in order to better control the behavior of an application.</span></span>  
  
 <span data-ttu-id="ea665-141">시스템에서 더 많은 부분을 속성에서 제어할 수 있게 만들기 위해 [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)]이 제공하는 것보다 다양한 속성 시스템이 필요했습니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-141">In order to have more of the system driven by properties, a richer property system than what the [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] provides was needed.</span></span> <span data-ttu-id="ea665-142">간단한 예로 변경 알림을 들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-142">A simple example of this richness is change notifications.</span></span> <span data-ttu-id="ea665-143">양방향 바인딩을 사용하기 위해서는 바인드의 양쪽이 변경 알림을 지원해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-143">In order to enable two way binding, you need both sides of the bind to support change notification.</span></span> <span data-ttu-id="ea665-144">동작이 속성 값에 연결되려면 속성 값이 변경될 때 알림을 받아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-144">In order to have behavior tied to property values, you need to be notified when the property value changes.</span></span> <span data-ttu-id="ea665-145">Microsoft.NET Framework, 인터페이스가 **INotifyPropertyChange**는 선택 사항 이지만 개체 변경 알림을 게시할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-145">The Microsoft .NET Framework has an interface, **INotifyPropertyChange**, which allows an object to publish change notifications, however it is optional.</span></span>  
  
 [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] <span data-ttu-id="ea665-146">파생 된 다양 한 속성 시스템을 제공 합니다 <xref:System.Windows.DependencyObject> 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-146">provides a richer property system, derived from the <xref:System.Windows.DependencyObject> type.</span></span> <span data-ttu-id="ea665-147">속성 시스템은 속성 식 간의 종속성을 추적하고 종속성이 변경될 때 속성 값의 유효성을 자동으로 다시 검사하는 면에서 진정한 "종속성" 속성 시스템입니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-147">The property system is truly a "dependency" property system in that it tracks dependencies between property expressions and automatically revalidates property values when dependencies change.</span></span> <span data-ttu-id="ea665-148">예를 들어, 상속 하는 속성이 있는 경우 (같은 <xref:System.Windows.Controls.Control.FontSize%2A>), 시스템 속성 값이 상속 하는 요소의 부모에서 속성이 변경 되 면 자동으로 업데이트 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-148">For example, if you have a property that inherits (like <xref:System.Windows.Controls.Control.FontSize%2A>), the system is automatically updated if the property changes on a parent of an element that inherits the value.</span></span>  
  
 <span data-ttu-id="ea665-149">[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] 속성 시스템의 기반은 속성 식의 개념입니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-149">The foundation of the [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] property system is the concept of a property expression.</span></span> <span data-ttu-id="ea665-150">이 첫 릴리스의 [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)]에서는 속성 식 시스템이 닫혀 있고 식이 모두 프레임워크의 일부로 제공됩니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-150">In this first release of [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)], the property expression system is closed, and the expressions are all provided as part of the framework.</span></span> <span data-ttu-id="ea665-151">속성 시스템에 하드 코드된 상속, 스타일 설정 또는 데이터 바인딩이 없고 대신 프레임워크 내의 이후 계층에 의해 제공되는 이유는 식 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-151">Expressions are why the property system doesn’t have data binding, styling, or inheritance hard coded, but rather provided by later layers within the framework.</span></span>  
  
 <span data-ttu-id="ea665-152">속성 시스템은 밀도가 낮은 속성 값 스토리지도 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-152">The property system also provides for sparse storage of property values.</span></span> <span data-ttu-id="ea665-153">개체에 수십 또는 수백 개의 속성이 있을 수 있고 대부분의 값은 기본 상태(상속됨, 스타일에 의해 설정됨 등)로 되어 있으므로 개체의 모든 인스턴스에서 모든 속성을 정의할 필요는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-153">Because objects can have dozens (if not hundreds) of properties, and most of the values are in their default state (inherited, set by styles, etc.), not every instance of an object needs to have the full weight of every property defined on it.</span></span>  
  
 <span data-ttu-id="ea665-154">속성 시스템의 마지막 새 기능은 연결된 속성이라는 개념입니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-154">The final new feature of the property system is the notion of attached properties.</span></span> [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] <span data-ttu-id="ea665-155">요소는 컴퍼지션 및 구성 요소 재사용 원칙을 기반으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-155">elements are built on the principle of composition and component reuse.</span></span> <span data-ttu-id="ea665-156">것은 종종 일부 요소를 포함 하 (같은 <xref:System.Windows.Controls.Grid> 레이아웃 요소) (예: 행/열 정보) 동작을 제어할 자식 요소에 추가 데이터가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-156">It is often the case that some containing element (like a <xref:System.Windows.Controls.Grid> layout element) needs additional data on child elements to control its behavior (like the Row/Column information).</span></span> <span data-ttu-id="ea665-157">이러한 모든 속성을 모든 요소와 연결하는 대신 개체가 다른 개체에 대한 속성 정의를 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-157">Instead of associating all of these properties with every element, any object is allowed to provide property definitions for any other object.</span></span> <span data-ttu-id="ea665-158">이는 JavaScript의 "expando" 기능과 유사합니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-158">This is similar to the "expando" features of JavaScript.</span></span>  
  
<a name="System_Windows_Media_Visual"></a>   
## <a name="systemwindowsmediavisual"></a><span data-ttu-id="ea665-159">System.Windows.Media.Visual</span><span class="sxs-lookup"><span data-stu-id="ea665-159">System.Windows.Media.Visual</span></span>  
 <span data-ttu-id="ea665-160">시스템이 정의되면 다음 단계는 화면에서 픽셀을 그리는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-160">With a system defined, the next step is getting pixels drawn to the screen.</span></span> <span data-ttu-id="ea665-161"><xref:System.Windows.Media.Visual> 그리기 명령과 해당 명령을 (예: 클리핑, 변환) 렌더링 하는 방법에 대 한 메타 데이터를 선택적으로 포함 된 각 시각적 개체의 트리를 빌드하기 위한 클래스를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-161">The <xref:System.Windows.Media.Visual> class provides for building a tree of visual objects, each optionally containing drawing instructions and metadata about how to render those instructions (clipping, transformation, etc.).</span></span> <xref:System.Windows.Media.Visual> <span data-ttu-id="ea665-162">대부분의 기능은 비공용 있으므로 매우 간단 하 고 유연 하도록 설계 되었습니다 [!INCLUDE[TLA2#tla_api](../../../../includes/tla2sharptla-api-md.md)] 노출 보호 되는 콜백 함수에 크게 의존 합니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-162">is designed to be extremely lightweight and flexible, so most of the features have no public [!INCLUDE[TLA2#tla_api](../../../../includes/tla2sharptla-api-md.md)] exposure and rely heavily on protected callback functions.</span></span>  
  
 <xref:System.Windows.Media.Visual> <span data-ttu-id="ea665-163">에 대 한 진입점은 실제로 [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] 컴퍼지션 시스템입니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-163">is really the entry point to the [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] composition system.</span></span> <xref:System.Windows.Media.Visual> <span data-ttu-id="ea665-164">관리 되는 두 하위 간의 연결 지점이 [!INCLUDE[TLA#tla_api](../../../../includes/tlasharptla-api-md.md)] 및 관리 되지 않는 milcore 합니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-164">is the point of connection between these two subsystems, the managed [!INCLUDE[TLA#tla_api](../../../../includes/tlasharptla-api-md.md)] and the unmanaged milcore.</span></span>  
  
 [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] <span data-ttu-id="ea665-165">milcore에 의해 관리 되는 관리 되지 않는 데이터 구조를 이동 하 여 데이터를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-165">displays data by traversing the unmanaged data structures managed by the milcore.</span></span> <span data-ttu-id="ea665-166">컴포지션 노드라고 하는 이 구조는 각 노드에 렌더링 명령이 있는 계층적 디스플레이 트리를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-166">These structures, called composition nodes, represent a hierarchical display tree with rendering instructions at each node.</span></span> <span data-ttu-id="ea665-167">아래 그림의 오른쪽에 있는 이 트리에는 메시징 프로토콜을 통해서만 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-167">This tree, illustrated on the right hand side of the figure below, is only accessible through a messaging protocol.</span></span>  
  
 <span data-ttu-id="ea665-168">프로그래밍할 때 [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)]에서 만든 <xref:System.Windows.Media.Visual> 요소 및이 메시징 프로토콜을 통해 컴포지션 트리와 내부적으로 통신 하는 파생된 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-168">When programming [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)], you create <xref:System.Windows.Media.Visual> elements, and derived types, which internally communicate to the composition tree through this messaging protocol.</span></span> <span data-ttu-id="ea665-169">각 <xref:System.Windows.Media.Visual> 에서 [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] 하나, none, 또는 여러 개의 컴포지션 노드를 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-169">Each <xref:System.Windows.Media.Visual> in [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] may create one, none, or several composition nodes.</span></span>  
  
 <span data-ttu-id="ea665-170">![Windows Presentation Foundation 시각적 트리.](./media/wpf-architecture2.PNG "wpf_architecture2")</span><span class="sxs-lookup"><span data-stu-id="ea665-170">![The Windows Presentation Foundation Visual Tree.](./media/wpf-architecture2.PNG "wpf_architecture2")</span></span>  
  
 <span data-ttu-id="ea665-171">여기에서 알아 두어야 할 매우 중요한 아키텍처 정보가 있습니다. 그것은 바로 시각 요소 및 그리기 명령의 전체 트리가 캐시된다는 사실입니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-171">There is a very important architectural detail to notice here – the entire tree of visuals and drawing instructions is cached.</span></span> <span data-ttu-id="ea665-172">그래픽 측면에서 [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)]는 유지된 렌더링 시스템을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-172">In graphics terms, [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] uses a retained rendering system.</span></span> <span data-ttu-id="ea665-173">이로 인해 시스템은 사용자 코드에 대한 콜백을 차단하는 컴포지션 시스템 없이 높은 화면 주사율로 다시 그릴 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-173">This enables the system to repaint at high refresh rates without the composition system blocking on callbacks to user code.</span></span> <span data-ttu-id="ea665-174">따라서 응답하지 않는 애플리케이션이 나타나지 않게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-174">This helps prevent the appearance of an unresponsive application.</span></span>  
  
 <span data-ttu-id="ea665-175">다이어그램에서 놓치기 쉬운 또 다른 중요한 정보는 시스템이 실제로 컴포지션을 수행하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-175">Another important detail that isn’t really noticeable in the diagram is how the system actually performs composition.</span></span>  
  
 <span data-ttu-id="ea665-176">User32 및 [!INCLUDE[TLA2#tla_gdi](../../../../includes/tla2sharptla-gdi-md.md)]에서 시스템은 즉각적인 모드 클리핑 시스템으로 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-176">In User32 and [!INCLUDE[TLA2#tla_gdi](../../../../includes/tla2sharptla-gdi-md.md)], the system works on an immediate mode clipping system.</span></span> <span data-ttu-id="ea665-177">구성 요소를 렌더링해야 할 때는 시스템이 구성 요소가 픽셀과 닿을 수 없는 곳의 바깥에 클리핑 경계를 설정한 다음 구성 요소가 해당 상자에서 픽셀을 그려야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-177">When a component needs to be rendered, the system establishes a clipping bounds outside of which the component isn’t allowed to touch the pixels, and then the component is asked to paint pixels in that box.</span></span> <span data-ttu-id="ea665-178">이 시스템은 무언가 변경될 때 영향을 받는 구성 요소만 처리하면 되기 때문에 메모리가 제약된 시스템에서 잘 작동합니다. 단일 픽셀의 색상에 두 개의 구성 요소가 관여하는 경우는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-178">This system works very well in memory constrained systems because when something changes you only have to touch the affected component – no two components ever contribute to the color of a single pixel.</span></span>  
  
 [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] <span data-ttu-id="ea665-179">"페인 터 알고리즘" 그리기 모델을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-179">uses a "painter's algorithm" painting model.</span></span> <span data-ttu-id="ea665-180">즉, 각 구성 요소를 클리핑하는 대신 각 구성 요소가 디스플레이의 뒤쪽에서 앞쪽으로 렌더링해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-180">This means that instead of clipping each component, each component is asked to render from the back to the front of the display.</span></span> <span data-ttu-id="ea665-181">따라서 각 구성 요소가 이전 구성 요소의 디스플레이에 그릴 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-181">This allows each component to paint over the previous component's display.</span></span> <span data-ttu-id="ea665-182">이 모델의 장점은 복잡하고 부분적인 투명 모양이 가능하다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-182">The advantage of this model is that you can have complex, partially transparent shapes.</span></span> <span data-ttu-id="ea665-183">User32/ [!INCLUDE[TLA2#tla_gdi](../../../../includes/tla2sharptla-gdi-md.md)]를 만들었을 때와 달리 오늘날의 현대적인 그래픽 하드웨어에서는 이 모델이 상대적으로 빠릅니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-183">With today’s modern graphics hardware, this model is relatively fast (which wasn’t the case when User32/ [!INCLUDE[TLA2#tla_gdi](../../../../includes/tla2sharptla-gdi-md.md)] were created).</span></span>  
  
 <span data-ttu-id="ea665-184">앞에서 언급했듯이 [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)]의 핵심 방법은 보다 선언적인 "속성 중심의" 프로그래밍 모델로 이동하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-184">As mentioned previously, a core philosophy of [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] is to move to a more declarative, "property centric" model of programming.</span></span> <span data-ttu-id="ea665-185">시각적 시스템에서는 두 가지 흥미로운 장소에서 이러한 이동이 눈에 띕니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-185">In the visual system, this shows up in a couple of interesting places.</span></span>  
  
 <span data-ttu-id="ea665-186">첫째, 유지된 모드 그래픽 시스템을 고려해 보면 명령적 DrawLine/DrawLine 형식 모델에서 데이터 지향 모델인 new Line()/new Line()으로 이동하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-186">First, if you think about the retained mode graphic system, this is really moving away from an imperative DrawLine/DrawLine type model, to a data oriented model – new Line()/new Line().</span></span> <span data-ttu-id="ea665-187">이러한 데이터 중심 렌더링으로의 이동으로 인해 속성을 사용하여 그리기 지침에 대한 복잡한 작업을 표현할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-187">This move to data driven rendering allows complex operations on the drawing instructions to be expressed using properties.</span></span> <span data-ttu-id="ea665-188">파생 형식을 <xref:System.Windows.Media.Drawing> 은 효과적으로 렌더링 하기 위한 개체 모델입니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-188">The types deriving from <xref:System.Windows.Media.Drawing> are effectively the object model for rendering.</span></span>  
  
 <span data-ttu-id="ea665-189">둘째, 애니메이션 시스템을 평가할 경우 거의 모든 내용이 선언적인 것을 볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-189">Second, if you evaluate the animation system, you'll see that it is almost completely declarative.</span></span> <span data-ttu-id="ea665-190">개발자가 다음 위치 또는 다음 색상을 컴퓨팅하도록 하는 대신 애니메이션을 애니메이션 개체의 속성 집합으로 표현할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-190">Instead of requiring a developer to compute the next location, or next color, you can express animations as a set of properties on an animation object.</span></span> <span data-ttu-id="ea665-191">그런 다음 이 애니메이션은 개발자 또는 디자이너의 의도(예: 5초 이내에 이 단추를 다른 곳으로 이동)를 표현할 수 있으며 시스템은 이를 완료하기 위한 가장 효율적인 방법을 파악할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-191">These animations can then express the intent of the developer or designer (move this button from here to there in 5 seconds), and the system can determine the most efficient way to accomplish that.</span></span>  
  
<a name="System_Windows_UIElement"></a>   
## <a name="systemwindowsuielement"></a><span data-ttu-id="ea665-192">System.Windows.UIElement</span><span class="sxs-lookup"><span data-stu-id="ea665-192">System.Windows.UIElement</span></span>  
 <xref:System.Windows.UIElement> <span data-ttu-id="ea665-193">레이아웃, 입력 및 이벤트를 포함 하 여 핵심 하위 시스템을 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-193">defines core subsystems including Layout, Input, and Events.</span></span>  
  
 <span data-ttu-id="ea665-194">레이아웃은 [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)]의 핵심 개념입니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-194">Layout is a core concept in [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)].</span></span> <span data-ttu-id="ea665-195">대부분의 시스템에는 고정된 레이아웃 모델 집합(HTML은 세 가지 레이아웃 모델인 흐름, 절대 및 테이블을 지원함)이 있거나 레이아웃 모델이 아예 없습니다(User32는 실제로 절대 위치 지정만 지원함).</span><span class="sxs-lookup"><span data-stu-id="ea665-195">In many systems there is either a fixed set of layout models (HTML supports three models for layout; flow, absolute, and tables) or no model for layout (User32 really only supports absolute positioning).</span></span> [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] <span data-ttu-id="ea665-196">개발자 및 디자이너가 명령적 논리 대신 속성 값으로 결정 될 수 있는 유연 하 고 확장 가능한 레이아웃 모델을 사용 하는 원하는 가정으로 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-196">started with the assumption that developers and designers wanted a flexible, extensible layout model, which could be driven by property values rather than imperative logic.</span></span> <span data-ttu-id="ea665-197">에 <xref:System.Windows.UIElement> 수준에서 레이아웃의 기본 계약이 도입 되었습니다 – 사용 하 여 모델 단계는 두 개의 <xref:System.Windows.UIElement.Measure%2A> 및 <xref:System.Windows.UIElement.Arrange%2A> 전달 합니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-197">At the <xref:System.Windows.UIElement> level, the basic contract for layout is introduced – a two phase model with <xref:System.Windows.UIElement.Measure%2A> and <xref:System.Windows.UIElement.Arrange%2A> passes.</span></span>  
  
 <xref:System.Windows.UIElement.Measure%2A> <span data-ttu-id="ea665-198">사용 하려는 크기를 결정 하는 구성 요소를 허용 합니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-198">allows a component to determine how much size it would like to take.</span></span> <span data-ttu-id="ea665-199">별도 단계 <xref:System.Windows.UIElement.Arrange%2A> 되므로 대부분의 경우 여기서 부모 요소 자식을 최적의 위치 및 크기를 확인 하려면 몇 시간을 측정 하도록 묻습니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-199">This is a separate phase from <xref:System.Windows.UIElement.Arrange%2A> because there are many situations where a parent element will ask a child to measure several times to determine its optimal position and size.</span></span> <span data-ttu-id="ea665-200">부모 요소가 자식 요소에게 측정을 요구한다는 사실은 [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)]의 또 다른 주요 방법인 콘텐츠에 맞는 크기를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-200">The fact that parent elements ask child elements to measure demonstrates another key philosophy of [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] – size to content.</span></span> <span data-ttu-id="ea665-201">[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] 내에 있는 모든 컨트롤은 콘텐츠의 기본 크기에 맞게 크기가 조정되는 기능을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-201">All controls in [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] support the ability to size to the natural size of their content.</span></span> <span data-ttu-id="ea665-202">이에 따라 지역화가 훨씬 간단해지고 크기 조정에 따른 요소의 동적 레이아웃이 가능합니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-202">This makes localization much easier, and allows for dynamic layout of elements as things resize.</span></span> <span data-ttu-id="ea665-203"><xref:System.Windows.UIElement.Arrange%2A> 단계에 배치 하 고 각 자식 항목의 최종 크기를 결정 하는 부모 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-203">The <xref:System.Windows.UIElement.Arrange%2A> phase allows a parent to position and determine the final size of each child.</span></span>  
  
 <span data-ttu-id="ea665-204">시간이 많이 종종 할애 하 여의 출력 측면에 대 한 설명 [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] – <xref:System.Windows.Media.Visual> 및 관련 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-204">A lot of time is often spent talking about the output side of [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] – <xref:System.Windows.Media.Visual> and related objects.</span></span> <span data-ttu-id="ea665-205">입력 측면에도 새로운 내용이 매우 많습니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-205">However there is a tremendous amount of innovation on the input side as well.</span></span> <span data-ttu-id="ea665-206">[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)]의 입력 모델에서 가장 근본적인 변화는 입력 이벤트가 시스템을 통해 라우트되는 일관된 모델입니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-206">Probably the most fundamental change in the input model for [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] is the consistent model by which input events are routed through the system.</span></span>  
  
 <span data-ttu-id="ea665-207">입력은 커널 모드 디바이스 드라이버의 신호로 시작되며 Windows 커널 및 User32가 관련된 복잡한 프로세스를 통해 올바른 프로세스 및 스레드로 라우트됩니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-207">Input originates as a signal on a kernel mode device driver and gets routed to the correct process and thread through an intricate process involving the Windows kernel and User32.</span></span> <span data-ttu-id="ea665-208">입력에 해당하는 User32 메시지가 [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)]로 라우트되면 [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] 원시 입력 메시지로 변환되고 디스패처로 전송됩니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-208">Once the User32 message corresponding to the input is routed to [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)], it is converted into a [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] raw input message and sent to the dispatcher.</span></span> [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] <span data-ttu-id="ea665-209">원시 입력된 이벤트 배달이 보장된을 사용 하 여 시스템의 낮은 수준에서 구현 될 수 있는 "MouseEnter"와 같은 기능을 사용 하도록 설정 하는 여러 개의 실제 이벤트로 변환할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-209">allows for raw input events to be converted to multiple actual events, enabling features like "MouseEnter" to be implemented at a low level of the system with guaranteed delivery.</span></span>  
  
 <span data-ttu-id="ea665-210">각 입력 이벤트는 최소한 두 개의 이벤트인 "미리 보기" 이벤트와 실제 이벤트로 변환됩니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-210">Each input event is converted to at least two events – a "preview" event and the actual event.</span></span> <span data-ttu-id="ea665-211">[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)]에 있는 모든 이벤트는 요소 트리를 통해 라우트되는 개념입니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-211">All events in [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] have a notion of routing through the element tree.</span></span> <span data-ttu-id="ea665-212">루트에는 트리의 대상에서 트래버스 하며 루트에서 시작 하는 대상으로 아래로 이동할 경우에 "터널링" 라고 하는 경우 이벤트를 "버블링" 라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-212">Events are said to "bubble" if they traverse from a target up the tree to the root, and are said to "tunnel" if they start at the root and traverse down to a target.</span></span> <span data-ttu-id="ea665-213">입력 미리 보기 이벤트는 터널링되어 트리에 있는 각 요소가 이벤트를 필터링하거나 이벤트에 대한 작업을 수행할 수 있는 기회를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-213">Input preview events tunnel, enabling any element in the tree an opportunity to filter or take action on the event.</span></span> <span data-ttu-id="ea665-214">그런 다음 일반(미리 보기 아님) 이벤트가 대상에서 루트로 위로 버블링됩니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-214">The regular (non-preview) events then bubble from the target up to the root.</span></span>  
  
 <span data-ttu-id="ea665-215">이러한 터널링 단계와 버블링 단계 간의 구분으로 인해 컴포지션 영역에서 키보드 액셀러레이터 같은 기능이 일관된 방식으로 구현됩니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-215">This split between the tunnel and bubble phase makes implementation of features like keyboard accelerators work in a consistent fashion in a composite world.</span></span> <span data-ttu-id="ea665-216">User32에서는 지원하고자 하는 모든 가속기를 포함하는 단일 글로벌 테이블을 보유하여 키보드 액셀러레이터를 구현합니다(예: "새로 만들기"에 Ctrl+N 매핑).</span><span class="sxs-lookup"><span data-stu-id="ea665-216">In User32 you would implement keyboard accelerators by having a single global table containing all the accelerators you wanted to support (Ctrl+N mapping to "New").</span></span> <span data-ttu-id="ea665-217">애플리케이션의 디스패처에서는 User32의 입력 메시지를 탐지하고 등록된 액셀러레이터와 일치하는 것이 있는지 확인하는 **TranslateAccelerator**를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-217">In the dispatcher for your application you would call **TranslateAccelerator** which would sniff the input messages in User32 and determine if any matched a registered accelerator.</span></span> <span data-ttu-id="ea665-218">[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)]에서는 시스템이 완전히 "구성 가능"하기 때문에, 즉 모든 요소가 키보드 액셀러레이터를 처리하고 사용할 수 있기 때문에 이 방법이 작동하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-218">In [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] this wouldn’t work because the system is fully "composable" – any element can handle and use any keyboard accelerator.</span></span> <span data-ttu-id="ea665-219">입력에 이 2단계 모델을 사용하면 구성 요소가 자체적인 "TranslateAccelerator"를 구현할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-219">Having this two phase model for input allows components to implement their own "TranslateAccelerator".</span></span>  
  
 <span data-ttu-id="ea665-220">또한이 한 단계를 수행 하려면 <xref:System.Windows.UIElement> commandbindings 라는 개념도 도입 합니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-220">To take this one step further, <xref:System.Windows.UIElement> also introduces the notion of CommandBindings.</span></span> <span data-ttu-id="ea665-221">합니다 [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] 명령 시스템 개발자가 무언가 명령 끝점을 기준으로 기능을 정의 하는 구현 <xref:System.Windows.Input.ICommand>합니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-221">The [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] command system allows developers to define functionality in terms of a command end point – something that implements <xref:System.Windows.Input.ICommand>.</span></span> <span data-ttu-id="ea665-222">명령 바인딩을 통해 요소가 입력 제스처(예: Ctrl+N)와 명령(예: 새로 만들기) 사이의 매핑을 정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-222">Command bindings enable an element to define a mapping between an input gesture (Ctrl+N) and a command (New).</span></span> <span data-ttu-id="ea665-223">입력 제스처와 명령 정의는 모두 확장이 가능하며 사용 중에 함께 연결될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-223">Both the input gestures and command definitions are extensible, and can be wired together at usage time.</span></span> <span data-ttu-id="ea665-224">최종 사용자가 애플리케이션 내에서 사용할 키 바인딩을 사용자 지정하는 작업 등이 간단해집니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-224">This makes it trivial, for example, to allow an end user to customize the key bindings that they want to use within an application.</span></span>  
  
 <span data-ttu-id="ea665-225">항목의 이 시점에서는 [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)]의 "핵심" 기능, 즉 PresentationCore 어셈블리에 구현된 기능에 초점이 맞춰집니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-225">To this point in the topic, "core" features of [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] – features implemented in the PresentationCore assembly, have been the focus.</span></span> <span data-ttu-id="ea665-226">빌드하면 [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)], 기초 부분 사이가 완전히 구분 (사용 하 여 레이아웃에 대 한 계약 등 **측정값** 및 **정렬**)과 프레임 워크 부분 (예: 특정 구현 같은 레이아웃 <xref:System.Windows.Controls.Grid>) 원하는 결과 했습니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-226">When building [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)], a clean separation between foundational pieces (like the contract for layout with **Measure** and **Arrange**) and framework pieces (like the implementation of a specific layout like <xref:System.Windows.Controls.Grid>) was the desired outcome.</span></span> <span data-ttu-id="ea665-227">목표는 외부 개발자가 필요한 경우 자체적인 프레임워크를 만들 수 있도록 스택의 아래쪽에 확장 가능성 지점을 제공하는 것이었습니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-227">The goal was to provide an extensibility point low in the stack that would allow external developers to create their own frameworks if needed.</span></span>  
  
<a name="System_Windows_FrameworkElement"></a>   
## <a name="systemwindowsframeworkelement"></a><span data-ttu-id="ea665-228">System.Windows.FrameworkElement</span><span class="sxs-lookup"><span data-stu-id="ea665-228">System.Windows.FrameworkElement</span></span>  
 <xref:System.Windows.FrameworkElement> <span data-ttu-id="ea665-229">두 가지 방식에서에서 찾을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-229">can be looked at in two different ways.</span></span> <span data-ttu-id="ea665-230">[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)]의 낮은 계층에 도입되는 하위 시스템에 대한 정책 및 사용자 지정 집합을 소개한다는 것이며,</span><span class="sxs-lookup"><span data-stu-id="ea665-230">It introduces a set of policies and customizations on the subsystems introduced in lower layers of [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)].</span></span> <span data-ttu-id="ea665-231">다른 한 가지는 새로운 하위 시스템 집합을 소개한다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-231">It also introduces a set of new subsystems.</span></span>  
  
 <span data-ttu-id="ea665-232">도입 된 기본 정책은 <xref:System.Windows.FrameworkElement> 응용 프로그램 레이아웃에 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-232">The primary policy introduced by <xref:System.Windows.FrameworkElement> is around application layout.</span></span> <xref:System.Windows.FrameworkElement> <span data-ttu-id="ea665-233">도입 된 기본 레이아웃 계약 기반 <xref:System.Windows.UIElement> 레이아웃을 쉽게 레이아웃 작성자 속성 중심 레이아웃 의미 체계는 일관 된 집합에 대 한 "슬롯" 개념을 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-233">builds on the basic layout contract introduced by <xref:System.Windows.UIElement> and adds the notion of a layout "slot" that makes it easier for layout authors to have a consistent set of property driven layout semantics.</span></span> <span data-ttu-id="ea665-234">등의 속성 <xref:System.Windows.FrameworkElement.HorizontalAlignment%2A>, <xref:System.Windows.FrameworkElement.VerticalAlignment%2A>, <xref:System.Windows.FrameworkElement.MinWidth%2A>, 및 <xref:System.Windows.FrameworkElement.Margin%2A> (을)에서 파생 된 모든 구성 요소를 제공 <xref:System.Windows.FrameworkElement> 레이아웃 컨테이너 내의 일관 된 동작입니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-234">Properties like <xref:System.Windows.FrameworkElement.HorizontalAlignment%2A>, <xref:System.Windows.FrameworkElement.VerticalAlignment%2A>, <xref:System.Windows.FrameworkElement.MinWidth%2A>, and <xref:System.Windows.FrameworkElement.Margin%2A> (to name a few) give all components derived from <xref:System.Windows.FrameworkElement> consistent behavior inside of layout containers.</span></span>  
  
 <xref:System.Windows.FrameworkElement> <span data-ttu-id="ea665-235">또한 쉽게 제공 [!INCLUDE[TLA2#tla_api](../../../../includes/tla2sharptla-api-md.md)] 다양 한 기능에 대 한 노출을의 핵심 계층에 있는 [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)]합니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-235">also provides easier [!INCLUDE[TLA2#tla_api](../../../../includes/tla2sharptla-api-md.md)] exposure to many features found in the core layers of [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)].</span></span> <span data-ttu-id="ea665-236">예를 들어 <xref:System.Windows.FrameworkElement> 애니메이션에 직접 액세스할 수는 <xref:System.Windows.FrameworkElement.BeginStoryboard%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="ea665-236">For example, <xref:System.Windows.FrameworkElement> provides direct access to animation through the <xref:System.Windows.FrameworkElement.BeginStoryboard%2A> method.</span></span> <span data-ttu-id="ea665-237"><xref:System.Windows.Media.Animation.Storyboard> 속성 집합에 대해 여러 애니메이션을 스크립팅할 수 있는 방법을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-237">A <xref:System.Windows.Media.Animation.Storyboard> provides a way to script multiple animations against a set of properties.</span></span>  
  
 <span data-ttu-id="ea665-238">가장 중요 한 두 가지는 <xref:System.Windows.FrameworkElement> 소개은 데이터 바인딩 및 스타일.</span><span class="sxs-lookup"><span data-stu-id="ea665-238">The two most critical things that <xref:System.Windows.FrameworkElement> introduces are data binding and styles.</span></span>  
  
 <span data-ttu-id="ea665-239">[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)]의 데이터 바인딩 하위 시스템은 [!INCLUDE[TLA#tla_winforms](../../../../includes/tlasharptla-winforms-md.md)] 또는 [!INCLUDE[TLA#tla_aspnet](../../../../includes/tlasharptla-aspnet-md.md)]을 사용하여 응용 프로그램 [!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)]를 만든 사용자에게 비교적 친숙해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-239">The data binding subsystem in [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] should be relatively familiar to anyone that has used [!INCLUDE[TLA#tla_winforms](../../../../includes/tlasharptla-winforms-md.md)] or [!INCLUDE[TLA#tla_aspnet](../../../../includes/tlasharptla-aspnet-md.md)] for creating an application [!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)].</span></span> <span data-ttu-id="ea665-240">이러한 각 시스템에는 특정 요소에 있는 하나 이상의 속성을 데이터 조각에 바인딩하려고 한다는 것을 간단하게 표현할 수 있는 방법이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-240">In each of these systems, there is a simple way to express that you want one or more properties from a given element to be bound to a piece of data.</span></span> [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] <span data-ttu-id="ea665-241">속성 바인딩, 변환 및 목록 바인딩을 완전히 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-241">has full support for property binding, transformation, and list binding.</span></span>  
  
 <span data-ttu-id="ea665-242">[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)]에서 데이터 바인딩의 가장 흥미로운 기능 중 하나는 새로 도입된 데이터 템플릿입니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-242">One of the most interesting features of data binding in [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] is the introduction of data templates.</span></span> <span data-ttu-id="ea665-243">데이터 템플릿을 사용하면 어떤 데이터 조각을 시각화해야 하는지를 선언적으로 명시할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-243">Data templates allow you to declaratively specify how a piece of data should be visualized.</span></span> <span data-ttu-id="ea665-244">데이터에 바인딩할 수 있는 사용자 지정 사용자 인터페이스를 만드는 대신 역으로, 생성될 디스플레이를 데이터가 결정하도록 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-244">Instead of creating a custom user interface that can be bound to data, you can instead turn the problem around and let the data determine the display that will be created.</span></span>  
  
 <span data-ttu-id="ea665-245">스타일 지정은 실제로는 데이터 바인딩의 간단한 형태입니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-245">Styling is really a lightweight form of data binding.</span></span> <span data-ttu-id="ea665-246">스타일 지정을 사용하면 공유된 정의에 있는 속성 집합을 하나 이상의 요소 인스턴스에 바인딩할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-246">Using styling you can bind a set of properties from a shared definition to one or more instances of an element.</span></span> <span data-ttu-id="ea665-247">요소에 스타일 적용 하거나 명시적으로 참조 (설정 하 여 합니다 <xref:System.Windows.FrameworkElement.Style%2A> 속성) 또는 연결 된 스타일을 암시적으로 [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] 요소의 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-247">Styles get applied to an element either by explicit reference (by setting the <xref:System.Windows.FrameworkElement.Style%2A> property) or implicitly by associating a style with the [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] type of the element.</span></span>  
  
<a name="System_Windows_Controls_Control"></a>   
## <a name="systemwindowscontrolscontrol"></a><span data-ttu-id="ea665-248">System.Windows.Controls.Control</span><span class="sxs-lookup"><span data-stu-id="ea665-248">System.Windows.Controls.Control</span></span>  
 <span data-ttu-id="ea665-249">컨트롤의 가장 중요한 기능은 템플릿 설정입니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-249">Control’s most significant feature is templating.</span></span> <span data-ttu-id="ea665-250">WPF의 컴퍼지션 시스템을 유지된 모드 렌더링 시스템으로 생각하는 경우에는 템플릿 설정을 통해 컨트롤이 매개 변수가 있는 선언적 방식으로 렌더링되고 있음을 설명할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-250">If you think about WPF’s composition system as a retained mode rendering system, templating allows a control to describe its rendering in a parameterized, declarative manner.</span></span> <span data-ttu-id="ea665-251"><xref:System.Windows.Controls.ControlTemplate> 바인딩 컨트롤에서 제공 되는 속성을 사용 하 여 일련의 자식 요소를 만드는 데 필요한 스크립트 일 뿐 이라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-251">A <xref:System.Windows.Controls.ControlTemplate> is really nothing more than a script to create a set of child elements, with bindings to properties offered by the control.</span></span>  
  
 <xref:System.Windows.Controls.Control> <span data-ttu-id="ea665-252">스톡 속성 집합을 제공 <xref:System.Windows.Controls.Control.Foreground%2A>, <xref:System.Windows.Controls.Control.Background%2A>, <xref:System.Windows.Controls.Control.Padding%2A>를 템플릿 작성자는 컨트롤의 표시를 사용자 지정 하는 데 사용할 수는 이름을 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-252">provides a set of stock properties, <xref:System.Windows.Controls.Control.Foreground%2A>, <xref:System.Windows.Controls.Control.Background%2A>, <xref:System.Windows.Controls.Control.Padding%2A>, to name a few, which template authors can then use to customize the display of a control.</span></span> <span data-ttu-id="ea665-253">컨트롤 구현은 데이터 모델 및 상호 작용 모델을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-253">The implementation of a control provides a data model and interaction model.</span></span> <span data-ttu-id="ea665-254">상호 작용 모델은 명령 집합(예: 창 닫기)과 입력 제스처에 대한 바인딩(예: 창의 위쪽 모서리에 있는 빨간색 X 클릭)을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-254">The interaction model defines a set of commands (like Close for a window) and bindings to input gestures (like clicking the red X in the upper corner of the window).</span></span> <span data-ttu-id="ea665-255">데이터 모델은 상호 작용 모델을 사용자 지정하거나 디스플레이를 사용자 지정하기 위한 속성 집합을 제공합니다. 사용자 지정 대상은 템플릿에 의해 결정됩니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-255">The data model provides a set of properties to either customize the interaction model or customize the display (determined by the template).</span></span>  
  
 <span data-ttu-id="ea665-256">데이터 모델(속성), 상호 작용 모델(명령 및 이벤트) 및 디스플레이 모델(템플릿)이 이렇게 구분됨에 따라 컨트롤의 모양 및 동작을 완전히 사용자 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-256">This split between the data model (properties), interaction model (commands and events), and display model (templates) enables complete customization of a control’s look and behavior.</span></span>  
  
 <span data-ttu-id="ea665-257">컨트롤 데이터 모델의 공통적인 측면은 콘텐츠 모델입니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-257">A common aspect of the data model of controls is the content model.</span></span> <span data-ttu-id="ea665-258">와 같은 컨트롤을 살펴보면 <xref:System.Windows.Controls.Button>, 형식의 "Content" 라는 속성에 표시 됩니다 <xref:System.Object>합니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-258">If you look at a control like <xref:System.Windows.Controls.Button>, you will see that it has a property named "Content" of type <xref:System.Object>.</span></span> <span data-ttu-id="ea665-259">[!INCLUDE[TLA#tla_winforms](../../../../includes/tlasharptla-winforms-md.md)] 및 [!INCLUDE[TLA#tla_aspnet](../../../../includes/tlasharptla-aspnet-md.md)]에서 이 속성은 일반적으로 문자열이지만 단추에 입력할 수 있는 콘텐츠 형식이 제한됩니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-259">In [!INCLUDE[TLA#tla_winforms](../../../../includes/tlasharptla-winforms-md.md)] and [!INCLUDE[TLA#tla_aspnet](../../../../includes/tlasharptla-aspnet-md.md)], this property would typically be a string – however that limits the type of content you can put in a button.</span></span> <span data-ttu-id="ea665-260">단추의 콘텐츠는 간단한 문자열, 복잡한 데이터 개체 또는 전체 요소 트리일 수가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-260">Content for a button can either be a simple string, a complex data object, or an entire element tree.</span></span> <span data-ttu-id="ea665-261">데이터 개체의 경우 데이터 템플릿이 사용되어 디스플레이를 구성합니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-261">In the case of a data object, the data template is used to construct a display.</span></span>  
  
<a name="Summary"></a>   
## <a name="summary"></a><span data-ttu-id="ea665-262">요약</span><span class="sxs-lookup"><span data-stu-id="ea665-262">Summary</span></span>  
 [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] <span data-ttu-id="ea665-263">동적인 데이터 중심 프레젠테이션 시스템을 만들 수 있도록 설계 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-263">is designed to allow you to create dynamic, data driven presentation systems.</span></span> <span data-ttu-id="ea665-264">시스템의 모든 부분은 동작을 구현하는 속성 집합을 통해 개체를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-264">Every part of the system is designed to create objects through property sets that drive behavior.</span></span> <span data-ttu-id="ea665-265">데이터 바인딩은 시스템의 기초적인 부분이며 모든 계층과 통합됩니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-265">Data binding is a fundamental part of the system, and is integrated at every layer.</span></span>  
  
 <span data-ttu-id="ea665-266">일반 애플리케이션은 디스플레이를 만든 다음 일부 데이터에 바인딩합니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-266">Traditional applications create a display and then bind to some data.</span></span> <span data-ttu-id="ea665-267">[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)]에서는 컨트롤에 대한 모든 것과 디스플레이의 모든 측면이 일부 데이터 바인딩 형식에 의해 생성됩니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-267">In [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)], everything about the control, every aspect of the display, is generated by some type of data binding.</span></span> <span data-ttu-id="ea665-268">단추 내의 텍스트는 단추 내에 구성된 컨트롤을 만들고 해당 디스플레이를 단추의 콘텐츠 속성에 바인딩하여 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-268">The text found inside a button is displayed by creating a composed control inside of the button and binding its display to the button’s content property.</span></span>  
  
 <span data-ttu-id="ea665-269">[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] 기반 응용 프로그램의 개발을 시작하면 매우 친숙하다는 느낌을 받을 것입니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-269">When you begin developing [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] based applications, it should feel very familiar.</span></span> <span data-ttu-id="ea665-270">[!INCLUDE[TLA#tla_winforms](../../../../includes/tlasharptla-winforms-md.md)] 또는 [!INCLUDE[TLA#tla_aspnet](../../../../includes/tlasharptla-aspnet-md.md)] 을 사용하는 것과 거의 똑같은 방법으로 속성을 설정하고, 개체를 사용하고, 데이터를 바인딩할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-270">You can set properties, use objects, and data bind in much the same way that you can using [!INCLUDE[TLA#tla_winforms](../../../../includes/tlasharptla-winforms-md.md)] or [!INCLUDE[TLA#tla_aspnet](../../../../includes/tlasharptla-aspnet-md.md)].</span></span> <span data-ttu-id="ea665-271">[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)]의 아키텍처를 보다 자세히 살펴 보면 근본적으로 데이터를 응용 프로그램의 핵심 요소로 처리하는 보다 다양한 응용 프로그램을 만들 수 있는 가능성이 있다는 사실을 발견하게 될 것입니다.</span><span class="sxs-lookup"><span data-stu-id="ea665-271">With a deeper investigation into the architecture of [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)], you'll find that the possibility exists for creating much richer applications that fundamentally treat data as the core driver of the application.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="ea665-272">참고자료</span><span class="sxs-lookup"><span data-stu-id="ea665-272">See also</span></span>

- <xref:System.Windows.Media.Visual>
- <xref:System.Windows.UIElement>
- <xref:System.Windows.Input.ICommand>
- <xref:System.Windows.FrameworkElement>
- <xref:System.Windows.Threading.DispatcherObject>
- <xref:System.Windows.Input.CommandBinding>
- <xref:System.Windows.Controls.Control>
- [<span data-ttu-id="ea665-273">데이터 바인딩 개요</span><span class="sxs-lookup"><span data-stu-id="ea665-273">Data Binding Overview</span></span>](../data/data-binding-overview.md)
- [<span data-ttu-id="ea665-274">레이아웃</span><span class="sxs-lookup"><span data-stu-id="ea665-274">Layout</span></span>](layout.md)
- [<span data-ttu-id="ea665-275">애니메이션 개요</span><span class="sxs-lookup"><span data-stu-id="ea665-275">Animation Overview</span></span>](../graphics-multimedia/animation-overview.md)

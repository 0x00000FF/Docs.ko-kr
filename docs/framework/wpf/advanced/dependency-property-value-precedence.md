---
title: 종속성 속성 값 우선 순위
ms.date: 03/30/2017
helpviewer_keywords:
- dependency properties [WPF], classes as owners
- dependency properties [WPF], metadata
- classes [WPF], owners of dependency properties
- metadata [WPF], dependency properties
ms.assetid: 1fbada8e-4867-4ed1-8d97-62c07dad7ebc
ms.openlocfilehash: 25dfe63a65c3044837beb26ec6c4eaa772c1df1b
ms.sourcegitcommit: c7f3e2e9d6ead6cc3acd0d66b10a251d0c66e59d
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 09/08/2018
ms.locfileid: "44180745"
---
# <a name="dependency-property-value-precedence"></a><span data-ttu-id="acdb6-102">종속성 속성 값 우선 순위</span><span class="sxs-lookup"><span data-stu-id="acdb6-102">Dependency Property Value Precedence</span></span>
<a name="introduction"></a> <span data-ttu-id="acdb6-103">이 항목에서는 [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] 속성 시스템의 작업 방식이 종속성 속성 값에 영향을 주는 방식을 설명하고 속성 시스템의 일면이 속성의 유효 값이 적용되는 우선 순위에 관해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="acdb6-103">This topic explains how the workings of the [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] property system can affect the value of a dependency property, and describes the precedence by which aspects of the property system apply to the effective value of a property.</span></span>  
    
  
<a name="prerequisites"></a>   
## <a name="prerequisites"></a><span data-ttu-id="acdb6-104">전제 조건</span><span class="sxs-lookup"><span data-stu-id="acdb6-104">Prerequisites</span></span>  
 <span data-ttu-id="acdb6-105">이 항목에서는 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 클래스에서 기존 종속성 속성의 이용자 관점에서 종속성 속성을 이해하고 [종속성 속성 개요](../../../../docs/framework/wpf/advanced/dependency-properties-overview.md)를 읽었다고 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="acdb6-105">This topic assumes that you understand dependency properties from the perspective of a consumer of existing dependency properties on [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] classes, and have read [Dependency Properties Overview](../../../../docs/framework/wpf/advanced/dependency-properties-overview.md).</span></span> <span data-ttu-id="acdb6-106">이 항목의 예제를 따르려면 [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)]을 이해하고 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 응용 프로그램을 작성하는 방법도 알아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="acdb6-106">To follow the examples in this topic, you should also understand [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)] and know how to write [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications.</span></span>  
  
<a name="intro"></a>   
## <a name="the-wpf-property-system"></a><span data-ttu-id="acdb6-107">WPF 속성 시스템</span><span class="sxs-lookup"><span data-stu-id="acdb6-107">The WPF Property System</span></span>  
 <span data-ttu-id="acdb6-108">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 속성 시스템에서는 실시간 속성 유효성 검사, 지연 바인딩, 다른 속성의 값에 관련 속성의 변경 사항 알림과 같은 기능을 사용하여 다양한 요소에 따라 종속성 속성 값을 결정할 강력한 방법을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="acdb6-108">The [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] property system offers a powerful way to have the value of dependency properties be determined by a variety of factors, enabling features such as real-time property validation, late binding, and notifying related properties of changes to values for other properties.</span></span> <span data-ttu-id="acdb6-109">종속성 속성 값을 결정하는 데 사용되는 정확한 순서와 논리는 상당히 복잡합니다.</span><span class="sxs-lookup"><span data-stu-id="acdb6-109">The exact order and logic that is used to determine dependency property values is reasonably complex.</span></span> <span data-ttu-id="acdb6-110">이 순서를 알면 불필요한 속성 설정을 피할 수 있으며 종속성 속성 값을 예상하거나 영향을 주려고 했을 때 예상과 다른 값이 나온 이유를 정확하게 파악할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="acdb6-110">Knowing this order will help you avoid unnecessary property setting, and might also clear up confusion over exactly why some attempt to influence or anticipate a dependency property value did not end up resulting in the value you expected.</span></span>  
  
<a name="multiple_sets"></a>   
## <a name="dependency-properties-might-be-set-in-multiple-places"></a><span data-ttu-id="acdb6-111">종속성 속성을 여러 곳에 "설정"할 수 있음</span><span class="sxs-lookup"><span data-stu-id="acdb6-111">Dependency Properties Might Be "Set" in Multiple Places</span></span>  
 <span data-ttu-id="acdb6-112">다음은 예제 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] 는 동일한 속성 (<xref:System.Windows.Controls.Control.Background%2A>)에 세 가지 다른 "set" 값에 영향을 줄 수 있는 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="acdb6-112">The following is example [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] where the same property (<xref:System.Windows.Controls.Control.Background%2A>) has three different "set" operations that might influence the value.</span></span>  
  
 [!code-xaml[PropertiesOvwSupport#DPPrecedence](../../../../samples/snippets/csharp/VS_Snippets_Wpf/PropertiesOvwSupport/CSharp/page4.xaml#dpprecedence)]  
  
 <span data-ttu-id="acdb6-113">여기에서 적용될 것으로 예상되는 색은 빨간색, 녹색, 파란색 중에 어느 것입니까?</span><span class="sxs-lookup"><span data-stu-id="acdb6-113">Here, which color do you expect will apply—red, green, or blue?</span></span>  
  
 <span data-ttu-id="acdb6-114">애니메이션된 값과 강제 변환을 제외하면, 로컬 속성 설정이 가장 높은 우선 순위로 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="acdb6-114">With the exception of animated values and coercion, local property sets are set at the highest precedence.</span></span> <span data-ttu-id="acdb6-115">값을 로컬로 설정하면 그 값은 스타일이나 컨트롤 템플릿보다도 우선적으로 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="acdb6-115">If you set a value locally you can expect that the value will be honored, even above any styles or control templates.</span></span> <span data-ttu-id="acdb6-116">여기 예에서 <xref:System.Windows.Controls.Control.Background%2A> 로컬로 Red로 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="acdb6-116">Here in the example, <xref:System.Windows.Controls.Control.Background%2A> is set to Red locally.</span></span> <span data-ttu-id="acdb6-117">따라서 암시적 스타일 해당 범위에서 해당 형식의 모든 요소에 적용 되는 것도이 범위에 정의 된 스타일이 아닌 제공에 대 한 가장 높은 우선 순위는 <xref:System.Windows.Controls.Control.Background%2A> 속성 값입니다.</span><span class="sxs-lookup"><span data-stu-id="acdb6-117">Therefore, the style defined in this scope, even though it is an implicit style that would otherwise apply to all elements of that type in that scope, is not the highest precedence for giving the <xref:System.Windows.Controls.Control.Background%2A> property its value.</span></span>  <span data-ttu-id="acdb6-118">그 단추 인스턴스에서 로컬 값 Red를 제거하면 스타일이 우선적으로 적용되어 단추에 스타일의 Background 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="acdb6-118">If you removed the local value of Red from that Button instance, then the style would have precedence and the button would obtain the Background value from the style.</span></span>  <span data-ttu-id="acdb6-119">스타일 내에서는 트리거가 우선적으로 적용되므로 마우스가 위에 있을 때는 파란색, 그렇지 않을 때는 녹색이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="acdb6-119">Within the style, triggers take precedence, so the button will be blue if the mouse is over it, and green otherwise.</span></span>  
  
<a name="listing"></a>   
## <a name="dependency-property-setting-precedence-list"></a><span data-ttu-id="acdb6-120">종속성 속성 설정 우선 순위 목록</span><span class="sxs-lookup"><span data-stu-id="acdb6-120">Dependency Property Setting Precedence List</span></span>  
 <span data-ttu-id="acdb6-121">다음은 속성 시스템에서 종속성 속성의 런타임 값을 할당할 때 사용하는 최종적인 순서입니다.</span><span class="sxs-lookup"><span data-stu-id="acdb6-121">The following is the definitive order that the property system uses when assigning the run-time values of dependency properties.</span></span> <span data-ttu-id="acdb6-122">가장 높은 우선 순위가 가장 먼저 나열됩니다.</span><span class="sxs-lookup"><span data-stu-id="acdb6-122">Highest precedence is listed first.</span></span> <span data-ttu-id="acdb6-123">이 목록은 [종속성 속성 개요](../../../../docs/framework/wpf/advanced/dependency-properties-overview.md)에 나와 있는 일반적인 순서를 확장한 것입니다.</span><span class="sxs-lookup"><span data-stu-id="acdb6-123">This list expands on some of the generalizations made in the [Dependency Properties Overview](../../../../docs/framework/wpf/advanced/dependency-properties-overview.md).</span></span>  
  
1.  <span data-ttu-id="acdb6-124">**속성 시스템 강제 변환.**</span><span class="sxs-lookup"><span data-stu-id="acdb6-124">**Property system coercion.**</span></span> <span data-ttu-id="acdb6-125">강제 변환에 대한 자세한 내용은 이 항목의 뒷부분에 있는 [강제 변환, 애니메이션 및 기준 값](#animations)을 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="acdb6-125">For details on coercion, see [Coercion, Animation, and Base Value](#animations) later in this topic.</span></span>  
  
2.  <span data-ttu-id="acdb6-126">**활성 애니메이션 또는 보류 동작이 있는 애니메이션.**</span><span class="sxs-lookup"><span data-stu-id="acdb6-126">**Active animations, or animations with a Hold behavior.**</span></span> <span data-ttu-id="acdb6-127">속성 애니메이션이 실제로 효과를 발휘하려면 기준 값이 로컬로 설정된 경우에도 애니메이션되지 않은 기준 값보다 높은 우선 순위를 가질 수 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="acdb6-127">In order to have any practical effect, an animation of a property must be able to have precedence over the base (unanimated) value, even if that value was set locally.</span></span> <span data-ttu-id="acdb6-128">자세한 내용은 이 항목의 뒷부분에 있는 [강제 변환, 애니메이션 및 기준 값](#animations)을 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="acdb6-128">For details, see [Coercion, Animation, and Base Value](#animations) later in this topic.</span></span>  
  
3.  <span data-ttu-id="acdb6-129">**로컬 값.**</span><span class="sxs-lookup"><span data-stu-id="acdb6-129">**Local value.**</span></span> <span data-ttu-id="acdb6-130">편리 하 게도 동일에서 특성 또는 속성 요소로 설정 하는 "래퍼" 속성을 통해 로컬 값을 설정할 수 있습니다 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)], 또는를 호출 하 여 합니다 <xref:System.Windows.DependencyObject.SetValue%2A> [!INCLUDE[TLA#tla_api](../../../../includes/tlasharptla-api-md.md)] 특정 인스턴스의 속성을 사용 하 여 합니다.</span><span class="sxs-lookup"><span data-stu-id="acdb6-130">A local value might be set through the convenience of the "wrapper" property, which also equates to setting as an attribute or property element in [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)], or by a call to the <xref:System.Windows.DependencyObject.SetValue%2A> [!INCLUDE[TLA#tla_api](../../../../includes/tlasharptla-api-md.md)] using a property of a specific instance.</span></span> <span data-ttu-id="acdb6-131">바인딩이나 리소스를 사용하여 로컬 값을 설정하면 이들 각각은 직접 값을 설정한 것과 같은 우선 순위가 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="acdb6-131">If you set a local value by using a binding or a resource, these each act in the precedence as if a direct value was set.</span></span>  
  
4.  <span data-ttu-id="acdb6-132">**TemplatedParent 템플릿 속성.**</span><span class="sxs-lookup"><span data-stu-id="acdb6-132">**TemplatedParent template properties.**</span></span> <span data-ttu-id="acdb6-133">요소에는 <xref:System.Windows.FrameworkElement.TemplatedParent%2A> 템플릿의 일부로 만들어진 경우 (한 <xref:System.Windows.Controls.ControlTemplate> 또는 <xref:System.Windows.DataTemplate>).</span><span class="sxs-lookup"><span data-stu-id="acdb6-133">An element has a <xref:System.Windows.FrameworkElement.TemplatedParent%2A> if it was created as part of a template (a <xref:System.Windows.Controls.ControlTemplate> or <xref:System.Windows.DataTemplate>).</span></span> <span data-ttu-id="acdb6-134">적용 시기에 대한 자세한 내용은 이 항목의 뒷부분에 있는 [TemplatedParent](#templatedparent)를 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="acdb6-134">For details on when this applies, see [TemplatedParent](#templatedparent) later in this topic.</span></span> <span data-ttu-id="acdb6-135">템플릿 내에서는 다음과 같은 우선 순위가 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="acdb6-135">Within the template, the following precedence applies:</span></span>  
  
    1.  <span data-ttu-id="acdb6-136">트리거되는 <xref:System.Windows.FrameworkElement.TemplatedParent%2A> 템플릿.</span><span class="sxs-lookup"><span data-stu-id="acdb6-136">Triggers from the <xref:System.Windows.FrameworkElement.TemplatedParent%2A> template.</span></span>  
  
    2.  <span data-ttu-id="acdb6-137">속성 집합 (일반적으로 통해 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] 특성)에 <xref:System.Windows.FrameworkElement.TemplatedParent%2A> 템플릿.</span><span class="sxs-lookup"><span data-stu-id="acdb6-137">Property sets (typically through [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] attributes) in the <xref:System.Windows.FrameworkElement.TemplatedParent%2A> template.</span></span>  
  
5.  <span data-ttu-id="acdb6-138">**암시적 스타일.**</span><span class="sxs-lookup"><span data-stu-id="acdb6-138">**Implicit style.**</span></span> <span data-ttu-id="acdb6-139">`Style` 속성에만 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="acdb6-139">Applies only to the `Style` property.</span></span> <span data-ttu-id="acdb6-140">`Style` 속성은 해당 요소의 유형과 일치하는 키를 가진 스타일 리소스로 채워집니다.</span><span class="sxs-lookup"><span data-stu-id="acdb6-140">The `Style` property is filled by any style resource with a key that matches the type of that element.</span></span> <span data-ttu-id="acdb6-141">해당 스타일 리소스가 페이지나 응용 프로그램에 있어야 합니다. 암시적 스타일 리소스의 조회는 테마로 이어지지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="acdb6-141">That style resource must exist either in the page or the application; lookup for an implicit style resource does not proceed into the themes.</span></span>  
  
6.  <span data-ttu-id="acdb6-142">**스타일 트리거.**</span><span class="sxs-lookup"><span data-stu-id="acdb6-142">**Style triggers.**</span></span> <span data-ttu-id="acdb6-143">페이지나 응용 프로그램의 스타일에 있는 트리거(명시적 또는 암시적인 스타일일 수 있으나 우선 순위가 더 낮은 기본 스타일은 제외).</span><span class="sxs-lookup"><span data-stu-id="acdb6-143">The triggers within styles from page or application (these styles might be either explicit or implicit styles, but not from the default styles, which have lower precedence).</span></span>  
  
7.  <span data-ttu-id="acdb6-144">**템플릿 트리거.**</span><span class="sxs-lookup"><span data-stu-id="acdb6-144">**Template triggers.**</span></span> <span data-ttu-id="acdb6-145">스타일에 있는 템플릿 또는 직접 적용된 템플릿의 모든 트리거.</span><span class="sxs-lookup"><span data-stu-id="acdb6-145">Any trigger from a template within a style, or a directly applied template.</span></span>  
  
8.  <span data-ttu-id="acdb6-146">**스타일 setter.**</span><span class="sxs-lookup"><span data-stu-id="acdb6-146">**Style setters.**</span></span> <span data-ttu-id="acdb6-147">값을 <xref:System.Windows.Setter> 페이지나 응용 프로그램의 스타일입니다.</span><span class="sxs-lookup"><span data-stu-id="acdb6-147">Values from a <xref:System.Windows.Setter> within styles from page or application.</span></span>  
  
9. <span data-ttu-id="acdb6-148">**기본(테마) 스타일.**</span><span class="sxs-lookup"><span data-stu-id="acdb6-148">**Default (theme) style.**</span></span> <span data-ttu-id="acdb6-149">이 스타일이 적용되는 시기, 그리고 테마 스타일에 있는 템플릿과 테마 스타일의 관계에 대한 자세한 내용은 이 항목의 뒷부분에 있는 [기본(테마) 스타일](#themestyles)을 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="acdb6-149">For details on when this applies, and how theme styles relate to the templates within theme styles, see [Default (Theme) Styles](#themestyles) later in this topic.</span></span> <span data-ttu-id="acdb6-150">기본 스타일 내에서는 다음과 같은 우선 순위가 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="acdb6-150">Within a default style, the following order of precedence applies:</span></span>  
  
    1.  <span data-ttu-id="acdb6-151">테마 스타일의 활성 트리거.</span><span class="sxs-lookup"><span data-stu-id="acdb6-151">Active triggers in the theme style.</span></span>  
  
    2.  <span data-ttu-id="acdb6-152">테마 스타일의 setter.</span><span class="sxs-lookup"><span data-stu-id="acdb6-152">Setters in the theme style.</span></span>  
  
10. <span data-ttu-id="acdb6-153">**상속.**</span><span class="sxs-lookup"><span data-stu-id="acdb6-153">**Inheritance.**</span></span> <span data-ttu-id="acdb6-154">몇 가지 종속성 속성은 상위 요소에서 하위 요소로 값을 상속하므로 응용 프로그램 전체에서 각 요소에 따로 설정할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="acdb6-154">A few dependency properties inherit their values from parent element to child elements, such that they need not be set specifically on each element throughout an application.</span></span> <span data-ttu-id="acdb6-155">자세한 내용은 [속성 값 상속](../../../../docs/framework/wpf/advanced/property-value-inheritance.md)을 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="acdb6-155">For details see [Property Value Inheritance](../../../../docs/framework/wpf/advanced/property-value-inheritance.md).</span></span>  
  
11. <span data-ttu-id="acdb6-156">**종속성 속성 메타데이터의 기본값.**</span><span class="sxs-lookup"><span data-stu-id="acdb6-156">**Default value from dependency property metadata.**</span></span> <span data-ttu-id="acdb6-157">종속성 속성에는 해당 속성의 속성 시스템 등록에 따라 설정된 기본값이 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="acdb6-157">Any given dependency property may have a default value as established by the property system registration of that particular property.</span></span> <span data-ttu-id="acdb6-158">또한 종속성 속성을 상속하는 파생 클래스에서는 유형별로 해당 메타데이터를 재정의할 수 있습니다(기본값 포함).</span><span class="sxs-lookup"><span data-stu-id="acdb6-158">Also, derived classes that inherit a dependency property have the option to override that metadata (including the default value) on a per-type basis.</span></span> <span data-ttu-id="acdb6-159">자세한 내용은 [종속성 속성 메타데이터](../../../../docs/framework/wpf/advanced/dependency-property-metadata.md)를 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="acdb6-159">See [Dependency Property Metadata](../../../../docs/framework/wpf/advanced/dependency-property-metadata.md) for more information.</span></span> <span data-ttu-id="acdb6-160">기본값보다 먼저 상속을 확인하므로, 상속된 속성의 경우는 상위 요소의 기본값이 하위 요소의 기본값보다 우선적으로 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="acdb6-160">Because inheritance is checked before default value, for an inherited property, a parent element default value takes precedence over a child element.</span></span>  <span data-ttu-id="acdb6-161">따라서 상속 가능한 속성이 어디에서도 설정되어 있지 않으면 하위 요소의 기본값 대신 루트나 상위에 지정된 기본값이 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="acdb6-161">Consequently, if an inheritable property is not set anywhere, the default value as specified on the root or parent is used instead of the child element default value.</span></span>  
  
<a name="templatedparent"></a>   
## <a name="templatedparent"></a><span data-ttu-id="acdb6-162">TemplatedParent</span><span class="sxs-lookup"><span data-stu-id="acdb6-162">TemplatedParent</span></span>  
 <span data-ttu-id="acdb6-163">우선 순위 항목으로서의 TemplatedParent는 표준 응용 프로그램 마크업에서 직접 선언한 요소의 어느 속성에도 적용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="acdb6-163">TemplatedParent as a precedence item does not apply to any property of an element that you declare directly in standard application markup.</span></span> <span data-ttu-id="acdb6-164">TemplatedParent 개념은 템플릿 적용을 통해 생긴 시각적 트리의 하위 항목에만 존재합니다.</span><span class="sxs-lookup"><span data-stu-id="acdb6-164">The TemplatedParent concept exists only for child items within a visual tree that come into existence through the application of the template.</span></span> <span data-ttu-id="acdb6-165">속성 시스템 검색 하는 경우는 <xref:System.Windows.FrameworkElement.TemplatedParent%2A> 템플릿에서 값을 해당 템플릿을 검색 하는 해당 요소를 생성 합니다.</span><span class="sxs-lookup"><span data-stu-id="acdb6-165">When the property system searches the <xref:System.Windows.FrameworkElement.TemplatedParent%2A> template for a value, it is searching the template that created that element.</span></span> <span data-ttu-id="acdb6-166">속성에서 값을 <xref:System.Windows.FrameworkElement.TemplatedParent%2A> 템플릿을 로컬 값에 비해 우선 순위가 낮은 템플릿을 공유할 가능성이 때문에 문제가 발생 하지만 자식 요소에 대해 로컬 값으로 설정 된 것 처럼 일반적으로 작동 합니다.</span><span class="sxs-lookup"><span data-stu-id="acdb6-166">The property values from the <xref:System.Windows.FrameworkElement.TemplatedParent%2A> template generally act as if they were set as a local value on the child element, but this lesser precedence versus the local value exists because the templates are potentially shared.</span></span> <span data-ttu-id="acdb6-167">자세한 내용은 <xref:System.Windows.FrameworkElement.TemplatedParent%2A>를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="acdb6-167">For details, see <xref:System.Windows.FrameworkElement.TemplatedParent%2A>.</span></span>  
  
<a name="style_property"></a>   
## <a name="the-style-property"></a><span data-ttu-id="acdb6-168">스타일 속성</span><span class="sxs-lookup"><span data-stu-id="acdb6-168">The Style Property</span></span>  
 <span data-ttu-id="acdb6-169">앞서 설명한 조회 순서 하나를 제외한 모든 가능한 종속성 속성에 적용 됩니다:는 <xref:System.Windows.FrameworkElement.Style%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="acdb6-169">The order of lookup described earlier applies to all possible dependency properties except one: the <xref:System.Windows.FrameworkElement.Style%2A> property.</span></span> <span data-ttu-id="acdb6-170"><xref:System.Windows.FrameworkElement.Style%2A> 속성은 고유한 것 없습니다 스타일을 적용할에 우선 순위 항목 5-8이 적용 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="acdb6-170">The <xref:System.Windows.FrameworkElement.Style%2A> property is unique in that it cannot itself be styled, so the precedence items 5 through 8 do not apply.</span></span> <span data-ttu-id="acdb6-171">또한 애니메이션이 나 강제 변환 <xref:System.Windows.FrameworkElement.Style%2A> 권장 되지 않습니다 (및 애니메이션 <xref:System.Windows.FrameworkElement.Style%2A> 사용자 지정 애니메이션 클래스 필요).</span><span class="sxs-lookup"><span data-stu-id="acdb6-171">Also, either animating or coercing <xref:System.Windows.FrameworkElement.Style%2A> is not recommended (and animating <xref:System.Windows.FrameworkElement.Style%2A> would require a custom animation class).</span></span> <span data-ttu-id="acdb6-172">하는 방법은 세 가지가 남습니다이 <xref:System.Windows.FrameworkElement.Style%2A> 속성을 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="acdb6-172">This leaves three ways that the <xref:System.Windows.FrameworkElement.Style%2A> property might be set:</span></span>  
  
-   <span data-ttu-id="acdb6-173">**명시적 스타일.**</span><span class="sxs-lookup"><span data-stu-id="acdb6-173">**Explicit style.**</span></span> <span data-ttu-id="acdb6-174"><xref:System.Windows.FrameworkElement.Style%2A> 속성이 직접 설정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="acdb6-174">The <xref:System.Windows.FrameworkElement.Style%2A> property is set directly.</span></span> <span data-ttu-id="acdb6-175">대부분의 시나리오에서 스타일은 인라인으로 정의되지 않고 명시적 키를 통해 리소스로 참조됩니다.</span><span class="sxs-lookup"><span data-stu-id="acdb6-175">In most scenarios, the style is not defined inline, but instead is referenced as a resource, by explicit key.</span></span> <span data-ttu-id="acdb6-176">이 경우는 스타일 속성 자체가 우선 순위 항목 3인 로컬 값처럼 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="acdb6-176">In this case the Style property itself acts as if it were a local value, precedence item 3.</span></span>  
  
-   <span data-ttu-id="acdb6-177">**암시적 스타일.**</span><span class="sxs-lookup"><span data-stu-id="acdb6-177">**Implicit style.**</span></span> <span data-ttu-id="acdb6-178"><xref:System.Windows.FrameworkElement.Style%2A> 속성이 직접 설정 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="acdb6-178">The <xref:System.Windows.FrameworkElement.Style%2A> property is not set directly.</span></span> <span data-ttu-id="acdb6-179">그러나는 <xref:System.Windows.FrameworkElement.Style%2A> 리소스 조회 시퀀스 (페이지, 응용 프로그램)의 일부 수준에서 존재 하 고 스타일을 적용 하는 형식과 일치 하는 리소스 키를 사용 하 여 키로 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="acdb6-179">However, the <xref:System.Windows.FrameworkElement.Style%2A> exists at some level in the resource lookup sequence (page, application) and is keyed using a resource key that matches the type the style is to be applied to.</span></span> <span data-ttu-id="acdb6-180">이 경우에 <xref:System.Windows.FrameworkElement.Style%2A> 속성 자체가 항목 5 시퀀스에서 식별 하는 우선 순위에 따라 작동 합니다.</span><span class="sxs-lookup"><span data-stu-id="acdb6-180">In this case, the <xref:System.Windows.FrameworkElement.Style%2A> property itself acts by a precedence identified in the sequence as item 5.</span></span> <span data-ttu-id="acdb6-181">이 조건을 사용 하 여 검색할 수 있습니다 <xref:System.Windows.DependencyPropertyHelper> 에 대해 합니다 <xref:System.Windows.FrameworkElement.Style%2A> 속성을 찾고 <xref:System.Windows.BaseValueSource.ImplicitStyleReference> 결과에 합니다.</span><span class="sxs-lookup"><span data-stu-id="acdb6-181">This condition can be detected by using <xref:System.Windows.DependencyPropertyHelper> against the <xref:System.Windows.FrameworkElement.Style%2A> property and looking for <xref:System.Windows.BaseValueSource.ImplicitStyleReference> in the results.</span></span>  
  
-   <span data-ttu-id="acdb6-182">**기본 스타일**, 즉 **테마 스타일.**</span><span class="sxs-lookup"><span data-stu-id="acdb6-182">**Default style**, also known as **theme style.**</span></span> <span data-ttu-id="acdb6-183">합니다 <xref:System.Windows.FrameworkElement.Style%2A> 속성을 직접 설정 되지 않으며 사실에 따라 읽기는 `null` 실행된 시간까지 합니다.</span><span class="sxs-lookup"><span data-stu-id="acdb6-183">The <xref:System.Windows.FrameworkElement.Style%2A> property is not set directly, and in fact will read as `null` up until run time.</span></span> <span data-ttu-id="acdb6-184">이 경우 스타일은 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 프레젠테이션 엔진에 포함된 런타임 테마 평가에서 옵니다.</span><span class="sxs-lookup"><span data-stu-id="acdb6-184">In this case, the style comes from the run-time theme evaluation that is part of the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] presentation engine.</span></span>  
  
 <span data-ttu-id="acdb6-185">테마에 없는 암시적 스타일 형식-정확 하 게 일치 해야 합니다는 `MyButton` `Button`-파생된 클래스에 대 한 스타일을 암시적으로 사용 하지 것입니다 `Button`합니다.</span><span class="sxs-lookup"><span data-stu-id="acdb6-185">For implicit styles not in themes, the type must match exactly - a `MyButton` `Button`-derived class will not implicitly use a style for `Button`.</span></span>  
  
<a name="themestyles"></a>   
## <a name="default-theme-styles"></a><span data-ttu-id="acdb6-186">기본(테마) 스타일</span><span class="sxs-lookup"><span data-stu-id="acdb6-186">Default (Theme) Styles</span></span>  
 <span data-ttu-id="acdb6-187">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]와 함께 제공되는 모든 컨트롤에는 기본 스타일이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="acdb6-187">Every control that ships with [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] has a default style.</span></span> <span data-ttu-id="acdb6-188">이러한 기본 스타일은 테마에 따라 달라질 수 있으므로 테마 스타일이라고도 합니다.</span><span class="sxs-lookup"><span data-stu-id="acdb6-188">That default style potentially varies by theme, which is why this default style is sometimes referred to as a theme style.</span></span>  
  
 <span data-ttu-id="acdb6-189">컨트롤 테마 스타일의 setter로 서 존재 하는 컨트롤 템플릿입니다에 대 한 기본 스타일에서 찾을 수 있는 가장 중요 한 정보를 해당 <xref:System.Windows.Controls.Control.Template%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="acdb6-189">The most important information that is found within a default style for a control is its control template, which exists in the theme style as a setter for its <xref:System.Windows.Controls.Control.Template%2A> property.</span></span> <span data-ttu-id="acdb6-190">기본 스타일에 템플릿이 없으면 사용자 지정 스타일에 사용자 지정 템플릿이 포함되어 있지 않은 컨트롤에는 시각적인 모양이 전혀 없습니다.</span><span class="sxs-lookup"><span data-stu-id="acdb6-190">If there were no template from default styles, a control without a custom template as part of a custom style would have no visual appearance at all.</span></span> <span data-ttu-id="acdb6-191">기본 스타일의 템플릿은 각 컨트롤의 시각적인 모양에 기본적인 구조를 정해 주며 템플릿에 정의된 속성과 해당 컨트롤 클래스 사이의 연결을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="acdb6-191">The template from the default style gives the visual appearance of each control a basic structure, and also defines the connections between properties defined in the visual tree of the template and the corresponding control class.</span></span> <span data-ttu-id="acdb6-192">각 컨트롤은 템플릿을 완전히 교체하지 않고 컨트롤의 시각적인 모양에 영향을 줄 수 있는 속성의 집합을 노출합니다.</span><span class="sxs-lookup"><span data-stu-id="acdb6-192">Each control exposes a set of properties that can influence the visual appearance of the control without completely replacing the template.</span></span> <span data-ttu-id="acdb6-193">예를 들어의 기본 시각적 모양을 <xref:System.Windows.Controls.Primitives.Thumb> 요소인 컨트롤의는 <xref:System.Windows.Controls.Primitives.ScrollBar>합니다.</span><span class="sxs-lookup"><span data-stu-id="acdb6-193">For example, consider the default visual appearance of a <xref:System.Windows.Controls.Primitives.Thumb> control, which is a component of a <xref:System.Windows.Controls.Primitives.ScrollBar>.</span></span>  
  
 <span data-ttu-id="acdb6-194"><xref:System.Windows.Controls.Primitives.Thumb> 에 특정 사용자 지정 가능 속성이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="acdb6-194">A <xref:System.Windows.Controls.Primitives.Thumb> has certain customizable properties.</span></span> <span data-ttu-id="acdb6-195">기본 서식 파일을 <xref:System.Windows.Controls.Primitives.Thumb> 기본 구조를 만듭니다 여러 시각적 트리 중첩 / <xref:System.Windows.Controls.Border> 3d 효과 만들려면 구성 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="acdb6-195">The default template of a <xref:System.Windows.Controls.Primitives.Thumb> creates a basic structure / visual tree with several nested <xref:System.Windows.Controls.Border> components to create a bevel look.</span></span> <span data-ttu-id="acdb6-196">템플릿의 일부인 속성을 노출 하 여 사용자 지정 하려는 경우는 <xref:System.Windows.Controls.Primitives.Thumb> 속성으로 노출 해야 하는 다음 클래스는 [TemplateBinding](../../../../docs/framework/wpf/advanced/templatebinding-markup-extension.md), 템플릿 내에서.</span><span class="sxs-lookup"><span data-stu-id="acdb6-196">If a property that is part of the template is intended to be exposed for customization by the <xref:System.Windows.Controls.Primitives.Thumb> class, then that property must be exposed by a [TemplateBinding](../../../../docs/framework/wpf/advanced/templatebinding-markup-extension.md), within the template.</span></span> <span data-ttu-id="acdb6-197">경우 <xref:System.Windows.Controls.Primitives.Thumb>, 이러한 테두리의 다양 한 속성이 속성에 대 한 템플릿 바인딩을 같은 공유 <xref:System.Windows.Controls.Border.Background%2A> 또는 <xref:System.Windows.Controls.Border.BorderThickness%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="acdb6-197">In the case of <xref:System.Windows.Controls.Primitives.Thumb>, various properties of these borders share a template binding to properties such as <xref:System.Windows.Controls.Border.Background%2A> or <xref:System.Windows.Controls.Border.BorderThickness%2A>.</span></span> <span data-ttu-id="acdb6-198">하지만 다른 특정 속성 또는 시각적 배치는 컨트롤 템플릿에 하드 코딩되거나 테마에서 직접 제공되는 값에 바인딩되어 템플릿 전체를 바꾸지 않는 한은 변경할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="acdb6-198">But certain other properties or visual arrangements are hard-coded into the control template or are bound to values that come directly from the theme, and cannot be changed short of replacing the entire template.</span></span> <span data-ttu-id="acdb6-199">일반적으로, 속성이 템플릿 상위에서 오며 템플릿 바인딩을 통해 노출되지 않는 경우는, 쉽게 대상으로 지정할 방법이 없기 때문에 스타일을 통해 조정할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="acdb6-199">Generally, if a property comes from a templated parent and is not exposed by a template binding, it cannot be adjusted by styles because there is no easy way to target it.</span></span> <span data-ttu-id="acdb6-200">그러나 그 속성도 적용된 템플릿에서 상속된 속성 값이나 기본값의 영향을 받을 수는 있습니다.</span><span class="sxs-lookup"><span data-stu-id="acdb6-200">But that property could still be influenced by property value inheritance in the applied template, or by default value.</span></span>  
  
 <span data-ttu-id="acdb6-201">테마 스타일에서는 유형을 정의에서 키로 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="acdb6-201">The theme styles use a type as the key in their definitions.</span></span> <span data-ttu-id="acdb6-202">그러나 특정된 요소 인스턴스에 테마 적용 되 면이 형식에 대 한 테마 조회 수행 됩니다 확인 하 여는 <xref:System.Windows.FrameworkElement.DefaultStyleKey%2A> 컨트롤의 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="acdb6-202">However, when themes are applied to a given element instance, themes lookup for this type is performed by checking the <xref:System.Windows.FrameworkElement.DefaultStyleKey%2A> property on a control.</span></span> <span data-ttu-id="acdb6-203">암시적 스타일과 같이 리터럴 Type을 사용하는 방법과는 대조적입니다.</span><span class="sxs-lookup"><span data-stu-id="acdb6-203">This is in contrast to using the literal Type, as implicit styles do.</span></span> <span data-ttu-id="acdb6-204">변수의 <xref:System.Windows.FrameworkElement.DefaultStyleKey%2A> 구현자 (속성을 변경 하는 방법은 않습니다 재정의 하지만 속성 수준에서 대신 기본 메타 데이터 속성 값 변경)이 변경 되지 않은 경우에 파생된 클래스에 상속 됩니다.</span><span class="sxs-lookup"><span data-stu-id="acdb6-204">The value of <xref:System.Windows.FrameworkElement.DefaultStyleKey%2A> would inherit to derived classes even if the implementer did not change it (the intended way of changing the property is not to override it at the property level, but to instead change its default value in property metadata).</span></span> <span data-ttu-id="acdb6-205">이 간접 참조를 사용하면 기본 클래스에서 원래는 스타일이 없었을(그 스타일에 템플릿이 없어 기본적인 시각적 모양이 전혀 없었을) 파생 요소의 테마 스타일을 정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="acdb6-205">This indirection enables base classes to define the theme styles for derived elements that do not otherwise have a style (or more importantly, do not have a template within that style and would thus have no default visual appearance at all).</span></span> <span data-ttu-id="acdb6-206">따라서 파생 시킬 수 있습니다 `MyButton` 에서 <xref:System.Windows.Controls.Button> 했는데도 됩니다는 <xref:System.Windows.Controls.Button> 기본 템플릿을.</span><span class="sxs-lookup"><span data-stu-id="acdb6-206">Thus, you can derive `MyButton` from <xref:System.Windows.Controls.Button> and will still get the <xref:System.Windows.Controls.Button> default template.</span></span> <span data-ttu-id="acdb6-207">컨트롤 작성자의 경우 `MyButton` 하려는 경우 다른 동작을 종속성 속성 메타 데이터를 재정의할 수 있습니다 <xref:System.Windows.FrameworkElement.DefaultStyleKey%2A> 에서 `MyButton` 다른 키를 반환 하 고 다음 템플릿이 포함 된 관련 테마 스타일을 정의 하려면 에 대 한 `MyButton` 사용 하 여 패키지 해야 하는 프로그램 `MyButton` 제어 합니다.</span><span class="sxs-lookup"><span data-stu-id="acdb6-207">If you were the control author of `MyButton` and you wanted a different behavior, you could override the dependency property metadata for <xref:System.Windows.FrameworkElement.DefaultStyleKey%2A> on `MyButton` to return a different key, and then define the relevant theme styles including template for `MyButton` that you must package with your `MyButton` control.</span></span> <span data-ttu-id="acdb6-208">테마, 스타일 및 컨트롤 작성에 대한 자세한 내용은 [컨트롤 제작 개요](../../../../docs/framework/wpf/controls/control-authoring-overview.md)를 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="acdb6-208">For more details on themes, styles, and control authoring, see [Control Authoring Overview](../../../../docs/framework/wpf/controls/control-authoring-overview.md).</span></span>  
  
<a name="resources"></a>   
## <a name="dynamic-resource-references-and-binding"></a><span data-ttu-id="acdb6-209">동적 리소스 참조 및 바인딩</span><span class="sxs-lookup"><span data-stu-id="acdb6-209">Dynamic Resource References and Binding</span></span>  
 <span data-ttu-id="acdb6-210">동적 리소스 참조 및 바인딩 작업에서는 설정된 위치의 우선 순위를 따릅니다.</span><span class="sxs-lookup"><span data-stu-id="acdb6-210">Dynamic resource references and binding operations respect the precedence of the location at which they are set.</span></span> <span data-ttu-id="acdb6-211">예를 들어 로컬 값에 적용한 동적 리소스는 우선 순위 항목 3에 따라 작동하고, 테마 스타일에 있는 속성 setter의 바인딩은 우선 순위 항목 9에 따라 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="acdb6-211">For example, a dynamic resource applied to a local value acts per precedence item 3, a binding for a property setter within a theme style applies at precedence item 9, and so on.</span></span> <span data-ttu-id="acdb6-212">동적 리소스 참조 및 바인딩은 모두 응용 프로그램의 런타임 상태에서 값을 얻을 수 있어야 하므로 특정 속성의 속성 값 우선 순위를 결정하는 실제 프로세스가 런타임으로도 확장됩니다.</span><span class="sxs-lookup"><span data-stu-id="acdb6-212">Because dynamic resource references and binding must both be able to obtain values from the run time state of the application, this entails that the actual process of determining the property value precedence for any given property extends into the run time as well.</span></span>  
  
 <span data-ttu-id="acdb6-213">동적 리소스 참조는 엄밀하게 말해 속성 시스템에 포함되지 않지만, 위에 나열된 시퀀스와 상호 작용하는 자체 조회 순서가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="acdb6-213">Dynamic resource references are not strictly speaking part of the property system, but they do have a lookup order of their own which interacts with the sequence listed above.</span></span> <span data-ttu-id="acdb6-214">그 우선 순위에 관한 내용은 [XAML 리소스](../../../../docs/framework/wpf/advanced/xaml-resources.md)에 자세히 나와 있습니다.</span><span class="sxs-lookup"><span data-stu-id="acdb6-214">That precedence is documented more thoroughly in the [XAML Resources](../../../../docs/framework/wpf/advanced/xaml-resources.md).</span></span> <span data-ttu-id="acdb6-215">기본적인 우선 순위를 요약해 보면 요소에서 페이지 루트, 응용 프로그램, 테마, 시스템 순입니다.</span><span class="sxs-lookup"><span data-stu-id="acdb6-215">The basic summation of that precedence is: element to page root, application, theme, system.</span></span>  
  
 <span data-ttu-id="acdb6-216">동적 리소스 및 바인딩은 설정 위치의 우선 순위를 따르지만, 값은 지연됩니다.</span><span class="sxs-lookup"><span data-stu-id="acdb6-216">Dynamic resources and bindings have the precedence of where they were set, but the value is deferred.</span></span> <span data-ttu-id="acdb6-217">그 때문에 생기는 결과 중 하나는 동적 리소스나 바인딩을 로컬 값에 설정하라 경우 로컬 값의 변화가 동적 리소스나 바인딩을 완전히 대체한다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="acdb6-217">One consequence of this is that if you set a dynamic resource or binding to a local value, any change to the local value replaces the dynamic resource or binding entirely.</span></span> <span data-ttu-id="acdb6-218">호출 하는 경우에는 <xref:System.Windows.DependencyObject.ClearValue%2A> 로컬에서 설정의 선택을 취소 하는 방법 값, 동적 리소스나 바인딩이 복원 되지 것입니다.</span><span class="sxs-lookup"><span data-stu-id="acdb6-218">Even if you call the <xref:System.Windows.DependencyObject.ClearValue%2A> method to clear the locally set value, the dynamic resource or binding will not be restored.</span></span> <span data-ttu-id="acdb6-219">사실 호출 하는 경우 <xref:System.Windows.DependencyObject.ClearValue%2A> 에서 삭제 됩니다 (리터럴 로컬 값 없음)를에서 동적 리소스나 바인딩이 있는 속성을 <xref:System.Windows.DependencyObject.ClearValue%2A> 너무 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="acdb6-219">In fact, if you call <xref:System.Windows.DependencyObject.ClearValue%2A> on a property that has a dynamic resource or binding in place (with no literal local value), they are cleared by the <xref:System.Windows.DependencyObject.ClearValue%2A> call too.</span></span>  
  
<a name="setcurrentvalue"></a>   
## <a name="setcurrentvalue"></a><span data-ttu-id="acdb6-220">SetCurrentValue</span><span class="sxs-lookup"><span data-stu-id="acdb6-220">SetCurrentValue</span></span>  
 <span data-ttu-id="acdb6-221"><xref:System.Windows.DependencyObject.SetCurrentValue%2A> 메서드는 속성을 설정 하는 또 다른 방법은 하지만 우선 순위 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="acdb6-221">The <xref:System.Windows.DependencyObject.SetCurrentValue%2A> method is another way to set a property, but it is not in the order of precedence.</span></span> <span data-ttu-id="acdb6-222">대신 <xref:System.Windows.DependencyObject.SetCurrentValue%2A> 이전 값의 소스를 덮어쓰지 않고 속성 값을 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="acdb6-222">Instead, <xref:System.Windows.DependencyObject.SetCurrentValue%2A> enables you to change the value of a property without overwriting the source of a previous value.</span></span> <span data-ttu-id="acdb6-223">사용할 수 있습니다 <xref:System.Windows.DependencyObject.SetCurrentValue%2A> 언제 든 지 로컬 값의 우선 순위 값을 제공 하지 않고 값을 설정 하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="acdb6-223">You can use <xref:System.Windows.DependencyObject.SetCurrentValue%2A> any time that you want to set a value without giving that value the precedence of a local value.</span></span> <span data-ttu-id="acdb6-224">예를 들어, 속성 트리거에 의해 설정 되며 다음을 통해 다른 값을 할당 하는 경우 <xref:System.Windows.DependencyObject.SetCurrentValue%2A>, 속성 시스템을 계속 유지 하므로 트리거 및 작업이 발생 하는 경우 속성이 변경 됩니다.</span><span class="sxs-lookup"><span data-stu-id="acdb6-224">For example, if a property is set by a trigger and then assigned another value via <xref:System.Windows.DependencyObject.SetCurrentValue%2A>, the property system still respects the trigger and the property will change if the trigger’s action occurs.</span></span> <span data-ttu-id="acdb6-225"><xref:System.Windows.DependencyObject.SetCurrentValue%2A> 우선 순위가 높은 소스를 지정 하지 않고 속성 값을 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="acdb6-225"><xref:System.Windows.DependencyObject.SetCurrentValue%2A> enables you to change the property’s value without giving it a source with a higher precedence.</span></span> <span data-ttu-id="acdb6-226">마찬가지로, 사용할 수 있습니다 <xref:System.Windows.DependencyObject.SetCurrentValue%2A> 바인딩을 덮어쓰지 않고 속성 값을 변경 합니다.</span><span class="sxs-lookup"><span data-stu-id="acdb6-226">Likewise, you can use <xref:System.Windows.DependencyObject.SetCurrentValue%2A> to change the value of a property without overwriting a binding.</span></span>  
  
<a name="animations"></a>   
## <a name="coercion-animations-and-base-value"></a><span data-ttu-id="acdb6-227">강제 변환, 애니메이션 및 기준 값</span><span class="sxs-lookup"><span data-stu-id="acdb6-227">Coercion, Animations, and Base Value</span></span>  
 <span data-ttu-id="acdb6-228">강제 변환 및 애니메이션은 모두 이 [!INCLUDE[TLA2#tla_sdk](../../../../includes/tla2sharptla-sdk-md.md)] 전체에서 "기준 값"이라고 부르는 값에 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="acdb6-228">Coercion and animation both act on a value that is termed as the "base value" throughout this [!INCLUDE[TLA2#tla_sdk](../../../../includes/tla2sharptla-sdk-md.md)].</span></span> <span data-ttu-id="acdb6-229">따라서 기준 값은 항목 2에 도달할 때까지 위쪽으로 평가하여 결정된 값입니다.</span><span class="sxs-lookup"><span data-stu-id="acdb6-229">The base value is thus whatever value is determined through evaluating upwards in the items until item 2 is reached.</span></span>  
  
 <span data-ttu-id="acdb6-230">애니메이션의 경우, 그 애니메이션이 특정 동작의 "From" 및 "To"를 모두 지정하지 않거나 애니메이션이 완료되었을 때 기준 값으로 돌아가도록 되어 있는 경우는 애니메이션된 값에서 기준 값의 효과를 적용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="acdb6-230">For an animation, the base value can have an effect on the animated value, if that animation does not specify both "From" and "To" for certain behaviors, or if the animation deliberately reverts to the base value when completed.</span></span> <span data-ttu-id="acdb6-231">이 작동을 실제로 확인하려면 [From, To 및 By 애니메이션 대상 값 샘플](https://go.microsoft.com/fwlink/?LinkID=159988)을 실행하십시오.</span><span class="sxs-lookup"><span data-stu-id="acdb6-231">To see this in practice, run the [From, To, and By Animation Target Values Sample](https://go.microsoft.com/fwlink/?LinkID=159988).</span></span> <span data-ttu-id="acdb6-232">예에서 직사각형 높이의 로컬 값을 초기 로컬 값이 애니메이션에 있는 "From" 값과 달라지도록 설정해 보십시오.</span><span class="sxs-lookup"><span data-stu-id="acdb6-232">Try setting the local values of the rectangle height in the example, such that the initial local value differs from any "From" in the animation.</span></span> <span data-ttu-id="acdb6-233">애니메이션은 "From" 값을 사용하여 시작하며, 시작된 후에는 기준 값을 대체합니다.</span><span class="sxs-lookup"><span data-stu-id="acdb6-233">You will note that the animations start right away using the "From" values and replace the base value once started.</span></span> <span data-ttu-id="acdb6-234">반환 값에 애니메이션 전의 Stop을 지정 하 여 완료 되 면 애니메이션을 지정할 수도 있습니다 <xref:System.Windows.Media.Animation.FillBehavior>합니다.</span><span class="sxs-lookup"><span data-stu-id="acdb6-234">The animation might specify to return to the value found before animation once it is completed by specifying the Stop <xref:System.Windows.Media.Animation.FillBehavior>.</span></span> <span data-ttu-id="acdb6-235">그 후에는 일반적인 우선 순위를 사용하여 기준 값을 결정합니다.</span><span class="sxs-lookup"><span data-stu-id="acdb6-235">Afterwards, normal precedence is used for the base value determination.</span></span>  
  
 <span data-ttu-id="acdb6-236">여러 애니메이션을 단일 속성에 적용할 수 있으며, 이러한 애니메이션 각각은 값 우선 순위의 여러 지점에서 정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="acdb6-236">Multiple animations might be applied to a single property, with each of these animations possibly having been defined from different points in the value precedence.</span></span> <span data-ttu-id="acdb6-237">그러나 이러한 애니메이션을 사용하면 높은 우선 순위의 애니메이션이 그냥 적용되지 않고 값이 복합될 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="acdb6-237">However, these animations will potentially composite their values, rather than just applying the animation from the higher precedence.</span></span> <span data-ttu-id="acdb6-238">결과는 애니메이션을 정의하는 정확한 방식과 애니메이션되는 값의 유형에 따라 달라집니다.</span><span class="sxs-lookup"><span data-stu-id="acdb6-238">This depends on exactly how the animations are defined, and the type of the value that is being animated.</span></span> <span data-ttu-id="acdb6-239">속성 애니메이션에 대한 자세한 내용은 [애니메이션 개요](../../../../docs/framework/wpf/graphics-multimedia/animation-overview.md)를 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="acdb6-239">For more information about animating properties, see [Animation Overview](../../../../docs/framework/wpf/graphics-multimedia/animation-overview.md).</span></span>  
  
 <span data-ttu-id="acdb6-240">강제 변환이 가장 높은 수준에서 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="acdb6-240">Coercion applies at the highest level of all.</span></span> <span data-ttu-id="acdb6-241">이미 실행 중인 애니메이션도 값을 강제 변환할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="acdb6-241">Even an already running animation is subject to value coercion.</span></span> <span data-ttu-id="acdb6-242">어떤 기존 종속성 속성은 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]에 기본 제공 강제 변환이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="acdb6-242">Certain existing dependency properties in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] have built-in coercion.</span></span> <span data-ttu-id="acdb6-243">사용자 지정 종속성 속성에 대해 작성 하 여 사용자 지정 종속성 속성의 강제 변환 동작을 정의 <xref:System.Windows.CoerceValueCallback> 속성을 만들 때 메타 데이터의 일부로 콜백을 전달 합니다.</span><span class="sxs-lookup"><span data-stu-id="acdb6-243">For a custom dependency property, you define the coercion behavior for a custom dependency property by writing a <xref:System.Windows.CoerceValueCallback> and passing the callback as part of metadata when you create the property.</span></span> <span data-ttu-id="acdb6-244">파생 클래스에서 해당 속성의 메타데이터를 재정의하여 기존 속성의 강제 변환 동작을 재정의할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="acdb6-244">You can also override coercion behavior of existing properties by overriding the metadata on that property in a derived class.</span></span> <span data-ttu-id="acdb6-245">적용 시점에 존재하는 강제 변환의 제약 조건을 따르면서 기준 값은 유지하는 방식으로 강제 변환과 기준 값이 상호 작용합니다.</span><span class="sxs-lookup"><span data-stu-id="acdb6-245">Coercion interacts with the base value in such a way that the constraints on coercion are applied as those constraints exist at the time, but the base value is still retained.</span></span> <span data-ttu-id="acdb6-246">따라서 나중에 강제 변환의 제약 조건이 제거되면 강제 변환에서 가능한 가장 가까운 값을 기준 값으로 반환하며, 그러면 모든 제약 조건이 제거되는 즉시 속성에 미치는 강제 변환의 영향이 사라집니다.</span><span class="sxs-lookup"><span data-stu-id="acdb6-246">Therefore, if constraints in coercion are later lifted, the coercion will return the closest value possible to that base value, and potentially the coercion influence on a property will cease as soon as all constraints are lifted.</span></span> <span data-ttu-id="acdb6-247">강제 변환 동작에 대한 자세한 내용은 [종속성 속성 콜백 및 유효성 검사](../../../../docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md)를 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="acdb6-247">For more information about coercion behavior, see [Dependency Property Callbacks and Validation](../../../../docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md).</span></span>  
  
<a name="triggers"></a>   
## <a name="trigger-behaviors"></a><span data-ttu-id="acdb6-248">트리거 동작</span><span class="sxs-lookup"><span data-stu-id="acdb6-248">Trigger Behaviors</span></span>  
 <span data-ttu-id="acdb6-249">컨트롤에서 테마에 있는 기본 스타일의 일부로서 트리거 동작을 정의하는 경우가 많습니다.</span><span class="sxs-lookup"><span data-stu-id="acdb6-249">Controls often define trigger behaviors as part of their default style in themes.</span></span> <span data-ttu-id="acdb6-250">컨트롤에 로컬 속성을 설정하면 트리거가 시각적으로 또는 동작을 통해 사용자 기반 이벤트에 응답하지 못할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="acdb6-250">Setting local properties on controls might prevent the triggers from being able to respond to user-driven events either visually or behaviorally.</span></span> <span data-ttu-id="acdb6-251">와 같은 상태 속성이 나 컨트롤에 대 한 속성 트리거가 가장 일반적으로 사용 됩니다 <xref:System.Windows.Controls.Primitives.Selector.IsSelected%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="acdb6-251">The most common use of a property trigger is for control or state properties such as <xref:System.Windows.Controls.Primitives.Selector.IsSelected%2A>.</span></span> <span data-ttu-id="acdb6-252">기본적으로 예를 들어 경우는 <xref:System.Windows.Controls.Button> 을 사용할 수 없습니다 (트리거 <xref:System.Windows.UIElement.IsEnabled%2A> 는 `false`)는 <xref:System.Windows.Controls.Control.Foreground%2A> 테마 스타일의 값은 컨트롤이 "회색" 표시 되도록 한 원인을.</span><span class="sxs-lookup"><span data-stu-id="acdb6-252">For example, by default when a <xref:System.Windows.Controls.Button> is disabled (trigger for <xref:System.Windows.UIElement.IsEnabled%2A> is `false`) then the <xref:System.Windows.Controls.Control.Foreground%2A> value in the theme style is what causes the control to appear "grayed out".</span></span> <span data-ttu-id="acdb6-253">그러나 로컬을 사용 하도록 설정한 경우 <xref:System.Windows.Controls.Control.Foreground%2A> 값에 로컬 속성 집합에이 속성 트리거 시나리오 에서도 일반적인 회색 색 우선 순위에서 수정할 수는 있습니다.</span><span class="sxs-lookup"><span data-stu-id="acdb6-253">But if you have set a local <xref:System.Windows.Controls.Control.Foreground%2A> value, that normal gray-out color will be overruled in precedence by your local property set, even in this property-triggered scenario.</span></span> <span data-ttu-id="acdb6-254">테마 수준 트리거 동작이 있는 속성의 값을 설정할 때 주의해야 하며, 해당 컨트롤의 사용자 경험을 과도하게 방해하지 않도록 주의해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="acdb6-254">Be cautious of setting values for properties that have theme-level trigger behaviors and make sure you are not unduly interfering with the intended user experience for that control.</span></span>  
  
<a name="clearvalue"></a>   
## <a name="clearvalue-and-value-precedence"></a><span data-ttu-id="acdb6-255">ClearValue 및 값 우선 순위</span><span class="sxs-lookup"><span data-stu-id="acdb6-255">ClearValue and Value Precedence</span></span>  
 <span data-ttu-id="acdb6-256"><xref:System.Windows.DependencyObject.ClearValue%2A> 메서드를 손쉽게 요소에 설정 된 종속성 속성에서 로컬로 적용 된 모든 값의 선택을 취소 합니다.</span><span class="sxs-lookup"><span data-stu-id="acdb6-256">The <xref:System.Windows.DependencyObject.ClearValue%2A> method provides an expedient means to clear any locally applied value from a dependency property that is set on an element.</span></span> <span data-ttu-id="acdb6-257">그러나 호출 <xref:System.Windows.DependencyObject.ClearValue%2A> 속성을 등록할 때 메타 데이터에서 설정 된 기본값이 새 유효 값을 인지를 보장 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="acdb6-257">However, calling <xref:System.Windows.DependencyObject.ClearValue%2A> is not a guarantee that the default as established in metadata during property registration is the new effective value.</span></span> <span data-ttu-id="acdb6-258">값의 우선 순위에 있는 다른 항목도 모두 여전히 활성 상태입니다.</span><span class="sxs-lookup"><span data-stu-id="acdb6-258">All of the other participants in value precedence are still active.</span></span> <span data-ttu-id="acdb6-259">로컬에서 설정된 값만 우선 순위 시퀀스에서 제거되었습니다.</span><span class="sxs-lookup"><span data-stu-id="acdb6-259">Only the locally set value has been removed from the precedence sequence.</span></span> <span data-ttu-id="acdb6-260">예를 들어, 호출 하는 경우 <xref:System.Windows.DependencyObject.ClearValue%2A> 속성 여기서도 테마 스타일을 사용 하 여 해당 속성이 설정 되어 다음 메타 데이터 기반 기본값이 아니라 새 값으로 테마 값이 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="acdb6-260">For example, if you call <xref:System.Windows.DependencyObject.ClearValue%2A> on a property where that property is also set by a theme style, then the theme value is applied as the new value rather than the metadata-based default.</span></span> <span data-ttu-id="acdb6-261">프로세스에서 모든 속성 값 참가자를 사용 하 고 등록 된 메타 데이터 기본값으로 값을 설정 하려는 경우 명확 하 게 쿼리하여 종속성 속성 메타 데이터 및 다음 기본값 로컬로 기본 값을 사용할 수는 얻을 수 있습니다. 속성에 대 한 호출을 설정 <xref:System.Windows.DependencyObject.SetValue%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="acdb6-261">If you want to take all property value participants out of the process and set the value to the registered metadata default, you can obtain that default value definitively by querying the dependency property metadata, and then you can use the default value to locally set the property with a call to <xref:System.Windows.DependencyObject.SetValue%2A>.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="acdb6-262">참고 항목</span><span class="sxs-lookup"><span data-stu-id="acdb6-262">See Also</span></span>  
 <xref:System.Windows.DependencyObject>  
 <xref:System.Windows.DependencyProperty>  
 [<span data-ttu-id="acdb6-263">종속성 속성 개요</span><span class="sxs-lookup"><span data-stu-id="acdb6-263">Dependency Properties Overview</span></span>](../../../../docs/framework/wpf/advanced/dependency-properties-overview.md)  
 [<span data-ttu-id="acdb6-264">사용자 지정 종속성 속성</span><span class="sxs-lookup"><span data-stu-id="acdb6-264">Custom Dependency Properties</span></span>](../../../../docs/framework/wpf/advanced/custom-dependency-properties.md)  
 [<span data-ttu-id="acdb6-265">종속성 속성 콜백 및 유효성 검사</span><span class="sxs-lookup"><span data-stu-id="acdb6-265">Dependency Property Callbacks and Validation</span></span>](../../../../docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md)

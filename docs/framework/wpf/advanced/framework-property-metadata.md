---
title: 프레임워크 속성 메타데이터
ms.date: 03/30/2017
helpviewer_keywords:
- metadata [WPF], framework properties
- framework property metadata [WPF]
ms.assetid: 9962f380-b885-4b61-a62e-457397083fea
ms.openlocfilehash: f313c17a278a7b51379c4da9389c01eedf4a1e62
ms.sourcegitcommit: 0c48191d6d641ce88d7510e319cf38c0e35697d0
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/05/2019
ms.locfileid: "57379278"
---
# <a name="framework-property-metadata"></a><span data-ttu-id="ce5ec-102">프레임워크 속성 메타데이터</span><span class="sxs-lookup"><span data-stu-id="ce5ec-102">Framework Property Metadata</span></span>
<span data-ttu-id="ce5ec-103">프레임워크 속성 메타데이터는 [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] 아키텍처의 WPF 프레임워크 수준에 있는 것으로 간주되는 개체 요소의 속성용으로 보고됩니다.</span><span class="sxs-lookup"><span data-stu-id="ce5ec-103">Framework property metadata options are reported for the properties of object elements considered to be at the WPF framework level in the [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] architecture.</span></span> <span data-ttu-id="ce5ec-104">일반적으로 WPF 프레임워크 수준 지정에서는 렌더링, 데이터 바인딩 및 속성 시스템 미세 조정과 같은 기능이 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 프레젠테이션 [!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)] 및 실행 파일을 통해 처리됩니다.</span><span class="sxs-lookup"><span data-stu-id="ce5ec-104">In general the WPF framework-level designation entails that features such as rendering, data binding, and property system refinements are handled by the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] presentation [!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)] and executables.</span></span> <span data-ttu-id="ce5ec-105">이러한 시스템에서 프레임워크 속성 메타데이터를 쿼리하여 특정 요소 속성의 기능별 특성을 결정합니다.</span><span class="sxs-lookup"><span data-stu-id="ce5ec-105">Framework property metadata is queried by these systems to determine feature-specific characteristics of particular element properties.</span></span>  
  
 
  
<a name="prerequisites"></a>   
## <a name="prerequisites"></a><span data-ttu-id="ce5ec-106">필수 구성 요소</span><span class="sxs-lookup"><span data-stu-id="ce5ec-106">Prerequisites</span></span>  
 <span data-ttu-id="ce5ec-107">이 항목에서는 [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] 클래스에서 기존 종속성 속성의 소비자 관점에서 종속성 속성을 이해하고 [종속성 속성 개요](dependency-properties-overview.md)를 읽었다고 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="ce5ec-107">This topic assumes that you understand dependency properties from the perspective of a consumer of existing dependency properties on [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] classes, and have read the [Dependency Properties Overview](dependency-properties-overview.md).</span></span> <span data-ttu-id="ce5ec-108">[종속성 속성 메타데이터](dependency-property-metadata.md)도 읽어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ce5ec-108">You should also have read [Dependency Property Metadata](dependency-property-metadata.md).</span></span>  
  
<a name="What_Is_Communicated_by_Framework_Property"></a>   
## <a name="what-is-communicated-by-framework-property-metadata"></a><span data-ttu-id="ce5ec-109">프레임워크 속성 메타데이터로 통신하는 내용</span><span class="sxs-lookup"><span data-stu-id="ce5ec-109">What Is Communicated by Framework Property Metadata</span></span>  
 <span data-ttu-id="ce5ec-110">프레임워크 속성 메타데이터는 다음 범주로 구분할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ce5ec-110">Framework property metadata can be divided into the following categories:</span></span>  
  
-   <span data-ttu-id="ce5ec-111">요소에 영향을 미치는 레이아웃 속성 보고 (<xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A>하십시오 <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>).</span><span class="sxs-lookup"><span data-stu-id="ce5ec-111">Reporting layout properties that affect an element (<xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>).</span></span> <span data-ttu-id="ce5ec-112">속성에 해당 측면에 영향을 구현 하는 경우 메타 데이터에서 이러한 플래그를 설정할 수는 <xref:System.Windows.FrameworkElement.MeasureOverride%2A>  /  <xref:System.Windows.FrameworkElement.ArrangeOverride%2A> 특정 렌더링 동작 및 레이아웃 정보를 제공 하기 위해 클래스에서 메서드 시스템입니다.</span><span class="sxs-lookup"><span data-stu-id="ce5ec-112">You might set these flags in metadata if the property affects those respective aspects, and you are also implementing the <xref:System.Windows.FrameworkElement.MeasureOverride%2A> / <xref:System.Windows.FrameworkElement.ArrangeOverride%2A> methods in your class to supply specific rendering behavior and information to the layout system.</span></span> <span data-ttu-id="ce5ec-113">일반적으로 이러한 구현에서는 해당 레이아웃 속성이 속성 메타데이터에서 참인 종속성 속성의 속성 무효화를 확인하고 해당 무효화만 새로운 레이아웃 전달을 요청해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ce5ec-113">Typically, such an implementation would check for property invalidations in dependency properties where any of these layout properties were true in the property metadata, and only those invalidations would necessitate requesting a new layout pass.</span></span>  
  
-   <span data-ttu-id="ce5ec-114">요소의 부모 요소에 영향을 미치는 레이아웃 속성 보고 (<xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A>).</span><span class="sxs-lookup"><span data-stu-id="ce5ec-114">Reporting layout properties that affect the parent element of an element (<xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A>).</span></span> <span data-ttu-id="ce5ec-115">기본적으로 이러한 플래그가 설정 되어 있는 몇 가지 예는 <xref:System.Windows.Documents.FixedPage.Left%2A?displayProperty=nameWithType> 고 <xref:System.Windows.Documents.Paragraph.KeepWithNext%2A?displayProperty=nameWithType>입니다.</span><span class="sxs-lookup"><span data-stu-id="ce5ec-115">Some examples where these flags are set by default are <xref:System.Windows.Documents.FixedPage.Left%2A?displayProperty=nameWithType> and <xref:System.Windows.Documents.Paragraph.KeepWithNext%2A?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="ce5ec-116"><xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>.</span><span class="sxs-lookup"><span data-stu-id="ce5ec-116"><xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>.</span></span> <span data-ttu-id="ce5ec-117">기본적으로 종속성 속성은 값을 상속하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ce5ec-117">By default, dependency properties do not inherit values.</span></span> <span data-ttu-id="ce5ec-118"><xref:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior%2A> 또한 컨트롤 합성 시나리오에 필요한 시각적 트리로 이동 하는 상속 경로 허용 합니다.</span><span class="sxs-lookup"><span data-stu-id="ce5ec-118"><xref:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior%2A> allows the pathway of inheritance to also travel into a visual tree, which is necessary for some control compositing scenarios.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="ce5ec-119">속성 값 컨텍스트에서 “상속”이라는 용어는 종속성 속성에 특정한 것입니다. 즉, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 속성 시스템의 WPF 프레임워크 수준 기능때문에 자식 요소가 부모 요소에서 실제 종속성 속성 값을 상속할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ce5ec-119">The term "inherits" in the context of property values means something specific for dependency properties; it means that child elements can inherit the actual dependency property value from parent elements because of a WPF framework-level capability of the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] property system.</span></span> <span data-ttu-id="ce5ec-120">파생된 유형을 통한 멤버 상속 및 관리된 코드 유형과는 직접적인 관련이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ce5ec-120">It has nothing to do directly with managed code type and members inheritance through derived types.</span></span> <span data-ttu-id="ce5ec-121">자세한 내용은 [속성 값 상속](property-value-inheritance.md)을 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="ce5ec-121">For details, see [Property Value Inheritance](property-value-inheritance.md).</span></span>  
  
-   <span data-ttu-id="ce5ec-122">보고 데이터 바인딩 특성 (<xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>, <xref:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault%2A>).</span><span class="sxs-lookup"><span data-stu-id="ce5ec-122">Reporting data binding characteristics (<xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>, <xref:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault%2A>).</span></span> <span data-ttu-id="ce5ec-123">기본적으로 프레임워크의 종속성 속성은 단방향 바인딩 동작을 통한 데이터 바인딩을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="ce5ec-123">By default, dependency properties in the framework support data binding, with a one-way binding behavior.</span></span> <span data-ttu-id="ce5ec-124">시나리오가 전혀 없는 경우 데이터 바인딩을 사용하지 않게 설정할 수 있습니다(유연하고 확장 가능해야 하므로 기본 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] [!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)]에는 이러한 속성의 예가 많지 않음).</span><span class="sxs-lookup"><span data-stu-id="ce5ec-124">You might disable data binding if there were no scenario for it whatsoever (because they are intended to be flexible and extensible, there aren't many examples of such properties in the default [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] [!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)]).</span></span> <span data-ttu-id="ce5ec-125">바인딩의 구성 요소 간에 컨트롤의 동작을 함께 연결 하는 속성에 대 한 양방향 기본값을 설정할 수 있습니다 (<xref:System.Windows.Controls.MenuItem.IsSubmenuOpen%2A> 예로) 나 사용자에 대 한 일반적인 예상된 시나리오인 경우 양방향 바인딩 (<xref:System.Windows.Controls.TextBox.Text%2A> 예로).</span><span class="sxs-lookup"><span data-stu-id="ce5ec-125">You might set binding to have a two-way default for properties that tie together a control's behaviors amongst its component pieces (<xref:System.Windows.Controls.MenuItem.IsSubmenuOpen%2A> is an example) or where two-way binding is the common and expected scenario for users (<xref:System.Windows.Controls.TextBox.Text%2A> is an example).</span></span> <span data-ttu-id="ce5ec-126">데이터 바인딩 관련 메타데이터를 변경하면 기본값에만 영향을 미칩니다. 바인딩별 변경에서는 해당 기본값을 항상 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ce5ec-126">Changing the data binding–related metadata only influences the default; on a per-binding basis that default can always be changed.</span></span> <span data-ttu-id="ce5ec-127">바인딩 모드와 일반적인 바인딩에 대한 자세한 내용은 [데이터 바인딩 개요](../data/data-binding-overview.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ce5ec-127">For details on the binding modes and binding in general, see [Data Binding Overview](../data/data-binding-overview.md).</span></span>  
  
-   <span data-ttu-id="ce5ec-128">속성을 저널링을 지 원하는 서비스 또는 응용 프로그램에서 저널링 해야 할지 여부를 보고 (<xref:System.Windows.FrameworkPropertyMetadata.Journal%2A>).</span><span class="sxs-lookup"><span data-stu-id="ce5ec-128">Reporting whether properties should be journaled by applications or services that support journaling (<xref:System.Windows.FrameworkPropertyMetadata.Journal%2A>).</span></span> <span data-ttu-id="ce5ec-129">일반 요소에는 기본적으로 저널링을 사용하지 않지만, 특정 사용자 입력 컨트롤에 대해서는 선택적으로 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="ce5ec-129">For general elements, journaling is not enabled by default, but it is selectively enabled for certain user input controls.</span></span> <span data-ttu-id="ce5ec-130">이 속성은 저널링의 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 구현을 포함하여 저널링 서비스를 통해 읽어야 하며, 일반적으로 탐색 단계 간에 지속되어야 하는 목록의 사용자 선택 항목과 같은 사용자 컨트롤에 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="ce5ec-130">This property is intended to be read by journaling services including the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] implementation of journaling, and is typically set on user controls such as user selections within lists that should be persisted across navigation steps.</span></span> <span data-ttu-id="ce5ec-131">저널에 대한 자세한 내용은 [탐색 개요](../app-development/navigation-overview.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ce5ec-131">For information about the journal, see [Navigation Overview](../app-development/navigation-overview.md).</span></span>  
  
<a name="Reading_FrameworkPropertyMetadata"></a>   
## <a name="reading-frameworkpropertymetadata"></a><span data-ttu-id="ce5ec-132">FrameworkPropertyMetadata 읽기</span><span class="sxs-lookup"><span data-stu-id="ce5ec-132">Reading FrameworkPropertyMetadata</span></span>  
 <span data-ttu-id="ce5ec-133">각 위에 링크 된 속성은 특정 속성은 합니다 <xref:System.Windows.FrameworkPropertyMetadata> 즉시 기본 클래스에 추가 <xref:System.Windows.UIPropertyMetadata>합니다.</span><span class="sxs-lookup"><span data-stu-id="ce5ec-133">Each of the properties linked above are the specific properties that the <xref:System.Windows.FrameworkPropertyMetadata> adds to its immediate base class <xref:System.Windows.UIPropertyMetadata>.</span></span> <span data-ttu-id="ce5ec-134">이러한 각 속성은 기본적으로 `false`입니다.</span><span class="sxs-lookup"><span data-stu-id="ce5ec-134">Each of these properties will be `false` by default.</span></span> <span data-ttu-id="ce5ec-135">이러한 속성의 값을 아는 것이 중요 한 속성에 대 한 메타 데이터 요청에 반환된 된 메타 데이터를 캐스팅 하려고 시도해 야 <xref:System.Windows.FrameworkPropertyMetadata>, 한 다음 필요에 따라 개별 속성에 값을 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="ce5ec-135">A metadata request for a property where knowing the value of these properties is important should attempt to cast the returned metadata to <xref:System.Windows.FrameworkPropertyMetadata>, and then check the values of the individual properties as needed.</span></span>  
  
<a name="Specifying_Metadata"></a>   
## <a name="specifying-metadata"></a><span data-ttu-id="ce5ec-136">메타데이터 지정</span><span class="sxs-lookup"><span data-stu-id="ce5ec-136">Specifying Metadata</span></span>  
 <span data-ttu-id="ce5ec-137">메타 데이터 클래스를 사용 하 여 선택할 수 있습니다 새 종속성 속성 등록에 메타 데이터를 적용 하는 목적에 대 한 새 메타 데이터 인스턴스를 만든 경우: 기본 <xref:System.Windows.PropertyMetadata> 와 같은 일부 파생 클래스 또는 <xref:System.Windows.FrameworkPropertyMetadata>합니다.</span><span class="sxs-lookup"><span data-stu-id="ce5ec-137">When you create a new metadata instance for purposes of applying metadata to a new dependency property registration, you have the choice of which metadata class to use: the base <xref:System.Windows.PropertyMetadata> or some derived class such as <xref:System.Windows.FrameworkPropertyMetadata>.</span></span> <span data-ttu-id="ce5ec-138">일반적으로 사용 해야 <xref:System.Windows.FrameworkPropertyMetadata>재산 속성 시스템과 상호 작용 하는 경우에 특히 및 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 레이아웃 및 데이터 바인딩과 같은 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="ce5ec-138">In general, you should use <xref:System.Windows.FrameworkPropertyMetadata>, particularly if your property has any interaction with property system and [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] functions such as layout and data binding.</span></span> <span data-ttu-id="ce5ec-139">파생 시키는 더 복잡 한 시나리오에 대 한 또 다른 옵션은 <xref:System.Windows.FrameworkPropertyMetadata> 고유 메타 데이터를 만들려면 해당 멤버에 전달 추가 정보를 사용 하 여 클래스를 보고 합니다.</span><span class="sxs-lookup"><span data-stu-id="ce5ec-139">Another option for more sophisticated scenarios is to derive from <xref:System.Windows.FrameworkPropertyMetadata> to create your own metadata reporting class with extra information carried in its members.</span></span> <span data-ttu-id="ce5ec-140">사용할 수 있습니다 <xref:System.Windows.PropertyMetadata> 또는 <xref:System.Windows.UIPropertyMetadata> 구현의 기능에 대 한 지원 정도 통신할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ce5ec-140">Or you might use <xref:System.Windows.PropertyMetadata> or <xref:System.Windows.UIPropertyMetadata> to communicate the degree of support for features of your implementation.</span></span>  
  
 <span data-ttu-id="ce5ec-141">기존 속성 (<xref:System.Windows.DependencyProperty.AddOwner%2A> 또는 <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> 호출), 원래 등록에서 사용 하는 메타 데이터 형식을 사용 하 여 항상 재정의 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ce5ec-141">For existing properties (<xref:System.Windows.DependencyProperty.AddOwner%2A> or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> call), you should always override with the metadata type used by the original registration.</span></span>  
  
 <span data-ttu-id="ce5ec-142">만들려는 경우를 <xref:System.Windows.FrameworkPropertyMetadata> 인스턴스, 프레임 워크 속성 특성에 전달 하는 특정 속성에 대 한 값을 사용 하 여 해당 메타 데이터를 채우는 데는 두 가지 방법이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ce5ec-142">If you are creating a <xref:System.Windows.FrameworkPropertyMetadata> instance, there are two ways to populate that metadata with values for the specific properties that communicate the framework property characteristics:</span></span>  
  
1.  <span data-ttu-id="ce5ec-143">사용 된 <xref:System.Windows.FrameworkPropertyMetadata> 허용 하는 생성자 시그니처를 `flags` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="ce5ec-143">Use the <xref:System.Windows.FrameworkPropertyMetadata> constructor signature that allows a `flags` parameter.</span></span> <span data-ttu-id="ce5ec-144">값이 필요한 모든 조합된으로이 매개 변수를 채워야 합니다 <xref:System.Windows.FrameworkPropertyMetadataOptions> 열거형 플래그입니다.</span><span class="sxs-lookup"><span data-stu-id="ce5ec-144">This parameter should be filled with all desired combined values of the <xref:System.Windows.FrameworkPropertyMetadataOptions> enumeration flags.</span></span>  
  
2.  <span data-ttu-id="ce5ec-145">없이 시그니처 중 하나를 사용 하 여는 `flags` 매개 변수를 각 보고 부울 속성을 설정한 후 <xref:System.Windows.FrameworkPropertyMetadata> 에 `true` 원하는 각 특성 변경에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="ce5ec-145">Use one of the signatures without a `flags` parameter, and then set each reporting Boolean property on <xref:System.Windows.FrameworkPropertyMetadata> to `true` for each desired characteristic change.</span></span> <span data-ttu-id="ce5ec-146">이 작업을 수행하는 경우 이 종속성 속성이 있는 요소를 생성하기 전에 이러한 속성을 설정해야 합니다. `flags` 매개 변수를 방지하는 동작을 허용하기 위해 부울 속성은 읽기-쓰기가 되며 여전히 메타데이터를 채우지만, 속성을 사용하기 전에 메타데이터를 적절하게 봉인해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ce5ec-146">If you do this, you must set these properties before any elements with this dependency property are constructed; the Boolean properties are read-write in order to allow this behavior of avoiding the `flags` parameter and still populate the metadata, but the metadata must become effectively sealed before property use.</span></span> <span data-ttu-id="ce5ec-147">따라서 메타데이터를 요청한 후에 속성을 설정하려는 것은 올바른 작업이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="ce5ec-147">Thus, attempting to set the properties after metadata is requested will be an invalid operation.</span></span>  
  
<a name="Framework_Property_Metadata_Merge_Behavior"></a>   
## <a name="framework-property-metadata-merge-behavior"></a><span data-ttu-id="ce5ec-148">프레임워크 속성 메타데이터 병합 동작</span><span class="sxs-lookup"><span data-stu-id="ce5ec-148">Framework Property Metadata Merge Behavior</span></span>  
 <span data-ttu-id="ce5ec-149">프레임워크 속성 메타데이터를 재정의할 때, 여러 다른 메타데이터 특성을 병합하거나 대체합니다.</span><span class="sxs-lookup"><span data-stu-id="ce5ec-149">When you override framework property metadata, the different metadata characteristics are either merged or replaced.</span></span>  
  
-   <span data-ttu-id="ce5ec-150"><xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> 병합 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ce5ec-150"><xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> is merged.</span></span> <span data-ttu-id="ce5ec-151">새로 추가 하는 경우 <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A>, 해당 콜백은 메타 데이터에 저장 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ce5ec-151">If you add a new <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A>, that callback is stored in the metadata.</span></span> <span data-ttu-id="ce5ec-152">지정 하지 않으면 경우는 <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> 재정의 값에 <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> 메타 데이터에 지정 된 가장 가까운 상위 항목에서 참조로 승격 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ce5ec-152">If you do not specify a <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> in the override, the value of <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> is promoted as a reference from the nearest ancestor that specified it in metadata.</span></span>  
  
-   <span data-ttu-id="ce5ec-153">에 대 한 실제 속성 시스템 동작은 <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> 는 구현 계층의 모든 메타 데이터 소유자는 유지 하 고 테이블에 추가 하는 가장 많이 파생된 된 클래스의 콜백 되는 속성 시스템에서 실행 순서를 사용 하 여 먼저 호출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ce5ec-153">The actual property system behavior for <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> is that implementations for all metadata owners in the hierarchy are retained and added to a table, with order of execution by the property system being that the callbacks of the most deeply derived class are invoked first.</span></span> <span data-ttu-id="ce5ec-154">상속된 콜백은 한 번만 실행되며, 메타데이터에 해당 콜백을 둔 클래스가 소유하는 것으로 계산됩니다.</span><span class="sxs-lookup"><span data-stu-id="ce5ec-154">Inherited callbacks run only once, counting as being owned by the class that placed them in metadata.</span></span>  
  
-   <span data-ttu-id="ce5ec-155"><xref:System.Windows.PropertyMetadata.DefaultValue%2A> 대체 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ce5ec-155"><xref:System.Windows.PropertyMetadata.DefaultValue%2A> is replaced.</span></span> <span data-ttu-id="ce5ec-156">지정 하지 않으면 경우는 <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> 재정의 값에 <xref:System.Windows.PropertyMetadata.DefaultValue%2A> 메타 데이터에 지정 된 가장 가까운 상위 항목에서 제공 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ce5ec-156">If you do not specify a <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> in the override, the value of <xref:System.Windows.PropertyMetadata.DefaultValue%2A> comes from the nearest ancestor that specified it in metadata.</span></span>  
  
-   <span data-ttu-id="ce5ec-157"><xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> 구현이 대체 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ce5ec-157"><xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> implementations are replaced.</span></span> <span data-ttu-id="ce5ec-158">새로 추가 하는 경우 <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>, 해당 콜백은 메타 데이터에 저장 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ce5ec-158">If you add a new <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>, that callback is stored in the metadata.</span></span> <span data-ttu-id="ce5ec-159">지정 하지 않으면 경우는 <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> 재정의 값에 <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> 메타 데이터에 지정 된 가장 가까운 상위 항목에서 참조로 승격 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ce5ec-159">If you do not specify a <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> in the override, the value of <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> is promoted as a reference from the nearest ancestor that specified it in metadata.</span></span>  
  
-   <span data-ttu-id="ce5ec-160">속성 시스템 동작은는 <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> 직접 메타 데이터에서 호출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ce5ec-160">The property system behavior is that only the <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> in the immediate metadata is invoked.</span></span> <span data-ttu-id="ce5ec-161">다른 참조가 없는 <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> 구현 계층 구조에서 유지 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ce5ec-161">No references to other <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> implementations in the hierarchy are retained.</span></span>  
  
-   <span data-ttu-id="ce5ec-162">플래그 <xref:System.Windows.FrameworkPropertyMetadataOptions> 열거형을 비트 OR 연산으로 결합 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ce5ec-162">The flags of <xref:System.Windows.FrameworkPropertyMetadataOptions> enumeration are combined as a bitwise OR operation.</span></span>  <span data-ttu-id="ce5ec-163">지정 하는 경우 <xref:System.Windows.FrameworkPropertyMetadataOptions>, 원래 옵션을 덮어쓰지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ce5ec-163">If you specify <xref:System.Windows.FrameworkPropertyMetadataOptions>, the original options are not overwritten.</span></span>  <span data-ttu-id="ce5ec-164">옵션을 변경 하려면 해당 속성에 설정 <xref:System.Windows.FrameworkPropertyMetadata>합니다.</span><span class="sxs-lookup"><span data-stu-id="ce5ec-164">To change an option, set the corresponding property on <xref:System.Windows.FrameworkPropertyMetadata>.</span></span> <span data-ttu-id="ce5ec-165">예를 들어 경우 원래 <xref:System.Windows.FrameworkPropertyMetadata> 집합 개체를 <xref:System.Windows.FrameworkPropertyMetadataOptions.NotDataBindable?displayProperty=nameWithType> 플래그를 설정 하 여 변경할 수 있습니다 <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A?displayProperty=nameWithType> 에 `false`입니다.</span><span class="sxs-lookup"><span data-stu-id="ce5ec-165">For example, if the original <xref:System.Windows.FrameworkPropertyMetadata> object sets the <xref:System.Windows.FrameworkPropertyMetadataOptions.NotDataBindable?displayProperty=nameWithType> flag, you can change that by setting <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A?displayProperty=nameWithType> to `false`.</span></span>  
  
 <span data-ttu-id="ce5ec-166">이 동작을 구현 하 여 <xref:System.Windows.FrameworkPropertyMetadata.Merge%2A>, 파생 된 메타 데이터 클래스에서 재정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ce5ec-166">This behavior is implemented by <xref:System.Windows.FrameworkPropertyMetadata.Merge%2A>, and can be overridden on derived metadata classes.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="ce5ec-167">참고자료</span><span class="sxs-lookup"><span data-stu-id="ce5ec-167">See also</span></span>
- <xref:System.Windows.DependencyProperty.GetMetadata%2A>
- [<span data-ttu-id="ce5ec-168">종속성 속성 메타데이터</span><span class="sxs-lookup"><span data-stu-id="ce5ec-168">Dependency Property Metadata</span></span>](dependency-property-metadata.md)
- [<span data-ttu-id="ce5ec-169">종속성 속성 개요</span><span class="sxs-lookup"><span data-stu-id="ce5ec-169">Dependency Properties Overview</span></span>](dependency-properties-overview.md)
- [<span data-ttu-id="ce5ec-170">사용자 지정 종속성 속성</span><span class="sxs-lookup"><span data-stu-id="ce5ec-170">Custom Dependency Properties</span></span>](custom-dependency-properties.md)

---
title: 프레임워크 속성 메타데이터
ms.date: 03/30/2017
helpviewer_keywords:
- metadata [WPF], framework properties
- framework property metadata [WPF]
ms.assetid: 9962f380-b885-4b61-a62e-457397083fea
ms.openlocfilehash: 3e40dfbcbe88f424337ee5a32fb3e3aaaddd68d0
ms.sourcegitcommit: 944ddc52b7f2632f30c668815f92b378efd38eea
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 11/03/2019
ms.locfileid: "73460457"
---
# <a name="framework-property-metadata"></a><span data-ttu-id="c38f1-102">프레임워크 속성 메타데이터</span><span class="sxs-lookup"><span data-stu-id="c38f1-102">Framework Property Metadata</span></span>
<span data-ttu-id="c38f1-103">프레임워크 속성 메타데이터는 [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] 아키텍처의 WPF 프레임워크 수준에 있는 것으로 간주되는 개체 요소의 속성용으로 보고됩니다.</span><span class="sxs-lookup"><span data-stu-id="c38f1-103">Framework property metadata options are reported for the properties of object elements considered to be at the WPF framework level in the [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] architecture.</span></span> <span data-ttu-id="c38f1-104">일반적으로 WPF 프레임 워크 수준 지정은 렌더링, 데이터 바인딩 및 속성 시스템 구체화와 같은 기능이 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 프레젠테이션 Api 및 실행 파일에 의해 처리 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c38f1-104">In general the WPF framework-level designation entails that features such as rendering, data binding, and property system refinements are handled by the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] presentation APIs and executables.</span></span> <span data-ttu-id="c38f1-105">이러한 시스템에서 프레임워크 속성 메타데이터를 쿼리하여 특정 요소 속성의 기능별 특성을 결정합니다.</span><span class="sxs-lookup"><span data-stu-id="c38f1-105">Framework property metadata is queried by these systems to determine feature-specific characteristics of particular element properties.</span></span>  

<a name="prerequisites"></a>   
## <a name="prerequisites"></a><span data-ttu-id="c38f1-106">Prerequisites</span><span class="sxs-lookup"><span data-stu-id="c38f1-106">Prerequisites</span></span>  
 <span data-ttu-id="c38f1-107">이 항목에서는 [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] 클래스에서 기존 종속성 속성의 소비자 관점에서 종속성 속성을 이해하고 [종속성 속성 개요](dependency-properties-overview.md)를 읽었다고 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="c38f1-107">This topic assumes that you understand dependency properties from the perspective of a consumer of existing dependency properties on [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] classes, and have read the [Dependency Properties Overview](dependency-properties-overview.md).</span></span> <span data-ttu-id="c38f1-108">[종속성 속성 메타데이터](dependency-property-metadata.md)도 읽어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c38f1-108">You should also have read [Dependency Property Metadata](dependency-property-metadata.md).</span></span>  
  
<a name="What_Is_Communicated_by_Framework_Property"></a>   
## <a name="what-is-communicated-by-framework-property-metadata"></a><span data-ttu-id="c38f1-109">프레임워크 속성 메타데이터로 통신하는 내용</span><span class="sxs-lookup"><span data-stu-id="c38f1-109">What Is Communicated by Framework Property Metadata</span></span>  
 <span data-ttu-id="c38f1-110">프레임워크 속성 메타데이터는 다음 범주로 구분할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c38f1-110">Framework property metadata can be divided into the following categories:</span></span>  
  
- <span data-ttu-id="c38f1-111">요소에 영향을 주는 보고 레이아웃 속성 (<xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>).</span><span class="sxs-lookup"><span data-stu-id="c38f1-111">Reporting layout properties that affect an element (<xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>).</span></span> <span data-ttu-id="c38f1-112">속성이 각 측면에 영향을 주는 경우 메타 데이터에서 이러한 플래그를 설정할 수 있으며, 클래스에서 <xref:System.Windows.FrameworkElement.MeasureOverride%2A> / <xref:System.Windows.FrameworkElement.ArrangeOverride%2A> 메서드를 구현 하 여 레이아웃 시스템에 특정 렌더링 동작 및 정보를 제공할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c38f1-112">You might set these flags in metadata if the property affects those respective aspects, and you are also implementing the <xref:System.Windows.FrameworkElement.MeasureOverride%2A> / <xref:System.Windows.FrameworkElement.ArrangeOverride%2A> methods in your class to supply specific rendering behavior and information to the layout system.</span></span> <span data-ttu-id="c38f1-113">일반적으로 이러한 구현에서는 해당 레이아웃 속성이 속성 메타데이터에서 참인 종속성 속성의 속성 무효화를 확인하고 해당 무효화만 새로운 레이아웃 전달을 요청해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c38f1-113">Typically, such an implementation would check for property invalidations in dependency properties where any of these layout properties were true in the property metadata, and only those invalidations would necessitate requesting a new layout pass.</span></span>  
  
- <span data-ttu-id="c38f1-114">요소의 부모 요소에 영향을 주는 보고 레이아웃 속성 (<xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A>).</span><span class="sxs-lookup"><span data-stu-id="c38f1-114">Reporting layout properties that affect the parent element of an element (<xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A>).</span></span> <span data-ttu-id="c38f1-115">이러한 플래그를 기본적으로 설정 하는 몇 가지 예는 <xref:System.Windows.Documents.FixedPage.Left%2A?displayProperty=nameWithType> 및 <xref:System.Windows.Documents.Paragraph.KeepWithNext%2A?displayProperty=nameWithType>입니다.</span><span class="sxs-lookup"><span data-stu-id="c38f1-115">Some examples where these flags are set by default are <xref:System.Windows.Documents.FixedPage.Left%2A?displayProperty=nameWithType> and <xref:System.Windows.Documents.Paragraph.KeepWithNext%2A?displayProperty=nameWithType>.</span></span>  
  
- <span data-ttu-id="c38f1-116"><xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A></span><span class="sxs-lookup"><span data-stu-id="c38f1-116"><xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>.</span></span> <span data-ttu-id="c38f1-117">기본적으로 종속성 속성은 값을 상속하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c38f1-117">By default, dependency properties do not inherit values.</span></span> <span data-ttu-id="c38f1-118"><xref:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior%2A>를 사용 하 여 상속의 경로를 시각적 트리로 이동할 수 있으며,이는 일부 컨트롤 합성 시나리오에 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="c38f1-118"><xref:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior%2A> allows the pathway of inheritance to also travel into a visual tree, which is necessary for some control compositing scenarios.</span></span>  
  
    > [!NOTE]
    > <span data-ttu-id="c38f1-119">속성 값 컨텍스트에서 “상속”이라는 용어는 종속성 속성에 특정한 것입니다. 즉, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 속성 시스템의 WPF 프레임워크 수준 기능때문에 자식 요소가 부모 요소에서 실제 종속성 속성 값을 상속할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c38f1-119">The term "inherits" in the context of property values means something specific for dependency properties; it means that child elements can inherit the actual dependency property value from parent elements because of a WPF framework-level capability of the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] property system.</span></span> <span data-ttu-id="c38f1-120">파생된 유형을 통한 멤버 상속 및 관리된 코드 유형과는 직접적인 관련이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="c38f1-120">It has nothing to do directly with managed code type and members inheritance through derived types.</span></span> <span data-ttu-id="c38f1-121">자세한 내용은 [속성 값 상속](property-value-inheritance.md)을 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="c38f1-121">For details, see [Property Value Inheritance](property-value-inheritance.md).</span></span>  
  
- <span data-ttu-id="c38f1-122">보고 데이터 바인딩 특성 (<xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>, <xref:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault%2A>).</span><span class="sxs-lookup"><span data-stu-id="c38f1-122">Reporting data binding characteristics (<xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>, <xref:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault%2A>).</span></span> <span data-ttu-id="c38f1-123">기본적으로 프레임워크의 종속성 속성은 단방향 바인딩 동작을 통한 데이터 바인딩을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="c38f1-123">By default, dependency properties in the framework support data binding, with a one-way binding behavior.</span></span> <span data-ttu-id="c38f1-124">데이터 바인딩을 사용 하지 않도록 설정할 수 있습니다 .이는 유연 하 고 확장 하기 위한 것 이기 때문에 기본 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] Api에는 이러한 속성의 예가 많지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c38f1-124">You might disable data binding if there were no scenario for it whatsoever (because they are intended to be flexible and extensible, there aren't many examples of such properties in the default [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] APIs).</span></span> <span data-ttu-id="c38f1-125">구성 요소 부분 (<xref:System.Windows.Controls.MenuItem.IsSubmenuOpen%2A>)에서 컨트롤의 동작을 결합 하는 속성에 대 한 양방향 기본값을 포함 하도록 바인딩을 설정 하거나 양방향 바인딩이 사용자에 게 공통적이 고 예상 되는 시나리오 (<xref:System.Windows.Controls.TextBox.Text%2A> 예) 인 경우를 예로 들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c38f1-125">You might set binding to have a two-way default for properties that tie together a control's behaviors amongst its component pieces (<xref:System.Windows.Controls.MenuItem.IsSubmenuOpen%2A> is an example) or where two-way binding is the common and expected scenario for users (<xref:System.Windows.Controls.TextBox.Text%2A> is an example).</span></span> <span data-ttu-id="c38f1-126">데이터 바인딩 관련 메타데이터를 변경하면 기본값에만 영향을 미칩니다. 바인딩별 변경에서는 해당 기본값을 항상 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c38f1-126">Changing the data binding–related metadata only influences the default; on a per-binding basis that default can always be changed.</span></span> <span data-ttu-id="c38f1-127">바인딩 모드와 일반적인 바인딩에 대한 자세한 내용은 [데이터 바인딩 개요](../../../desktop-wpf/data/data-binding-overview.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="c38f1-127">For details on the binding modes and binding in general, see [Data Binding Overview](../../../desktop-wpf/data/data-binding-overview.md).</span></span>  
  
- <span data-ttu-id="c38f1-128">저널링을 지 원하는 응용 프로그램 또는 서비스에서 속성을 저널링 해야 하는지 여부를 보고 합니다 (<xref:System.Windows.FrameworkPropertyMetadata.Journal%2A>).</span><span class="sxs-lookup"><span data-stu-id="c38f1-128">Reporting whether properties should be journaled by applications or services that support journaling (<xref:System.Windows.FrameworkPropertyMetadata.Journal%2A>).</span></span> <span data-ttu-id="c38f1-129">일반 요소에는 기본적으로 저널링을 사용하지 않지만, 특정 사용자 입력 컨트롤에 대해서는 선택적으로 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="c38f1-129">For general elements, journaling is not enabled by default, but it is selectively enabled for certain user input controls.</span></span> <span data-ttu-id="c38f1-130">이 속성은 저널링의 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 구현을 포함하여 저널링 서비스를 통해 읽어야 하며, 일반적으로 탐색 단계 간에 지속되어야 하는 목록의 사용자 선택 항목과 같은 사용자 컨트롤에 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="c38f1-130">This property is intended to be read by journaling services including the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] implementation of journaling, and is typically set on user controls such as user selections within lists that should be persisted across navigation steps.</span></span> <span data-ttu-id="c38f1-131">저널에 대한 자세한 내용은 [탐색 개요](../app-development/navigation-overview.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="c38f1-131">For information about the journal, see [Navigation Overview](../app-development/navigation-overview.md).</span></span>  
  
<a name="Reading_FrameworkPropertyMetadata"></a>   
## <a name="reading-frameworkpropertymetadata"></a><span data-ttu-id="c38f1-132">FrameworkPropertyMetadata 읽기</span><span class="sxs-lookup"><span data-stu-id="c38f1-132">Reading FrameworkPropertyMetadata</span></span>  
 <span data-ttu-id="c38f1-133">위에서 연결 된 각 속성은 <xref:System.Windows.FrameworkPropertyMetadata>에서 직접 기본 클래스 <xref:System.Windows.UIPropertyMetadata>에 추가 하는 특정 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="c38f1-133">Each of the properties linked above are the specific properties that the <xref:System.Windows.FrameworkPropertyMetadata> adds to its immediate base class <xref:System.Windows.UIPropertyMetadata>.</span></span> <span data-ttu-id="c38f1-134">이러한 각 속성은 기본적으로 `false`입니다.</span><span class="sxs-lookup"><span data-stu-id="c38f1-134">Each of these properties will be `false` by default.</span></span> <span data-ttu-id="c38f1-135">이러한 속성의 값을 알고 있는 속성에 대 한 메타 데이터 요청은 반환 된 메타 데이터를 <xref:System.Windows.FrameworkPropertyMetadata>캐스팅 한 다음 필요에 따라 개별 속성의 값을 확인 하는 것이 중요 합니다.</span><span class="sxs-lookup"><span data-stu-id="c38f1-135">A metadata request for a property where knowing the value of these properties is important should attempt to cast the returned metadata to <xref:System.Windows.FrameworkPropertyMetadata>, and then check the values of the individual properties as needed.</span></span>  
  
<a name="Specifying_Metadata"></a>   
## <a name="specifying-metadata"></a><span data-ttu-id="c38f1-136">메타데이터 지정</span><span class="sxs-lookup"><span data-stu-id="c38f1-136">Specifying Metadata</span></span>  
 <span data-ttu-id="c38f1-137">새 종속성 속성 등록에 메타 데이터를 적용 하기 위해 새 메타 데이터 인스턴스를 만들 때 사용할 메타 데이터 클래스를 선택할 수 있습니다. 기본 <xref:System.Windows.PropertyMetadata> 또는 <xref:System.Windows.FrameworkPropertyMetadata>같은 파생 클래스를 선택할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c38f1-137">When you create a new metadata instance for purposes of applying metadata to a new dependency property registration, you have the choice of which metadata class to use: the base <xref:System.Windows.PropertyMetadata> or some derived class such as <xref:System.Windows.FrameworkPropertyMetadata>.</span></span> <span data-ttu-id="c38f1-138">일반적으로 속성에 속성 시스템과 상호 작용이 있고 레이아웃 및 데이터 바인딩과 같은 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 함수를 사용 하는 경우 특히 <xref:System.Windows.FrameworkPropertyMetadata>를 사용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c38f1-138">In general, you should use <xref:System.Windows.FrameworkPropertyMetadata>, particularly if your property has any interaction with property system and [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] functions such as layout and data binding.</span></span> <span data-ttu-id="c38f1-139">보다 정교한 시나리오에 대 한 또 다른 옵션은 <xref:System.Windows.FrameworkPropertyMetadata>에서 파생 하 여 해당 멤버에 추가 정보가 포함 된 고유한 메타 데이터 보고 클래스를 만드는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="c38f1-139">Another option for more sophisticated scenarios is to derive from <xref:System.Windows.FrameworkPropertyMetadata> to create your own metadata reporting class with extra information carried in its members.</span></span> <span data-ttu-id="c38f1-140">또는 <xref:System.Windows.PropertyMetadata> 또는 <xref:System.Windows.UIPropertyMetadata>를 사용 하 여 구현 기능에 대 한 지원 수준을 전달할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c38f1-140">Or you might use <xref:System.Windows.PropertyMetadata> or <xref:System.Windows.UIPropertyMetadata> to communicate the degree of support for features of your implementation.</span></span>  
  
 <span data-ttu-id="c38f1-141">기존 속성 (<xref:System.Windows.DependencyProperty.AddOwner%2A> 또는 <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> 호출)의 경우 항상 원래 등록에서 사용 하는 메타 데이터 형식으로를 재정의 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c38f1-141">For existing properties (<xref:System.Windows.DependencyProperty.AddOwner%2A> or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> call), you should always override with the metadata type used by the original registration.</span></span>  
  
 <span data-ttu-id="c38f1-142"><xref:System.Windows.FrameworkPropertyMetadata> 인스턴스를 만드는 경우 다음과 같은 두 가지 방법으로 프레임 워크 속성 특성을 전달 하는 특정 속성의 값으로 해당 메타 데이터를 채울 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c38f1-142">If you are creating a <xref:System.Windows.FrameworkPropertyMetadata> instance, there are two ways to populate that metadata with values for the specific properties that communicate the framework property characteristics:</span></span>  
  
1. <span data-ttu-id="c38f1-143">`flags` 매개 변수를 허용 하는 <xref:System.Windows.FrameworkPropertyMetadata> 생성자 시그니처를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="c38f1-143">Use the <xref:System.Windows.FrameworkPropertyMetadata> constructor signature that allows a `flags` parameter.</span></span> <span data-ttu-id="c38f1-144">이 매개 변수는 <xref:System.Windows.FrameworkPropertyMetadataOptions> 열거형 플래그의 원하는 모든 조합 값으로 채워야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c38f1-144">This parameter should be filled with all desired combined values of the <xref:System.Windows.FrameworkPropertyMetadataOptions> enumeration flags.</span></span>  
  
2. <span data-ttu-id="c38f1-145">`flags` 매개 변수 없이 서명 중 하나를 사용한 다음 <xref:System.Windows.FrameworkPropertyMetadata>의 각 보고 부울 속성을 원하는 각 특성 변경에 대해 `true`로 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="c38f1-145">Use one of the signatures without a `flags` parameter, and then set each reporting Boolean property on <xref:System.Windows.FrameworkPropertyMetadata> to `true` for each desired characteristic change.</span></span> <span data-ttu-id="c38f1-146">이 작업을 수행하는 경우 이 종속성 속성이 있는 요소를 생성하기 전에 이러한 속성을 설정해야 합니다. `flags` 매개 변수를 방지하는 동작을 허용하기 위해 부울 속성은 읽기-쓰기가 되며 여전히 메타데이터를 채우지만, 속성을 사용하기 전에 메타데이터를 적절하게 봉인해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c38f1-146">If you do this, you must set these properties before any elements with this dependency property are constructed; the Boolean properties are read-write in order to allow this behavior of avoiding the `flags` parameter and still populate the metadata, but the metadata must become effectively sealed before property use.</span></span> <span data-ttu-id="c38f1-147">따라서 메타데이터를 요청한 후에 속성을 설정하려는 것은 올바른 작업이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="c38f1-147">Thus, attempting to set the properties after metadata is requested will be an invalid operation.</span></span>  
  
<a name="Framework_Property_Metadata_Merge_Behavior"></a>   
## <a name="framework-property-metadata-merge-behavior"></a><span data-ttu-id="c38f1-148">프레임워크 속성 메타데이터 병합 동작</span><span class="sxs-lookup"><span data-stu-id="c38f1-148">Framework Property Metadata Merge Behavior</span></span>  
 <span data-ttu-id="c38f1-149">프레임워크 속성 메타데이터를 재정의할 때, 여러 다른 메타데이터 특성을 병합하거나 대체합니다.</span><span class="sxs-lookup"><span data-stu-id="c38f1-149">When you override framework property metadata, the different metadata characteristics are either merged or replaced.</span></span>  
  
- <span data-ttu-id="c38f1-150"><xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> 병합 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c38f1-150"><xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> is merged.</span></span> <span data-ttu-id="c38f1-151">새 <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A>을 추가 하는 경우 해당 콜백은 메타 데이터에 저장 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c38f1-151">If you add a new <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A>, that callback is stored in the metadata.</span></span> <span data-ttu-id="c38f1-152">재정의에 <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A>을 지정 하지 않으면 <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A>의 값이 메타 데이터에 지정 된 가장 가까운 상위 항목에서 참조로 승격 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c38f1-152">If you do not specify a <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> in the override, the value of <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> is promoted as a reference from the nearest ancestor that specified it in metadata.</span></span>  
  
- <span data-ttu-id="c38f1-153"><xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A>에 대 한 실제 속성 시스템 동작은 계층 구조에 있는 모든 메타 데이터 소유자에 대 한 구현이 가장 많이 파생 된 클래스의 콜백이 호출 되는 속성 시스템의 실행 순서와 함께 유지 되 고 테이블에 추가 된다는 것입니다. 기본.</span><span class="sxs-lookup"><span data-stu-id="c38f1-153">The actual property system behavior for <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> is that implementations for all metadata owners in the hierarchy are retained and added to a table, with order of execution by the property system being that the callbacks of the most deeply derived class are invoked first.</span></span> <span data-ttu-id="c38f1-154">상속된 콜백은 한 번만 실행되며, 메타데이터에 해당 콜백을 둔 클래스가 소유하는 것으로 계산됩니다.</span><span class="sxs-lookup"><span data-stu-id="c38f1-154">Inherited callbacks run only once, counting as being owned by the class that placed them in metadata.</span></span>  
  
- <span data-ttu-id="c38f1-155"><xref:System.Windows.PropertyMetadata.DefaultValue%2A> 바뀝니다.</span><span class="sxs-lookup"><span data-stu-id="c38f1-155"><xref:System.Windows.PropertyMetadata.DefaultValue%2A> is replaced.</span></span> <span data-ttu-id="c38f1-156">재정의에 <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A>을 지정 하지 않으면 <xref:System.Windows.PropertyMetadata.DefaultValue%2A> 값은 메타 데이터에서 지정 된 가장 가까운 상위 항목에서 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="c38f1-156">If you do not specify a <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> in the override, the value of <xref:System.Windows.PropertyMetadata.DefaultValue%2A> comes from the nearest ancestor that specified it in metadata.</span></span>  
  
- <span data-ttu-id="c38f1-157"><xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> 구현이 대체 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c38f1-157"><xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> implementations are replaced.</span></span> <span data-ttu-id="c38f1-158">새 <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>을 추가 하는 경우 해당 콜백은 메타 데이터에 저장 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c38f1-158">If you add a new <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>, that callback is stored in the metadata.</span></span> <span data-ttu-id="c38f1-159">재정의에 <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>을 지정 하지 않으면 <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>의 값이 메타 데이터에 지정 된 가장 가까운 상위 항목에서 참조로 승격 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c38f1-159">If you do not specify a <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> in the override, the value of <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> is promoted as a reference from the nearest ancestor that specified it in metadata.</span></span>  
  
- <span data-ttu-id="c38f1-160">속성 시스템 동작은 즉시 메타 데이터의 <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>만 호출 된다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="c38f1-160">The property system behavior is that only the <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> in the immediate metadata is invoked.</span></span> <span data-ttu-id="c38f1-161">계층의 다른 <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> 구현에 대 한 참조는 유지 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c38f1-161">No references to other <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> implementations in the hierarchy are retained.</span></span>  
  
- <span data-ttu-id="c38f1-162"><xref:System.Windows.FrameworkPropertyMetadataOptions> 열거형의 플래그는 비트 OR 연산으로 결합 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c38f1-162">The flags of <xref:System.Windows.FrameworkPropertyMetadataOptions> enumeration are combined as a bitwise OR operation.</span></span>  <span data-ttu-id="c38f1-163"><xref:System.Windows.FrameworkPropertyMetadataOptions>지정 하는 경우 원래 옵션을 덮어쓰지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c38f1-163">If you specify <xref:System.Windows.FrameworkPropertyMetadataOptions>, the original options are not overwritten.</span></span>  <span data-ttu-id="c38f1-164">옵션을 변경 하려면 <xref:System.Windows.FrameworkPropertyMetadata>에서 해당 속성을 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="c38f1-164">To change an option, set the corresponding property on <xref:System.Windows.FrameworkPropertyMetadata>.</span></span> <span data-ttu-id="c38f1-165">예를 들어 원래 <xref:System.Windows.FrameworkPropertyMetadata> 개체가 <xref:System.Windows.FrameworkPropertyMetadataOptions.NotDataBindable?displayProperty=nameWithType> 플래그를 설정 하는 경우 <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A?displayProperty=nameWithType>를 `false`로 설정 하 여 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c38f1-165">For example, if the original <xref:System.Windows.FrameworkPropertyMetadata> object sets the <xref:System.Windows.FrameworkPropertyMetadataOptions.NotDataBindable?displayProperty=nameWithType> flag, you can change that by setting <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A?displayProperty=nameWithType> to `false`.</span></span>  
  
 <span data-ttu-id="c38f1-166">이 동작은 <xref:System.Windows.FrameworkPropertyMetadata.Merge%2A>에 의해 구현 되며 파생 된 메타 데이터 클래스에서 재정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c38f1-166">This behavior is implemented by <xref:System.Windows.FrameworkPropertyMetadata.Merge%2A>, and can be overridden on derived metadata classes.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="c38f1-167">참조</span><span class="sxs-lookup"><span data-stu-id="c38f1-167">See also</span></span>

- <xref:System.Windows.DependencyProperty.GetMetadata%2A>
- [<span data-ttu-id="c38f1-168">종속성 속성 메타데이터</span><span class="sxs-lookup"><span data-stu-id="c38f1-168">Dependency Property Metadata</span></span>](dependency-property-metadata.md)
- [<span data-ttu-id="c38f1-169">종속성 속성 개요</span><span class="sxs-lookup"><span data-stu-id="c38f1-169">Dependency Properties Overview</span></span>](dependency-properties-overview.md)
- [<span data-ttu-id="c38f1-170">사용자 지정 종속성 속성</span><span class="sxs-lookup"><span data-stu-id="c38f1-170">Custom Dependency Properties</span></span>](custom-dependency-properties.md)

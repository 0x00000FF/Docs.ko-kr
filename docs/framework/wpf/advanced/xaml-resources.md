---
title: XAML 리소스
ms.date: 03/30/2017
helpviewer_keywords:
- reusing resources [WPF]
- resources [WPF], reusing
- reusing commonly defined objects [WPF]
- XAML [WPF], reusing resources
ms.assetid: 91580b89-a0a8-4889-aecb-fddf8e63175f
ms.openlocfilehash: e02c80f4c1fdacbfdcb50ed57d89cc9df1f277f9
ms.sourcegitcommit: ccd8c36b0d74d99291d41aceb14cf98d74dc9d2b
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 12/10/2018
ms.locfileid: "53126405"
---
# <a name="xaml-resources"></a><span data-ttu-id="f1660-102">XAML 리소스</span><span class="sxs-lookup"><span data-stu-id="f1660-102">XAML Resources</span></span>
<span data-ttu-id="f1660-103">리소스는 응용 프로그램의 여러 위치에서 다시 사용할 수 있는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-103">A resource is an object that can be reused in different places in your application.</span></span> <span data-ttu-id="f1660-104">리소스의 예로는 브러시와 스타일이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-104">Examples of resources include brushes and styles.</span></span> <span data-ttu-id="f1660-105">이 개요에서 리소스를 사용 하는 방법에 설명 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]합니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-105">This overview describes how to use resources in [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)].</span></span> <span data-ttu-id="f1660-106">또한 만들고 하 하거나 코드 서로 바꿔 코드를 사용 하 여 리소스에 액세스 하 고 [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)]입니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-106">You can also create and access resources by using code, or interchangeably between code and [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)].</span></span> <span data-ttu-id="f1660-107">자세한 내용은 [리소스 및 코드](../../../../docs/framework/wpf/advanced/resources-and-code.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-107">For more information, see [Resources and Code](../../../../docs/framework/wpf/advanced/resources-and-code.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f1660-108">이 항목에서 설명 하는 리소스 파일은 리소스 파일에 설명 된 다르지 [WPF 응용 프로그램 리소스, 콘텐츠 및 데이터 파일](../../../../docs/framework/wpf/app-development/wpf-application-resource-content-and-data-files.md) 포함 또는 연결 된 리소스에 설명 된 것과 다르며 [ 응용 프로그램 리소스 관리 (.NET)](https://msdn.microsoft.com/library/f2582734-8ada-4baa-8a7c-e2ef943ddf7e)합니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-108">The resource files described in this topic are different than the resource files described in [WPF Application Resource, Content, and Data Files](../../../../docs/framework/wpf/app-development/wpf-application-resource-content-and-data-files.md) and different than the embedded or linked resources described in [Managing Application Resources (.NET)](https://msdn.microsoft.com/library/f2582734-8ada-4baa-8a7c-e2ef943ddf7e).</span></span>  
  
  
<a name="usingresources"></a>   
## <a name="using-resources-in-xaml"></a><span data-ttu-id="f1660-109">XAML의 리소스 사용</span><span class="sxs-lookup"><span data-stu-id="f1660-109">Using Resources in XAML</span></span>  
 <span data-ttu-id="f1660-110">다음 예제에서는 정의 <xref:System.Windows.Media.SolidColorBrush> 페이지의 루트 요소에서 리소스로 합니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-110">The following example defines a <xref:System.Windows.Media.SolidColorBrush> as a resource on the root element of a page.</span></span> <span data-ttu-id="f1660-111">이 예제에서는 리소스를 참조 하 고 포함 하 여 여러 자식 요소의 속성을 설정 하는 데 사용을 <xref:System.Windows.Shapes.Ellipse>, <xref:System.Windows.Controls.TextBlock>, 및 <xref:System.Windows.Controls.Button>합니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-111">The example then references the resource and uses it to set properties of several child elements, including an <xref:System.Windows.Shapes.Ellipse>, a <xref:System.Windows.Controls.TextBlock>, and a <xref:System.Windows.Controls.Button>.</span></span>  
  
 [!code-xaml[FEResourceSH_snip#XAML](../../../../samples/snippets/csharp/VS_Snippets_Wpf/FEResourceSH_snip/CS/page1.xaml#xaml)]  
  
 <span data-ttu-id="f1660-112">모든 프레임 워크 수준 요소 (<xref:System.Windows.FrameworkElement> 또는 <xref:System.Windows.FrameworkContentElement>)에 <xref:System.Windows.FrameworkElement.Resources%2A> 속성은 리소스를 포함 하는 속성 (으로 <xref:System.Windows.ResourceDictionary>) 리소스를 정의 하는 합니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-112">Every framework-level element (<xref:System.Windows.FrameworkElement> or <xref:System.Windows.FrameworkContentElement>) has a <xref:System.Windows.FrameworkElement.Resources%2A> property, which is the property that contains the resources (as a <xref:System.Windows.ResourceDictionary>) that a resource defines.</span></span> <span data-ttu-id="f1660-113">모든 요소에서 리소스를 정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-113">You can define resources on any element.</span></span> <span data-ttu-id="f1660-114">그러나 리소스는 대부분 인 루트 요소에 정의 <xref:System.Windows.Controls.Page> 예제에서입니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-114">However, resources are most often defined on the root element, which is <xref:System.Windows.Controls.Page> in the example.</span></span>  
  
 <span data-ttu-id="f1660-115">리소스 디렉터리의 각 리소스에는 고유 키가 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-115">Each resource in a resource dictionary must have a unique key.</span></span> <span data-ttu-id="f1660-116">통해 고유 키를 할당 하는 태그에 리소스를 정의 하는 경우는 [X:key 지시문](../../../../docs/framework/xaml-services/x-key-directive.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-116">When you define resources in markup, you assign the unique key through the [x:Key Directive](../../../../docs/framework/xaml-services/x-key-directive.md).</span></span> <span data-ttu-id="f1660-117">일반적으로 키는 문자열이지만, 적절한 태그 확장을 사용하여 다른 개체 형식으로도 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-117">Typically, the key is a string; however, you can also set it to other object types by using the appropriate markup extensions.</span></span> <span data-ttu-id="f1660-118">문자열이 아닌 리소스 키는의 특정 기능 영역에서 사용할 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], 스타일, 구성 요소 리소스 및 데이터 스타일링을 위해.</span><span class="sxs-lookup"><span data-stu-id="f1660-118">Nonstring keys for resources are used by certain feature areas in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], notably for styles, component resources, and data styling.</span></span>  
  
 <span data-ttu-id="f1660-119">리소스를 정의한 다음 키 이름을 지정하는 리소스 태그 확장 구문을 사용하여 속성에 사용되도록 해당 리소스를 참조할 수 있습니다. 예를 들어 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-119">After you define a resource, you can reference the resource to be used for a property value by using a resource markup extension syntax that specifies the key name, for example:</span></span>  
  
 [!code-xaml[FEResourceSH_snip#KeyNameUsage](../../../../samples/snippets/csharp/VS_Snippets_Wpf/FEResourceSH_snip/CS/page2.xaml#keynameusage)]  
  
 <span data-ttu-id="f1660-120">앞의 예제에서 때를 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] 값을 처리 하는 로더 `{StaticResource MyBrush}` 에 대 한 합니다 <xref:System.Windows.Controls.Control.Background%2A> 속성을 <xref:System.Windows.Controls.Button>, 리소스 조회 논리에 대 한 리소스 사전을 먼저 확인는 <xref:System.Windows.Controls.Button> 요소.</span><span class="sxs-lookup"><span data-stu-id="f1660-120">In the preceding example, when the [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] loader processes the value `{StaticResource MyBrush}` for the <xref:System.Windows.Controls.Control.Background%2A> property on <xref:System.Windows.Controls.Button>, the resource lookup logic first checks the resource dictionary for the <xref:System.Windows.Controls.Button> element.</span></span> <span data-ttu-id="f1660-121">하는 경우 <xref:System.Windows.Controls.Button> 리소스 키의 정의 되지 않은 `MyBrush` (하지 않는; 해당 리소스 컬렉션이 비어)의 부모 요소를 다음 확인 하는 조회 <xref:System.Windows.Controls.Button>는 <xref:System.Windows.Controls.Page>합니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-121">If <xref:System.Windows.Controls.Button> does not have a definition of the resource key `MyBrush` (it does not; its resource collection is empty), the lookup next checks the parent element of <xref:System.Windows.Controls.Button>, which is <xref:System.Windows.Controls.Page>.</span></span> <span data-ttu-id="f1660-122">따라서에서 정의할 때 리소스를 <xref:System.Windows.Controls.Page> 루트 요소, 논리 트리의 모든 요소를 <xref:System.Windows.Controls.Page> 후에 액세스할 수 있으며 허용 하는 모든 속성의 값을 설정에 대 한 동일한 리소스를 다시 사용할 수 있습니다는 <xref:System.Type> 는 리소스 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-122">Thus, when you define a resource on the <xref:System.Windows.Controls.Page> root element, all the elements in the logical tree of the <xref:System.Windows.Controls.Page> can access it, and you can reuse the same resource for setting the value of any property that accepts the <xref:System.Type> that the resource represents.</span></span> <span data-ttu-id="f1660-123">이전 예제에서는 동일한 `MyBrush` 서로 다른 두 속성을 설정 하는 리소스: 합니다 <xref:System.Windows.Controls.Control.Background%2A> 의 <xref:System.Windows.Controls.Button>, 및 <xref:System.Windows.Shapes.Shape.Fill%2A> 의 <xref:System.Windows.Shapes.Rectangle>입니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-123">In the previous example, the same `MyBrush` resource sets two different properties: the <xref:System.Windows.Controls.Control.Background%2A> of a <xref:System.Windows.Controls.Button>, and the <xref:System.Windows.Shapes.Shape.Fill%2A> of a <xref:System.Windows.Shapes.Rectangle>.</span></span>  
  
<a name="staticdynamic"></a>   
## <a name="static-and-dynamic-resources"></a><span data-ttu-id="f1660-124">정적 및 동적 리소스</span><span class="sxs-lookup"><span data-stu-id="f1660-124">Static and Dynamic Resources</span></span>  
 <span data-ttu-id="f1660-125">리소스는 정적 리소스 또는 동적 리소스로 참조될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-125">A resource can be referenced as either a static resource or a dynamic resource.</span></span> <span data-ttu-id="f1660-126">사용 하 여 이렇게 합니다 [StaticResource 태그 확장](../../../../docs/framework/wpf/advanced/staticresource-markup-extension.md) 또는 [DynamicResource 태그 확장](../../../../docs/framework/wpf/advanced/dynamicresource-markup-extension.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-126">This is done by using either the [StaticResource Markup Extension](../../../../docs/framework/wpf/advanced/staticresource-markup-extension.md) or the [DynamicResource Markup Extension](../../../../docs/framework/wpf/advanced/dynamicresource-markup-extension.md).</span></span> <span data-ttu-id="f1660-127">태그 확장의 기능은 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] 태그 확장이 특성 문자열을 처리 하 고 개체를 반환 하 여 개체 참조를 지정할 수 있습니다 차게 되는 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] 로더.</span><span class="sxs-lookup"><span data-stu-id="f1660-127">A markup extension is a feature of [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] whereby you can specify an object reference by having the markup extension process the attribute string and return the object to a [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] loader.</span></span> <span data-ttu-id="f1660-128">태그 확장 동작에 대 한 자세한 내용은 참조 하세요. [태그 확장 및 WPF XAML](../../../../docs/framework/wpf/advanced/markup-extensions-and-wpf-xaml.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-128">For more information about markup extension behavior, see [Markup Extensions and WPF XAML](../../../../docs/framework/wpf/advanced/markup-extensions-and-wpf-xaml.md).</span></span>  
  
 <span data-ttu-id="f1660-129">태그 확장을 사용하면 일반적으로 설정 중인 속성의 컨텍스트에서 평가되는 것이 아니라 특정 태그 확장을 통해 처리되는 문자열 형식으로 하나 이상의 매개 변수를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-129">When you use a markup extension, you typically provide one or more parameters in string form that are processed by that particular markup extension, rather than being evaluated in the context of the property being set.</span></span> <span data-ttu-id="f1660-130">합니다 [StaticResource 태그 확장](../../../../docs/framework/wpf/advanced/staticresource-markup-extension.md) 모든 사용 가능한 리소스 사전에서 해당 키에 대 한 값을 조회 하 여 키를 처리 합니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-130">The [StaticResource Markup Extension](../../../../docs/framework/wpf/advanced/staticresource-markup-extension.md) processes a key by looking up the value for that key in all available resource dictionaries.</span></span> <span data-ttu-id="f1660-131">이 작업은 로드 프로세스에서 정적 리소스 참조를 사용하는 속성 값을 할당해야 하는 시점인 로드 시에 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-131">This happens during loading, which is the point in time when the loading process needs to assign the property value that takes the static resource reference.</span></span> <span data-ttu-id="f1660-132">합니다 [DynamicResource 태그 확장](../../../../docs/framework/wpf/advanced/dynamicresource-markup-extension.md) 대신 프로세스는 응용 프로그램이 실제로 실행 될 때까지 식과 해당 식을 만들어 키 확인 되지 않은 유지, 이때 식이 평가 되 고 값을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-132">The [DynamicResource Markup Extension](../../../../docs/framework/wpf/advanced/dynamicresource-markup-extension.md) instead processes a key by creating an expression, and that expression remains unevaluated until the application is actually run, at which time the expression is evaluated and provides a value.</span></span>  
  
 <span data-ttu-id="f1660-133">리소스를 참조할 때 정적 리소스 참조를 사용하는지 아니면 동적 리소스 참조를 사용하는지에 상관없이 영향을 미칠 수 있는 고려 사항은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-133">When you reference a resource, the following considerations can influence whether you use a static resource reference or a dynamic resource reference:</span></span>  
  
-   <span data-ttu-id="f1660-134">응용 프로그램에 대해 만든 리소스의 전반적인 디자인 (페이지당, 응용 프로그램에서 느슨한 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]를 리소스 전용 어셈블리에서).</span><span class="sxs-lookup"><span data-stu-id="f1660-134">The overall design of how you create the resources for your application (per page, in the application, in loose [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)], in a resource only assembly).</span></span>  
  
-   <span data-ttu-id="f1660-135">응용 프로그램 기능: 응용 프로그램 요구 사항의 일부로서 실시간으로 리소스 업데이트.</span><span class="sxs-lookup"><span data-stu-id="f1660-135">The application functionality: is updating resources in real time part of your application requirements?</span></span>  
  
-   <span data-ttu-id="f1660-136">해당 리소스 참조 형식의 각 조회 동작.</span><span class="sxs-lookup"><span data-stu-id="f1660-136">The respective lookup behavior of that resource reference type.</span></span>  
  
-   <span data-ttu-id="f1660-137">특정 속성 또는 리소스 형식 및 해당 형식의 기본 동작.</span><span class="sxs-lookup"><span data-stu-id="f1660-137">The particular property or resource type, and the native behavior of those types.</span></span>  
  
### <a name="static-resources"></a><span data-ttu-id="f1660-138">정적 리소스</span><span class="sxs-lookup"><span data-stu-id="f1660-138">Static Resources</span></span>  
 <span data-ttu-id="f1660-139">정적 리소스 참조는 다음 환경에 가장 적합합니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-139">Static resource references work best for the following circumstances:</span></span>  
  
-   <span data-ttu-id="f1660-140">응용 프로그램 디자인에서는 대부분의 리소스를 페이지나 응용 프로그램 수준 리소스 사전에 집중합니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-140">Your application design concentrates most of all of its resources into page or application level resource dictionaries.</span></span> <span data-ttu-id="f1660-141">정적 리소스 참조는 페이지 다시 로드와 같은 런타임 동작을 기반으로 다시 평가하지 않으므로, 리소스와 응용 프로그램 디자인별로 필요하지 않을 때 다수의 동적 리소스 참조를 사용하지 않을 수 있다는 성능상의 이점이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-141">Static resource references are not reevaluated based on runtime behaviors such as reloading a page, and therefore there can be some performance benefit to avoiding large numbers of dynamic resource references when they are not necessary per your resource and application design.</span></span>  
  
-   <span data-ttu-id="f1660-142">에 있지 않은 속성의 값을 설정 하는 한 <xref:System.Windows.DependencyObject> 또는 <xref:System.Windows.Freezable>합니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-142">You are setting the value of a property that is not on a <xref:System.Windows.DependencyObject> or a <xref:System.Windows.Freezable>.</span></span>  
  
-   <span data-ttu-id="f1660-143">DLL로 컴파일되고 응용 프로그램의 일부로 컴파일되거나 응용 프로그램에 공유될 리소스 사전을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-143">You are creating a resource dictionary that will be compiled into a DLL, and packaged as part of the application or shared between applications.</span></span>  
  
-   <span data-ttu-id="f1660-144">사용자 지정 컨트롤의 테마를 만들고 테마에서 사용되는 리소스를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-144">You are creating a theme for a custom control, and are defining resources that are used within the themes.</span></span> <span data-ttu-id="f1660-145">이 경우 일반적으로 동적 리소스 참조 조회 동작을 사용하지 않습니다. 대신, 조회가 예측 가능하고 테마에 자체 포함되도록 정적 리소스 참조 동작을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-145">For this case, you typically do not want the dynamic resource reference lookup behavior, you instead want the static resource reference behavior so that the lookup is predictable and self-contained to the theme.</span></span> <span data-ttu-id="f1660-146">동적 리소스 참조를 사용하면, 테마에 있는 참조까지도 런타임 시까지 평가되지 않은 상태로 남아 있게 되며, 테마를 적용할 때 일부 요소에서 테마가 참조하려는 키를 재정의하고 조회에서 로컬 요소가 테마 자체보다 앞에 옵니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-146">With a dynamic resource reference, even a reference within a theme is left unevaluated until runtime, and there is a chance that when the theme is applied, some local element will redefine a key that your theme is trying to reference, and the local element will fall prior to the theme itself in the lookup.</span></span> <span data-ttu-id="f1660-147">이 경우 테마가 예상대로 작동하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-147">If that happens, your theme will not behave in an expected manner.</span></span>  
  
-   <span data-ttu-id="f1660-148">리소스를 사용하여 다수의 종속성 속성을 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-148">You are using resources to set large numbers of dependency properties.</span></span> <span data-ttu-id="f1660-149">종속성 속성에는 속성 시스템에서 사용하게 설정한 유효 값이 캐싱이 있습니다. 따라서 로드 시 평가될 수 있는 종속성 속성의 값을 제공하는 경우, 종속성 속성에서 재평가된 식을 확인하지 않아도 되며 마지막 유효 값을 반환할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-149">Dependency properties have effective value caching as enabled by the property system, so if you provide a value for a dependency property that can be evaluated at load time, the dependency property does not have to check for a reevaluated expression and can return the last effective value.</span></span> <span data-ttu-id="f1660-150">이 기술을 사용하면 성능상의 이점이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-150">This technique can be a performance benefit.</span></span>  
  
-   <span data-ttu-id="f1660-151">모든 소비자에 대 한 기본 리소스를 변경 하려면 또는 사용 하 여 각 소비자의 별도 작성 가능 인스턴스를 유지 하려는 합니다 [x: 공유 특성](../../../../docs/framework/xaml-services/x-shared-attribute.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-151">You want to change the underlying resource for all consumers, or you want to maintain separate writable instances for each consumer by using the [x:Shared Attribute](../../../../docs/framework/xaml-services/x-shared-attribute.md).</span></span>  
  
#### <a name="static-resource-lookup-behavior"></a><span data-ttu-id="f1660-152">정적 리소스 조회 동작</span><span class="sxs-lookup"><span data-stu-id="f1660-152">Static resource lookup behavior</span></span>  
  
1.  <span data-ttu-id="f1660-153">조회 프로세스가 속성을 설정하는 요소를 통해 정의된 리소스 사전에서 요청된 키를 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-153">The lookup process checks for the requested key within the resource dictionary defined by the element that sets the property.</span></span>  
  
2.  <span data-ttu-id="f1660-154">그런 다음 조회 프로세스가 논리 트리를 상향식으로 통과하여 부모 요소와 해당 리소스 사전으로 이동합니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-154">The lookup process then traverses the logical tree upward, to the parent element and its resource dictionary.</span></span> <span data-ttu-id="f1660-155">이 작업은 루트 요소에 도달할 때까지 계속됩니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-155">This continues until the root element is reached.</span></span>  
  
3.  <span data-ttu-id="f1660-156">다음으로 응용 프로그램 리소스를 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-156">Next, application resources are checked.</span></span> <span data-ttu-id="f1660-157">응용 프로그램 리소스는 리소스 사전에서 정의한 내에서 리소스를 <xref:System.Windows.Application> 개체에 대 한 프로그램 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 응용 프로그램입니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-157">Application resources are those resources within the resource dictionary that is defined by the <xref:System.Windows.Application> object for your [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] application.</span></span>  
  
 <span data-ttu-id="f1660-158">리소스 사전 내의 정적 리소스 참조는 리소스 참조 전에 사전순으로 이미 정의된 리소스를 참조해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-158">Static resource references from within a resource dictionary must reference a resource that has already been defined lexically before the resource reference.</span></span> <span data-ttu-id="f1660-159">전방 참조는 정적 리소스 참조로 확인할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-159">Forward references cannot be resolved by a static resource reference.</span></span> <span data-ttu-id="f1660-160">따라서 정적 리소스 참조를 사용하는 경우, 리소스별 용도에 맞게 리소스를 각 리소스 사전의 시작 부분에 정의하도록 리소스 사전 구조를 디자인해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-160">For this reason, if you use static resource references, you must design your resource dictionary structure such that resources intended for by-resource use are defined at or near the beginning of each respective resource dictionary.</span></span>  
  
 <span data-ttu-id="f1660-161">정적 리소스 조회 테마 또는 시스템 리소스로 확장 될 수 있지만이 때문에 지원 합니다 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] 로더에서 요청을 지연 합니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-161">Static resource lookup can extend into themes, or into system resources, but this is supported only because the [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] loader defers the request.</span></span> <span data-ttu-id="f1660-162">페이지가 로드될 때 런타임 테마가 응용 프로그램에 적절하게 적용되기 위해 지연이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-162">The deferral is necessary so that the runtime theme at the time the page loads applies properly to the application.</span></span> <span data-ttu-id="f1660-163">그러나 테마에만 존재하거나 시스템 리소스로 존재하는 것으로 알려진 키의 정적 리소스 참조는 사용하지 않는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-163">However, static resource references to keys that are known to only exist in themes or as system resources are not recommended.</span></span> <span data-ttu-id="f1660-164">사용자가 실시간으로 테마를 변경하는 경우 해당 참조가 다시 평가되지 않기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-164">This is because such references are not reevaluated if the theme is changed by the user in realtime.</span></span> <span data-ttu-id="f1660-165">동적 리소스 참조는 테마나 시스템 리소스를 요청할 때 더욱 안정적입니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-165">A dynamic resource reference is more reliable when you request theme or system resources.</span></span> <span data-ttu-id="f1660-166">테마 요소 자체가 다른 리소스를 요청할 때는 예외입니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-166">The exception is when a theme element itself requests another resource.</span></span> <span data-ttu-id="f1660-167">이러한 참조는 앞서 설명한 이유때문에 정적 리소스 참조여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-167">These references should be static resource references, for the reasons mentioned earlier.</span></span>  
  
 <span data-ttu-id="f1660-168">정적 리소스 참조가 없으면 다양한 예외 동작이 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-168">The exception behavior if a static resource reference is not found varies.</span></span> <span data-ttu-id="f1660-169">리소스가 지연되면 런타임 시 예외가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-169">If the resource was deferred, then the exception occurs at runtime.</span></span> <span data-ttu-id="f1660-170">리소스가 지연되지 않으면 로드 시 예외가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-170">If the resource was not deferred, the exception occurs at load time.</span></span>  
  
### <a name="dynamic-resources"></a><span data-ttu-id="f1660-171">동적 리소스</span><span class="sxs-lookup"><span data-stu-id="f1660-171">Dynamic Resources</span></span>  
 <span data-ttu-id="f1660-172">동적 리소스는 다음과 같은 환경에 가장 적합합니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-172">Dynamic resources work best for the following circumstances:</span></span>  
  
-   <span data-ttu-id="f1660-173">리소스 값은 런타임 시까지 알려지지 않은 조건에 따라 달라집니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-173">The value of the resource depends on conditions that are not known until runtime.</span></span> <span data-ttu-id="f1660-174">여기에는 시스템 리소스 또는 사용자가 설정 가능한 리소스가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-174">This includes system resources, or resources that are otherwise user settable.</span></span> <span data-ttu-id="f1660-175">예를 들어로 노출 시스템 속성을 참조 하는 setter 값 만들 수 있습니다 <xref:System.Windows.SystemColors>, <xref:System.Windows.SystemFonts>, 또는 <xref:System.Windows.SystemParameters>합니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-175">For example, you can create setter values that refer to system properties, as exposed by <xref:System.Windows.SystemColors>, <xref:System.Windows.SystemFonts>, or <xref:System.Windows.SystemParameters>.</span></span> <span data-ttu-id="f1660-176">이러한 값은 궁극적으로 운영 체제와 사용자의 런타임 환경에서 오므로 정말로 동적입니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-176">These values are truly dynamic because they ultimately come from the runtime environment of the user and operating system.</span></span> <span data-ttu-id="f1660-177">변경할 수 있는 응용 프로그램 수준 테마도 있습니다. 이 경우 페이지 수준 리소스 액세스를 통해서도 변경 사항을 캡처해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-177">You might also have application-level themes that can change, where page-level resource access must also capture the change.</span></span>  
  
-   <span data-ttu-id="f1660-178">사용자 지정 컨트롤의 테마 스타일을 만들거나 참조합니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-178">You are creating or referencing theme styles for a custom control.</span></span>  
  
-   <span data-ttu-id="f1660-179">콘텐츠를 조정 하려는 <xref:System.Windows.ResourceDictionary> 응용 프로그램 수명 동안.</span><span class="sxs-lookup"><span data-stu-id="f1660-179">You intend to adjust the contents of a <xref:System.Windows.ResourceDictionary> during an application lifetime.</span></span>  
  
-   <span data-ttu-id="f1660-180">상호 종속된 복잡한 리소스 구조체 가 있으며, 이 경우에는 전방 참조가 필요할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-180">You have a complicated resource structure that has interdependencies, where a forward reference may be required.</span></span> <span data-ttu-id="f1660-181">정적 리소스 참조는 전방 참조를 지원 하지 않습니다 하지만 동적 리소스 참조에서는 이러한 리소스는 런타임 시까지 계산할 필요가 없기 때문에 전방 참조 하므로 하지 관련 개념이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-181">Static resource references do not support forward references, but dynamic resource references do support them because the resource does not need to be evaluated until runtime, and forward references are therefore not a relevant concept.</span></span>  
  
-   <span data-ttu-id="f1660-182">컴파일 또는 작업 집합 면에서 특히 큰 리소스를 참조하며, 페이지를 로드할 때 즉시 리소스를 사용하지 않을 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-182">You are referencing a resource that is particularly large from the perspective of a compile or working set, and the resource might not be used immediately when the page loads.</span></span> <span data-ttu-id="f1660-183">정적 리소스 참조가 항상 로드 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] 페이지를 로드할 때; 있지만 동적 리소스 참조를 로드 하지 않습니다는 실제로 사용할 때까지 합니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-183">Static resource references always load from [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] when the page loads; however, a dynamic resource reference does not load until it is actually used.</span></span>  
  
-   <span data-ttu-id="f1660-184">setter 값이 테마나 다른 사용자 설정의 영향을 받는 다른 값에서 오는 스타일을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-184">You are creating a style where setter values might come from other values that are influenced by themes or other user settings.</span></span>  
  
-   <span data-ttu-id="f1660-185">응용 프로그램 수명 중에 논리 트리에서 다시 부모가 지정될 수 있는 요소에 리소스를 적용합니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-185">You are applying resources to elements that might be reparented in the logical tree during application lifetime.</span></span> <span data-ttu-id="f1660-186">부모를 변경하면 리소스 조회 범위도 변경될 수 있으므로, 부모가 재지정된 요소의 리소스를 새 범위에 따라 재평가하려면 항상 동적 리소스 참조를 사용하세요.</span><span class="sxs-lookup"><span data-stu-id="f1660-186">Changing the parent also potentially changes the resource lookup scope, so if you want the resource for a reparented element to be reevaluated based on the new scope, always use a dynamic resource reference.</span></span>  
  
#### <a name="dynamic-resource-lookup-behavior"></a><span data-ttu-id="f1660-187">동적 리소스 조회 동작</span><span class="sxs-lookup"><span data-stu-id="f1660-187">Dynamic resource lookup behavior</span></span>  
 <span data-ttu-id="f1660-188">동적 리소스 참조에 대 한 리소스 조회 동작 호출 하는 경우 코드의 조회 동작과 유사 <xref:System.Windows.FrameworkElement.FindResource%2A> 또는 <xref:System.Windows.FrameworkElement.SetResourceReference%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-188">Resource lookup behavior for a dynamic resource reference parallels the lookup behavior in your code if you call <xref:System.Windows.FrameworkElement.FindResource%2A> or <xref:System.Windows.FrameworkElement.SetResourceReference%2A>.</span></span>  
  
1.  <span data-ttu-id="f1660-189">조회 프로세스가 속성을 설정하는 요소를 통해 정의된 리소스 사전에서 요청된 키를 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-189">The lookup process checks for the requested key within the resource dictionary defined by the element that sets the property.</span></span>  
  
    -   <span data-ttu-id="f1660-190">요소를 정의 하는 경우는 <xref:System.Windows.FrameworkElement.Style%2A> 속성을 <xref:System.Windows.Style.Resources%2A> 사전 내에서 <xref:System.Windows.Style> 확인란이 선택 되어.</span><span class="sxs-lookup"><span data-stu-id="f1660-190">If the element defines a <xref:System.Windows.FrameworkElement.Style%2A> property, the <xref:System.Windows.Style.Resources%2A> dictionary within the <xref:System.Windows.Style> is checked.</span></span>  
  
    -   <span data-ttu-id="f1660-191">요소를 정의 하는 경우는 <xref:System.Windows.Controls.Control.Template%2A> 속성을 <xref:System.Windows.FrameworkTemplate.Resources%2A> 사전 내에서 <xref:System.Windows.FrameworkTemplate> 확인란이 선택 되어.</span><span class="sxs-lookup"><span data-stu-id="f1660-191">If the element defines a <xref:System.Windows.Controls.Control.Template%2A> property, the <xref:System.Windows.FrameworkTemplate.Resources%2A> dictionary within the <xref:System.Windows.FrameworkTemplate> is checked.</span></span>  
  
2.  <span data-ttu-id="f1660-192">그런 다음 조회 프로세스가 논리 트리를 상향식으로 통과하여 부모 요소와 해당 리소스 사전으로 이동합니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-192">The lookup process then traverses the logical tree upward, to the parent element and its resource dictionary.</span></span> <span data-ttu-id="f1660-193">이 작업은 루트 요소에 도달할 때까지 계속됩니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-193">This continues until the root element is reached.</span></span>  
  
3.  <span data-ttu-id="f1660-194">다음으로 응용 프로그램 리소스를 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-194">Next, application resources are checked.</span></span> <span data-ttu-id="f1660-195">응용 프로그램 리소스는 리소스 사전에서 정의한 내에서 리소스를 <xref:System.Windows.Application> 개체에 대 한 프로그램 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 응용 프로그램입니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-195">Application resources are those resources within the resource dictionary that is defined by the <xref:System.Windows.Application> object for your [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] application.</span></span>  
  
4.  <span data-ttu-id="f1660-196">현재 활성 테마의 테마 리소스 사전을 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-196">Theme resource dictionary is checked, for the currently active theme.</span></span> <span data-ttu-id="f1660-197">런타임 시 테마가 변경되면 값을 재평가합니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-197">If the theme changes at runtime, the value is reevaluated.</span></span>  
  
5.  <span data-ttu-id="f1660-198">시스템 리소스를 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-198">System resources are checked.</span></span>  
  
 <span data-ttu-id="f1660-199">예외 동작이 있는 경우 다음과 같이 다양합니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-199">Exception behavior (if any) varies:</span></span>  
  
-   <span data-ttu-id="f1660-200">리소스에서 요청한 경우를 <xref:System.Windows.FrameworkElement.FindResource%2A> 를 호출 하 고 찾을 수 없습니다, 예외가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-200">If a resource was requested by a <xref:System.Windows.FrameworkElement.FindResource%2A> call, and was not found, an exception is raised.</span></span>  
  
-   <span data-ttu-id="f1660-201">리소스에서 요청한 경우는 <xref:System.Windows.FrameworkElement.TryFindResource%2A> 를 호출 하 고 찾을 수 없습니다, 예외가 발생 하지 않지만 반환된 값은 `null`합니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-201">If a resource was requested by a <xref:System.Windows.FrameworkElement.TryFindResource%2A> call, and was not found, no exception is raised, but the returned value is `null`.</span></span> <span data-ttu-id="f1660-202">설정 되는 속성을 허용 하지 않는 경우 `null`는 심층 예외가 발생할 수 있습니다 (이에 따라 달라 집니다 설정 되는 개별 속성).</span><span class="sxs-lookup"><span data-stu-id="f1660-202">If the property being set does not accept `null`, then it is still possible that a deeper exception will be raised (this depends on the individual property being set).</span></span>  
  
-   <span data-ttu-id="f1660-203">리소스에 대 한 동적 리소스 참조를 요청한 경우 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)], 및 찾지 다음 동작을 일반 속성 시스템에에 따라 달라 지지만 일반적인 동작은 것 처럼 속성 설정 작업이 수행 되지 않은 리소스가 있는 수준입니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-203">If a resource was requested by a dynamic resource reference in [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)], and was not found, then the behavior depends on the general property system, but the general behavior is as if no property setting operation occurred at the level where the resource exists.</span></span> <span data-ttu-id="f1660-204">예를 들어, 평가할 수 없는 리소스를 사용하여 개별 단추 요소에서 배경을 설정하려고 하면 값 집합이 생기지 않지만, 속성 시스템 및 값 우선 순위의 다른 참가자로부터 유효 값을 여전히 가져올 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-204">For instance, if you attempt to set the background on a an individual button element using a resource that could not be evaluated, then no value set results, but the effective value can still come from other participants in the property system and value precedence.</span></span> <span data-ttu-id="f1660-205">예를 들어, 배경색은 로컬에 정의한 단추 스타일 또는 테마 스타일에서 여전히 가져올 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-205">For instance, the background value might still come from a locally defined button style, or from the theme style.</span></span> <span data-ttu-id="f1660-206">테마 스타일이 정의하지 않은 속성의 경우, 실패한 리소스 평가 후 유효 값은 속성 메타데이터의 기본값에서 가져올 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-206">For properties that are not defined by theme styles, the effective value after a failed resource evaluation might come from the default value in the property metadata.</span></span>  
  
#### <a name="restrictions"></a><span data-ttu-id="f1660-207">제한</span><span class="sxs-lookup"><span data-stu-id="f1660-207">Restrictions</span></span>  
 <span data-ttu-id="f1660-208">동적 리소스 참조에는 몇 가지 주목할 만한 제한 사항이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-208">Dynamic resource references have some notable restrictions.</span></span> <span data-ttu-id="f1660-209">다음 중 하나 이상이 참이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-209">At least one of the following must be true:</span></span>  
  
-   <span data-ttu-id="f1660-210">설정 되는 속성의 속성 이어야 합니다는 <xref:System.Windows.FrameworkElement> 또는 <xref:System.Windows.FrameworkContentElement>합니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-210">The property being set must be a property on a <xref:System.Windows.FrameworkElement> or <xref:System.Windows.FrameworkContentElement>.</span></span> <span data-ttu-id="f1660-211">속성에서 백업 해야 하는 <xref:System.Windows.DependencyProperty>합니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-211">That property must be backed by a <xref:System.Windows.DependencyProperty>.</span></span>  
  
-   <span data-ttu-id="f1660-212">내의 값에 대 한 참조 되는 <xref:System.Windows.Style> <xref:System.Windows.Setter>합니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-212">The reference is for a value within a <xref:System.Windows.Style><xref:System.Windows.Setter>.</span></span>  
  
-   <span data-ttu-id="f1660-213">설정 되는 속성의 속성 이어야 합니다는 <xref:System.Windows.Freezable> 값으로 제공 되는 <xref:System.Windows.FrameworkElement> 또는 <xref:System.Windows.FrameworkContentElement> 속성인 또는 <xref:System.Windows.Setter> 값입니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-213">The property being set must be a property on a <xref:System.Windows.Freezable> that is provided as a value of either a <xref:System.Windows.FrameworkElement> or <xref:System.Windows.FrameworkContentElement> property, or a <xref:System.Windows.Setter> value.</span></span>  
  
 <span data-ttu-id="f1660-214">설정 되는 속성 이어야 하므로 <xref:System.Windows.DependencyProperty> 또는 <xref:System.Windows.Freezable> 속성, 속성 변경 (변경 된 동적 리소스 값) 속성 시스템에 의해 승인 되기 때문에 UI에 대부분의 속성 변경 내용을 전파할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-214">Because the property being set must be a <xref:System.Windows.DependencyProperty> or <xref:System.Windows.Freezable> property, most property changes can propagate to UI because a property change (the changed dynamic resource value) is acknowledged by the property system.</span></span> <span data-ttu-id="f1660-215">대부분의 컨트롤 포함 하는 경우 컨트롤의 다른 레이아웃에 적용 됩니다는 논리는 <xref:System.Windows.DependencyProperty> 변경 내용 및 속성이 레이아웃에 영향을 줄 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-215">Most controls include logic that will force another layout of a control if a <xref:System.Windows.DependencyProperty> changes and that property might affect layout.</span></span> <span data-ttu-id="f1660-216">그러나 속성 중 일부만 있는 [DynamicResource 태그 확장](../../../../docs/framework/wpf/advanced/dynamicresource-markup-extension.md) 해당 값으로 UI에 실시간으로에서 업데이트 하는 방식으로 값을 제공 하도록 보장 합니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-216">However, not all properties that have a [DynamicResource Markup Extension](../../../../docs/framework/wpf/advanced/dynamicresource-markup-extension.md) as their value are guaranteed to provide the value in such a way that they update in realtime in the UI.</span></span> <span data-ttu-id="f1660-217">이 기능은 속성 외에도 속성을 소유하는 형식, 심지어는 응용 프로그램의 논리 구조체에 따라서도 여전히 달라질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-217">That functionality still might vary depending on the property, as well as depending on the type that owns the property, or even the logical structure of your application.</span></span>  
  
<a name="stylesimplicitkeys"></a>   
## <a name="styles-datatemplates-and-implicit-keys"></a><span data-ttu-id="f1660-218">스타일, DataTemplates 및 암시적 키</span><span class="sxs-lookup"><span data-stu-id="f1660-218">Styles, DataTemplates, and Implicit Keys</span></span>  
 <span data-ttu-id="f1660-219">에 있는 모든 항목이 한다고 설명 했습니다 이전에 <xref:System.Windows.ResourceDictionary> 키가 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-219">Earlier, it was stated that all items in a <xref:System.Windows.ResourceDictionary> must have a key.</span></span> <span data-ttu-id="f1660-220">그러나 의미는 아닙니다 리소스를 모두 명시적 있어야 `x:Key`합니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-220">However, that does not mean that all resources must have an explicit `x:Key`.</span></span> <span data-ttu-id="f1660-221">리소스로 정의된 경우 여러 개체 형식에서 암시적 키를 지원하며, 이 경우 키 값이 다른 속성의 값과 연결됩니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-221">Several object types support an implicit key when defined as a resource, where the key value is tied to the value of another property.</span></span> <span data-ttu-id="f1660-222">반면 알려진 암시적 키로이 `x:Key` 특성은 명시적 키입니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-222">This is known as an implicit key, whereas an `x:Key` attribute is an explicit key.</span></span> <span data-ttu-id="f1660-223">명시적 키를 지정하여 암시적 키를 덮어쓸 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-223">You can overwrite any implicit key by specifying an explicit key.</span></span>  
  
 <span data-ttu-id="f1660-224">리소스에 대 한 한 가지 매우 중요 한 시나리오는 정의 하는 경우는 <xref:System.Windows.Style>합니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-224">One very important scenario for resources is when you define a <xref:System.Windows.Style>.</span></span> <span data-ttu-id="f1660-225">실제로 <xref:System.Windows.Style> 거의 항상 기본적으로 다시 사용할 수 있도록 스타일은 때문에 리소스 사전에 항목으로 정의 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-225">In fact, a <xref:System.Windows.Style> is almost always defined as an entry in a resource dictionary, because styles are inherently intended for reuse.</span></span> <span data-ttu-id="f1660-226">스타일에 대 한 자세한 내용은 참조 하세요. [스타일 및 템플릿](../../../../docs/framework/wpf/controls/styling-and-templating.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-226">For more information about styles, see [Styling and Templating](../../../../docs/framework/wpf/controls/styling-and-templating.md).</span></span>  
  
 <span data-ttu-id="f1660-227">컨트롤의 스타일은 암시적 키로 만들어 참조될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-227">Styles for controls can be both created with and referenced with an implicit key.</span></span> <span data-ttu-id="f1660-228">컨트롤의 기본 모양을 정의하는 테마 스타일은 이 암시적 키에 따라 달라집니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-228">The theme styles that define the default appearance of a control rely on this implicit key.</span></span> <span data-ttu-id="f1660-229">요청 관점에서 암시적 키는 <xref:System.Type> 컨트롤 자체입니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-229">The implicit key from the standpoint of requesting it is the <xref:System.Type> of the control itself.</span></span> <span data-ttu-id="f1660-230">리소스를 정의 하는 관점에서 암시적 키는 <xref:System.Windows.Style.TargetType%2A> 스타일입니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-230">The implicit key from the standpoint of defining the resource is the <xref:System.Windows.Style.TargetType%2A> of the style.</span></span> <span data-ttu-id="f1660-231">따라서 사용자 지정 컨트롤에 테마를 만드는 경우 기존 테마 스타일과 상호 작용 하는 스타일을 만드는 있습니다 필요가 없습니다 지정 하는 [X:key 지시문](../../../../docs/framework/xaml-services/x-key-directive.md) 에 대 한 <xref:System.Windows.Style>합니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-231">Therefore, if you are creating themes for custom controls, creating styles that interact with existing theme styles, you do not need to specify an [x:Key Directive](../../../../docs/framework/xaml-services/x-key-directive.md) for that <xref:System.Windows.Style>.</span></span> <span data-ttu-id="f1660-232">테마로 지정된 스타일을 사용하려면 스타일을 전혀 지정하지 않아도 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-232">And if you want to use the themed styles, you do not need to specify any style at all.</span></span> <span data-ttu-id="f1660-233">다음 스타일 정의 하더라도 작동 되는 예를 들어를 <xref:System.Windows.Style> 리소스 키가 표시 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-233">For instance, the following style definition works, even though the <xref:System.Windows.Style> resource does not appear to have a key:</span></span>  
  
 [!code-xaml[FEResourceSH_snip#ImplicitStyle](../../../../samples/snippets/csharp/VS_Snippets_Wpf/FEResourceSH_snip/CS/page2.xaml#implicitstyle)]  
  
 <span data-ttu-id="f1660-234">스타일 실제로 키가: 암시적 키는 `typeof(` <xref:System.Windows.Controls.Button> `)`합니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-234">That style really does have a key: the implicit key `typeof(`<xref:System.Windows.Controls.Button>`)`.</span></span> <span data-ttu-id="f1660-235">태그를 지정할 수 있습니다는 <xref:System.Windows.Style.TargetType%2A> 형식으로 직접 이름 (또는 필요에 따라 사용할 수 있습니다 [{x: Type...}](../../../../docs/framework/xaml-services/x-type-markup-extension.md)</span><span class="sxs-lookup"><span data-stu-id="f1660-235">In markup, you can specify a <xref:System.Windows.Style.TargetType%2A> directly as the type name (or you can optionally use [{x:Type...}](../../../../docs/framework/xaml-services/x-type-markup-extension.md)</span></span> <span data-ttu-id="f1660-236">반환할는 <xref:System.Type>합니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-236">to return a <xref:System.Type>.</span></span>  
  
 <span data-ttu-id="f1660-237">사용 하는 기본 테마 스타일 메커니즘을 통해 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], 스타일의 런타임 스타일으로 적용 되지 않음을 <xref:System.Windows.Controls.Button> 페이지에서도 합니다 <xref:System.Windows.Controls.Button> 자체를 지정 하지 않습니다 해당 <xref:System.Windows.FrameworkElement.Style%2A> 속성 또는 특정 리소스 스타일에 대 한 참조입니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-237">Through the default theme style mechanisms used by [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], that style is applied as the runtime style of a <xref:System.Windows.Controls.Button> on the page, even though the <xref:System.Windows.Controls.Button> itself does not attempt to specify its <xref:System.Windows.FrameworkElement.Style%2A> property or a specific resource reference to the style.</span></span> <span data-ttu-id="f1660-238">페이지에 정의 된 스타일은 테마 사전 스타일에는 동일한 키를 사용 하 여 테마 사전 스타일 보다 조회 시퀀스 앞 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-238">Your style defined in the page is found earlier in the lookup sequence than the theme dictionary style, using the same key that the theme dictionary style has.</span></span> <span data-ttu-id="f1660-239">만 지정할 수 있습니다 `<Button>Hello</Button>` 어디에 페이지를 사용 하 여 정의 된 스타일 <xref:System.Windows.Style.TargetType%2A> 의 `Button` 해당 단추에 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-239">You could just specify `<Button>Hello</Button>` anywhere in the page, and the style you defined with <xref:System.Windows.Style.TargetType%2A> of `Button` would apply to that button.</span></span> <span data-ttu-id="f1660-240">동일한 형식 값을 사용 하 여 스타일을 명시적으로 키를 <xref:System.Windows.Style.TargetType%2A>에 있지만 태그에서 명확 하 게는 선택 사항입니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-240">If you want, you can still explicitly key the style with the same type value as <xref:System.Windows.Style.TargetType%2A>, for clarity in your markup, but that is optional.</span></span>  
  
 <span data-ttu-id="f1660-241">암시적 키는 스타일의 경우 컨트롤에 적용 되지 않습니다 <xref:System.Windows.FrameworkElement.OverridesDefaultStyle%2A> 됩니다 `true` (또한 <xref:System.Windows.FrameworkElement.OverridesDefaultStyle%2A> 대신 명시적으로 컨트롤의 인스턴스 컨트롤 클래스에 대 한 기본 동작의 일부로 설정할 수 있습니다).</span><span class="sxs-lookup"><span data-stu-id="f1660-241">Implicit keys for styles do not apply on a control if <xref:System.Windows.FrameworkElement.OverridesDefaultStyle%2A> is `true` (also note that <xref:System.Windows.FrameworkElement.OverridesDefaultStyle%2A> might be set as part of native behavior for the control class, rather than explicitly on an instance of the control).</span></span> <span data-ttu-id="f1660-242">또한 파생 된 클래스 시나리오에 대 한 암시적 키를 지원 하기 위해 컨트롤 재정의 해야 합니다 <xref:System.Windows.FrameworkElement.DefaultStyleKey%2A> (모든 기존 컨트롤의 일부로 제공 된 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 이 작업을 수행).</span><span class="sxs-lookup"><span data-stu-id="f1660-242">Also, in order to support implicit keys for derived class scenarios, the control must override <xref:System.Windows.FrameworkElement.DefaultStyleKey%2A> (all existing controls provided as part of [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] do this).</span></span> <span data-ttu-id="f1660-243">스타일, 테마 및 컨트롤 디자인에 대 한 자세한 내용은 참조 하세요. [컨트롤을 디자인 하기 위한 지침](../../../../docs/framework/wpf/controls/guidelines-for-designing-stylable-controls.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-243">For more information about styles, themes, and control design, see [Guidelines for Designing Stylable Controls](../../../../docs/framework/wpf/controls/guidelines-for-designing-stylable-controls.md).</span></span>  
  
 <span data-ttu-id="f1660-244"><xref:System.Windows.DataTemplate> 암시적 키가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-244"><xref:System.Windows.DataTemplate> also has an implicit key.</span></span> <span data-ttu-id="f1660-245">에 대 한 암시적 키를 <xref:System.Windows.DataTemplate> 는 <xref:System.Windows.DataTemplate.DataType%2A> 속성 값입니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-245">The implicit key for a <xref:System.Windows.DataTemplate> is the <xref:System.Windows.DataTemplate.DataType%2A> property value.</span></span> <span data-ttu-id="f1660-246"><xref:System.Windows.DataTemplate.DataType%2A> 명시적으로 사용 하는 것이 아니라 형식의 이름으로 지정할 수도 있습니다 [{x: Type...} ](../../../../docs/framework/xaml-services/x-type-markup-extension.md).</span><span class="sxs-lookup"><span data-stu-id="f1660-246"><xref:System.Windows.DataTemplate.DataType%2A> can also be specified as the name of the type rather than explicitly using [{x:Type...}](../../../../docs/framework/xaml-services/x-type-markup-extension.md).</span></span> <span data-ttu-id="f1660-247">자세한 내용은 참조 하세요 [데이터 템플릿 개요](../../../../docs/framework/wpf/data/data-templating-overview.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="f1660-247">For details, see [Data Templating Overview](../../../../docs/framework/wpf/data/data-templating-overview.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="f1660-248">참고 항목</span><span class="sxs-lookup"><span data-stu-id="f1660-248">See Also</span></span>  
 <xref:System.Windows.ResourceDictionary>  
 [<span data-ttu-id="f1660-249">응용 프로그램 리소스</span><span class="sxs-lookup"><span data-stu-id="f1660-249">Application Resources</span></span>](../../../../docs/framework/wpf/advanced/optimizing-performance-application-resources.md)  
 [<span data-ttu-id="f1660-250">리소스 및 코드</span><span class="sxs-lookup"><span data-stu-id="f1660-250">Resources and Code</span></span>](../../../../docs/framework/wpf/advanced/resources-and-code.md)  
 [<span data-ttu-id="f1660-251">리소스 정의 및 참조</span><span class="sxs-lookup"><span data-stu-id="f1660-251">Define and Reference a Resource</span></span>](../../../../docs/framework/wpf/advanced/how-to-define-and-reference-a-resource.md)  
 [<span data-ttu-id="f1660-252">응용 프로그램 관리 개요</span><span class="sxs-lookup"><span data-stu-id="f1660-252">Application Management Overview</span></span>](../../../../docs/framework/wpf/app-development/application-management-overview.md)  
 [<span data-ttu-id="f1660-253">x:Type 태그 확장</span><span class="sxs-lookup"><span data-stu-id="f1660-253">x:Type Markup Extension</span></span>](../../../../docs/framework/xaml-services/x-type-markup-extension.md)  
 [<span data-ttu-id="f1660-254">StaticResource 태그 확장</span><span class="sxs-lookup"><span data-stu-id="f1660-254">StaticResource Markup Extension</span></span>](../../../../docs/framework/wpf/advanced/staticresource-markup-extension.md)  
 [<span data-ttu-id="f1660-255">DynamicResource 태그 확장</span><span class="sxs-lookup"><span data-stu-id="f1660-255">DynamicResource Markup Extension</span></span>](../../../../docs/framework/wpf/advanced/dynamicresource-markup-extension.md)

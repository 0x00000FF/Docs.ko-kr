---
title: WPF의 트리
ms.date: 03/30/2017
helpviewer_keywords:
- logical tree [WPF]
- element tree [WPF]
- visual tree [WPF]
ms.assetid: e83f25e5-d66b-4fc7-92d2-50130c9a6649
ms.openlocfilehash: 0dfae3a601a07c68b2dfe029f061dcf838e98af7
ms.sourcegitcommit: 944ddc52b7f2632f30c668815f92b378efd38eea
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 11/03/2019
ms.locfileid: "73459502"
---
# <a name="trees-in-wpf"></a><span data-ttu-id="ccfe8-102">WPF의 트리</span><span class="sxs-lookup"><span data-stu-id="ccfe8-102">Trees in WPF</span></span>
<span data-ttu-id="ccfe8-103">대부분의 기술에서 요소와 구성 요소는 트리 구조로 구성됩니다. 이 트리 구조에서 개발자는 트리의 개체 노드를 직접 조작하여 애플리케이션의 동작이나 렌더링에 영향을 줍니다.</span><span class="sxs-lookup"><span data-stu-id="ccfe8-103">In many technologies, elements and components are organized in a tree structure where developers directly manipulate the object nodes in the tree to affect the rendering or behavior of an application.</span></span> [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]<span data-ttu-id="ccfe8-104">에서도 여러 가지 트리 구조 메타포를 사용하여 프로그램 요소 간의 관계를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="ccfe8-104">also uses several tree structure metaphors to define relationships between program elements.</span></span> <span data-ttu-id="ccfe8-105">대부분 경우 WPF 개발자는 개념적으로 개체 트리 메타포를 고려하면서 코드로 애플리케이션을 만들거나 XAML로 애플리케이션의 일부를 정의할 수 있지만 XML DOM에서 사용할 수 있는 몇 가지 일반적인 개체 트리 조작 API 대신 특정 API를 호출하거나 특정 태그를 사용하여 이 작업을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="ccfe8-105">For the most part WPF developers can create an application in code or define portions of the application in XAML while thinking conceptually about the object tree metaphor, but will be calling specific API or using specific markup to do so rather than some general object tree manipulation API such as you might use in XML DOM.</span></span> <span data-ttu-id="ccfe8-106">WPF는 트리 메타포 뷰, <xref:System.Windows.LogicalTreeHelper> 및 <xref:System.Windows.Media.VisualTreeHelper>를 제공 하는 두 개의 도우미 클래스를 노출 합니다.</span><span class="sxs-lookup"><span data-stu-id="ccfe8-106">WPF exposes two helper classes that provide a tree metaphor view, <xref:System.Windows.LogicalTreeHelper> and <xref:System.Windows.Media.VisualTreeHelper>.</span></span> <span data-ttu-id="ccfe8-107">또한 WPF 설명서에서는 시각적 트리와 논리 트리라는 용어를 사용하는데 이러한 동일한 트리는 특정 주요 WPF 기능의 동작을 이해하는 데 유용하기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="ccfe8-107">The terms visual tree and logical tree are also used in the WPF documentation because these same trees are useful for understanding the behavior of certain key WPF features.</span></span> <span data-ttu-id="ccfe8-108">이 항목에서는 시각적 트리와 논리적 트리가 나타내는 항목을 정의 하 고, 이러한 트리가 전반적인 개체 트리 개념과 어떻게 관련 되는지를 설명 하 고, <xref:System.Windows.LogicalTreeHelper> 및 <xref:System.Windows.Media.VisualTreeHelper>를 소개 합니다.</span><span class="sxs-lookup"><span data-stu-id="ccfe8-108">This topic defines what the visual tree and logical tree represent, discusses how such trees relate to an overall object tree concept, and introduces <xref:System.Windows.LogicalTreeHelper> and <xref:System.Windows.Media.VisualTreeHelper>s.</span></span>  

<a name="element_tree"></a>   
## <a name="trees-in-wpf"></a><span data-ttu-id="ccfe8-109">WPF의 트리</span><span class="sxs-lookup"><span data-stu-id="ccfe8-109">Trees in WPF</span></span>  
 <span data-ttu-id="ccfe8-110">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]에서 가장 완벽한 트리 구조는 개체 트리입니다.</span><span class="sxs-lookup"><span data-stu-id="ccfe8-110">The most complete tree structure in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] is the object tree.</span></span> <span data-ttu-id="ccfe8-111">[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]에서 애플리케이션 페이지를 정의한 후 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]을 로드하는 경우 트리 구조는 태그에 있는 요소의 중첩 관계에 따라 만들어집니다.</span><span class="sxs-lookup"><span data-stu-id="ccfe8-111">If you define an application page in [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] and then load the [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)], the tree structure is created based on the nesting relationships of the elements in the markup.</span></span> <span data-ttu-id="ccfe8-112">코드에서 애플리케이션이나 애플리케이션 일부를 정의하는 경우 트리 구조는 지정된 개체에 대한 콘텐츠 모델을 구현하는 속성에 대해 속성 값을 할당하는 방법에 따라 만들어집니다.</span><span class="sxs-lookup"><span data-stu-id="ccfe8-112">If you define an application or a portion of the application in code, then the tree structure is created based on how you assign property values for properties that implement the content model for a given object.</span></span> <span data-ttu-id="ccfe8-113">[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]에서 완벽한 트리 구조는 논리 트리와 시각적 트리라는 두 가지 방법으로 개념화하고 공용 API에 보고할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ccfe8-113">In [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)], there are two ways that the complete object tree is conceptualized and can be reported to its public API: as the logical tree and as the visual tree.</span></span> <span data-ttu-id="ccfe8-114">논리 트리와 시각적 트리의 구분이 항상 반드시 중요한 것은 아니지만 경우에 따라 특정 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 하위 시스템에서 문제를 발생시키고 태그나 코드에서 선택하는 항목에 영향을 줄 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ccfe8-114">The distinctions between logical tree and visual tree are not always necessarily important, but they can occasionally cause issues with certain [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] subsystems and affect choices you make in markup or code.</span></span>  
  
 <span data-ttu-id="ccfe8-115">항상 논리 트리나 시각적 트리를 직접 조작하지 않는 경우에도 트리가 상호 작용하는 방식에 대한 개념을 이해하면 WPF를 기술로 이해하는 데 도움이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ccfe8-115">Even though you do not always manipulate either the logical tree or the visual tree directly, understanding the concepts of how the trees interact is useful for understanding WPF as a technology.</span></span> <span data-ttu-id="ccfe8-116">또한 WPF를 일종의 트리 메타포로 생각하는 것은 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]에서 속성 상속 및 이벤트 라우팅의 작동 방식을 이해하는 데 매우 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="ccfe8-116">Thinking of WPF as a tree metaphor of some kind is also crucial to understanding how property inheritance and event routing work in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)].</span></span>  
  
> [!NOTE]
> <span data-ttu-id="ccfe8-117">개체 트리는 실제 API라기보다는 일종의 개념이기 때문에 이 개념을 개체 그래프로 생각할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ccfe8-117">Because the object tree is more of a concept than an actual API, another way to think of the concept is as an object graph.</span></span> <span data-ttu-id="ccfe8-118">실제로 트리 메타포가 분류되는 런타임에 개체 간에 관계가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ccfe8-118">In practice, there are relationships between objects at run time where the tree metaphor will break down.</span></span> <span data-ttu-id="ccfe8-119">그러나 특히 XAML 정의 UI를 사용하는 경우 트리 메타포는 대부분의 WPF 설명서에서 이 일반적인 개념을 참조할 때 개체 트리라는 용어를 사용할 정도로 충분히 관련이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ccfe8-119">Nevertheless, particularly with XAML-defined UI, the tree metaphor is relevant enough that most WPF documentation will use the term object tree when referencing this general concept.</span></span>  
  
<a name="logical_tree"></a>   
## <a name="the-logical-tree"></a><span data-ttu-id="ccfe8-120">논리 트리</span><span class="sxs-lookup"><span data-stu-id="ccfe8-120">The Logical Tree</span></span>  
 <span data-ttu-id="ccfe8-121">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]에서는 해당 요소를 지원하는 개체의 속성을 설정하여 UI 요소에 콘텐츠를 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="ccfe8-121">In [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], you add content to UI elements by setting properties of the objects that back those elements.</span></span> <span data-ttu-id="ccfe8-122">예를 들어 <xref:System.Windows.Controls.ItemsControl.Items%2A> 속성을 조작 하 여 <xref:System.Windows.Controls.ListBox> 컨트롤에 항목을 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="ccfe8-122">For example, you add items to a <xref:System.Windows.Controls.ListBox> control by manipulating its <xref:System.Windows.Controls.ItemsControl.Items%2A> property.</span></span> <span data-ttu-id="ccfe8-123">이렇게 하면 <xref:System.Windows.Controls.ItemsControl.Items%2A> 속성 값인 <xref:System.Windows.Controls.ItemCollection>에 항목이 배치 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ccfe8-123">By doing this, you are placing items into the <xref:System.Windows.Controls.ItemCollection> that is the <xref:System.Windows.Controls.ItemsControl.Items%2A> property value.</span></span> <span data-ttu-id="ccfe8-124">마찬가지로 <xref:System.Windows.Controls.DockPanel>에 개체를 추가 하려면 <xref:System.Windows.Controls.Panel.Children%2A> 속성 값을 조작 합니다.</span><span class="sxs-lookup"><span data-stu-id="ccfe8-124">Similarly, to add objects to a <xref:System.Windows.Controls.DockPanel>, you manipulate its <xref:System.Windows.Controls.Panel.Children%2A> property value.</span></span> <span data-ttu-id="ccfe8-125">여기에서 <xref:System.Windows.Controls.UIElementCollection>개체를 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="ccfe8-125">Here, you are adding objects to the <xref:System.Windows.Controls.UIElementCollection>.</span></span> <span data-ttu-id="ccfe8-126">코드 예제는 [방법: 동적으로 요소 추가](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ms752374(v=vs.100))를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="ccfe8-126">For a code example, see [How to: Add an Element Dynamically](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ms752374(v=vs.100)).</span></span>  
  
 <span data-ttu-id="ccfe8-127">[!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)]에서 목록 항목을 <xref:System.Windows.Controls.DockPanel>의 <xref:System.Windows.Controls.ListBox> 또는 컨트롤이 나 기타 UI 요소에 배치한 경우 다음 예제와 같이 명시적 또는 암시적으로 <xref:System.Windows.Controls.ItemsControl.Items%2A> 및 <xref:System.Windows.Controls.Panel.Children%2A> 속성을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="ccfe8-127">In [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)], when you place list items in a <xref:System.Windows.Controls.ListBox> or controls or other UI elements in a <xref:System.Windows.Controls.DockPanel>, you also use the <xref:System.Windows.Controls.ItemsControl.Items%2A> and <xref:System.Windows.Controls.Panel.Children%2A> properties, either explicitly or implicitly, as in the following example.</span></span>  
  
 [!code-xaml[TreeOvwsSupport#AllCode](~/samples/snippets/csharp/VS_Snippets_Wpf/TreeOvwsSupport/CS/page1.xaml#allcode)]  
  
 <span data-ttu-id="ccfe8-128">문서 개체 모델에서 이 XAML을 XML로 처리하려는 경우 및 적합해야 하는 태그를 암시적으로 주석 처리하여 포함한 경우 결과 XML DOM 트리에는 `<ListBox.Items>`에 대한 요소 및 기타 암시적 항목이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="ccfe8-128">If you were to process this XAML as XML under a document object model, and if you had included the tags commented out as implicit (which would have been legal), then the resulting XML DOM tree would have included elements for `<ListBox.Items>` and the other implicit items.</span></span> <span data-ttu-id="ccfe8-129">그러나 XAML은 태그를 읽고 개체에 쓸 때 이런 방식으로 처리하지 않으며 결과 개체 그래프에 `ListBox.Items`가 포함되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ccfe8-129">But XAML does not process that way when you read the markup and write to objects, the resulting object graph does not literally include `ListBox.Items`.</span></span> <span data-ttu-id="ccfe8-130">그러나이 파일에는 <xref:System.Windows.Controls.ItemCollection>를 포함 하는 `Items` 라는 <xref:System.Windows.Controls.ListBox> 속성이 있지만 <xref:System.Windows.Controls.ListBox> XAML이 처리 될 때 <xref:System.Windows.Controls.ItemCollection>는 초기화 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ccfe8-130">It does however have a <xref:System.Windows.Controls.ListBox> property named `Items` that contains a <xref:System.Windows.Controls.ItemCollection>, and that <xref:System.Windows.Controls.ItemCollection> is initialized but empty when the <xref:System.Windows.Controls.ListBox> XAML is processed.</span></span> <span data-ttu-id="ccfe8-131">그런 다음 <xref:System.Windows.Controls.ListBox>의 콘텐츠로 존재 하는 각 자식 개체 요소는 `ItemCollection.Add`에 대 한 파서 호출을 통해 <xref:System.Windows.Controls.ItemCollection>에 추가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ccfe8-131">Then, each child object element that exists as content for the <xref:System.Windows.Controls.ListBox> is added to the <xref:System.Windows.Controls.ItemCollection> by parser calls to `ItemCollection.Add`.</span></span> <span data-ttu-id="ccfe8-132">지금까지 XAML을 개체 트리로 처리하는 이 예제는 생성된 개체 트리가 기본적으로 논리 트리인 경우로 보입니다.</span><span class="sxs-lookup"><span data-stu-id="ccfe8-132">This example of processing XAML into an object tree is so far seemingly an example where the created object tree is basically the logical tree.</span></span>  
  
 <span data-ttu-id="ccfe8-133">그러나 논리적 트리는 XAML 암시적 구문 항목이 제외 된 경우에도 런타임에 응용 프로그램 UI에 대해 존재 하는 전체 개체 그래프가 아닙니다. 주요 이유는 시각적 개체 및 템플릿입니다.</span><span class="sxs-lookup"><span data-stu-id="ccfe8-133">However, the logical tree is not the entire object graph that exists for your application UI at run time, even with the XAML implicit syntax items factored out. The main reason for this is visuals and templates.</span></span> <span data-ttu-id="ccfe8-134">예를 들어 <xref:System.Windows.Controls.Button>을 고려 합니다.</span><span class="sxs-lookup"><span data-stu-id="ccfe8-134">For example, consider the <xref:System.Windows.Controls.Button>.</span></span> <span data-ttu-id="ccfe8-135">논리적 트리는 <xref:System.Windows.Controls.Button> 개체 및 해당 문자열 `Content`보고 합니다.</span><span class="sxs-lookup"><span data-stu-id="ccfe8-135">The logical tree reports the <xref:System.Windows.Controls.Button> object and also its string `Content`.</span></span> <span data-ttu-id="ccfe8-136">하지만 런타임 개체 트리의 이 단추에는 더 많은 정보가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ccfe8-136">But there is more to this button in the run-time object tree.</span></span> <span data-ttu-id="ccfe8-137">특히 단추는 특정 <xref:System.Windows.Controls.Button> 컨트롤 템플릿이 적용 되었기 때문에 화면에 표시 되는 방식에만 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ccfe8-137">In particular, the button only appears on screen the way it does because a specific <xref:System.Windows.Controls.Button> control template was applied.</span></span> <span data-ttu-id="ccfe8-138">런타임에 논리 트리를 확인 하는 경우에도 적용 된 템플릿에서 가져온 시각적 개체 (예: 시각적 단추 주위의 진한 회색의 템플릿 정의 <xref:System.Windows.Controls.Border>)는 논리적 트리에서 보고 되지 않습니다. 표시 되는 UI를 찾은 다음 논리 트리를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="ccfe8-138">The visuals that come from an applied template (such as the template-defined <xref:System.Windows.Controls.Border> of dark gray around the visual button) are not reported in the logical tree, even if you are looking at the logical tree during run time (such as handling an input event from the visible UI and then reading the logical tree).</span></span> <span data-ttu-id="ccfe8-139">템플릿 시각 효과를 찾으려면 시각적 트리를 대신 검사해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ccfe8-139">To find the template visuals, you would instead need to examine the visual tree.</span></span>  
  
 <span data-ttu-id="ccfe8-140">[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] 구문이 생성된 개체 그래프에 매핑되는 방법 및 XAML의 암시적 구문에 대한 자세한 내용은 [XAML 구문 정보](xaml-syntax-in-detail.md) 또는 [XAML 개요(WPF)](xaml-overview-wpf.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ccfe8-140">For more information about how [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] syntax maps to the created object graph, and implicit syntax in XAML, see [XAML Syntax In Detail](xaml-syntax-in-detail.md) or [XAML Overview (WPF)](xaml-overview-wpf.md).</span></span>  
  
<a name="tree_property_inheritance_event_routing"></a>   
### <a name="the-purpose-of-the-logical-tree"></a><span data-ttu-id="ccfe8-141">논리 트리의 용도</span><span class="sxs-lookup"><span data-stu-id="ccfe8-141">The Purpose of the Logical Tree</span></span>  
 <span data-ttu-id="ccfe8-142">논리 트리를 통해 콘텐츠 모델은 해당 자식 개체를 쉽게 반복할 수 있고 콘텐츠 모델을 확장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ccfe8-142">The logical tree exists so that content models can readily iterate over their possible child objects, and so that content models can be extensible.</span></span> <span data-ttu-id="ccfe8-143">또한 논리 트리는 논리 트리의 모든 개체가 로드된 경우 등의 특정 알림에 대한 프레임워크를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="ccfe8-143">Also, the logical tree provides a framework for certain notifications, such as when all objects in the logical tree are loaded.</span></span> <span data-ttu-id="ccfe8-144">기본적으로 논리 트리는 시각 효과를 제외한 프레임워크 수준의 런타임 개체 그래프와 유사하지만 고유한 런타임 애플리케이션의 구성에 대한 많은 쿼리 작업에 적합합니다.</span><span class="sxs-lookup"><span data-stu-id="ccfe8-144">Basically, the logical tree is an approximation of a run time object graph at the framework level, which excludes visuals, but is adequate for many querying operations against your own run time application's composition.</span></span>  
  
 <span data-ttu-id="ccfe8-145">또한 초기 요청 개체에 대 한 <xref:System.Windows.FrameworkElement.Resources%2A> 컬렉션에 대 한 논리 트리를 위쪽으로 조회 한 다음 논리 트리를 진행 하 고 각 <xref:System.Windows.FrameworkElement> (또는 <xref:System.Windows.FrameworkContentElement>)를 확인 하 여 정적 및 동적 리소스 참조를 모두 확인 합니다. 해당 키를 포함할 수 있는 <xref:System.Windows.ResourceDictionary>을 포함 하는 다른 `Resources` 값입니다.</span><span class="sxs-lookup"><span data-stu-id="ccfe8-145">In addition, both static and dynamic resource references are resolved by looking upwards through the logical tree for <xref:System.Windows.FrameworkElement.Resources%2A> collections on the initial requesting object, and then continuing up the logical tree and checking each <xref:System.Windows.FrameworkElement> (or <xref:System.Windows.FrameworkContentElement>) for another `Resources` value that contains a <xref:System.Windows.ResourceDictionary>, possibly containing that key.</span></span> <span data-ttu-id="ccfe8-146">논리 트리와 시각적 트리가 모두 있을 경우 논리 트리가 리소스 조회에 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="ccfe8-146">The logical tree is used for resource lookup when both the logical tree and the visual tree are present.</span></span> <span data-ttu-id="ccfe8-147">리소스 사전 및 조회에 대한 자세한 내용은 [XAML 리소스](../../../desktop-wpf/fundamentals/xaml-resources-define.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ccfe8-147">For more information on resource dictionaries and lookup, see [XAML Resources](../../../desktop-wpf/fundamentals/xaml-resources-define.md).</span></span>  
  
<a name="composition"></a>   
### <a name="composition-of-the-logical-tree"></a><span data-ttu-id="ccfe8-148">논리 트리의 구성</span><span class="sxs-lookup"><span data-stu-id="ccfe8-148">Composition of the Logical Tree</span></span>  
 <span data-ttu-id="ccfe8-149">논리 트리는 WPF 프레임 워크 수준에서 정의 됩니다. 즉, 논리적 트리 작업에 가장 적합 한 WPF 기본 요소가 <xref:System.Windows.FrameworkElement> 또는 <xref:System.Windows.FrameworkContentElement>입니다.</span><span class="sxs-lookup"><span data-stu-id="ccfe8-149">The logical tree is defined at the WPF framework-level, which means that the WPF base element that is most relevant for logical tree operations is either <xref:System.Windows.FrameworkElement> or <xref:System.Windows.FrameworkContentElement>.</span></span> <span data-ttu-id="ccfe8-150">그러나 실제로 <xref:System.Windows.LogicalTreeHelper> API를 사용 하는 것 처럼 논리 트리에는 <xref:System.Windows.FrameworkElement> 또는 <xref:System.Windows.FrameworkContentElement>되지 않는 노드가 포함 될 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ccfe8-150">However, as you can see if you actually use the <xref:System.Windows.LogicalTreeHelper> API, the logical tree sometimes contains nodes that are not either <xref:System.Windows.FrameworkElement> or <xref:System.Windows.FrameworkContentElement>.</span></span> <span data-ttu-id="ccfe8-151">예를 들어 논리 트리는 문자열인 <xref:System.Windows.Controls.TextBlock>의 <xref:System.Windows.Controls.TextBlock.Text%2A> 값을 보고 합니다.</span><span class="sxs-lookup"><span data-stu-id="ccfe8-151">For instance, the logical tree reports the <xref:System.Windows.Controls.TextBlock.Text%2A> value of a <xref:System.Windows.Controls.TextBlock>, which is a string.</span></span>  
  
<a name="override_logical_tree"></a>   
### <a name="overriding-the-logical-tree"></a><span data-ttu-id="ccfe8-152">논리 트리 재정의</span><span class="sxs-lookup"><span data-stu-id="ccfe8-152">Overriding the Logical Tree</span></span>  
 <span data-ttu-id="ccfe8-153">고급 컨트롤 작성자는 일반 개체 또는 콘텐츠 모델이 논리 트리 내에서 개체를 추가 하거나 제거 하는 방법을 정의 하는 여러 Api를 재정의 하 여 논리적 트리를 재정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ccfe8-153">Advanced control authors can override the logical tree by overriding several APIs that define how a general object or content model adds or removes objects within the logical tree.</span></span> <span data-ttu-id="ccfe8-154">논리 트리를 재정의하는 방법에 대한 예제는 [논리 트리 재정의](how-to-override-the-logical-tree.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ccfe8-154">For an example of how to override the logical tree, see [Override the Logical Tree](how-to-override-the-logical-tree.md).</span></span>  
  
<a name="pvi"></a>   
### <a name="property-value-inheritance"></a><span data-ttu-id="ccfe8-155">속성 값 상속</span><span class="sxs-lookup"><span data-stu-id="ccfe8-155">Property Value Inheritance</span></span>  
 <span data-ttu-id="ccfe8-156">속성 값 상속은 혼합 트리를 통해 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="ccfe8-156">Property value inheritance operates through a hybrid tree.</span></span> <span data-ttu-id="ccfe8-157">속성 상속을 가능 하 게 하는 <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> 속성을 포함 하는 실제 메타 데이터는 WPF 프레임 워크 수준 <xref:System.Windows.FrameworkPropertyMetadata> 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="ccfe8-157">The actual metadata that contains the <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> property that enables property inheritance is the WPF framework-level <xref:System.Windows.FrameworkPropertyMetadata> class.</span></span> <span data-ttu-id="ccfe8-158">따라서 원래 값을 포함 하는 부모와 해당 값을 상속 하는 자식 개체 모두 <xref:System.Windows.FrameworkElement> 하거나 <xref:System.Windows.FrameworkContentElement>해야 하며 둘 다 논리적 트리의 일부 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ccfe8-158">Therefore, both the parent that holds the original value and the child object that inherits that value must both be <xref:System.Windows.FrameworkElement> or <xref:System.Windows.FrameworkContentElement>, and they must both be part of some logical tree.</span></span> <span data-ttu-id="ccfe8-159">그러나 속성 상속을 지원하는 기존 WPF 속성의 경우 속성 값 상속은 논리 트리에 없는 중간 개체를 통해 지속될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ccfe8-159">However, for existing WPF properties that support property inheritance, property value inheritance is able to perpetuate through an intervening object that is not in the logical tree.</span></span> <span data-ttu-id="ccfe8-160">주로 이 기능은 템플릿 요소가 템플릿 기반의 인스턴스 또는 더 높은 수준의 페이지 수준 구성 및 논리 트리의 더 높은 위치에서 설정된 상속된 속성 값을 사용하도록 하려는 경우와 관련이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ccfe8-160">Mainly this is relevant for having template elements use any inherited property values set either on the instance that is templated, or at still higher levels of page-level composition and therefore higher in the logical tree.</span></span> <span data-ttu-id="ccfe8-161">속성 값 상속이 이러한 경계에서 일관되게 작동하려면 상속하는 속성을 연결된 속성으로 등록해야 하며 속성 상속 동작으로 사용자 지정 종속성 속성을 정의하려는 경우 이 패턴을 따라야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ccfe8-161">In order for property value inheritance to work consistently across such a boundary, the inheriting property must be registered as an attached property, and you should follow this pattern if you intend to define a custom dependency property with property inheritance behavior.</span></span> <span data-ttu-id="ccfe8-162">속성 상속에 사용되는 정확한 트리는 도우미 클래스 유틸리티 메서드에서 완전히 예상할 수 없으며, 런타임에도 마찬가지입니다.</span><span class="sxs-lookup"><span data-stu-id="ccfe8-162">The exact tree used for property inheritance cannot be entirely anticipated by a helper class utility method, even at run time.</span></span> <span data-ttu-id="ccfe8-163">자세한 내용은 [속성 값 상속](property-value-inheritance.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ccfe8-163">For more information, see [Property Value Inheritance](property-value-inheritance.md).</span></span>  
  
<a name="two_trees"></a>   
## <a name="the-visual-tree"></a><span data-ttu-id="ccfe8-164">시각적 트리</span><span class="sxs-lookup"><span data-stu-id="ccfe8-164">The Visual Tree</span></span>  
 <span data-ttu-id="ccfe8-165">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]에는 논리 트리의 개념 외에 시각적 트리라는 개념도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ccfe8-165">In addition to the concept of the logical tree, there is also the concept of the visual tree in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)].</span></span> <span data-ttu-id="ccfe8-166">시각적 트리는 <xref:System.Windows.Media.Visual> 기본 클래스로 표시 되는 시각적 개체의 구조를 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="ccfe8-166">The visual tree describes the structure of visual objects, as represented by the <xref:System.Windows.Media.Visual> base class.</span></span> <span data-ttu-id="ccfe8-167">컨트롤에 대한 템플릿을 작성하면 해당 컨트롤에 적용되는 시각적 트리를 정의하거나 다시 정의하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="ccfe8-167">When you write a template for a control, you are defining or redefining the visual tree that applies for that control.</span></span> <span data-ttu-id="ccfe8-168">또한 시각적 트리는 성능 및 최적화를 위해 그리기를 낮은 수준으로 제어하려는 개발자에게 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="ccfe8-168">The visual tree is also of interest to developers who want lower-level control over drawing for performance and optimization reasons.</span></span> <span data-ttu-id="ccfe8-169">기존 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 애플리케이션 프로그래밍의 일부로 시각적 트리가 노출되는 한 가지 경우는 라우트된 이벤트에 대한 이벤트 경로가 대부분 논리 트리가 아닌 시각적 트리를 따라 이동하는 경우입니다.</span><span class="sxs-lookup"><span data-stu-id="ccfe8-169">One exposure of the visual tree as part of conventional [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] application programming is that event routes for a routed event mostly travel along the visual tree, not the logical tree.</span></span> <span data-ttu-id="ccfe8-170">이렇게 미묘한 라우트된 이벤트 동작은 컨트롤 작성자가 아닌 경우 바로 파악되지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ccfe8-170">This subtlety of routed event behavior might not be immediately apparent unless you are a control author.</span></span> <span data-ttu-id="ccfe8-171">시각적 트리를 통한 이벤트 라우팅에서는 시각적 수준에서 구성을 구현하는 컨트롤을 사용하여 이벤트를 처리하거나 이벤트 setter를 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ccfe8-171">Routing events through the visual tree enables controls that implement composition at the visual level to handle events or create event setters.</span></span>  
  
<a name="trees_content"></a>   
## <a name="trees-content-elements-and-content-hosts"></a><span data-ttu-id="ccfe8-172">트리, 콘텐츠 요소 및 콘텐츠 호스트</span><span class="sxs-lookup"><span data-stu-id="ccfe8-172">Trees, Content Elements, and Content Hosts</span></span>  
 <span data-ttu-id="ccfe8-173">콘텐츠 요소 (<xref:System.Windows.ContentElement>에서 파생 되는 클래스)는 시각적 트리의 일부가 아닙니다. <xref:System.Windows.Media.Visual>에서 상속 되지 않으며 시각적 표현이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ccfe8-173">Content elements (classes that derive from <xref:System.Windows.ContentElement>) are not part of the visual tree; they do not inherit from <xref:System.Windows.Media.Visual> and do not have a visual representation.</span></span> <span data-ttu-id="ccfe8-174">UI에 표시 되려면 <xref:System.Windows.ContentElement>은 <xref:System.Windows.Media.Visual> 및 논리적 트리 참가자 인 콘텐츠 호스트에서 호스팅되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ccfe8-174">In order to appear in a UI at all, a <xref:System.Windows.ContentElement> must be hosted in a content host that is both a <xref:System.Windows.Media.Visual> and a logical tree participant.</span></span> <span data-ttu-id="ccfe8-175">일반적으로 이러한 개체는 <xref:System.Windows.FrameworkElement>입니다.</span><span class="sxs-lookup"><span data-stu-id="ccfe8-175">Usually such an object is a <xref:System.Windows.FrameworkElement>.</span></span> <span data-ttu-id="ccfe8-176">콘텐츠 호스트는 콘텐츠에 대한 "브라우저"와 약간 비슷하며 호스트가 제어하는 화면 영역 내에서 해당 콘텐츠를 표시하는 방법을 선택하는 것으로 개념화할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ccfe8-176">You can conceptualize that the content host is somewhat like a "browser" for the content and chooses how to display that content within the screen region that the host controls.</span></span> <span data-ttu-id="ccfe8-177">호스트된 콘텐츠는 일반적으로 시각적 트리와 연관된 특정 트리 프로세스의 참가자가 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ccfe8-177">When the content is hosted, the content can be made a participant in certain tree processes that are normally associated with the visual tree.</span></span> <span data-ttu-id="ccfe8-178">일반적으로 <xref:System.Windows.FrameworkElement> 호스트 클래스에는 호스트 된 콘텐츠가 진정한 시각적 트리의 일부가 아니더라도 콘텐츠 논리 트리의 하위 노드를 통해 호스트 된 <xref:System.Windows.ContentElement>를 이벤트 경로에 추가 하는 구현 코드가 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ccfe8-178">Generally, the <xref:System.Windows.FrameworkElement> host class includes implementation code that adds any hosted <xref:System.Windows.ContentElement> to the event route through subnodes of the content logical tree, even though the hosted content is not part of the true visual tree.</span></span> <span data-ttu-id="ccfe8-179">이는 <xref:System.Windows.ContentElement>가 자체가 아닌 모든 요소로 라우팅하는 라우트된 이벤트를 원본으로 사용할 수 있도록 하기 위해 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="ccfe8-179">This is necessary so that a <xref:System.Windows.ContentElement> can source a routed event that routes to any element other than itself.</span></span>  
  
<a name="tree_traversal"></a>   
## <a name="tree-traversal"></a><span data-ttu-id="ccfe8-180">트리 순회</span><span class="sxs-lookup"><span data-stu-id="ccfe8-180">Tree Traversal</span></span>  
 <span data-ttu-id="ccfe8-181"><xref:System.Windows.LogicalTreeHelper> 클래스는 논리 트리 순회를 위한 <xref:System.Windows.LogicalTreeHelper.GetChildren%2A>, <xref:System.Windows.LogicalTreeHelper.GetParent%2A>및 <xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A> 메서드를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="ccfe8-181">The <xref:System.Windows.LogicalTreeHelper> class provides the <xref:System.Windows.LogicalTreeHelper.GetChildren%2A>, <xref:System.Windows.LogicalTreeHelper.GetParent%2A>, and <xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A> methods for logical tree traversal.</span></span> <span data-ttu-id="ccfe8-182">대부분의 경우 기존 컨트롤의 논리 트리를 트래버스할 필요가 없습니다. 이러한 컨트롤은 거의 항상 논리 자식 요소를 `Add`, 인덱서 등 컬렉션 액세스를 지원하는 전용 컬렉션 속성으로 노출하기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="ccfe8-182">In most cases, you should not have to traverse the logical tree of existing controls, because these controls almost always expose their logical child elements as a dedicated collection property that supports collection access such as `Add`, an indexer, and so on.</span></span> <span data-ttu-id="ccfe8-183">트리 순회는 주로 컬렉션 속성이 이미 정의 된 <xref:System.Windows.Controls.ItemsControl> 또는 <xref:System.Windows.Controls.Panel>와 같은 의도 된 컨트롤 패턴에서 파생 되지 않도록 선택 하 고 고유한 컬렉션 속성을 제공 하려는 컨트롤 작성자가 사용 하는 시나리오입니다. 지원은.</span><span class="sxs-lookup"><span data-stu-id="ccfe8-183">Tree traversal is mainly a scenario that is used by control authors who choose not to derive from intended control patterns such as <xref:System.Windows.Controls.ItemsControl> or <xref:System.Windows.Controls.Panel> where collection properties are already defined, and who intend to provide their own collection property support.</span></span>  
  
 <span data-ttu-id="ccfe8-184">시각적 트리는 <xref:System.Windows.Media.VisualTreeHelper>시각적 트리 순회에 대 한 도우미 클래스도 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="ccfe8-184">The visual tree also supports a helper class for visual tree traversal, <xref:System.Windows.Media.VisualTreeHelper>.</span></span> <span data-ttu-id="ccfe8-185">시각적 트리는 컨트롤별 속성을 통해 편리 하 게 노출 되지 않으므로 프로그래밍 시나리오에 필요한 경우에는 시각적 트리를 트래버스하는 데 <xref:System.Windows.Media.VisualTreeHelper> 클래스가 권장 되는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="ccfe8-185">The visual tree is not exposed as conveniently through control-specific properties, so the <xref:System.Windows.Media.VisualTreeHelper> class is the recommended way to traverse the visual tree if that is necessary for your programming scenario.</span></span> <span data-ttu-id="ccfe8-186">자세한 내용은 [WPF 그래픽 렌더링 개요](../graphics-multimedia/wpf-graphics-rendering-overview.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ccfe8-186">For more information, see [WPF Graphics Rendering Overview](../graphics-multimedia/wpf-graphics-rendering-overview.md).</span></span>  
  
> [!NOTE]
> <span data-ttu-id="ccfe8-187">경우에 따라 적용된 템플릿의 시각적 트리를 검사해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ccfe8-187">Sometimes it is necessary to examine the visual tree of an applied template.</span></span> <span data-ttu-id="ccfe8-188">이 기술을 사용할 때는 주의해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ccfe8-188">You should be careful when using this technique.</span></span> <span data-ttu-id="ccfe8-189">템플릿을 정의 하는 컨트롤에 대 한 시각적 트리를 트래버스하는 경우에도 컨트롤의 소비자는 인스턴스에서 <xref:System.Windows.Controls.Control.Template%2A> 속성을 설정 하 여 항상 템플릿을 변경할 수 있으며, 최종 사용자는 시스템을 변경 하 여 적용 된 템플릿에 영향을 줄 수 있습니다. 테마나.</span><span class="sxs-lookup"><span data-stu-id="ccfe8-189">Even if you are traversing a visual tree for a control where you define the template, consumers of your control can always change the template by setting the <xref:System.Windows.Controls.Control.Template%2A> property on instances, and even the end user can influence the applied template by changing the system theme.</span></span>  
  
<a name="routes"></a>   
## <a name="routes-for-routed-events-as-a-tree"></a><span data-ttu-id="ccfe8-190">"트리"로 라우트된 이벤트에 대한 경로</span><span class="sxs-lookup"><span data-stu-id="ccfe8-190">Routes for Routed Events as a "Tree"</span></span>  
 <span data-ttu-id="ccfe8-191">앞서 언급했듯이 지정된 라우트된 이벤트의 경로는 시각적 트리와 논리 트리 표현이 혼합된 트리의 미리 결정된 단일 경로를 따라 이동합니다.</span><span class="sxs-lookup"><span data-stu-id="ccfe8-191">As mentioned before, the route of any given routed event travels along a single and predetermined path of a tree that is a hybrid of the visual and logical tree representations.</span></span> <span data-ttu-id="ccfe8-192">이벤트 경로는 라우트된 터널링 이벤트인지 버블링 이벤트인지에 따라 트리 내에서 위쪽이나 아래쪽 방향으로 이동할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ccfe8-192">The event route can travel either in the up or down directions within the tree depending on whether it is a tunneling or bubbling routed event.</span></span> <span data-ttu-id="ccfe8-193">이벤트 경로 개념에는 실제로 라우트되는 이벤트를 발생시키는 것과 별개로 이벤트 경로를 "이동"하는 데 사용할 수 있는 직접적인 지원 도우미 클래스가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ccfe8-193">The event route concept does not have a directly supporting helper class that could be used to "walk" the event route independently of raising an event that actually routes.</span></span> <span data-ttu-id="ccfe8-194">경로를 나타내는 클래스는 <xref:System.Windows.EventRoute>있지만 해당 클래스의 메서드는 일반적으로 내부용 으로만 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ccfe8-194">There is a class that represents the route, <xref:System.Windows.EventRoute>, but the methods of that class are generally for internal use only.</span></span>  
  
<a name="resourcesandtrees"></a>   
## <a name="resource-dictionaries-and-trees"></a><span data-ttu-id="ccfe8-195">리소스 사전 및 트리</span><span class="sxs-lookup"><span data-stu-id="ccfe8-195">Resource Dictionaries and Trees</span></span>  
 <span data-ttu-id="ccfe8-196">페이지에 정의된 모든 `Resources`에 대한 리소스 사전 조회는 기본적으로 논리 트리를 트래버스합니다.</span><span class="sxs-lookup"><span data-stu-id="ccfe8-196">Resource dictionary lookup for all `Resources` defined in a page traverses basically the logical tree.</span></span> <span data-ttu-id="ccfe8-197">논리 트리에 없는 개체는 키 지정 리소스를 참조할 수 있지만 리소스 조회 시퀀스는 해당 개체가 논리 트리와 연결되는 지점에서 시작됩니다.</span><span class="sxs-lookup"><span data-stu-id="ccfe8-197">Objects that are not in the logical tree can reference keyed resources, but the resource lookup sequence begins at the point where that object is connected to the logical tree.</span></span> <span data-ttu-id="ccfe8-198">WPF에서 논리적 트리 노드만 <xref:System.Windows.ResourceDictionary>를 포함 하는 `Resources` 속성을 가질 수 있으므로 <xref:System.Windows.ResourceDictionary>에서 키가 지정 된 리소스를 찾는 시각적 트리를 트래버스하는 이점을 누릴 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ccfe8-198">In WPF, only logical tree nodes can have a `Resources` property that contains a <xref:System.Windows.ResourceDictionary>, therefore there is no benefit in traversing the visual tree looking for keyed resources from a <xref:System.Windows.ResourceDictionary>.</span></span>  
  
 <span data-ttu-id="ccfe8-199">그러나 리소스 조회는 직접적인 논리 트리를 넘어 확장될 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ccfe8-199">However, resource lookup can also extend beyond the immediate logical tree.</span></span> <span data-ttu-id="ccfe8-200">애플리케이션 태그의 경우 리소스 조회가 애플리케이션 수준 리소스 사전까지 계속된 다음 정적 속성이나 키로 참조되는 테마 지원 및 시스템 값까지 계속될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ccfe8-200">For application markup, the resource lookup can then continue onward to application-level resource dictionaries and then to theme support and system values that are referenced as static properties or keys.</span></span> <span data-ttu-id="ccfe8-201">테마 자체는 리소스 참조가 동적인 경우 테마 논리 트리 외부의 시스템 값을 참조할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ccfe8-201">Themes themselves can also reference system values outside of the theme logical tree if the resource references are dynamic.</span></span> <span data-ttu-id="ccfe8-202">리소스 사전 및 조회 논리에 대한 자세한 내용은 [XAML 리소스](../../../desktop-wpf/fundamentals/xaml-resources-define.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ccfe8-202">For more information on resource dictionaries and the lookup logic, see [XAML Resources](../../../desktop-wpf/fundamentals/xaml-resources-define.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="ccfe8-203">참조</span><span class="sxs-lookup"><span data-stu-id="ccfe8-203">See also</span></span>

- [<span data-ttu-id="ccfe8-204">입력 개요</span><span class="sxs-lookup"><span data-stu-id="ccfe8-204">Input Overview</span></span>](input-overview.md)
- [<span data-ttu-id="ccfe8-205">WPF 그래픽 렌더링 개요</span><span class="sxs-lookup"><span data-stu-id="ccfe8-205">WPF Graphics Rendering Overview</span></span>](../graphics-multimedia/wpf-graphics-rendering-overview.md)
- [<span data-ttu-id="ccfe8-206">라우트된 이벤트 개요</span><span class="sxs-lookup"><span data-stu-id="ccfe8-206">Routed Events Overview</span></span>](routed-events-overview.md)
- [<span data-ttu-id="ccfe8-207">개체 트리에 없는 개체 요소 초기화</span><span class="sxs-lookup"><span data-stu-id="ccfe8-207">Initialization for Object Elements Not in an Object Tree</span></span>](initialization-for-object-elements-not-in-an-object-tree.md)
- [<span data-ttu-id="ccfe8-208">WPF 아키텍처</span><span class="sxs-lookup"><span data-stu-id="ccfe8-208">WPF Architecture</span></span>](wpf-architecture.md)

---
title: 사용자 지정 종속성 속성
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- implementing [WPF], wrappers
- registering properties [WPF]
- properties [WPF], metadata
- metadata [WPF], for properties
- custom dependency properties [WPF]
- properties [WPF], registering
- wrappers [WPF], implementing
- dependency properties [WPF], custom
ms.assetid: e6bfcfac-b10d-4f58-9f77-a864c2a2938f
ms.openlocfilehash: f15490417d54121c750e2ea918820c5cb717002e
ms.sourcegitcommit: efff8f331fd9467f093f8ab8d23a203d6ecb5b60
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 09/02/2018
ms.locfileid: "43468326"
---
# <a name="custom-dependency-properties"></a><span data-ttu-id="ab18e-102">사용자 지정 종속성 속성</span><span class="sxs-lookup"><span data-stu-id="ab18e-102">Custom Dependency Properties</span></span>

<span data-ttu-id="ab18e-103">이 항목에서는 [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] 응용 프로그램 개발자와 구성 요소 작성자가 사용자 지정 종속성 속성을 만들려고 하는 이유와 구현 단계 및 속성의 성능, 유용성 또는 유연성을 향상시킬 수 있는 일부 구현 옵션에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="ab18e-103">This topic describes the reasons that [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] application developers and component authors might want to create custom dependency property, and describes the implementation steps as well as some implementation options that can improve performance, usability, or versatility of the property.</span></span>

<a name="prerequisites"></a>
## <a name="prerequisites"></a><span data-ttu-id="ab18e-104">전제 조건</span><span class="sxs-lookup"><span data-stu-id="ab18e-104">Prerequisites</span></span>

<span data-ttu-id="ab18e-105">이 항목에서는 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 클래스에서 기존 종속성 속성의 소비자 관점에서 종속성 속성을 이해하고 [종속성 속성 개요](../../../../docs/framework/wpf/advanced/dependency-properties-overview.md) 항목을 읽었다고 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="ab18e-105">This topic assumes that you understand dependency properties from the perspective of a consumer of existing dependency properties on [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] classes, and have read the [Dependency Properties Overview](../../../../docs/framework/wpf/advanced/dependency-properties-overview.md) topic.</span></span> <span data-ttu-id="ab18e-106">이 항목의 예제를 따르려면 [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)]를 이해하고 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 응용 프로그램을 작성하는 방법도 알아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab18e-106">In order to follow the examples in this topic, you should also understand [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)] and know how to write [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications.</span></span>

<a name="whatis"></a>
## <a name="what-is-a-dependency-property"></a><span data-ttu-id="ab18e-107">종속성 속성이란?</span><span class="sxs-lookup"><span data-stu-id="ab18e-107">What Is a Dependency Property?</span></span>

<span data-ttu-id="ab18e-108">[!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] 속성을 종속성 속성으로 구현하여 스타일 지정, 데이터 바인딩, 애니메이션 및 기본값을 지원하도록 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ab18e-108">You can enable what would otherwise be a [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] property to support styling, data binding, inheritance, animations, and default values by implementing it as a dependency property.</span></span> <span data-ttu-id="ab18e-109">종속성 속성은 등록 된 속성을 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 호출 하 여 속성 시스템을 <xref:System.Windows.DependencyProperty.Register%2A> 메서드 (또는 <xref:System.Windows.DependencyProperty.RegisterReadOnly%2A>), 및에서 지원 되는 <xref:System.Windows.DependencyProperty> 식별자 필드입니다.</span><span class="sxs-lookup"><span data-stu-id="ab18e-109">Dependency properties are properties that are registered with the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] property system by calling the <xref:System.Windows.DependencyProperty.Register%2A> method (or <xref:System.Windows.DependencyProperty.RegisterReadOnly%2A>), and that are backed by a <xref:System.Windows.DependencyProperty> identifier field.</span></span> <span data-ttu-id="ab18e-110">종속성 속성 에서만 사용할 수 있습니다 <xref:System.Windows.DependencyObject> 형식 하지만 <xref:System.Windows.DependencyObject> 에서 매우 높은 합니다 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 에서 사용할 수 있는 대부분의 클래스 계층 클래스 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 종속성 속성을 지원할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ab18e-110">Dependency properties can be used only by <xref:System.Windows.DependencyObject> types, but <xref:System.Windows.DependencyObject> is quite high in the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] class hierarchy, so the majority of classes available in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] can support dependency properties.</span></span> <span data-ttu-id="ab18e-111">종속성 속성 및 이 [!INCLUDE[TLA2#tla_sdk](../../../../includes/tla2sharptla-sdk-md.md)]에서 종속성 속성을 설명하는 데 사용된 일부 용어 및 규칙에 대한 자세한 내용은 [종속성 속성 개요](../../../../docs/framework/wpf/advanced/dependency-properties-overview.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ab18e-111">For more information about dependency properties and some of the terminology and conventions used for describing them in this [!INCLUDE[TLA2#tla_sdk](../../../../includes/tla2sharptla-sdk-md.md)], see [Dependency Properties Overview](../../../../docs/framework/wpf/advanced/dependency-properties-overview.md).</span></span>

<a name="example_dp"></a>
## <a name="examples-of-dependency-properties"></a><span data-ttu-id="ab18e-112">종속성 속성의 예</span><span class="sxs-lookup"><span data-stu-id="ab18e-112">Examples of Dependency Properties</span></span>

<span data-ttu-id="ab18e-113">구현 되는 종속성 속성의 예로 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 클래스에 포함 되어를 <xref:System.Windows.Controls.Control.Background%2A> 속성인을 <xref:System.Windows.FrameworkElement.Width%2A> 속성 및 <xref:System.Windows.Controls.TextBox.Text%2A> 다양 한 기타 속성을 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab18e-113">Examples of dependency properties that are implemented on [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] classes include the <xref:System.Windows.Controls.Control.Background%2A> property, the <xref:System.Windows.FrameworkElement.Width%2A> property, and the <xref:System.Windows.Controls.TextBox.Text%2A> property, among many others.</span></span> <span data-ttu-id="ab18e-114">클래스에 의해 노출 되는 각 종속성 속성에 형식의 해당 공용 정적 필드가 <xref:System.Windows.DependencyProperty> 는 동일한 클래스에서 노출 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab18e-114">Each dependency property exposed by a class has a corresponding public static field of type <xref:System.Windows.DependencyProperty> exposed on that same class.</span></span> <span data-ttu-id="ab18e-115">이는 종속성 속성의 식별자입니다.</span><span class="sxs-lookup"><span data-stu-id="ab18e-115">This is the identifier for the dependency property.</span></span> <span data-ttu-id="ab18e-116">식별자는 규칙을 사용하여 이름이 지정됩니다. 종속성 속성의 이름에는 문자열 `Property`가 추가됩니다.</span><span class="sxs-lookup"><span data-stu-id="ab18e-116">The identifier is named using a convention: the name of the dependency property with the string `Property` appended to it.</span></span> <span data-ttu-id="ab18e-117">해당 예를 들어 <xref:System.Windows.DependencyProperty> 에 대 한 식별자 필드를 <xref:System.Windows.Controls.Control.Background%2A> 속성은 <xref:System.Windows.Controls.Control.BackgroundProperty>합니다.</span><span class="sxs-lookup"><span data-stu-id="ab18e-117">For example, the corresponding <xref:System.Windows.DependencyProperty> identifier field for the <xref:System.Windows.Controls.Control.Background%2A> property is <xref:System.Windows.Controls.Control.BackgroundProperty>.</span></span> <span data-ttu-id="ab18e-118">식별자에 대 한 정보가 종속성 속성에는 등록 된와 호출 같은 종속성 속성에 관련 된 기타 작업 식별자를 나중에 사용 됩니다 <xref:System.Windows.DependencyObject.SetValue%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="ab18e-118">The identifier stores the information about the dependency property as it was registered, and the identifier is then used later for other operations involving the dependency property, such as calling <xref:System.Windows.DependencyObject.SetValue%2A>.</span></span>

<span data-ttu-id="ab18e-119">[종속성 속성 개요](../../../../docs/framework/wpf/advanced/dependency-properties-overview.md)에서 언급했듯이 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]의 모든 종속성 속성(대부분의 연결된 속성 제외)은 "래퍼" 구현으로 인해 [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] 속성이기도 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab18e-119">As mentioned in the [Dependency Properties Overview](../../../../docs/framework/wpf/advanced/dependency-properties-overview.md), all dependency properties in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] (except most attached properties) are also [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] properties because of the "wrapper" implementation.</span></span> <span data-ttu-id="ab18e-120">따라서 코드에서 다른 [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] 속성을 사용하는 것과 같은 방식으로 래퍼를 정의하는 [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] 접근자를 호출하여 종속성 속성을 가져오거나 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ab18e-120">Therefore, from code, you can get or set dependency properties by calling [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] accessors that define the wrappers in the same manner that you would use other [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] properties.</span></span> <span data-ttu-id="ab18e-121">설정 된 종속성 속성의 소비자로 사용 하지 않는 일반적으로 <xref:System.Windows.DependencyObject> 메서드 <xref:System.Windows.DependencyObject.GetValue%2A> 및 <xref:System.Windows.DependencyObject.SetValue%2A>는 기본 속성 시스템에 연결 지점입니다.</span><span class="sxs-lookup"><span data-stu-id="ab18e-121">As a consumer of established dependency properties, you do not typically use the <xref:System.Windows.DependencyObject> methods <xref:System.Windows.DependencyObject.GetValue%2A> and <xref:System.Windows.DependencyObject.SetValue%2A>, which are the connection point to the underlying property system.</span></span> <span data-ttu-id="ab18e-122">대신 기존 구현을 합니다 [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] 속성은 이미 호출한 <xref:System.Windows.DependencyObject.GetValue%2A> 및 <xref:System.Windows.DependencyObject.SetValue%2A> 내에서 `get` 및 `set` 래퍼 구현은 식별자 필드를 적절 하 게 사용 하 여 속성의 .</span><span class="sxs-lookup"><span data-stu-id="ab18e-122">Rather, the existing implementation of the [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] properties will have already called <xref:System.Windows.DependencyObject.GetValue%2A> and <xref:System.Windows.DependencyObject.SetValue%2A> within the `get` and `set` wrapper implementations of the property, using the identifier field appropriately.</span></span> <span data-ttu-id="ab18e-123">사용자 지정 종속성 속성을 직접 구현하는 경우 유사한 방법으로 래퍼를 정의하게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ab18e-123">If you are implementing a custom dependency property yourself, then you will be defining the wrapper in a similar way.</span></span>

<a name="backing_with_dp"></a>
## <a name="when-should-you-implement-a-dependency-property"></a><span data-ttu-id="ab18e-124">종속성 속성의 구현 시기</span><span class="sxs-lookup"><span data-stu-id="ab18e-124">When Should You Implement a Dependency Property?</span></span>

<span data-ttu-id="ab18e-125">구현 하는 경우 속성을 클래스에서 클래스에서 파생 하기만 <xref:System.Windows.DependencyObject>를 사용 하 여 속성을 백업 하는 옵션이 있습니다를 <xref:System.Windows.DependencyProperty> 식별자 이므로 종속성 속성을 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab18e-125">When you implement a property on a class, so long as your class derives from <xref:System.Windows.DependencyObject>, you have the option to back your property with a <xref:System.Windows.DependencyProperty> identifier and thus to make it a dependency property.</span></span> <span data-ttu-id="ab18e-126">속성을 종속성 속성으로 만드는 것이 항상 필요하거나 적절한 것은 아니며 시나리오 요구에 따라 달라집니다.</span><span class="sxs-lookup"><span data-stu-id="ab18e-126">Having your property be a dependency property is not always necessary or appropriate, and will depend on your scenario needs.</span></span> <span data-ttu-id="ab18e-127">때로는 개인 필드로 속성을 지원하는 일반적인 기술이 적합합니다.</span><span class="sxs-lookup"><span data-stu-id="ab18e-127">Sometimes, the typical technique of backing your property with a private field is adequate.</span></span> <span data-ttu-id="ab18e-128">그러나 속성에서 다음 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 기능 중 하나 이상을 지원하기를 원할 때마다 속성을 종속성 속성으로 구현해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab18e-128">However, you should implement your property as a dependency property whenever you want your property to support one or more of the following [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] capabilities:</span></span>

-   <span data-ttu-id="ab18e-129">스타일에 속성을 설정하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab18e-129">You want your property to be settable in a style.</span></span> <span data-ttu-id="ab18e-130">자세한 내용은 [스타일 지정 및 템플릿](../../../../docs/framework/wpf/controls/styling-and-templating.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ab18e-130">For more information, see [Styling and Templating](../../../../docs/framework/wpf/controls/styling-and-templating.md).</span></span>

-   <span data-ttu-id="ab18e-131">속성에서 데이터 바인딩을 지원하게 하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab18e-131">You want your property to support data binding.</span></span> <span data-ttu-id="ab18e-132">데이터 바인딩 종속성 속성에 대한 자세한 내용은 [두 컨트롤의 속성 바인딩](../../../../docs/framework/wpf/data/how-to-bind-the-properties-of-two-controls.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ab18e-132">For more information about data binding dependency properties, see [Bind the Properties of Two Controls](../../../../docs/framework/wpf/data/how-to-bind-the-properties-of-two-controls.md).</span></span>

-   <span data-ttu-id="ab18e-133">동적 리소스 참조를 사용하여 속성을 설정하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab18e-133">You want your property to be settable with a dynamic resource reference.</span></span> <span data-ttu-id="ab18e-134">자세한 내용은 [XAML 리소스](../../../../docs/framework/wpf/advanced/xaml-resources.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ab18e-134">For more information, see [XAML Resources](../../../../docs/framework/wpf/advanced/xaml-resources.md).</span></span>

-   <span data-ttu-id="ab18e-135">요소 트리의 부모 요소에서 속성 값을 자동으로 상속받도록 하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab18e-135">You want to inherit a property value automatically from a parent element in the element tree.</span></span> <span data-ttu-id="ab18e-136">이 경우 등록 합니다 <xref:System.Windows.DependencyProperty.RegisterAttached%2A> 메서드를 속성 래퍼를 만드는 경우에 [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] 액세스 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab18e-136">In this case, register with the <xref:System.Windows.DependencyProperty.RegisterAttached%2A> method, even if you also create a property wrapper for [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] access.</span></span> <span data-ttu-id="ab18e-137">자세한 내용은 [속성 값 상속](../../../../docs/framework/wpf/advanced/property-value-inheritance.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ab18e-137">For more information, see [Property Value Inheritance](../../../../docs/framework/wpf/advanced/property-value-inheritance.md).</span></span>

-   <span data-ttu-id="ab18e-138">속성에 애니메이션 효과를 주려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab18e-138">You want your property to be animatable.</span></span> <span data-ttu-id="ab18e-139">자세한 내용은 [애니메이션 개요](../../../../docs/framework/wpf/graphics-multimedia/animation-overview.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ab18e-139">For more information, see [Animation Overview](../../../../docs/framework/wpf/graphics-multimedia/animation-overview.md).</span></span>

-   <span data-ttu-id="ab18e-140">속성 시스템, 환경 또는 사용자가 수행한 작업을 통해 또는 스타일을 읽고 사용하여 이전 속성 값이 변경되었을 때 속성 시스템에서 보고하도록 하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab18e-140">You want the property system to report when the previous value of the property has been changed by actions taken by the property system, the environment, or the user, or by reading and using styles.</span></span> <span data-ttu-id="ab18e-141">속성 메타데이터를 사용하여 속성 시스템에서 속성 값이 명확하게 변경되었다는 것을 확인할 때마다 호출되는 콜백 메서드를 속성이 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ab18e-141">By using property metadata, your property can specify a callback method that will be invoked each time the property system determines that your property value was definitively changed.</span></span> <span data-ttu-id="ab18e-142">관련 개념은 속성 값 강제 변환입니다.</span><span class="sxs-lookup"><span data-stu-id="ab18e-142">A related concept is property value coercion.</span></span> <span data-ttu-id="ab18e-143">자세한 내용은 [종속성 속성 콜백 및 유효성 검사](../../../../docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ab18e-143">For more information, see [Dependency Property Callbacks and Validation](../../../../docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md).</span></span>

-   <span data-ttu-id="ab18e-144">속성 값 변경 시 레이아웃 시스템에서 요소의 시각적 개체를 재구성해야 하는지 여부를 보고하는 것과 같이 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 프로세스에서도 사용되는 설정된 메타데이터 규칙을 사용하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab18e-144">You want to use established metadata conventions that are also used by [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] processes, such as reporting whether changing a property value should require the layout system to recompose the visuals for an element.</span></span> <span data-ttu-id="ab18e-145">또는 파생 클래스가 기본값과 같은 메타데이터 기반 특성을 변경할 수 있도록 메타데이터 재정의를 사용할 수 있도록 하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab18e-145">Or you want to be able to use metadata overrides so that derived classes can change metadata-based characteristics such as the default value.</span></span>

-   <span data-ttu-id="ab18e-146">Visual Studio WPF 디자이너를 받으려면 사용자 지정 컨트롤의 속성 등의 지원, 원하는 **속성** 창 편집 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab18e-146">You want properties of a custom control to receive Visual Studio WPF Designer support, such as **Properties** window editing.</span></span> <span data-ttu-id="ab18e-147">자세한 내용은 [컨트롤 제작 개요](../../../../docs/framework/wpf/controls/control-authoring-overview.md)를 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="ab18e-147">For more information, see [Control Authoring Overview](../../../../docs/framework/wpf/controls/control-authoring-overview.md).</span></span>

<span data-ttu-id="ab18e-148">이러한 시나리오를 검토할 때는 완전히 새로운 속성을 구현하는 대신 기존 종속성 속성의 메타데이터를 재정의하여 시나리오를 얻을 수 있는지 여부도 고려해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab18e-148">When you examine these scenarios, you should also consider whether you can achieve your scenario by overriding the metadata of an existing dependency property, rather than implementing a completely new property.</span></span> <span data-ttu-id="ab18e-149">메타데이터 재정의가 실용적인지 여부는 시나리오 유형과 해당 시나리오가 기존 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 종속성 속성 및 클래스의 구현과 얼마나 유사한지에 따라 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="ab18e-149">Whether a metadata override is practical depends on your scenario and how closely that scenario resembles the implementation in existing [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] dependency properties and classes.</span></span> <span data-ttu-id="ab18e-150">기존 속성에서 메타데이터 재정의에 대한 자세한 내용은 [종속성 속성 메타데이터](../../../../docs/framework/wpf/advanced/dependency-property-metadata.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ab18e-150">For more information about overriding metadata on existing properties, see [Dependency Property Metadata](../../../../docs/framework/wpf/advanced/dependency-property-metadata.md).</span></span>

<a name="checklist"></a>
## <a name="checklist-for-defining-a-dependency-property"></a><span data-ttu-id="ab18e-151">종속성 속성 정의를 위한 검사 목록</span><span class="sxs-lookup"><span data-stu-id="ab18e-151">Checklist for Defining a Dependency Property</span></span>

<span data-ttu-id="ab18e-152">종속성 속성 정의는 4가지 고유한 개념으로 구성됩니다.</span><span class="sxs-lookup"><span data-stu-id="ab18e-152">Defining a dependency property consists of four distinct concepts.</span></span> <span data-ttu-id="ab18e-153">이러한 개념은 반드시 엄격한 절차적 단계는 아니며, 그중 일부는 구현 시 단일 코드 줄로 결합됩니다.</span><span class="sxs-lookup"><span data-stu-id="ab18e-153">These concepts are not necessarily strict procedural steps, because some of these end up being combined as single lines of code in the implementation:</span></span>

-   <span data-ttu-id="ab18e-154">(선택 사항) 종속성 속성의 속성 메타데이터를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="ab18e-154">(Optional) Create property metadata for the dependency property.</span></span>

-   <span data-ttu-id="ab18e-155">속성 시스템에 속성 이름을 등록하여 소유자 유형과 속성 값의 유형을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="ab18e-155">Register the property name with the property system, specifying an owner type and the type of the property value.</span></span> <span data-ttu-id="ab18e-156">또한 사용되는 경우 속성 메타데이터를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="ab18e-156">Also specify the property metadata, if used.</span></span>

-   <span data-ttu-id="ab18e-157">정의 된 <xref:System.Windows.DependencyProperty> 식별자를 `public` `static` `readonly` 소유자 형식에 필드.</span><span class="sxs-lookup"><span data-stu-id="ab18e-157">Define a <xref:System.Windows.DependencyProperty> identifier as a `public` `static` `readonly` field on the owner type.</span></span>

-   <span data-ttu-id="ab18e-158">이름이 종속성 속성의 이름과 일치하는 [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] "래퍼" 속성을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="ab18e-158">Define a [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] "wrapper" property whose name matches the name of the dependency property.</span></span> <span data-ttu-id="ab18e-159">[!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] "래퍼" 속성의 `get` 및 `set` 접근자는 해당 속성을 지원하는 종속성 속성과 연결하도록 구현합니다.</span><span class="sxs-lookup"><span data-stu-id="ab18e-159">Implement the [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] "wrapper" property's `get` and `set` accessors to connect with the dependency property that backs it.</span></span>

<a name="registering"></a>
### <a name="registering-the-property-with-the-property-system"></a><span data-ttu-id="ab18e-160">속성 시스템에 속성 등록</span><span class="sxs-lookup"><span data-stu-id="ab18e-160">Registering the Property with the Property System</span></span>

<span data-ttu-id="ab18e-161">속성이 종속성 속성이 되게 하려면 속성 시스템에서 유지하는 테이블에 해당 속성을 등록한 다음 나중에 속성 시스템 작업의 한정자로 사용되는 고유 식별자를 지정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab18e-161">In order for your property to be a dependency property, you must register that property into a table maintained by the property system, and give it a unique identifier that is used as the qualifier for later property system operations.</span></span> <span data-ttu-id="ab18e-162">이러한 작업은 내부 작업이거나 속성 시스템 [!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)]를 호출하는 자체 코드일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ab18e-162">These operations might be internal operations, or your own code calling property system [!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)].</span></span> <span data-ttu-id="ab18e-163">속성을 등록 하려면 호출을 <xref:System.Windows.DependencyProperty.Register%2A> 클래스 (클래스 내부 이지만 멤버 정의 외부)의 본문 내에서 메서드.</span><span class="sxs-lookup"><span data-stu-id="ab18e-163">To register the property, you call the <xref:System.Windows.DependencyProperty.Register%2A> method within the body of your class (inside the class, but outside of any member definitions).</span></span> <span data-ttu-id="ab18e-164">식별자 필드 여도 제공 됩니다는 <xref:System.Windows.DependencyProperty.Register%2A> 메서드 호출에서 반환 값으로.</span><span class="sxs-lookup"><span data-stu-id="ab18e-164">The identifier field is also provided by the <xref:System.Windows.DependencyProperty.Register%2A> method call, as the return value.</span></span> <span data-ttu-id="ab18e-165">이유는 합니다 <xref:System.Windows.DependencyProperty.Register%2A> 호출이 완료 될 다른 멤버 외부에서 정의 되므로이 반환 값을 사용 하 여 할당 하 고 만들기를 `public` `static` `readonly` 형식의 필드 <xref:System.Windows.DependencyProperty> 클래스의 일부로.</span><span class="sxs-lookup"><span data-stu-id="ab18e-165">The reason that the <xref:System.Windows.DependencyProperty.Register%2A> call is done outside of other member definitions is because you use this return value to assign and create a `public` `static` `readonly` field of type <xref:System.Windows.DependencyProperty> as part of your class.</span></span> <span data-ttu-id="ab18e-166">이 필드는 종속성 속성의 식별자가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ab18e-166">This field becomes the identifier for your dependency property.</span></span>

[!code-csharp[WPFAquariumSln#RegisterAG](../../../../samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#registerag)]
[!code-vb[WPFAquariumSln#RegisterAG](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#registerag)]

<a name="nameconventions"></a>
### <a name="dependency-property-name-conventions"></a><span data-ttu-id="ab18e-167">종속성 속성 이름 규칙</span><span class="sxs-lookup"><span data-stu-id="ab18e-167">Dependency Property Name Conventions</span></span>

<span data-ttu-id="ab18e-168">예외적인 상황을 제외하고 모든 상황에서 따라야 하는 종속성 속성과 관련하여 설정된 명명 규칙이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ab18e-168">There are established naming conventions regarding dependency properties that you must follow in all but exceptional circumstances.</span></span>

<span data-ttu-id="ab18e-169">종속성 속성 자체에 기본 이름 "AquariumGraphic"의 첫 번째 매개 변수로 제공 된이 예제에서는 해야 <xref:System.Windows.DependencyProperty.Register%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="ab18e-169">The dependency property itself will have a basic name, "AquariumGraphic" as in this example, which is given as the first parameter of <xref:System.Windows.DependencyProperty.Register%2A>.</span></span> <span data-ttu-id="ab18e-170">그 이름은 각 등록 형식 내에서 고유해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab18e-170">That name must be unique within each registering type.</span></span> <span data-ttu-id="ab18e-171">기본 형식을 통해 상속된 종속성 속성은 이미 등록 형식의 일부로 간주되어 상속된 속성의 이름을 다시 등록할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ab18e-171">Dependency properties inherited through base types are considered to be already part of the registering type; names of inherited properties cannot be registered again.</span></span> <span data-ttu-id="ab18e-172">그러나 종속성 속성이 상속되지 않는 경우에도 클래스를 종속성 속성의 소유자로 추가하는 기술이 있습니다. 자세한 내용은 [종속성 속성 메타데이터](../../../../docs/framework/wpf/advanced/dependency-property-metadata.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ab18e-172">However, there is a technique for adding a class as owner of a dependency property even when that dependency property is not inherited; for details, see [Dependency Property Metadata](../../../../docs/framework/wpf/advanced/dependency-property-metadata.md).</span></span>

<span data-ttu-id="ab18e-173">식별자 필드를 만들 때 이 필드의 이름을 등록할 때의 속성 이름과 접미사 `Property`로 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="ab18e-173">When you create the identifier field, name this field by the name of the property as you registered it, plus the suffix `Property`.</span></span> <span data-ttu-id="ab18e-174">이 필드는 종속성 속성에 대 한 식별자 이며 나중에 대 한 입력으로 사용 합니다 <xref:System.Windows.DependencyObject.SetValue%2A> 및 <xref:System.Windows.DependencyObject.GetValue%2A> 만드는 모든 다른 코드 속성에 대 한 사용자 고유의 코드에서 모든 외부 코드 액세스 하 여 래퍼가 있습니다 호출 수 에서 속성 시스템에서 잠재적으로 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] 프로세서.</span><span class="sxs-lookup"><span data-stu-id="ab18e-174">This field is your identifier for the dependency property, and it will be used later as an input for the <xref:System.Windows.DependencyObject.SetValue%2A> and <xref:System.Windows.DependencyObject.GetValue%2A> calls you will make in the wrappers, by any other code access to the property by your own code, by any external code access you allow, by the property system, and potentially by [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] processors.</span></span>

> [!NOTE]
> <span data-ttu-id="ab18e-175">클래스 본문에서 종속성 속성을 정의하는 것이 일반적인 구현이지만 클래스 정적 생성자에서 종속성 속성을 정의할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ab18e-175">Defining the dependency property in the class body is the typical implementation, but it is also possible to define a dependency property in the class static constructor.</span></span> <span data-ttu-id="ab18e-176">이 접근 방식은 종속성 속성을 초기화하기 위해 두 줄 이상의 코드가 필요한 경우에 유용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ab18e-176">This approach might make sense if you need more than one line of code to initialize the dependency property.</span></span>

<a name="wrapper1"></a>
### <a name="implementing-the-wrapper"></a><span data-ttu-id="ab18e-177">"래퍼" 구현</span><span class="sxs-lookup"><span data-stu-id="ab18e-177">Implementing the "Wrapper"</span></span>

<span data-ttu-id="ab18e-178">래퍼 구현은 호출 해야 <xref:System.Windows.DependencyObject.GetValue%2A> 에 `get` 구현 및 <xref:System.Windows.DependencyObject.SetValue%2A> 에 `set` 구현 (원래 등록 호출 및 필드도 여기에 표시 됨 명확성을 위해).</span><span class="sxs-lookup"><span data-stu-id="ab18e-178">Your wrapper implementation should call <xref:System.Windows.DependencyObject.GetValue%2A> in the `get` implementation, and <xref:System.Windows.DependencyObject.SetValue%2A> in the `set` implementation (the original registration call and field are shown here too for clarity).</span></span>

<span data-ttu-id="ab18e-179">예외적인 상황을 모두 제외 하 고 래퍼 구현은 수행 해야 합니다 <xref:System.Windows.DependencyObject.GetValue%2A> 및 <xref:System.Windows.DependencyObject.SetValue%2A> 작업, 각각.</span><span class="sxs-lookup"><span data-stu-id="ab18e-179">In all but exceptional circumstances, your wrapper implementations should perform only the <xref:System.Windows.DependencyObject.GetValue%2A> and <xref:System.Windows.DependencyObject.SetValue%2A> actions, respectively.</span></span> <span data-ttu-id="ab18e-180">그 이유는 [XAML로드 및 종속성 속성](../../../../docs/framework/wpf/advanced/xaml-loading-and-dependency-properties.md) 항목에서 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="ab18e-180">The reason for this is discussed in the topic [XAML Loading and Dependency Properties](../../../../docs/framework/wpf/advanced/xaml-loading-and-dependency-properties.md).</span></span>

<span data-ttu-id="ab18e-181">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 클래스에서 제공되는 모든 기존의 공용 종속성 속성은 이 간단한 래퍼 구현 모델을 사용합니다. 종속성 속성의 작동 방식의 대부분은 본질적으로 속성 시스템의 동작이거나 속성 메타데이터를 통한 속성 변경 콜백 또는 강제 변환과 같은 다른 개념을 통해 구현됩니다.</span><span class="sxs-lookup"><span data-stu-id="ab18e-181">All existing public dependency properties that are provided on the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] classes use this simple wrapper implementation model; most of the complexity of how dependency properties work is either inherently a behavior of the property system, or is implemented through other concepts such as coercion or property change callbacks through property metadata.</span></span>

[!code-csharp[WPFAquariumSln#AGWithWrapper](../../../../samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#agwithwrapper)]
[!code-vb[WPFAquariumSln#AGWithWrapper](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#agwithwrapper)]

<span data-ttu-id="ab18e-182">마찬가지로 규칙에 따라 래퍼 속성의 이름을 같아야 선택 및의 첫 번째 매개 변수로 지정 된 이름으로는 <xref:System.Windows.DependencyProperty.Register%2A> 호출 속성을 등록 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab18e-182">Again, by convention, the name of the wrapper property must be the same as the name chosen and given as first parameter of the <xref:System.Windows.DependencyProperty.Register%2A> call that registered the property.</span></span> <span data-ttu-id="ab18e-183">속성이 규칙을 따르지 않는다고 해서 가능한 모든 용도에 사용하지 못한다는 것은 아니지만 몇 가지 주목할 만한 문제가 발생하게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ab18e-183">If your property does not follow the convention, this does not necessarily disable all possible uses, but you will encounter several notable issues:</span></span>

-   <span data-ttu-id="ab18e-184">스타일과 템플릿의 특정 측면이 작동하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ab18e-184">Certain aspects of styles and templates will not work.</span></span>

-   <span data-ttu-id="ab18e-185">대부분의 도구와 디자이너는 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]을 제대로 serialize하거나 속성별 수준에서 디자이너 환경 지원을 제공하기 위해 명명 규칙을 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab18e-185">Most tools and designers must rely on the naming conventions to properly serialize [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)], or to provide designer environment assistance at a per-property level.</span></span>

-   <span data-ttu-id="ab18e-186">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] 로더의 현재 구현은 래퍼를 완전히 무시하고 특성 값을 처리할 때 명명 규칙을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="ab18e-186">The current implementation of the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] loader bypasses the wrappers entirely, and relies on the naming convention when processing attribute values.</span></span> <span data-ttu-id="ab18e-187">자세한 내용은 [XAML로드 및 종속성 속성](../../../../docs/framework/wpf/advanced/xaml-loading-and-dependency-properties.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ab18e-187">For more information, see [XAML Loading and Dependency Properties](../../../../docs/framework/wpf/advanced/xaml-loading-and-dependency-properties.md).</span></span>

<a name="metadata"></a>
### <a name="property-metadata-for-a-new-dependency-property"></a><span data-ttu-id="ab18e-188">새 종속성 속성의 속성 메타데이터</span><span class="sxs-lookup"><span data-stu-id="ab18e-188">Property Metadata for a New Dependency Property</span></span>

<span data-ttu-id="ab18e-189">종속성 속성을 등록할 때 속성 시스템을 통한 등록은 속성 특성을 저장하는 메타데이터 개체를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="ab18e-189">When you register a dependency property, the registration through the property system creates a metadata object that stores property characteristics.</span></span> <span data-ttu-id="ab18e-190">이러한 특성 중 상당수에 속성의 단순 시그니처로 등록 되어 있으면 설정 된 기본값 <xref:System.Windows.DependencyProperty.Register%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="ab18e-190">Many of these characteristics have defaults that are set if the property is registered with the simple signatures of <xref:System.Windows.DependencyProperty.Register%2A>.</span></span> <span data-ttu-id="ab18e-191">다른 시그니처 <xref:System.Windows.DependencyProperty.Register%2A> 속성을 등록할 때 원하는 메타 데이터를 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ab18e-191">Other signatures of <xref:System.Windows.DependencyProperty.Register%2A> allow you to specify the metadata that you want as you register the property.</span></span> <span data-ttu-id="ab18e-192">종속성 속성에 대해 지정된 가장 일반적인 메타데이터는 속성을 사용하는 새 인스턴스에 적용되는 기본값을 속성에 제공하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="ab18e-192">The most common metadata given for dependency properties is to give them a default value that is applied on new instances that use the property.</span></span>

<span data-ttu-id="ab18e-193">파생된 클래스에 대해 존재 하는 종속성 속성을 만드는 경우 <xref:System.Windows.FrameworkElement>, 보다 전문화 된 메타 데이터 클래스를 사용할 수 있습니다 <xref:System.Windows.FrameworkPropertyMetadata> 기본 대신 <xref:System.Windows.PropertyMetadata> 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="ab18e-193">If you are creating a dependency property that exists on a derived class of <xref:System.Windows.FrameworkElement>, you can use the more specialized metadata class <xref:System.Windows.FrameworkPropertyMetadata> rather than the base <xref:System.Windows.PropertyMetadata> class.</span></span> <span data-ttu-id="ab18e-194">에 대 한 생성자는 <xref:System.Windows.FrameworkPropertyMetadata> 클래스 여러 시그니처가 조합 하 여 다양 한 메타 데이터 특성을 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ab18e-194">The constructor for the <xref:System.Windows.FrameworkPropertyMetadata> class has several signatures where you can specify various metadata characteristics in combination.</span></span> <span data-ttu-id="ab18e-195">기본값만 지정 하려는 경우 형식의 단일 매개 변수를 사용 하는 시그니처를 사용 <xref:System.Object>합니다.</span><span class="sxs-lookup"><span data-stu-id="ab18e-195">If you want to specify the default value only, use the signature that takes a single parameter of type <xref:System.Object>.</span></span> <span data-ttu-id="ab18e-196">개체 매개 변수 속성에 대 한 type 별 기본 값으로 전달 (제공 된 기본 값으로 제공 된 형식 이어야 합니다는 `propertyType` 의 매개 변수는 <xref:System.Windows.DependencyProperty.Register%2A> 호출).</span><span class="sxs-lookup"><span data-stu-id="ab18e-196">Pass that object parameter as a type-specific default value for your property (the default value provided must be the type you provided as the `propertyType` parameter in the <xref:System.Windows.DependencyProperty.Register%2A> call).</span></span>

<span data-ttu-id="ab18e-197">에 대 한 <xref:System.Windows.FrameworkPropertyMetadata>, 속성에 대 한 메타 데이터 옵션 플래그를 지정할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ab18e-197">For <xref:System.Windows.FrameworkPropertyMetadata>, you can also specify metadata option flags for your property.</span></span> <span data-ttu-id="ab18e-198">이러한 플래그는 등록 후에 속성 메타데이터에서 불연속 속성으로 변환되며 특정 조건을 레이아웃 엔진과 같은 다른 프로세스와 통신하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="ab18e-198">These flags are converted into discrete properties on the property metadata after registration and are used to communicate certain conditionals to other processes such as the layout engine.</span></span>

#### <a name="setting-appropriate-metadata-flags"></a><span data-ttu-id="ab18e-199">적절한 메타데이터 플래그 설정</span><span class="sxs-lookup"><span data-stu-id="ab18e-199">Setting Appropriate Metadata Flags</span></span>

-   <span data-ttu-id="ab18e-200">속성 (또는 값의 변경)에 영향을 줍니다 합니다 [!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)], 특히에 영향을 줍니다 레이아웃 시스템 크기를 조정 하거나 페이지에서 요소를 렌더링 하는 방법 설정 플래그 중 하나 이상의: <xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsMeasure>를 <xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsArrange>, <xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsRender>합니다.</span><span class="sxs-lookup"><span data-stu-id="ab18e-200">If your property (or changes in its value) affects the [!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)], and in particular affects how the layout system should size or render your element in a page, set one or more of the following flags: <xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsMeasure>, <xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsArrange>, <xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsRender>.</span></span>

    -   <span data-ttu-id="ab18e-201"><xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsMeasure> 이 속성에 대 한 변경에 대 한 변경에 필요 함을 나타냅니다 [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] 를 포함 하는 개체 더 많거나 적은 공간이 필요 부모 내에서 렌더링 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab18e-201"><xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsMeasure> indicates that a change to this property requires a change to [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] rendering where the containing object might require more or less space within the parent.</span></span> <span data-ttu-id="ab18e-202">예를 들어 "Width" 속성은 이 플래그를 설정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab18e-202">For example, a "Width" property should have this flag set.</span></span>

    -   <span data-ttu-id="ab18e-203"><xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsArrange> 이 속성에 대 한 변경에 대 한 변경에 필요 함을 나타냅니다 [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] 전용된 공간에서 변경이 필요 하지 않지만 공간 내의 위치 지정이 변경 되었음을 나타내지는 일반적으로 렌더링 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab18e-203"><xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsArrange> indicates that a change to this property requires a change to [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] rendering that typically does not require a change in the dedicated space, but does indicate that the positioning within the space has changed.</span></span> <span data-ttu-id="ab18e-204">예를 들어 "Alignment" 속성은 이 플래그를 설정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab18e-204">For example, an "Alignment" property should have this flag set.</span></span>

    -   <span data-ttu-id="ab18e-205"><xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsRender> 나타냅니다 레이아웃과 측정값에 영향을 주지 것입니다 하지만 다른 렌더링이 필요한는 다른 변경이 발생 했습니다.</span><span class="sxs-lookup"><span data-stu-id="ab18e-205"><xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsRender> indicates that some other change has occurred that will not affect layout and measure, but does require another render.</span></span> <span data-ttu-id="ab18e-206">예를 들어 기존 요소의 색상을 변경하는 "Background"와 같은 속성이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ab18e-206">An example would be a property that changes a color of an existing element, such as "Background".</span></span>

    -   <span data-ttu-id="ab18e-207">이러한 플래그는 종종 속성 시스템 또는 레이아웃 콜백의 자체 재정의 구현에 대한 메타데이터의 프로토콜로 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="ab18e-207">These flags are often used as a protocol in metadata for your own override implementations of property system or layout callbacks.</span></span> <span data-ttu-id="ab18e-208">예를 들어 있을 수 있습니다는 <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> 를 호출 하는 콜백 <xref:System.Windows.UIElement.InvalidateArrange%2A> 인스턴스의 속성 값 변경을 보고 및 <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> 으로 `true` 해당 메타 데이터에서입니다.</span><span class="sxs-lookup"><span data-stu-id="ab18e-208">For instance, you might have an <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> callback that will call <xref:System.Windows.UIElement.InvalidateArrange%2A> if any property of the instance reports a value change and has <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> as `true` in its metadata.</span></span>

-   <span data-ttu-id="ab18e-209">일부 속성은 위에 언급된 필수 크기의 변경 이상으로, 포함하는 부모 요소의 렌더링 특성에 영향을 줄 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ab18e-209">Some properties may affect the rendering characteristics of the containing parent element, in ways above and beyond the changes in required size mentioned above.</span></span> <span data-ttu-id="ab18e-210">예로 <xref:System.Windows.Documents.Paragraph.MinOrphanLines%2A> 해당 속성을 변경 하면 단락이 포함 된 유동 문서의 전체 렌더링을 변경할 수 있는 흐름 문서 모델에 사용 되는 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="ab18e-210">An example is the <xref:System.Windows.Documents.Paragraph.MinOrphanLines%2A> property used in the flow document model, where changes to that property can change the overall rendering of the flow document that contains the paragraph.</span></span> <span data-ttu-id="ab18e-211">사용 하 여 <xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsParentArrange> 또는 <xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsParentMeasure> 사용자 고유의 속성에서 유사한 사례를 식별 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab18e-211">Use <xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsParentArrange> or <xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsParentMeasure> to identify similar cases in your own properties.</span></span>

-   <span data-ttu-id="ab18e-212">기본적으로 종속성 속성은 데이터 바인딩을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="ab18e-212">By default, dependency properties support data binding.</span></span> <span data-ttu-id="ab18e-213">데이터 바인딩에 대한 현실적인 시나리오가 없거나 큰 개체에 대한 데이터 바인딩의 성능이 문제로 인식되는 경우 데이터 바인딩을 의도적으로 사용하지 않도록 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ab18e-213">You can deliberately disable data binding, for cases where there is no realistic scenario for data binding, or where performance in data binding for a large object is recognized as a problem.</span></span>

-   <span data-ttu-id="ab18e-214">기본적으로 데이터 바인딩 <xref:System.Windows.Data.Binding.Mode%2A> 종속성 속성 기본값에 대 한 <xref:System.Windows.Data.BindingMode.OneWay>합니다.</span><span class="sxs-lookup"><span data-stu-id="ab18e-214">By default, data binding <xref:System.Windows.Data.Binding.Mode%2A> for dependency properties defaults to <xref:System.Windows.Data.BindingMode.OneWay>.</span></span> <span data-ttu-id="ab18e-215">가 되도록 바인딩을 항상 변경할 수 있습니다 <xref:System.Windows.Data.BindingMode.TwoWay> 바인딩 인스턴스마다; 세부 정보에 대 한 참조 [바인딩의 방향을 지정](../../../../docs/framework/wpf/data/how-to-specify-the-direction-of-the-binding.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="ab18e-215">You can always change the binding to be <xref:System.Windows.Data.BindingMode.TwoWay> per binding instance; for details, see [Specify the Direction of the Binding](../../../../docs/framework/wpf/data/how-to-specify-the-direction-of-the-binding.md).</span></span> <span data-ttu-id="ab18e-216">종속성 속성 작성자를 사용 하 여 속성을 확인 하도록 선택할 수 있습니다 하지만 <xref:System.Windows.Data.BindingMode.TwoWay> 기본적으로 바인딩 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="ab18e-216">But as the dependency property author, you can choose to make the property use <xref:System.Windows.Data.BindingMode.TwoWay> binding mode by default.</span></span> <span data-ttu-id="ab18e-217">기존 종속성 속성의 예로 <xref:System.Windows.Controls.MenuItem.IsSubmenuOpen%2A?displayProperty=nameWithType>;는이 속성에 대 한 시나리오는 <xref:System.Windows.Controls.MenuItem.IsSubmenuOpen%2A> 설정 논리와의 합치기 <xref:System.Windows.Controls.MenuItem> 기본 테마 스타일을 사용 하 여 상호 작용 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab18e-217">An example of an existing dependency property is <xref:System.Windows.Controls.MenuItem.IsSubmenuOpen%2A?displayProperty=nameWithType>; the scenario for this property is that the <xref:System.Windows.Controls.MenuItem.IsSubmenuOpen%2A> setting logic and the compositing of <xref:System.Windows.Controls.MenuItem> interact with the default theme style.</span></span> <span data-ttu-id="ab18e-218"><xref:System.Windows.Controls.MenuItem.IsSubmenuOpen%2A> 속성 논리를 사용 하 여 데이터 바인딩을 고유 하 게 다른 상태 속성 및 메서드 호출에 따라에서 속성의 상태를 유지 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab18e-218">The <xref:System.Windows.Controls.MenuItem.IsSubmenuOpen%2A> property logic uses data binding natively to maintain the state of the property in accordance to other state properties and method calls.</span></span> <span data-ttu-id="ab18e-219">바인딩하는 또 다른 예제에서는 속성 <xref:System.Windows.Data.BindingMode.TwoWay> 기본적으로는 <xref:System.Windows.Controls.TextBox.Text%2A?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="ab18e-219">Another example property that binds <xref:System.Windows.Data.BindingMode.TwoWay> by default is <xref:System.Windows.Controls.TextBox.Text%2A?displayProperty=nameWithType>.</span></span>

-   <span data-ttu-id="ab18e-220">설정 하 여 사용자 지정 종속성 속성에서 속성 상속을 사용할 수도 있습니다는 <xref:System.Windows.FrameworkPropertyMetadataOptions.Inherits> 플래그입니다.</span><span class="sxs-lookup"><span data-stu-id="ab18e-220">You can also enable property inheritance in a custom dependency property by setting the <xref:System.Windows.FrameworkPropertyMetadataOptions.Inherits> flag.</span></span> <span data-ttu-id="ab18e-221">속성 상속은 부모 요소와 자식 요소가 공통된 속성을 갖는 시나리오에 유용하며 자식 요소가 해당 특정 속성 값을 부모가 설정한 값과 동일한 값으로 설정하는 것이 적합합니다.</span><span class="sxs-lookup"><span data-stu-id="ab18e-221">Property inheritance is useful for a scenario where parent elements and child elements have a property in common, and it makes sense for the child elements to have that particular property value set to the same value as the parent set it.</span></span> <span data-ttu-id="ab18e-222">예제에서는 상속 가능한 속성은 <xref:System.Windows.FrameworkElement.DataContext%2A>, 데이터 프레젠테이션에 중요 한 마스터-세부 시나리오를 사용 하는 바인딩 작업에 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ab18e-222">An example inheritable property is <xref:System.Windows.FrameworkElement.DataContext%2A>, which is used for binding operations to enable the important master-detail scenario for data presentation.</span></span> <span data-ttu-id="ab18e-223">만들어 <xref:System.Windows.FrameworkElement.DataContext%2A> , 상속 가능한 모든 자식 요소는 데이터 컨텍스트를 상속도 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab18e-223">By making <xref:System.Windows.FrameworkElement.DataContext%2A> inheritable, any child elements inherit that data context also.</span></span> <span data-ttu-id="ab18e-224">속성 값 상속으로 인해 페이지 또는 응용 프로그램 루트에서 데이터 컨텍스트를 지정할 수 있으며 가능한 모든 하위 요소의 바인딩에 대해 다시 지정할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ab18e-224">Because of property value inheritance, you can specify a data context at the page or application root, and do not need to respecify it for bindings in all possible child elements.</span></span> <span data-ttu-id="ab18e-225"><xref:System.Windows.FrameworkElement.DataContext%2A> 상속 기본값을 재정의 합니다. 하지만 항상 설정할 수 있습니다 로컬로 모든 특정 자식 요소에는 설명 하기 위해 좋은 예 이기도 자세한 내용은 참조 하세요 [계층적 데이터에 마스터-세부 패턴 사용](../../../../docs/framework/wpf/data/how-to-use-the-master-detail-pattern-with-hierarchical-data.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="ab18e-225"><xref:System.Windows.FrameworkElement.DataContext%2A> is also a good example to illustrate that inheritance overrides the default value, but it can always be set locally on any particular child element; for details, see [Use the Master-Detail Pattern with Hierarchical Data](../../../../docs/framework/wpf/data/how-to-use-the-master-detail-pattern-with-hierarchical-data.md).</span></span> <span data-ttu-id="ab18e-226">속성 값 상속을 사용하면 성능이 저하될 수 있으므로 꼭 필요할 때만 사용해야 합니다. 자세한 내용은 [속성 값 상속](../../../../docs/framework/wpf/advanced/property-value-inheritance.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ab18e-226">Property value inheritance does have a possible performance cost, and thus should be used sparingly; for details, see [Property Value Inheritance](../../../../docs/framework/wpf/advanced/property-value-inheritance.md).</span></span>

-   <span data-ttu-id="ab18e-227">설정 된 <xref:System.Windows.FrameworkPropertyMetadataOptions.Journal> 종속성 속성을 검색 또는 탐색 저널링 서비스에서 사용 하는 경우를 나타내는 플래그입니다.</span><span class="sxs-lookup"><span data-stu-id="ab18e-227">Set the <xref:System.Windows.FrameworkPropertyMetadataOptions.Journal> flag to indicate if your dependency property should be detected or used by navigation journaling services.</span></span> <span data-ttu-id="ab18e-228">예로 <xref:System.Windows.Controls.Primitives.Selector.SelectedIndex%2A> 속성; 선택에서 선택한 모든 항목은 저널링 기록을 탐색할 때 컨트롤을 유지 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab18e-228">An example is the <xref:System.Windows.Controls.Primitives.Selector.SelectedIndex%2A> property; any item selected in a selection control should be persisted when the journaling history is navigated.</span></span>

<a name="RODP"></a>
## <a name="read-only-dependency-properties"></a><span data-ttu-id="ab18e-229">읽기 전용 종속성 속성</span><span class="sxs-lookup"><span data-stu-id="ab18e-229">Read-Only Dependency Properties</span></span>

<span data-ttu-id="ab18e-230">읽기 전용인 종속성 속성을 정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ab18e-230">You can define a dependency property that is read-only.</span></span> <span data-ttu-id="ab18e-231">그러나 속성을 읽기 전용으로 정의하는 이유에 대한 시나리오는 속성 시스템에 속성을 등록하고 식별자를 노출하는 절차와 약간 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="ab18e-231">However, the scenarios for why you might define your property as read-only are somewhat different, as is the procedure for registering them with the property system and exposing the identifier.</span></span> <span data-ttu-id="ab18e-232">자세한 내용은 [읽기 전용 종속성 속성](../../../../docs/framework/wpf/advanced/read-only-dependency-properties.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ab18e-232">For more information, see [Read-Only Dependency Properties](../../../../docs/framework/wpf/advanced/read-only-dependency-properties.md).</span></span>

<a name="CTDP"></a>
## <a name="collection-type-dependency-properties"></a><span data-ttu-id="ab18e-233">컬렉션 형식 종속성 속성</span><span class="sxs-lookup"><span data-stu-id="ab18e-233">Collection-Type Dependency Properties</span></span>

<span data-ttu-id="ab18e-234">컬렉션 형식 종속성 속성에는 고려할 몇 가지 추가 구현의 문제점이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ab18e-234">Collection-type dependency properties have some additional implementation issues to consider.</span></span> <span data-ttu-id="ab18e-235">자세한 내용은 [컬렉션 형식 종속성 속성](../../../../docs/framework/wpf/advanced/collection-type-dependency-properties.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ab18e-235">For details, see [Collection-Type Dependency Properties](../../../../docs/framework/wpf/advanced/collection-type-dependency-properties.md).</span></span>

<a name="SecurityC"></a>
## <a name="dependency-property-security-considerations"></a><span data-ttu-id="ab18e-236">종속성 속성 보안 고려 사항</span><span class="sxs-lookup"><span data-stu-id="ab18e-236">Dependency Property Security Considerations</span></span>

<span data-ttu-id="ab18e-237">종속성 속성은 공용 속성으로 선언해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab18e-237">Dependency properties should be declared as public properties.</span></span> <span data-ttu-id="ab18e-238">종속성 속성 식별자 필드는 공용 정적 필드로 선언해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab18e-238">Dependency property identifier fields should be declared as public static fields.</span></span> <span data-ttu-id="ab18e-239">다른 액세스 수준(예: 보호됨)을 선언하려고 시도하더라도 속성 시스템 [!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)]와 함께 식별자를 통해 종속성 속성에 항상 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ab18e-239">Even if you attempt to declare other access levels (such as protected), a dependency property can always be accessed through the identifier in combination with the property system [!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)].</span></span> <span data-ttu-id="ab18e-240">메타 데이터 보고 또는 값 결정으로 인해도 보호 된 식별자 필드는 잠재적으로 액세스할 수 있습니다 [!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)] 의 일부인 속성 시스템에 같은 <xref:System.Windows.LocalValueEnumerator>합니다.</span><span class="sxs-lookup"><span data-stu-id="ab18e-240">Even a protected identifier field is potentially accessible because of metadata reporting or value determination [!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)] that are part of the property system, such as <xref:System.Windows.LocalValueEnumerator>.</span></span> <span data-ttu-id="ab18e-241">자세한 내용은 [종속성 속성 보안](../../../../docs/framework/wpf/advanced/dependency-property-security.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ab18e-241">For more information, see [Dependency Property Security](../../../../docs/framework/wpf/advanced/dependency-property-security.md).</span></span>

<a name="DPCtor"></a>
## <a name="dependency-properties-and-class-constructors"></a><span data-ttu-id="ab18e-242">종속성 속성 및 클래스 생성자</span><span class="sxs-lookup"><span data-stu-id="ab18e-242">Dependency Properties and Class Constructors</span></span>

<span data-ttu-id="ab18e-243">클래스 생성자가 가상 ​​메서드를 호출해서는 안 되는 관리 코드 프로그래밍(종종 FxCop와 같은 코드 분석 도구로 시행)에 일반적인 원칙이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ab18e-243">There is a general principle in managed code programming (often enforced by code analysis tools such as FxCop) that class constructors should not call virtual methods.</span></span> <span data-ttu-id="ab18e-244">이는 생성자가 파생 클래스 생성자의 기본 초기화로 호출될 수 있고 생성자를 통한 가상 메서드 입력이 생성 중인 개체 인스턴스의 불완전 초기화 상태에서 발생할 수 있기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="ab18e-244">This is because constructors can be called as base initialization of a derived class constructor, and entering the virtual method through the constructor might occur at an incomplete initialization state of the object instance being constructed.</span></span> <span data-ttu-id="ab18e-245">이미 파생 된 클래스에서 파생 하는 경우 <xref:System.Windows.DependencyObject>, 속성 시스템 자체를 호출 하는 가상 메서드를 내부적으로 노출 알고 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab18e-245">When you derive from any class that already derives from <xref:System.Windows.DependencyObject>, you should be aware that the property system itself calls and exposes virtual methods internally.</span></span> <span data-ttu-id="ab18e-246">이러한 가상 메서드는 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 속성 시스템 서비스의 일부입니다.</span><span class="sxs-lookup"><span data-stu-id="ab18e-246">These virtual methods are part of the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] property system services.</span></span> <span data-ttu-id="ab18e-247">메서드를 재정의하면 파생 클래스가 값 결정에 참여할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ab18e-247">Overriding the methods enables derived classes to participate in value determination.</span></span> <span data-ttu-id="ab18e-248">런타임 초기화 시 발생할 수 있는 문제를 방지하려면 매우 구체적인 생성자 패턴을 따라 클래스의 생성자 내에서 종속성 속성 값을 설정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab18e-248">To avoid potential issues with runtime initialization, you should not set dependency property values within constructors of classes, unless you follow a very specific constructor pattern.</span></span> <span data-ttu-id="ab18e-249">자세한 내용은 [DependencyObjects의 안전한 생성자 패턴](../../../../docs/framework/wpf/advanced/safe-constructor-patterns-for-dependencyobjects.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ab18e-249">For details, see [Safe Constructor Patterns for DependencyObjects](../../../../docs/framework/wpf/advanced/safe-constructor-patterns-for-dependencyobjects.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="ab18e-250">참고 항목</span><span class="sxs-lookup"><span data-stu-id="ab18e-250">See Also</span></span>

- [<span data-ttu-id="ab18e-251">종속성 속성 개요</span><span class="sxs-lookup"><span data-stu-id="ab18e-251">Dependency Properties Overview</span></span>](../../../../docs/framework/wpf/advanced/dependency-properties-overview.md)
- [<span data-ttu-id="ab18e-252">종속성 속성 메타데이터</span><span class="sxs-lookup"><span data-stu-id="ab18e-252">Dependency Property Metadata</span></span>](../../../../docs/framework/wpf/advanced/dependency-property-metadata.md)
- [<span data-ttu-id="ab18e-253">컨트롤 제작 개요</span><span class="sxs-lookup"><span data-stu-id="ab18e-253">Control Authoring Overview</span></span>](../../../../docs/framework/wpf/controls/control-authoring-overview.md)
- [<span data-ttu-id="ab18e-254">컬렉션 형식 종속성 속성</span><span class="sxs-lookup"><span data-stu-id="ab18e-254">Collection-Type Dependency Properties</span></span>](../../../../docs/framework/wpf/advanced/collection-type-dependency-properties.md)
- [<span data-ttu-id="ab18e-255">종속성 속성 보안</span><span class="sxs-lookup"><span data-stu-id="ab18e-255">Dependency Property Security</span></span>](../../../../docs/framework/wpf/advanced/dependency-property-security.md)
- [<span data-ttu-id="ab18e-256">XAML 로드 및 종속성 속성</span><span class="sxs-lookup"><span data-stu-id="ab18e-256">XAML Loading and Dependency Properties</span></span>](../../../../docs/framework/wpf/advanced/xaml-loading-and-dependency-properties.md)
- [<span data-ttu-id="ab18e-257">DependencyObjects의 안전한 생성자 패턴</span><span class="sxs-lookup"><span data-stu-id="ab18e-257">Safe Constructor Patterns for DependencyObjects</span></span>](../../../../docs/framework/wpf/advanced/safe-constructor-patterns-for-dependencyobjects.md)
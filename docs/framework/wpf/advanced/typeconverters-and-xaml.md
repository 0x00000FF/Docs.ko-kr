---
title: TypeConverter 및 XAML
ms.date: 03/30/2017
helpviewer_keywords:
- XAML [WPF], TypeConverter class
ms.assetid: f6313e4d-e89d-497d-ac87-b43511a1ae4b
ms.openlocfilehash: 94cfce44d5702e0550310723ec56184096165436
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/12/2020
ms.locfileid: "79187293"
---
# <a name="typeconverters-and-xaml"></a><span data-ttu-id="a1b20-102">TypeConverter 및 XAML</span><span class="sxs-lookup"><span data-stu-id="a1b20-102">TypeConverters and XAML</span></span>
<span data-ttu-id="a1b20-103">이 항목에서는 문자열에서 형식 변환의 용도를 일반 XAML 언어 기능으로 소개합니다.</span><span class="sxs-lookup"><span data-stu-id="a1b20-103">This topic introduces the purpose of type conversion from string as a general XAML language feature.</span></span> <span data-ttu-id="a1b20-104">.NET Framework에서 <xref:System.ComponentModel.TypeConverter> 클래스는 XAML 특성 사용에서 속성 값으로 사용할 수 있는 관리되는 사용자 지정 클래스에 대한 구현의 일부로 특정 용도로 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="a1b20-104">In the .NET Framework, the <xref:System.ComponentModel.TypeConverter> class serves a particular purpose as part of the implementation for a managed custom class that can be used as a property value in XAML attribute usage.</span></span> <span data-ttu-id="a1b20-105">사용자 지정 클래스를 작성하고 클래스의 인스턴스를 XAML settable 특성 값으로 사용할 수 있도록 <xref:System.ComponentModel.TypeConverterAttribute> 하려면 클래스에 a를 <xref:System.ComponentModel.TypeConverter> 적용하거나 사용자 지정 클래스를 작성하거나 둘 다 사용해야 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a1b20-105">If you write a custom class, and you want instances of your class to be usable as XAML settable attribute values, you might need to apply a <xref:System.ComponentModel.TypeConverterAttribute> to your class, write a custom <xref:System.ComponentModel.TypeConverter> class, or both.</span></span>  

## <a name="type-conversion-concepts"></a><span data-ttu-id="a1b20-106">형식 변환 개념</span><span class="sxs-lookup"><span data-stu-id="a1b20-106">Type Conversion Concepts</span></span>  
  
### <a name="xaml-and-string-values"></a><span data-ttu-id="a1b20-107">XAML 및 문자열 값</span><span class="sxs-lookup"><span data-stu-id="a1b20-107">XAML and String Values</span></span>  
 <span data-ttu-id="a1b20-108">XAML 파일에서 특성 값을 설정하는 경우 해당 값의 초기 형식은 일반 텍스트의 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="a1b20-108">When you set an attribute value in a XAML file, the initial type of that value is a string in pure text.</span></span> <span data-ttu-id="a1b20-109">XAML 프로세서에 대한 <xref:System.Double> 처음에는 텍스트 문자열과 같은 다른 프리미티브도 마찬가지입니다.</span><span class="sxs-lookup"><span data-stu-id="a1b20-109">Even other primitives such as <xref:System.Double> are initially text strings to a XAML processor.</span></span>  
  
 <span data-ttu-id="a1b20-110">XAML 프로세서에서 특성 값을 처리하려면 두 가지 정보가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="a1b20-110">A XAML processor needs two pieces of information in order to process an attribute value.</span></span> <span data-ttu-id="a1b20-111">첫 번째 정보는 설정되는 속성의 값 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="a1b20-111">The first piece of information is the value type of the property that is being set.</span></span> <span data-ttu-id="a1b20-112">특성 값을 정의하고 XAML에서 처리되는 모든 문자열은 결국 해당 형식의 값으로 변환되거나 확인되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a1b20-112">Any string that defines an attribute value and that is processed in XAML must ultimately be converted or resolved to a value of that type.</span></span> <span data-ttu-id="a1b20-113">값이 숫자 값과 같이 XAML 파서에서 인식되는 기본 형식인 경우 문자열의 직접 변환이 시도됩니다.</span><span class="sxs-lookup"><span data-stu-id="a1b20-113">If the value is a primitive that is understood by the XAML parser (such as a numeric value), a direct conversion of the string is attempted.</span></span> <span data-ttu-id="a1b20-114">값이 열거형인 경우에는 문자열은 이름이 해당 열거형에 명명된 상수와 일치하는지 확인하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="a1b20-114">If the value is an enumeration, the string is used to check for a name match to a named constant in that enumeration.</span></span> <span data-ttu-id="a1b20-115">값이 파서에서 인식되는 기본 형식이나 열거형이 아닌 경우 해당 형식은 변환된 문자열에 따라 형식의 인스턴스나 값을 제공할 수 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a1b20-115">If the value is neither a parser-understood primitive nor an enumeration, then the type in question must be able to provide an instance of the type, or a value, based on a converted string.</span></span> <span data-ttu-id="a1b20-116">이렇게 하려면 형식 변환기 클래스를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="a1b20-116">This is done by indicating a type converter class.</span></span> <span data-ttu-id="a1b20-117">실제로 형식 변환기는 XAML 시나리오와 .NET 코드의 코드 호출에서 다른 클래스의 값을 제공하기 위한 도우미 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="a1b20-117">The type converter is effectively a helper class for providing values of another class, both for the XAML scenario and also potentially for code calls in .NET code.</span></span>  
  
### <a name="using-existing-type-conversion-behavior-in-xaml"></a><span data-ttu-id="a1b20-118">XAML에서 기존 형식 변환 동작 사용</span><span class="sxs-lookup"><span data-stu-id="a1b20-118">Using Existing Type Conversion Behavior in XAML</span></span>  
 <span data-ttu-id="a1b20-119">기본 XAML 개념에 대한 숙련도에 따라 자신도 모르게 기본 애플리케이션 XAML에서 형식 변환 동작을 이미 사용하고 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a1b20-119">Depending on your familiarity with the underlying XAML concepts, you may already be using type conversion behavior in basic application XAML without realizing it.</span></span> <span data-ttu-id="a1b20-120">예를 들어 WPF는 형식값을 <xref:System.Windows.Point>취하는 수백 개의 속성을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="a1b20-120">For instance, WPF defines literally hundreds of properties that take a value of type <xref:System.Windows.Point>.</span></span> <span data-ttu-id="a1b20-121">A는 <xref:System.Windows.Point> 2차원 좌표 공간에서 좌표를 설명하는 값이며 실제로 는 두 가지 <xref:System.Windows.Point.X%2A> <xref:System.Windows.Point.Y%2A>중요한 속성과 를 가만히 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a1b20-121">A <xref:System.Windows.Point> is a value that describes a coordinate in a two-dimensional coordinate space, and it really just has two important properties: <xref:System.Windows.Point.X%2A> and <xref:System.Windows.Point.Y%2A>.</span></span> <span data-ttu-id="a1b20-122">XAML에서 점을 지정할 때 제공하는 <xref:System.Windows.Point.X%2A> 값과 <xref:System.Windows.Point.Y%2A> 값 사이에 구분기호(일반적으로 쉼표)가 있는 문자열로 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="a1b20-122">When you specify a point in XAML, you specify it as a string with a delimiter (typically a comma) between the <xref:System.Windows.Point.X%2A> and <xref:System.Windows.Point.Y%2A> values you provide.</span></span> <span data-ttu-id="a1b20-123">예: `<LinearGradientBrush StartPoint="0,0" EndPoint="1,1"/>`</span><span class="sxs-lookup"><span data-stu-id="a1b20-123">For example: `<LinearGradientBrush StartPoint="0,0" EndPoint="1,1"/>`.</span></span>  
  
 <span data-ttu-id="a1b20-124">XAML에서 <xref:System.Windows.Point> 이러한 간단한 유형과 간단한 사용법조차도 형식 변환기를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="a1b20-124">Even this simple type of <xref:System.Windows.Point> and its simple usage in XAML involve a type converter.</span></span> <span data-ttu-id="a1b20-125">이 경우 클래스입니다. <xref:System.Windows.PointConverter></span><span class="sxs-lookup"><span data-stu-id="a1b20-125">In this case that is the class <xref:System.Windows.PointConverter>.</span></span>  
  
 <span data-ttu-id="a1b20-126">클래스 수준에서 <xref:System.Windows.Point> 정의된 형식 변환기는 을 수행하는 <xref:System.Windows.Point>모든 속성의 태그 사용을 간소화합니다.</span><span class="sxs-lookup"><span data-stu-id="a1b20-126">The type converter for <xref:System.Windows.Point> defined at the class level streamlines the markup usages of all properties that take <xref:System.Windows.Point>.</span></span> <span data-ttu-id="a1b20-127">형식 변환기를 사용하지 않을 경우 위에 나온 동일한 예제에 훨씬 더 자세한 다음과 같은 태그가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="a1b20-127">Without a type converter here, you would need the following much more verbose markup for the same example shown previously:</span></span>  

```xaml
<LinearGradientBrush>
  <LinearGradientBrush.StartPoint>
    <Point X="0" Y="0"/>
  </LinearGradientBrush.StartPoint>
  <LinearGradientBrush.EndPoint>
    <Point X="1" Y="1"/>
  </LinearGradientBrush.EndPoint>
</LinearGradientBrush>
 ```
  
 <span data-ttu-id="a1b20-128">형식 변환 문자열을 사용할지 보다 자세한 해당 구문을 사용할지 여부는 일반적으로 코딩 스타일에 따라 선택됩니다.</span><span class="sxs-lookup"><span data-stu-id="a1b20-128">Whether to use the type conversion string or a more verbose equivalent syntax is generally a coding style choice.</span></span> <span data-ttu-id="a1b20-129">XAML 도구 워크플로도 값 설정 방법에 영향을 줄 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a1b20-129">Your XAML tooling workflow might also influence how values are set.</span></span> <span data-ttu-id="a1b20-130">일부 XAML 도구는 디자이너 뷰 또는 고유한 serialization 메커니즘을 더 쉽게 왕복하기 때문에 가장 자세한 형식의 태그를 내보내는 경향이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a1b20-130">Some XAML tools tend to emit the most verbose form of the markup because it is easier to round-trip to designer views or its own serialization mechanism.</span></span>  
  
 <span data-ttu-id="a1b20-131">기존 형식 변환기는 일반적으로 적용된 <xref:System.ComponentModel.TypeConverterAttribute>클래스(또는 속성)를 확인하여 WPF 및 .NET Framework 형식에서 검색할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a1b20-131">Existing type converters can generally be discovered on WPF and .NET Framework types by checking a class (or property) for the presence of an applied <xref:System.ComponentModel.TypeConverterAttribute>.</span></span> <span data-ttu-id="a1b20-132">이 특성은 XAML 용도 및 기타 가능한 용도에서 해당 형식의 값을 지원하는 형식 변환기인 클래스의 이름을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="a1b20-132">This attribute will name the class that is the supporting type converter for values of that type, for XAML purposes as well as potentially other purposes.</span></span>  
  
### <a name="type-converters-and-markup-extensions"></a><span data-ttu-id="a1b20-133">형식 변환기 및 태그 확장명</span><span class="sxs-lookup"><span data-stu-id="a1b20-133">Type Converters and Markup Extensions</span></span>  
 <span data-ttu-id="a1b20-134">태그 확장 및 형식 변환기는 적용되는 시나리오 및 XAML 프로세서 동작 측면에서 직교 역할을 채웁니다.</span><span class="sxs-lookup"><span data-stu-id="a1b20-134">Markup extensions and type converters fill orthogonal roles in terms of XAML processor behavior and the scenarios that they are applied to.</span></span> <span data-ttu-id="a1b20-135">태그 확장 사용에 컨텍스트를 사용할 수는 있지만 태그 확장에서 값을 제공하는 속성의 형식 변환 동작은 일반적으로 태그 확장 구현에서 확인되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="a1b20-135">Although context is available for markup extension usages, type conversion behavior of properties where a markup extension provides a value is generally is not checked in the markup extension implementations.</span></span> <span data-ttu-id="a1b20-136">즉, 태그 확장에서 텍스트 문자열을 해당 `ProvideValue` 출력으로 반환하는 경우에도 특정 속성이나 속성 값 형식에 적용될 때 해당 문자열의 형식 변환 동작은 호출되지 않습니다. 일반적으로 태그 확장의 목적은 문자열을 처리하고 관련된 형식 변환기 없이 개체를 반환하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="a1b20-136">In other words, even if a markup extension returns a text string as its `ProvideValue` output, type conversion behavior on that string as applied to a specific property or property value type is not invoked, Generally, the purpose of a markup extension is to process a string and return an object without any type converter involved.</span></span>  
  
 <span data-ttu-id="a1b20-137">형식 변환기가 아니라 태그 확장이 필요한 일반적인 상황은 이미 존재하는 개체에 대한 참조를 만드는 경우입니다.</span><span class="sxs-lookup"><span data-stu-id="a1b20-137">One common situation where a markup extension is necessary rather than a type converter is to make a reference to an object that already exists.</span></span> <span data-ttu-id="a1b20-138">기껏해야 상태 비저장 형식 변환기만 새 인스턴스를 생성할 수 있으며, 이는 바람직하지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a1b20-138">At best, a stateless type converter could only generate a new instance, which might not be desirable.</span></span> <span data-ttu-id="a1b20-139">태그 확장에 대한 자세한 내용은 [태그 확장 및 WPF XAML](markup-extensions-and-wpf-xaml.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="a1b20-139">For more information on markup extensions, see [Markup Extensions and WPF XAML](markup-extensions-and-wpf-xaml.md).</span></span>  
  
### <a name="native-type-converters"></a><span data-ttu-id="a1b20-140">네이티브 형식 변환기</span><span class="sxs-lookup"><span data-stu-id="a1b20-140">Native Type Converters</span></span>  
 <span data-ttu-id="a1b20-141">XAML 파서의 WPF 및 .NET Framework 구현에는 네이티브 형식 변환 처리를 사용하는 특정 형식이 있지만 일반적으로 이 형식은 기본 형식으로 간주되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="a1b20-141">In the WPF and .NET Framework implementation of the XAML parser, there are certain types that have native type conversion handling, yet are not types that might conventionally be thought of as primitives.</span></span> <span data-ttu-id="a1b20-142">이러한 형식의 예로는 <xref:System.DateTime>이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a1b20-142">An example of such a type is <xref:System.DateTime>.</span></span> <span data-ttu-id="a1b20-143">그 이유는 .NET Framework 아키텍처의 작동 방식에 따라 <xref:System.DateTime> 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="a1b20-143">The reason for this is based on how the .NET Framework architecture works: the type <xref:System.DateTime> is defined in mscorlib, the most basic library in .NET.</span></span> <span data-ttu-id="a1b20-144"><xref:System.DateTime>속성(시스템에서<xref:System.ComponentModel.TypeConverterAttribute> 온 속성)을 도입하는 다른 어셈블리에서 온 특성으로 인해 인해 발생할 수 없으므로 일반적인 형식 변환기 검색 메커니즘을 지원할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="a1b20-144"><xref:System.DateTime> is not permitted to be attributed with an attribute that comes from another assembly that introduces a dependency (<xref:System.ComponentModel.TypeConverterAttribute> is from System) so the usual type converter discovery mechanism by attributing cannot be supported.</span></span> <span data-ttu-id="a1b20-145">대신 XAML 파서에 이러한 네이티브 처리가 필요한 형식 목록이 있으며 실제 기본 형식이 처리되는 방법과 유사한 방법으로 이러한 형식을 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="a1b20-145">Instead, the XAML parser has a list of types that need such native processing and processes these similarly to how the true primitives are processed.</span></span> <span data-ttu-id="a1b20-146">(이 경우 <xref:System.DateTime> <xref:System.DateTime.Parse%2A>.)</span><span class="sxs-lookup"><span data-stu-id="a1b20-146">(In the case of <xref:System.DateTime> this involves a call to <xref:System.DateTime.Parse%2A>.)</span></span>  
  
<a name="Implementing_a_Type_Converter"></a>
## <a name="implementing-a-type-converter"></a><span data-ttu-id="a1b20-147">형식 변환기 구현</span><span class="sxs-lookup"><span data-stu-id="a1b20-147">Implementing a Type Converter</span></span>  
  
### <a name="typeconverter"></a><span data-ttu-id="a1b20-148">TypeConverter</span><span class="sxs-lookup"><span data-stu-id="a1b20-148">TypeConverter</span></span>  
 <span data-ttu-id="a1b20-149">앞에서 <xref:System.Windows.Point> 설명한 예제에서는 <xref:System.Windows.PointConverter> 클래스가 언급되었습니다.</span><span class="sxs-lookup"><span data-stu-id="a1b20-149">In the <xref:System.Windows.Point> example given previously, the class <xref:System.Windows.PointConverter> was mentioned.</span></span> <span data-ttu-id="a1b20-150">XAML의 .NET 구현의 경우 XAML 용도로 사용되는 모든 형식 변환기는 <xref:System.ComponentModel.TypeConverter>기본 클래스에서 파생되는 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="a1b20-150">For .NET implementations of XAML, all type converters that are used for XAML purposes are classes that derive from the base class <xref:System.ComponentModel.TypeConverter>.</span></span> <span data-ttu-id="a1b20-151">클래스는 <xref:System.ComponentModel.TypeConverter> XAML의 존재보다 먼저 .NET Framework 버전에 존재했습니다. 원래 사용 법 중 하나는 시각적 디자이너에서 속성 대화 상자에 대 한 문자열 변환을 제공 하는 것이었습니다.</span><span class="sxs-lookup"><span data-stu-id="a1b20-151">The <xref:System.ComponentModel.TypeConverter> class existed in versions of .NET Framework that precede the existence of XAML; one of its original usages was to provide string conversion for property dialogs in visual designers.</span></span> <span data-ttu-id="a1b20-152">XAML의 <xref:System.ComponentModel.TypeConverter> 경우 문자열 속성 값을 구문 분석할 수 있는 문자열 간 변환 및 문자열 변환에 대한 기본 클래스가 되고 특정 개체 속성의 런타임 값을 다시 함수화를 위한 문자열로 처리하도록 역할이 확장됩니다.</span><span class="sxs-lookup"><span data-stu-id="a1b20-152">For XAML, the role of <xref:System.ComponentModel.TypeConverter> is expanded to include being the base class for to-string and from-string conversions that enable parsing a string attribute value, and possibly processing a run-time value of a particular object property back into a string for serialization as an attribute.</span></span>  
  
 <span data-ttu-id="a1b20-153"><xref:System.ComponentModel.TypeConverter>XAML 처리를 위해 문자열로 변환하는 데 관련된 네 개의 멤버를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="a1b20-153"><xref:System.ComponentModel.TypeConverter> defines four members that are relevant for converting to and from strings for XAML processing purposes:</span></span>  
  
- <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A>  
  
- <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A>  
  
- <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>  
  
- <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A>  
  
 <span data-ttu-id="a1b20-154">이 중 가장 중요한 <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A>방법은 .</span><span class="sxs-lookup"><span data-stu-id="a1b20-154">Of these, the most important method is <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A>.</span></span> <span data-ttu-id="a1b20-155">이 메서드는 입력 문자열을 필요한 개체 형식으로 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="a1b20-155">This method converts the input string to the required object type.</span></span> <span data-ttu-id="a1b20-156">엄밀히 말하면 훨씬 더 넓은 범위의 형식을 변환하는 <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> 메서드를 변환자의 의도된 대상 유형으로 변환할 수 있으므로 런타임 변환을 지원하는 등 XAML을 넘어 확장되는 <xref:System.String> 용도로 사용할 수 있지만 XAML의 경우 중요한 입력을 처리할 수 있는 코드 경로일 뿐입니다.</span><span class="sxs-lookup"><span data-stu-id="a1b20-156">Strictly speaking, the <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> method could be implemented to convert a much wider range of types into the converter's intended destination type, and thus serve purposes that extend beyond XAML such as supporting run-time conversions, but for XAML purposes it is only the code path that can process a <xref:System.String> input that matters.</span></span>  
  
 <span data-ttu-id="a1b20-157">다음으로 가장 중요한 <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>방법은 .</span><span class="sxs-lookup"><span data-stu-id="a1b20-157">The next most important method is <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>.</span></span> <span data-ttu-id="a1b20-158">응용 프로그램이 태그 표현으로 변환되는 경우(예: XAML에 파일로 저장된 <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> 경우) 태그 표현을 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="a1b20-158">If an application is converted to a markup representation (for instance, if it is saved to XAML as a file), <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> is responsible for producing a markup representation.</span></span> <span data-ttu-id="a1b20-159">이 경우 XAML에서 중요한 코드 경로는 `destinationType` <xref:System.String> 을 전달할 때입니다.</span><span class="sxs-lookup"><span data-stu-id="a1b20-159">In this case, the code path that matters for XAML is when you pass a `destinationType` of <xref:System.String> .</span></span>  
  
 <span data-ttu-id="a1b20-160"><xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> 및 <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A> 은 서비스에서 <xref:System.ComponentModel.TypeConverter> 구현의 기능을 쿼리할 때 사용되는 지원 메서드입니다.</span><span class="sxs-lookup"><span data-stu-id="a1b20-160"><xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> and <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A> are support methods that are used when a service queries the capabilities of the <xref:System.ComponentModel.TypeConverter> implementation.</span></span> <span data-ttu-id="a1b20-161">변환기의 동일한 변환 메서드에서 지원하는 형식 관련 케이스에 대해 `true`를 반환하려면 이러한 메서드를 구현해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a1b20-161">You must implement these methods to return `true` for type-specific cases that the equivalent conversion methods of your converter support.</span></span> <span data-ttu-id="a1b20-162">XAML 용도에서는 일반적으로 <xref:System.String> 형식을 의미합니다.</span><span class="sxs-lookup"><span data-stu-id="a1b20-162">For XAML purposes, this generally means the <xref:System.String> type.</span></span>  
  
### <a name="culture-information-and-type-converters-for-xaml"></a><span data-ttu-id="a1b20-163">XAML에 대한 문화권 정보 및 형식 변환기</span><span class="sxs-lookup"><span data-stu-id="a1b20-163">Culture Information and Type Converters for XAML</span></span>  

 <span data-ttu-id="a1b20-164">각 <xref:System.ComponentModel.TypeConverter> 구현은 변환에 유효한 문자열을 구성하는 항목에 대한 고유한 해석을 가질 수 있으며 매개 변수로 전달된 형식 설명을 사용하거나 무시할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a1b20-164">Each <xref:System.ComponentModel.TypeConverter> implementation can have its own interpretation of what constitutes a valid string for a conversion, and can also use or ignore the type description passed as parameters.</span></span> <span data-ttu-id="a1b20-165">문화권 및 XAML 형식 변환과 관련하여 중요한 고려 사항이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a1b20-165">There is an important consideration with regard to culture and XAML type conversion.</span></span> <span data-ttu-id="a1b20-166">XAML에서는 지역화 가능 문자열을 특성 값으로 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a1b20-166">Using localizable strings as attribute values is entirely supported by XAML.</span></span> <span data-ttu-id="a1b20-167">그러나 해당 지역화 가능 문자열을 특정 문화권 요구 사항이 있는 형식 변환기 입력으로 사용할 수는 없습니다. XAML 특성 값에 대한 형식 변환기에는 `en-US` 문화권을 사용하는 고정 언어 구문 분석 동작이 반드시 포함되기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="a1b20-167">But using that localizable string as type converter input with specific culture requirements is not supported, because type converters for XAML attribute values involve a necessarily fixed-language parsing behavior, using `en-US` culture.</span></span> <span data-ttu-id="a1b20-168">이 제한에 대한 디자인 이유에 대한 자세한 내용은 XAML 언어[\[\]사양(MS-XAML)을](https://download.microsoft.com/download/0/A/6/0A6F7755-9AF5-448B-907D-13985ACCF53E/[MS-XAML].pdf)참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="a1b20-168">For more information on the design reasons for this restriction, you should consult the XAML language specification ([\[MS-XAML\]](https://download.microsoft.com/download/0/A/6/0A6F7755-9AF5-448B-907D-13985ACCF53E/[MS-XAML].pdf).</span></span>  
  
 <span data-ttu-id="a1b20-169">문화권이 문제가 될 수 있는 경우에 대한 예로 일부 문화권에서는 숫자에 대한 소수점 구분 기호로 쉼표를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="a1b20-169">As an example where culture can be an issue, some cultures use a comma as their decimal point delimiter for numbers.</span></span> <span data-ttu-id="a1b20-170">이러한 사용은 일반적인 X,Y 형식이나 쉼표로 구분된 목록 같은 역사적 선례에 따라 쉼표를 구분 기호로 사용하는 많은 WPF XAML 형식 변환기의 동작과 충돌합니다.</span><span class="sxs-lookup"><span data-stu-id="a1b20-170">This will collide with the behavior that many of the WPF XAML type converters have, which is to use a comma as a delimiter (based on historical precedents such as the common X,Y form, or comma delimited lists).</span></span> <span data-ttu-id="a1b20-171">주변 XAML에서 `Language` 또는 `xml:lang`을 `sl-SI` 문화권(이런 식으로 소수점에 쉼표를 사용하는 문화권의 예)으로 설정하여 문화권을 전달해도 문제가 해결되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="a1b20-171">Even passing a culture in the surrounding XAML (setting `Language` or `xml:lang` to the `sl-SI` culture, an example of a culture that uses a comma for decimal in this way) does not solve the issue.</span></span>  
  
### <a name="implementing-convertfrom"></a><span data-ttu-id="a1b20-172">ConvertFrom 구현</span><span class="sxs-lookup"><span data-stu-id="a1b20-172">Implementing ConvertFrom</span></span>  
 <span data-ttu-id="a1b20-173">XAML을 지원하는 <xref:System.ComponentModel.TypeConverter> 구현으로 사용하려면 해당 변환기에 대한 <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> 메서드에서 문자열을 `value` 매개 변수로 허용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a1b20-173">To be usable as a <xref:System.ComponentModel.TypeConverter> implementation that supports XAML, the <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> method for that converter must accept a string as the `value` parameter.</span></span> <span data-ttu-id="a1b20-174">문자열이 유효한 형식이고 <xref:System.ComponentModel.TypeConverter> 구현에서 변환할 수 있는 경우 반환된 개체는 속성에서 예상하는 형식으로 캐스트를 지원해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a1b20-174">If the string was in valid format, and can be converted by the <xref:System.ComponentModel.TypeConverter> implementation, then the returned object must support a cast to the type expected by the property.</span></span> <span data-ttu-id="a1b20-175">그렇지 않은 경우 <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> 구현에서 `null`을 반환해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a1b20-175">Otherwise, the <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> implementation must return `null`.</span></span>  
  
 <span data-ttu-id="a1b20-176">각 <xref:System.ComponentModel.TypeConverter> 구현은 변환에 유효한 문자열을 구성하는 항목에 대한 고유한 해석을 가질 수 있으며 매개 변수로 전달된 형식 설명 또는 문화권 컨텍스트를 사용하거나 무시할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a1b20-176">Each <xref:System.ComponentModel.TypeConverter> implementation can have its own interpretation of what constitutes a valid string for a conversion, and can also use or ignore the type description or culture contexts passed as parameters.</span></span> <span data-ttu-id="a1b20-177">그러나 WPF XAML 처리에서 모든 경우의 형식 설명 컨텍스트에 값을 전달할 수는 없으며 `xml:lang`을 기반으로 하는 문화권을 전달할 수도 없습니다.</span><span class="sxs-lookup"><span data-stu-id="a1b20-177">However, the WPF XAML processing might not pass values to the type description context in all cases, and also might not pass culture based on `xml:lang`.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="a1b20-178">중괄호 문자, 특히 {를 문자열 형식의 가능한 요소로 사용하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="a1b20-178">Do not use the curly brace characters, particularly {, as a possible element of your string format.</span></span> <span data-ttu-id="a1b20-179">이러한 문자는 태그 확장명 시퀀스의 시작 및 종료로 예약되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a1b20-179">These characters are reserved as the entry and exit for a markup extension sequence.</span></span>  
  
### <a name="implementing-convertto"></a><span data-ttu-id="a1b20-180">ConvertTo 구현</span><span class="sxs-lookup"><span data-stu-id="a1b20-180">Implementing ConvertTo</span></span>  
 <span data-ttu-id="a1b20-181"><xref:System.ComponentModel.TypeConverter.ConvertTo%2A> 는 serialization 지원에 잠재적으로 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="a1b20-181"><xref:System.ComponentModel.TypeConverter.ConvertTo%2A> is potentially used for serialization support.</span></span> <span data-ttu-id="a1b20-182"><xref:System.ComponentModel.TypeConverter.ConvertTo%2A> 를 통해 사용자 지정 형식 및 해당 형식 변환기에 대해 Serialization을 지원하는 것은 절대적인 요구 사항이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="a1b20-182">Serialization support through <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> for your custom type and its type converter is not an absolute requirement.</span></span> <span data-ttu-id="a1b20-183">그러나 컨트롤을 구현하거나 클래스의 디자인 또는 기능의 일부로 serialization을 사용하는 경우에는 <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>를 구현해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a1b20-183">However, if you are implementing a control, or using serialization of as part of the features or design of your class, you should implement <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>.</span></span>  
  
 <span data-ttu-id="a1b20-184">XAML을 <xref:System.ComponentModel.TypeConverter> 지원하는 구현으로 사용할 수 <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> 있으려면 해당 변환기의 메서드는 `value` 지원되는 형식(또는 값)의 인스턴스를 매개 변수로 받아들여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a1b20-184">To be usable as a <xref:System.ComponentModel.TypeConverter> implementation that supports XAML, the <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> method for that converter must accept an instance of the type (or a value) being supported as the `value` parameter.</span></span> <span data-ttu-id="a1b20-185">매개 `destinationType` 변수가 형식인 <xref:System.String>경우 반환된 개체를 로 <xref:System.String>캐스팅할 수 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a1b20-185">When the `destinationType` parameter is the type <xref:System.String>, then the returned object must be able to be cast as <xref:System.String>.</span></span> <span data-ttu-id="a1b20-186">반환된 문자열은 `value`의 직렬화된 값을 나타내야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a1b20-186">The returned string must represent a serialized value of `value`.</span></span> <span data-ttu-id="a1b20-187">이상적으로 선택한 직렬화 형식은 해당 문자열이 상당한 정보 손실 없이 동일한 <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> 변환기의 구현에 전달된 경우 동일한 값을 생성할 수 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a1b20-187">Ideally, the serialization format you choose should be capable of generating the same value if that string were passed to the <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> implementation of the same converter, without significant loss of information.</span></span>  
  
 <span data-ttu-id="a1b20-188">값을 직렬화할 수 없거나 변환기가 직렬화를 지원하지 <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> 않는 `null`경우 구현은 반환해야 하며 이 경우 예외를 throw할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a1b20-188">If the value cannot be serialized, or the converter does not support serialization, the <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> implementation must return `null`, and is permitted to throw an exception in this case.</span></span> <span data-ttu-id="a1b20-189">그러나 예외를 throw하는 경우 예외를 피하기 위해 <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> 먼저 확인하는 모범 사례가 지원되도록 구현의 일부로 해당 변환을 사용할 수 없음을 보고해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a1b20-189">But if you do throw exceptions, you should report the inability to use that conversion as part of your <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> implementation so that the best practice of checking with <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> first to avoid exceptions is supported.</span></span>  
  
 <span data-ttu-id="a1b20-190">매개 `destinationType` 변수가 형식이 <xref:System.String>아닌 경우 사용자 고유의 변환기 처리를 선택할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a1b20-190">If `destinationType` parameter is not of type <xref:System.String>, you can choose your own converter handling.</span></span> <span data-ttu-id="a1b20-191">일반적으로 기본 구현 처리로 되돌아갑니다. <xref:System.ComponentModel.TypeConverter.ConvertTo%2A></span><span class="sxs-lookup"><span data-stu-id="a1b20-191">Typically, you would revert to base implementation handling, which in the basemost <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> raises a specific exception.</span></span>  
  
### <a name="implementing-canconvertto"></a><span data-ttu-id="a1b20-192">CanConvertTo 구현</span><span class="sxs-lookup"><span data-stu-id="a1b20-192">Implementing CanConvertTo</span></span>  
 <span data-ttu-id="a1b20-193"><xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> 구현은 `true` 형식의 `destinationType` 에 대해 <xref:System.String>를 반환하고, 그렇지 않은 경우 기본 구현에서 결정합니다.</span><span class="sxs-lookup"><span data-stu-id="a1b20-193">Your <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> implementation should return `true` for `destinationType` of type <xref:System.String>, and otherwise defer to the base implementation.</span></span>  
  
### <a name="implementing-canconvertfrom"></a><span data-ttu-id="a1b20-194">CanConvertFrom 구현</span><span class="sxs-lookup"><span data-stu-id="a1b20-194">Implementing CanConvertFrom</span></span>  
 <span data-ttu-id="a1b20-195"><xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A> 구현은 `true` 형식의 `sourceType` 에 대해 <xref:System.String>를 반환하고, 그렇지 않은 경우 기본 구현에서 결정합니다.</span><span class="sxs-lookup"><span data-stu-id="a1b20-195">Your <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A> implementation should return `true` for `sourceType` of type <xref:System.String>, and otherwise defer to the base implementation.</span></span>  
  
<a name="Applying_the_TypeConverterAttribute"></a>
## <a name="applying-the-typeconverterattribute"></a><span data-ttu-id="a1b20-196">TypeConverterAttribute 적용</span><span class="sxs-lookup"><span data-stu-id="a1b20-196">Applying the TypeConverterAttribute</span></span>  
 <span data-ttu-id="a1b20-197">사용자 지정 형식 변환기를 XAML 프로세서에서 사용자 지정 클래스의 연기 형식 변환기로 사용하려면 <xref:System.ComponentModel.TypeConverterAttribute> 클래스 정의에 이 변환기를 적용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a1b20-197">In order for your custom type converter to be used as the acting type converter for a custom class by a XAML processor, you must apply the <xref:System.ComponentModel.TypeConverterAttribute> to your class definition.</span></span> <span data-ttu-id="a1b20-198">특성을 통해 지정하는 <xref:System.ComponentModel.TypeConverterAttribute.ConverterTypeName%2A> 은 사용자 지정 형식 변환기의 형식 이름이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a1b20-198">The <xref:System.ComponentModel.TypeConverterAttribute.ConverterTypeName%2A> that you specify through the attribute must be the type name of your custom type converter.</span></span> <span data-ttu-id="a1b20-199">XAML 프로세서에서 속성 형식이 사용자 지정 클래스 형식을 사용하는 값을 처리할 때 이 특성을 적용하면 문자열을 입력하고 개체 인스턴스를 반환할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a1b20-199">With this attribute applied, when a XAML processor handles values where the property type uses your custom class type, it can input strings and return object instances.</span></span>  
  
 <span data-ttu-id="a1b20-200">또한 속성별로 형식 변환기를 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a1b20-200">You can also provide a type converter on a per-property basis.</span></span> <span data-ttu-id="a1b20-201">클래스 정의에 <xref:System.ComponentModel.TypeConverterAttribute> a를 적용하는 대신 속성 정의(기본 정의는 구현이 `get` / `set` 아닌 기본 정의)에 적용합니다.</span><span class="sxs-lookup"><span data-stu-id="a1b20-201">Instead of applying a <xref:System.ComponentModel.TypeConverterAttribute> to the class definition, apply it to a property definition (the main definition, not the `get`/`set` implementations within it).</span></span> <span data-ttu-id="a1b20-202">속성의 형식은 사용자 지정 형식 변환기에서 처리되는 형식과 일치해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a1b20-202">The type of the property must match the type that is processed by your custom type converter.</span></span> <span data-ttu-id="a1b20-203">XAML 프로세서에서 해당 속성의 값을 처리할 때 이 특성을 적용하면 입력 문자열을 처리하고 개체 인스턴스를 반환할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a1b20-203">With this attribute applied, when a XAML processor handles values of that property, it can process input strings and return object instances.</span></span> <span data-ttu-id="a1b20-204">속성별 변환기 기술은 Microsoft .NET Framework또는 클래스 정의를 제어할 수 없고 <xref:System.ComponentModel.TypeConverterAttribute> 적용할 수 없는 다른 라이브러리에서 속성 형식을 사용하도록 선택하는 경우에 특히 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="a1b20-204">The per-property type converter technique is particularly useful if you choose to use a property type from Microsoft .NET Framework or from some other library where you cannot control the class definition and cannot apply a <xref:System.ComponentModel.TypeConverterAttribute> there.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="a1b20-205">참고 항목</span><span class="sxs-lookup"><span data-stu-id="a1b20-205">See also</span></span>

- <xref:System.ComponentModel.TypeConverter>
- [<span data-ttu-id="a1b20-206">XAML 개요(WPF)</span><span class="sxs-lookup"><span data-stu-id="a1b20-206">XAML Overview (WPF)</span></span>](../../../desktop-wpf/fundamentals/xaml.md)
- [<span data-ttu-id="a1b20-207">태그 확장 및 WPF XAML</span><span class="sxs-lookup"><span data-stu-id="a1b20-207">Markup Extensions and WPF XAML</span></span>](markup-extensions-and-wpf-xaml.md)
- [<span data-ttu-id="a1b20-208">XAML 구문 정보</span><span class="sxs-lookup"><span data-stu-id="a1b20-208">XAML Syntax In Detail</span></span>](xaml-syntax-in-detail.md)

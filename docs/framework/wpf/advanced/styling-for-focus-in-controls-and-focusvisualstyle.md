---
title: 컨트롤의 포커스 스타일 지정 및 FocusVisualStyle
ms.date: 03/30/2017
helpviewer_keywords:
- keyboard focus [WPF]
- focus [WPF], visual styling
- styles [WPF], focus visual style
ms.assetid: 786ac576-011b-4d72-913b-558deccb9b35
ms.openlocfilehash: 6c73c8bbfcf7631094ddf89641de9af38f86f88e
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 05/04/2018
ms.locfileid: "33549518"
---
# <a name="styling-for-focus-in-controls-and-focusvisualstyle"></a><span data-ttu-id="e7e58-102">컨트롤의 포커스 스타일 지정 및 FocusVisualStyle</span><span class="sxs-lookup"><span data-stu-id="e7e58-102">Styling for Focus in Controls, and FocusVisualStyle</span></span>
[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]<span data-ttu-id="e7e58-103">에서는 컨트롤이 키보드 포커스를 받을 때 컨트롤의 시각적 모양을 변경하는 두 가지 병렬 메커니즘을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="e7e58-103"> provides two parallel mechanisms for changing the visual appearance of a control when it receives keyboard focus.</span></span> <span data-ttu-id="e7e58-104">와 같은 속성에 대 한 속성 setter를 사용 하는 첫 번째 메커니즘은 <xref:System.Windows.UIElement.IsKeyboardFocused%2A> 스타일 또는 컨트롤에 적용 되는 서식 파일 내에서.</span><span class="sxs-lookup"><span data-stu-id="e7e58-104">The first mechanism is to use property setters for properties such as <xref:System.Windows.UIElement.IsKeyboardFocused%2A> within the style or template that is applied to the control.</span></span> <span data-ttu-id="e7e58-105">두 번째 메커니즘에서는 별도 스타일의 값으로 제공 하는 것은 <xref:System.Windows.FrameworkElement.FocusVisualStyle%2A> 속성 컨트롤 또는 다른 UI의 시각적 트리를 변경 하지 않고 컨트롤을 기반으로 그려지는 표시기에 대 한 별도 시각적 트리를 만듭니다 "포커스 비주얼 스타일" 교체 하 여 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="e7e58-105">The second mechanism is to provide a separate style as the value of the <xref:System.Windows.FrameworkElement.FocusVisualStyle%2A> property; the "focus visual style" creates a separate visual tree for an adorner that draws on top of the control, rather than changing the visual tree of the control or other UI element by replacing it.</span></span> <span data-ttu-id="e7e58-106">이 항목에서는 이러한 각 메커니즘이 적절하게 적용되는 시나리오를 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="e7e58-106">This topic discusses the scenarios where each of these mechanisms is appropriate.</span></span>  
   
  
<a name="Purpose"></a>   
## <a name="the-purpose-of-focus-visual-style"></a><span data-ttu-id="e7e58-107">포커스 비주얼 스타일의 목적</span><span class="sxs-lookup"><span data-stu-id="e7e58-107">The Purpose of Focus Visual Style</span></span>  
 <span data-ttu-id="e7e58-108">포커스 비주얼 스타일 기능은 UI 요소에 대한 키보드 탐색에 따라 시각적 사용자 피드백을 추가하기 위한 공통 “개체 모델”을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="e7e58-108">The focus visual style feature provides a common "object model" for introducing visual user feedback based on keyboard navigation to any UI element.</span></span> <span data-ttu-id="e7e58-109">이 작업은 컨트롤에 새 템플릿을 적용하거나 특정 템플릿 컴퍼지션을 인식하지 않아도 가능합니다.</span><span class="sxs-lookup"><span data-stu-id="e7e58-109">This is possible without applying a new template to the control, or knowing the specific template composition.</span></span>  
  
 <span data-ttu-id="e7e58-110">하지만 정확히는 포커스 비주얼 스타일 기능은 컨트롤 템플릿을 인식하지 않고 작동하므로 포커스 비주얼 스타일을 통해 컨트롤에 대해 표시될 수 있는 시각적 피드백은 제한되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="e7e58-110">However, precisely because the focus visual style feature works without knowing the control templates, the visual feedback that can be displayed for a control using a focus visual style is necessarily limited.</span></span> <span data-ttu-id="e7e58-111">이 기능이 실제로 수행하는 작업은 템플릿을 사용한 컨트롤 렌더링에서 만들어진 것처럼 시각적 트리 위에 다른 시각적 트리(표시기)를 오버레이하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="e7e58-111">What the feature actually does is to overlay a different visual tree (an adorner) on top of the visual tree as created by a control's rendering through its template.</span></span> <span data-ttu-id="e7e58-112">채우는 스타일을 사용 하 여이 별도 시각적 트리를 정의 하는 <xref:System.Windows.FrameworkElement.FocusVisualStyle%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="e7e58-112">You define this separate visual tree using a style that fills the <xref:System.Windows.FrameworkElement.FocusVisualStyle%2A> property.</span></span>  
  
<a name="Default"></a>   
## <a name="default-focus-visual-style-behavior"></a><span data-ttu-id="e7e58-113">기본 포커스 비주얼 스타일 동작</span><span class="sxs-lookup"><span data-stu-id="e7e58-113">Default Focus Visual Style Behavior</span></span>  
 <span data-ttu-id="e7e58-114">포커스 비주얼 스타일은 포커스 작업이 키보드에서 시작된 경우에만 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="e7e58-114">Focus visual styles act only when the focus action was initiated by the keyboard.</span></span> <span data-ttu-id="e7e58-115">마우스 작업이나 프로그래밍 방식 포커스 변경인 경우에는 포커스 비주얼 스타일 모드가 적용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="e7e58-115">Any mouse action or programmatic focus change disables the mode for focus visual styles.</span></span> <span data-ttu-id="e7e58-116">포커스 모드 간의 차이점에 대한 자세한 내용은 [포커스 개요](../../../../docs/framework/wpf/advanced/focus-overview.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="e7e58-116">For more information about the distinctions between focus modes, see [Focus Overview](../../../../docs/framework/wpf/advanced/focus-overview.md).</span></span>  
  
 <span data-ttu-id="e7e58-117">컨트롤에 대한 테마에는 테마의 모든 컨트롤에 대한 포커스 비주얼 스타일이 되는 기본 포커스 비주얼 스타일 동작이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="e7e58-117">The themes for controls include a default focus visual style behavior that becomes the focus visual style for all controls in the theme.</span></span> <span data-ttu-id="e7e58-118">이 테마 스타일은 정적 키의 값으로 구별 <xref:System.Windows.SystemParameters.FocusVisualStyleKey%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="e7e58-118">This theme style is identified by the value of the static key <xref:System.Windows.SystemParameters.FocusVisualStyleKey%2A>.</span></span> <span data-ttu-id="e7e58-119">응용 프로그램 수준에서 자체 포커스 비주얼 스타일을 선언하면 테마에서 이 기본 스타일 동작이 대체됩니다.</span><span class="sxs-lookup"><span data-stu-id="e7e58-119">When you declare your own focus visual style at the application level, you replace this default style behavior from the themes.</span></span> <span data-ttu-id="e7e58-120">또는 전체 테마를 정의할 경우 이 동일한 키를 사용하여 전체 테마의 기본 동작에 대한 스타일을 정의해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="e7e58-120">Alternatively, if you define the entire theme, then you should use this same key to define the style for the default behavior for your entire theme.</span></span>  
  
 <span data-ttu-id="e7e58-121">일반적으로 테마에서 기본 포커스 비주얼 스타일은 매우 간단합니다.</span><span class="sxs-lookup"><span data-stu-id="e7e58-121">In the themes, the default focus visual style is generally very simple.</span></span> <span data-ttu-id="e7e58-122">대략적인 설명은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="e7e58-122">The following is a rough approximation:</span></span>  
  
```  
<Style x:Key="{x:Static SystemParameters.FocusVisualStyleKey}">  
  <Setter Property="Control.Template">  
    <Setter.Value>  
      <ControlTemplate>  
        <Rectangle StrokeThickness="1"  
          Stroke="Black"  
          StrokeDashArray="1 2"  
          SnapsToDevicePixels="true"/>  
      </ControlTemplate>  
    </Setter.Value>  
  </Setter>  
</Style>  
```  
  
<a name="When"></a>   
## <a name="when-to-use-focus-visual-styles"></a><span data-ttu-id="e7e58-123">포커스 비주얼 스타일을 사용하는 시점</span><span class="sxs-lookup"><span data-stu-id="e7e58-123">When to Use Focus Visual Styles</span></span>  
 <span data-ttu-id="e7e58-124">개념상 컨트롤에 적용되는 포커스 비주얼 스타일의 모양은 컨트롤 간에 일관되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="e7e58-124">Conceptually, the appearance of focus visual styles applied to controls should be coherent from control to control.</span></span> <span data-ttu-id="e7e58-125">일관성을 유지하는 한 가지 방법은 전체 테마를 작성할 경우에만 포커스 비주얼 스타일을 변경하는 것입니다. 이 경우 테마에 정의된 각 컨트롤이 똑같은 포커스 비주얼 스타일을 가져오거나 컨트롤 간에 시각적으로 관련된 스타일의 일부 변형을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="e7e58-125">One way to ensure coherence is to change the focus visual style only if you are composing an entire theme, where each control that is defined in the theme gets either the very same focus visual style, or some variation of a style that is visually related from control to control.</span></span> <span data-ttu-id="e7e58-126">또는 같은 스타일(또는 비슷한 스타일)을 사용하여 페이지 또는 UI에서 모든 키보드 포커스 가능 요소에 스타일을 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e7e58-126">Alternatively, you might use the same style (or similar styles) to style every keyboard-focusable element on a page or in a UI.</span></span>  
  
 <span data-ttu-id="e7e58-127">설정 <xref:System.Windows.FrameworkElement.FocusVisualStyle%2A> 테마의 일부가 아닌 개별 컨트롤 스타일에 사용 하는 하지 의도 한 포커스 비주얼 스타일입니다.</span><span class="sxs-lookup"><span data-stu-id="e7e58-127">Setting <xref:System.Windows.FrameworkElement.FocusVisualStyle%2A> on individual control styles that are not part of a theme is not the intended usage of focus visual styles.</span></span> <span data-ttu-id="e7e58-128">이는 컨트롤 간에 시각적 동작이 일치하지 않으면 키보드 포커스에 대한 사용자 환경이 복잡해질 수 있기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="e7e58-128">This is because an inconsistent visual behavior between controls can lead to a confusing user experience regarding keyboard focus.</span></span> <span data-ttu-id="e7e58-129">일관 되지 테마 전체에서 키보드 포커스에 대 한 컨트롤 특정 동작을 하려는 경우 더 좋은 방법은를 사용 하 트리거 스타일의 개별 입력된 상태 속성 같은 <xref:System.Windows.UIElement.IsFocused%2A> 또는 <xref:System.Windows.UIElement.IsKeyboardFocused%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="e7e58-129">If you are intending control-specific behaviors for keyboard focus that are deliberately not coherent across a theme, a much better approach is to use triggers in styles for individual input state properties, such as <xref:System.Windows.UIElement.IsFocused%2A> or <xref:System.Windows.UIElement.IsKeyboardFocused%2A>.</span></span>  
  
 <span data-ttu-id="e7e58-130">포커스 비주얼 스타일은 키보드 포커스와 함께 사용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="e7e58-130">Focus visual styles act exclusively for keyboard focus.</span></span> <span data-ttu-id="e7e58-131">마찬가지로 포커스 비주얼 스타일은 접근성 기능의 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="e7e58-131">As such, focus visual styles are a type of accessibility feature.</span></span> <span data-ttu-id="e7e58-132">마우스, 키보드 또는 프로그래밍 방식이든 관계없이 포커스 형식에 따라 UI가 변경되게 하려면 포커스 비주얼 스타일을 사용하면 안 되며 `IsFocused` 또는 `IsFocusWithin`과 같은 일반 포커스 속성의 값에 따라 작동하는 스타일 또는 템플릿에서 setter 및 트리거를 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="e7e58-132">If you want UI changes for any type of focus, whether via mouse, keyboard, or programmatically, then you should not use focus visual styles, and should instead use setters and triggers in styles or templates that are working from the value of general focus properties such as `IsFocused` or `IsFocusWithin`.</span></span>  
  
<a name="How"></a>   
## <a name="how-to-create-a-focus-visual-style"></a><span data-ttu-id="e7e58-133">포커스 비주얼 스타일을 만드는 방법</span><span class="sxs-lookup"><span data-stu-id="e7e58-133">How to Create a Focus Visual Style</span></span>  
 <span data-ttu-id="e7e58-134">포커스 시각적 스타일을 항상 있어야에 대해 만드는 스타일은 <xref:System.Windows.Style.TargetType%2A> 의 <xref:System.Windows.Controls.Control>합니다.</span><span class="sxs-lookup"><span data-stu-id="e7e58-134">The style you create for a focus visual style should always have the <xref:System.Windows.Style.TargetType%2A> of <xref:System.Windows.Controls.Control>.</span></span> <span data-ttu-id="e7e58-135">주로 스타일 구성 되어야는 <xref:System.Windows.Controls.ControlTemplate>합니다.</span><span class="sxs-lookup"><span data-stu-id="e7e58-135">The style should consist mainly of a <xref:System.Windows.Controls.ControlTemplate>.</span></span> <span data-ttu-id="e7e58-136">대상 유형 형식이 되도록 포커스 시각적 스타일에 할당 된 위치를 지정 하지 않으면는 <xref:System.Windows.FrameworkElement.FocusVisualStyle%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="e7e58-136">You do not specify the target type to be the type where the focus visual style is assigned to the <xref:System.Windows.FrameworkElement.FocusVisualStyle%2A>.</span></span>  
  
 <span data-ttu-id="e7e58-137">대상 형식이 항상 이므로 <xref:System.Windows.Controls.Control>, 모든 컨트롤에 공통 된 속성을 사용 하 여 스타일을 적용 해야 (속성을 사용 하는 <xref:System.Windows.Controls.Control> 클래스와 해당 기본 클래스).</span><span class="sxs-lookup"><span data-stu-id="e7e58-137">Because the target type is always <xref:System.Windows.Controls.Control>, you must style by using properties that are common to all controls (using properties of the <xref:System.Windows.Controls.Control> class and its base classes).</span></span> <span data-ttu-id="e7e58-138">UI 요소에 대한 오버레이로 제대로 작동하고 컨트롤의 기능 영역을 가리지 않는 템플릿을 만들어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="e7e58-138">You should create a template that will properly function as an overlay to a UI element and that will not obscure functional areas of the control.</span></span> <span data-ttu-id="e7e58-139">일반적으로 이는 시각적 피드백은 컨트롤 여백 외부에 표시되거나 포커스 비주얼 스타일이 적용되는 컨트롤에 대한 적중 테스트를 차단하지 않는 일시적이거나 간섭하지 않는 효과로 표시어야 함을 의미합니다.</span><span class="sxs-lookup"><span data-stu-id="e7e58-139">Generally, this means that the visual feedback should appear outside the control margins, or as temporary or unobtrusive effects that will not block the hit testing on the control where the focus visual style is applied.</span></span> <span data-ttu-id="e7e58-140">크기 조정 및 오버레이 서식 파일의 위치를 지정 하는 데 도움이 되는 템플릿 바인딩에 사용할 수 있는 속성에 포함 <xref:System.Windows.FrameworkElement.ActualHeight%2A>, <xref:System.Windows.FrameworkElement.ActualWidth%2A>, <xref:System.Windows.FrameworkElement.Margin%2A>, 및 <xref:System.Windows.Controls.Control.Padding%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="e7e58-140">Properties that you can use in template binding that are useful for determining sizing and positioning of your overlay template include <xref:System.Windows.FrameworkElement.ActualHeight%2A>, <xref:System.Windows.FrameworkElement.ActualWidth%2A>, <xref:System.Windows.FrameworkElement.Margin%2A>, and <xref:System.Windows.Controls.Control.Padding%2A>.</span></span>  
  
<a name="Alternatives"></a>   
## <a name="alternatives-to-using-a-focus-visual-style"></a><span data-ttu-id="e7e58-141">포커스 비주얼 스타일 사용의 대체 방법</span><span class="sxs-lookup"><span data-stu-id="e7e58-141">Alternatives to Using a Focus Visual Style</span></span>  
 <span data-ttu-id="e7e58-142">포커스 비주얼 스타일이 적절하지 않은 상황에서는 단일 컨트롤에만 스타일을 지정하거나 컨트롤 템플릿보다 더 큰 컨트롤이 필요하기 때문에 포커스 변경에 대한 응답으로 시각적 동작을 만들 수 있는 많은 다른 액세스 가능한 속성 및 기술이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e7e58-142">For situations where using a focus visual style is not appropriate, either because you are only styling single controls or because you want greater control over the control template, there are many other accessible properties and techniques that can create visual behavior in response to changes in focus.</span></span>  
  
 <span data-ttu-id="e7e58-143">트리거, setter 및 이벤트 setter는 모두 [스타일 지정 및 템플릿](../../../../docs/framework/wpf/controls/styling-and-templating.md)에서 자세히 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="e7e58-143">Triggers, setters, and event setters are all discussed in detail in [Styling and Templating](../../../../docs/framework/wpf/controls/styling-and-templating.md).</span></span> <span data-ttu-id="e7e58-144">라우트된 이벤트 처리는 [라우트된 이벤트 개요](../../../../docs/framework/wpf/advanced/routed-events-overview.md)에서 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="e7e58-144">Routed event handling is discussed in [Routed Events Overview](../../../../docs/framework/wpf/advanced/routed-events-overview.md).</span></span>  
  
### <a name="iskeyboardfocused"></a><span data-ttu-id="e7e58-145">IsKeyboardFocused</span><span class="sxs-lookup"><span data-stu-id="e7e58-145">IsKeyboardFocused</span></span>  
 <span data-ttu-id="e7e58-146">키보드 포커스에 관심이 있는 경우는 <xref:System.Windows.UIElement.IsKeyboardFocused%2A> 속성에 대 한 종속성 속성을 사용할 수 있습니다 <xref:System.Windows.Trigger>합니다.</span><span class="sxs-lookup"><span data-stu-id="e7e58-146">If you are specifically interested in keyboard focus, the <xref:System.Windows.UIElement.IsKeyboardFocused%2A> dependency property can be used for a property <xref:System.Windows.Trigger>.</span></span> <span data-ttu-id="e7e58-147">단일 컨트롤에만 관련되고 다른 컨트롤의 키보드 포커스 동작과 시각적으로 일치하지 않는 키보드 포커스 동작을 정의할 경우 스타일 또는 템플릿의 속성 트리거가 더 적절한 기술입니다.</span><span class="sxs-lookup"><span data-stu-id="e7e58-147">A property trigger in either a style or template is a more appropriate technique for defining a keyboard focus behavior that is very specifically for a single control, and which might not visually match the keyboard focus behavior for other controls.</span></span>  
  
 <span data-ttu-id="e7e58-148">또 다른 유사한 종속성 속성은 <xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A>, 합성 내 또는 컨트롤의 기능 영역 내에서 특정 위치는 해당 키보드 포커스가 시각적으로 호출 하려는 경우 사용 될 수 있는 합니다.</span><span class="sxs-lookup"><span data-stu-id="e7e58-148">Another similar dependency property is <xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A>, which might be appropriate to use if you want to visually call out that keyboard focus is somewhere within compositing or within the functional area of the control.</span></span> <span data-ttu-id="e7e58-149">예를 들어 배치할 수 있습니다는 <xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A> 트리거 여러 컨트롤을 그룹화 하는 패널을 보다 정확 하 게 할 수 있더라도 다르게 표시 되도록 일의 개별 요소에 해당 패널에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e7e58-149">For example, you might place an <xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A> trigger such that a panel that groups several controls appears differently, even though keyboard focus might more precisely be on an individual element within that panel.</span></span>  
  
 <span data-ttu-id="e7e58-150">이벤트를 사용할 수도 <xref:System.Windows.UIElement.GotKeyboardFocus> 및 <xref:System.Windows.UIElement.LostKeyboardFocus> (뿐만 아니라 해당 미리 보기 이벤트).</span><span class="sxs-lookup"><span data-stu-id="e7e58-150">You can also use the events <xref:System.Windows.UIElement.GotKeyboardFocus> and <xref:System.Windows.UIElement.LostKeyboardFocus> (as well as their Preview equivalents).</span></span> <span data-ttu-id="e7e58-151">이러한 이벤트에 대 한 기준으로 사용할 수 있습니다는 <xref:System.Windows.EventSetter>, 관련 코드에서에서 이벤트에 대 한 처리기를 작성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e7e58-151">You can use these events as the basis for an <xref:System.Windows.EventSetter>, or you can write handlers for the events in code-behind.</span></span>  
  
### <a name="other-focus-properties"></a><span data-ttu-id="e7e58-152">기타 포커스 속성</span><span class="sxs-lookup"><span data-stu-id="e7e58-152">Other Focus Properties</span></span>  
 <span data-ttu-id="e7e58-153">기반으로 setter 또는 트리거를 해야 시각적 동작을 생성 하기 위해 모든 가능한 원인의 포커스를 변경 하려는 경우는 <xref:System.Windows.UIElement.IsFocused%2A> 종속성 속성 또는 또는에 <xref:System.Windows.UIElement.GotFocus> 또는 <xref:System.Windows.UIElement.LostFocus> 이벤트에 대 한 프로그램 <xref:System.Windows.EventSetter>합니다.</span><span class="sxs-lookup"><span data-stu-id="e7e58-153">If you want all possible causes of changing focus to produce a visual behavior, you should base a setter or trigger on the <xref:System.Windows.UIElement.IsFocused%2A> dependency property, or alternatively on the <xref:System.Windows.UIElement.GotFocus> or <xref:System.Windows.UIElement.LostFocus> events used for an <xref:System.Windows.EventSetter>.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="e7e58-154">참고 항목</span><span class="sxs-lookup"><span data-stu-id="e7e58-154">See Also</span></span>  
 <xref:System.Windows.FrameworkElement.FocusVisualStyle%2A>  
 [<span data-ttu-id="e7e58-155">스타일 지정 및 템플릿</span><span class="sxs-lookup"><span data-stu-id="e7e58-155">Styling and Templating</span></span>](../../../../docs/framework/wpf/controls/styling-and-templating.md)  
 [<span data-ttu-id="e7e58-156">포커스 개요</span><span class="sxs-lookup"><span data-stu-id="e7e58-156">Focus Overview</span></span>](../../../../docs/framework/wpf/advanced/focus-overview.md)  
 [<span data-ttu-id="e7e58-157">입력 개요</span><span class="sxs-lookup"><span data-stu-id="e7e58-157">Input Overview</span></span>](../../../../docs/framework/wpf/advanced/input-overview.md)

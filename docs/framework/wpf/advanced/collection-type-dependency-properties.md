---
title: 컬렉션 형식 종속성 속성
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- properties [WPF], dependency
- properties [WPF], collection-type
- dependency properties [WPF]
- collection-type properties [WPF]
ms.assetid: 99f96a42-3ab7-4f64-a16b-2e10d654e97c
ms.openlocfilehash: 71c29cc6d1c7955b889a56b0a6629690a2947c78
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 05/04/2018
ms.locfileid: "33540357"
---
# <a name="collection-type-dependency-properties"></a><span data-ttu-id="7f8e0-102">컬렉션 형식 종속성 속성</span><span class="sxs-lookup"><span data-stu-id="7f8e0-102">Collection-Type Dependency Properties</span></span>
<span data-ttu-id="7f8e0-103">이 항목에서는 속성 형식이 컬렉션 형식인 종속성 속성을 구현하는 방법에 대한 지침과 제안된 패턴을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="7f8e0-103">This topic provides guidance and suggested patterns for how to implement a dependency property where the type of the property is a collection type.</span></span>  
  
 
  
<a name="implementing"></a>   
## <a name="implementing-a-collection-type-dependency-property"></a><span data-ttu-id="7f8e0-104">컬렉션 형식 종속성 속성 구현</span><span class="sxs-lookup"><span data-stu-id="7f8e0-104">Implementing a Collection-Type Dependency Property</span></span>  
 <span data-ttu-id="7f8e0-105">종속성 속성에 대 한 일반적으로 수행 하는 구현 패턴은 정의 하는 한 [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] 래퍼 속성에는 해당 속성에서 지원 되며 여기서는 <xref:System.Windows.DependencyProperty> 식별자 보다는 필드 있든 다른 구문입니다.</span><span class="sxs-lookup"><span data-stu-id="7f8e0-105">For a dependency property in general, the implementation pattern that you follow is that you define a [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] property wrapper, where that property is backed by a <xref:System.Windows.DependencyProperty> identifier rather than a field or other construct.</span></span> <span data-ttu-id="7f8e0-106">콜렉션 형식 속성을 구현할 때도 이와 동일한 패턴을 따릅니다.</span><span class="sxs-lookup"><span data-stu-id="7f8e0-106">You follow this same pattern when you implement a collection-type property.</span></span> <span data-ttu-id="7f8e0-107">그러나 컬렉션 형식 속성 더 복잡해 패턴을 컬렉션에 포함 된 형식이 자체 때마다는 <xref:System.Windows.DependencyObject> 또는 <xref:System.Windows.Freezable> 클래스를 파생 합니다.</span><span class="sxs-lookup"><span data-stu-id="7f8e0-107">However, a collection-type property introduces some complexity to the pattern whenever the type that is contained within the collection is itself a <xref:System.Windows.DependencyObject> or <xref:System.Windows.Freezable> derived class.</span></span>  
  
<a name="initializing"></a>   
## <a name="initializing-the-collection-beyond-the-default-value"></a><span data-ttu-id="7f8e0-108">기본값 이외의 컬렉션 초기화</span><span class="sxs-lookup"><span data-stu-id="7f8e0-108">Initializing the Collection Beyond the Default Value</span></span>  
 <span data-ttu-id="7f8e0-109">종속성 속성을 만들 때는 속성 기본값을 초기 필드 값으로 지정하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="7f8e0-109">When you create a dependency property, you do not specify the property default value as the initial field value.</span></span> <span data-ttu-id="7f8e0-110">대신 종속성 속성 메타데이터를 통해 기본값을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="7f8e0-110">Instead, you specify the default value through the dependency property metadata.</span></span> <span data-ttu-id="7f8e0-111">속성이 참조 형식인 경우 종속성 속성 메타데이터에 지정된 기본값은 인스턴스별 기본값이 아니라 해당 형식의 모든 인스턴스에 적용되는 기본값입니다.</span><span class="sxs-lookup"><span data-stu-id="7f8e0-111">If your property is a reference type, the default value specified in dependency property metadata is not a default value per instance; instead it is a default value that applies to all instances of the type.</span></span> <span data-ttu-id="7f8e0-112">따라서 컬렉션 속성 메타데이터로 정의된 단일 정적 컬렉션을 형식에 대해 새로 만든 인스턴스의 작업 기본값으로 사용하지 않도록 주의해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="7f8e0-112">Therefore you must be careful to not use the singular static collection defined by the collection property metadata as the working default value for newly created instances of your type.</span></span> <span data-ttu-id="7f8e0-113">대신 클래스 생성자 논리의 일부로서 의도적으로 컬렉션 값을 고유한(인스턴스) 컬렉션으로 설정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="7f8e0-113">Instead, you must make sure that you deliberately set the collection value to a unique (instance) collection as part of your class constructor logic.</span></span> <span data-ttu-id="7f8e0-114">그렇지 않으면 의도하지 않은 Singleton 클래스가 만들어집니다.</span><span class="sxs-lookup"><span data-stu-id="7f8e0-114">Otherwise you will have created an unintentional singleton class.</span></span>  
  
 <span data-ttu-id="7f8e0-115">다음 예제를 살펴보십시오.</span><span class="sxs-lookup"><span data-stu-id="7f8e0-115">Consider the following example.</span></span> <span data-ttu-id="7f8e0-116">예제의 다음 섹션에서는 `Aquarium` 클래스에 대한 정의를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="7f8e0-116">The following section of the example shows the definition for a class `Aquarium`.</span></span> <span data-ttu-id="7f8e0-117">클래스는 컬렉션 형식 종속성 속성을 정의 하며 `AquariumObjects`, 제네릭을 사용 하 여 <xref:System.Collections.Generic.List%601> 형식을 <xref:System.Windows.FrameworkElement> 형식 제약 조건입니다.</span><span class="sxs-lookup"><span data-stu-id="7f8e0-117">The class defines the collection type dependency property `AquariumObjects`, which uses the generic <xref:System.Collections.Generic.List%601> type with a <xref:System.Windows.FrameworkElement> type constraint.</span></span> <span data-ttu-id="7f8e0-118">에 <xref:System.Windows.DependencyProperty.Register%28System.String%2CSystem.Type%2CSystem.Type%2CSystem.Windows.PropertyMetadata%29> 새 제네릭 되도록 기본값을 설정 하는 종속성 속성을 메타 데이터에 대 한 호출 <xref:System.Collections.Generic.List%601>합니다.</span><span class="sxs-lookup"><span data-stu-id="7f8e0-118">In the <xref:System.Windows.DependencyProperty.Register%28System.String%2CSystem.Type%2CSystem.Type%2CSystem.Windows.PropertyMetadata%29> call for the dependency property, the metadata establishes the default value to be a new generic <xref:System.Collections.Generic.List%601>.</span></span>  
  
 [!code-csharp[PropertiesOvwSupport2#CollectionProblemDefinition](../../../../samples/snippets/csharp/VS_Snippets_Wpf/PropertiesOvwSupport2/CSharp/page.xaml.cs#collectionproblemdefinition)]
 [!code-vb[PropertiesOvwSupport2#CollectionProblemDefinition](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/PropertiesOvwSupport2/visualbasic/page.xaml.vb#collectionproblemdefinition)]  
  
 <span data-ttu-id="7f8e0-119">그러나 설명한 대로 코드를 방금 벗어나면 모든 `Aquarium` 인스턴스에서 단일 목록 기본값을 공유합니다.</span><span class="sxs-lookup"><span data-stu-id="7f8e0-119">However, if you just left the code as shown, that single list default value is shared for all instances of `Aquarium`.</span></span> <span data-ttu-id="7f8e0-120">두 개의 개별 `Aquarium` 인스턴스를 인스턴스화하고 각 인스턴스에 서로 다른 단일 `Fish`를 추가하는 방법을 보여 주는 다음 테스트 코드를 실행하면 놀라운 결과를 볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7f8e0-120">If you ran the following test code, which is intended to show how you would instantiate two separate `Aquarium` instances and add a single different `Fish` to each of them, you would see a surprising result:</span></span>  
  
 [!code-csharp[PropertiesOvwSupport#CollectionProblemTestCode](../../../../samples/snippets/csharp/VS_Snippets_Wpf/PropertiesOvwSupport/CSharp/page4.xaml.cs#collectionproblemtestcode)]
 [!code-vb[PropertiesOvwSupport#CollectionProblemTestCode](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/PropertiesOvwSupport/visualbasic/page4.xaml.vb#collectionproblemtestcode)]  
  
 <span data-ttu-id="7f8e0-121">각 콜렉션의 개수는 1이 아니라 2입니다!</span><span class="sxs-lookup"><span data-stu-id="7f8e0-121">Instead of each collection having a count of one, each collection has a count of two!</span></span> <span data-ttu-id="7f8e0-122">이는 메타데이터의 단일 생성자 호출로 인해 각 `Aquarium`에서 해당 `Fish`를 기본값 컬렉션에 추가했기 때문이며, 이에 따라 모든 인스턴스 간에 공유됩니다.</span><span class="sxs-lookup"><span data-stu-id="7f8e0-122">This is because each `Aquarium` added its `Fish` to the default value collection, which resulted from a single constructor call in the metadata and is therefore shared between all instances.</span></span> <span data-ttu-id="7f8e0-123">이 상황은 결코 바람직한 작업이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="7f8e0-123">This situation is almost never what you want.</span></span>  
  
 <span data-ttu-id="7f8e0-124">이 문제를 해결하려면 클래스 생성자 호출의 일부로 컬렉션 종속성 속성 값을 고유한 인스턴스로 다시 설정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="7f8e0-124">To correct this problem, you must reset the collection dependency property value to a unique instance, as part of the class constructor call.</span></span> <span data-ttu-id="7f8e0-125">속성은 읽기 전용 종속성 속성을 사용는 <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29> 메서드를 사용 하 여 설정 하는 <xref:System.Windows.DependencyPropertyKey> 하는 클래스 내에서 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7f8e0-125">Because the property is a read-only dependency property, you use the <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29> method to set it, using the <xref:System.Windows.DependencyPropertyKey> that is only accessible within the class.</span></span>  
  
 [!code-csharp[PropertiesOvwSupport#CollectionProblemCtor](../../../../samples/snippets/csharp/VS_Snippets_Wpf/PropertiesOvwSupport/CSharp/page4.xaml.cs#collectionproblemctor)]
 [!code-vb[PropertiesOvwSupport#CollectionProblemCtor](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/PropertiesOvwSupport/visualbasic/page4.xaml.vb#collectionproblemctor)]  
  
 <span data-ttu-id="7f8e0-126">이제 동일한 테스트 코드를 다시 실행하면 각 `Aquarium`에서 자체의 고유한 컬렉션을 지원하는 예상 결과를 더 많이 볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7f8e0-126">Now, if you ran that same test code again, you could see more expected results, where each `Aquarium` supported its own unique collection.</span></span>  
  
 <span data-ttu-id="7f8e0-127">읽기/쓰기 컬렉션 속성이 되도록 선택한 경우 이 패턴에 약간의 변형이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7f8e0-127">There would be a slight variation on this pattern if you chose to have your collection property be read-write.</span></span> <span data-ttu-id="7f8e0-128">이 경우 초기화의 키가 아닌 서명을 계속 호출 됩니다는 작업을 수행 하는 생성자에서 접근자를 호출할 수 있습니다 <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyProperty%2CSystem.Object%29> 를 내에서 사용 하 여 공용 <xref:System.Windows.DependencyProperty> 식별자입니다.</span><span class="sxs-lookup"><span data-stu-id="7f8e0-128">In that case, you could call the public set accessor from the constructor to do the initialization, which would still be calling the nonkey signature of <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyProperty%2CSystem.Object%29> within your set wrapper, using a public <xref:System.Windows.DependencyProperty> identifier.</span></span>  
  
## <a name="reporting-binding-value-changes-from-collection-properties"></a><span data-ttu-id="7f8e0-129">컬렉션 속성에서 바인딩 값 변경 보고</span><span class="sxs-lookup"><span data-stu-id="7f8e0-129">Reporting Binding Value Changes from Collection Properties</span></span>  
 <span data-ttu-id="7f8e0-130">자체적으로 종속성 속성인 콜렉션 속성은 변경 내용을 하위 속성에 자동으로 보고하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="7f8e0-130">A collection property that is itself a dependency property does not automatically report changes to its subproperties.</span></span> <span data-ttu-id="7f8e0-131">컬렉션에 바인딩을 만들면 바인딩에서 변경 내용을 보고하지 못하도록 하여 일부 데이터 바인딩 시나리오가 무효화될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7f8e0-131">If you are creating bindings into a collection, this can prevent the binding from reporting changes, thus invalidating some data binding scenarios.</span></span> <span data-ttu-id="7f8e0-132">그러나 컬렉션 형식을 사용 하면 <xref:System.Windows.FreezableCollection%601> 컬렉션 형식으로 다음 컬렉션에 포함 된 요소에 대 한 하위 속성 변경 제대로 보고 되 고 바인딩이 예상 대로 작동 합니다.</span><span class="sxs-lookup"><span data-stu-id="7f8e0-132">However, if you use the collection type <xref:System.Windows.FreezableCollection%601> as your collection type, then subproperty changes to contained elements in the collection are properly reported, and binding works as expected.</span></span>  
  
 <span data-ttu-id="7f8e0-133">종속성 개체 컬렉션의 하위 속성 바인딩을 사용 하려면 컬렉션 속성 형식으로 만듭니다 <xref:System.Windows.FreezableCollection%601>, 모든 해당 컬렉션에 대 한 형식 제약 조건을 <xref:System.Windows.DependencyObject> 클래스를 파생 합니다.</span><span class="sxs-lookup"><span data-stu-id="7f8e0-133">To enable subproperty binding in a dependency object collection, create the collection property as type <xref:System.Windows.FreezableCollection%601>, with a type constraint for that collection to any <xref:System.Windows.DependencyObject> derived class.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="7f8e0-134">참고 항목</span><span class="sxs-lookup"><span data-stu-id="7f8e0-134">See Also</span></span>  
 <xref:System.Windows.FreezableCollection%601>  
 [<span data-ttu-id="7f8e0-135">WPF에 대한 XAML 및 사용자 지정 클래스</span><span class="sxs-lookup"><span data-stu-id="7f8e0-135">XAML and Custom Classes for WPF</span></span>](../../../../docs/framework/wpf/advanced/xaml-and-custom-classes-for-wpf.md)  
 [<span data-ttu-id="7f8e0-136">데이터 바인딩 개요</span><span class="sxs-lookup"><span data-stu-id="7f8e0-136">Data Binding Overview</span></span>](../../../../docs/framework/wpf/data/data-binding-overview.md)  
 [<span data-ttu-id="7f8e0-137">종속성 속성 개요</span><span class="sxs-lookup"><span data-stu-id="7f8e0-137">Dependency Properties Overview</span></span>](../../../../docs/framework/wpf/advanced/dependency-properties-overview.md)  
 [<span data-ttu-id="7f8e0-138">사용자 지정 종속성 속성</span><span class="sxs-lookup"><span data-stu-id="7f8e0-138">Custom Dependency Properties</span></span>](../../../../docs/framework/wpf/advanced/custom-dependency-properties.md)  
 [<span data-ttu-id="7f8e0-139">종속성 속성 메타데이터</span><span class="sxs-lookup"><span data-stu-id="7f8e0-139">Dependency Property Metadata</span></span>](../../../../docs/framework/wpf/advanced/dependency-property-metadata.md)

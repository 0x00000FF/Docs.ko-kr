---
title: 스타일을 지정할 수 있는 컨트롤을 디자인하기 위한 지침
ms.date: 03/30/2017
helpviewer_keywords:
- style design for controls [WPF]
- controls [WPF], style design
ms.assetid: c52dde45-a311-4531-af4c-853371c4d5f4
ms.openlocfilehash: 02333d05bc1c0f9804caa36af1a1842cba22908c
ms.sourcegitcommit: 6b308cf6d627d78ee36dbbae8972a310ac7fd6c8
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 01/23/2019
ms.locfileid: "54545032"
---
# <a name="guidelines-for-designing-stylable-controls"></a><span data-ttu-id="4e7dc-102">스타일을 지정할 수 있는 컨트롤을 디자인하기 위한 지침</span><span class="sxs-lookup"><span data-stu-id="4e7dc-102">Guidelines for Designing Stylable Controls</span></span>
<span data-ttu-id="4e7dc-103">이 문서에서는 쉽게 스타일을 지정하고 템플릿을 지정할 수 있는 컨트롤을 디자인할 때 고려해야 하는 모범 사례 집합을 요약합니다.</span><span class="sxs-lookup"><span data-stu-id="4e7dc-103">This document summarizes a set of best practices to consider when designing a control which you intend to be easily stylable and templatable.</span></span> <span data-ttu-id="4e7dc-104">기본 제공 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 컨트롤 집합의 테마 컨트롤 스타일에 대해 작업하는 동안 많은 시행착오를 거쳐 이 모범 사례 집합을 얻게 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="4e7dc-104">We came to this set of best practices through a lot of trial and error while working on the theme control styles for the built-in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] control set.</span></span> <span data-ttu-id="4e7dc-105">성공적으로 스타일을 지정하려면 스타일 자체만큼이나 잘 설계된 개체 모델이 필요함을 알게 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="4e7dc-105">We learned that successful styling is as much a function of a well-designed object model as it is of the style itself.</span></span> <span data-ttu-id="4e7dc-106">이 문서의 독자는 스타일 작성자가 아니라 컨트롤 작성자입니다.</span><span class="sxs-lookup"><span data-stu-id="4e7dc-106">The intended audience for this document is the control author, not the style author.</span></span>  
  
  <a name="Terminology"></a>   
## <a name="terminology"></a><span data-ttu-id="4e7dc-107">용어</span><span class="sxs-lookup"><span data-stu-id="4e7dc-107">Terminology</span></span>  
 <span data-ttu-id="4e7dc-108">“스타일 지정 및 템플릿 지정”은 컨트롤 작성자가 컨트롤의 시각적 요소를 컨트롤의 스타일과 템플릿에 의존할 수 있는 기술 집합체를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="4e7dc-108">"Styling and templating" refer to the suite of technologies that enable a control author to defer the visual aspects of the control to the style and template of the control.</span></span> <span data-ttu-id="4e7dc-109">이 기술 집합체에는 다음이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="4e7dc-109">This suite of technologies includes:</span></span>  
  
-   <span data-ttu-id="4e7dc-110">스타일(속성 setter, 트리거 및 스토리보드 포함).</span><span class="sxs-lookup"><span data-stu-id="4e7dc-110">Styles (including property setters, triggers, and storyboards).</span></span>  
  
-   <span data-ttu-id="4e7dc-111">리소스.</span><span class="sxs-lookup"><span data-stu-id="4e7dc-111">Resources.</span></span>  
  
-   <span data-ttu-id="4e7dc-112">컨트롤 템플릿.</span><span class="sxs-lookup"><span data-stu-id="4e7dc-112">Control templates.</span></span>  
  
-   <span data-ttu-id="4e7dc-113">데이터 템플릿.</span><span class="sxs-lookup"><span data-stu-id="4e7dc-113">Data templates.</span></span>  
  
 <span data-ttu-id="4e7dc-114">스타일 지정과 템플릿 지정에 대한 소개는 [스타일 지정 및 템플릿 지정](../../../../docs/framework/wpf/controls/styling-and-templating.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="4e7dc-114">For an introduction to styling and templating, see [Styling and Templating](../../../../docs/framework/wpf/controls/styling-and-templating.md).</span></span>  
  
<a name="Before_You_Start__Understanding_Your_Control"></a>   
## <a name="before-you-start-understanding-your-control"></a><span data-ttu-id="4e7dc-115">시작 하기 전에: 컨트롤 이해</span><span class="sxs-lookup"><span data-stu-id="4e7dc-115">Before You Start: Understanding Your Control</span></span>  
 <span data-ttu-id="4e7dc-116">이 지침으로 이동하기 전에 컨트롤의 일반 용도를 이해하고 정의하는 것이 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="4e7dc-116">Before you jump into these guidelines, it is important to understand and have defined the common usage of your control.</span></span> <span data-ttu-id="4e7dc-117">스타일 지정에서는 다루기 힘든 상황이 많이 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="4e7dc-117">Styling exposes an often unruly set of possibilities.</span></span> <span data-ttu-id="4e7dc-118">여러 애플리케이션에서 많은 개발자가 광범위하게 사용하도록 작성된 컨트롤에서는 스타일 지정을 통해 컨트롤의 시각적 모양을 광범위하게 변경할 수 있다는 문제가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="4e7dc-118">Controls that are written to be used broadly (in many applications, by many developers) face the challenge that styling can be used to make far-reaching changes to the visual appearance of the control.</span></span> <span data-ttu-id="4e7dc-119">스타일 지정된 컨트롤이 실제로는 작성자가 의도한 컨트롤과 전혀 비슷하지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4e7dc-119">In fact, the styled control may not even resemble the control author's intentions.</span></span> <span data-ttu-id="4e7dc-120">기본적으로 스타일 지정에서 제공하는 유연성은 무한하므로 일반적인 용도라는 개념을 사용하여 한정된 범위에서 결정을 내릴 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4e7dc-120">Since the flexibility offered by styling is essentially boundless, you can use the idea of common usage to help you scope your decisions.</span></span>  
  
 <span data-ttu-id="4e7dc-121">컨트롤의 일반 용도를 이해하려면 컨트롤의 가치 제안에 대해 생각해 보는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="4e7dc-121">To understand your control's common usage, it's good to think about the value proposition of the control.</span></span> <span data-ttu-id="4e7dc-122">테이블에 사용자의 컨트롤은 제공할 수 있지만, 다른 컨트롤에서는 제공할 수 없는 기능은 무엇인가요?</span><span class="sxs-lookup"><span data-stu-id="4e7dc-122">What does your control bring to the table that no other control can offer?</span></span> <span data-ttu-id="4e7dc-123">일반적인 용도란 시각적인 특정 모양을 의미하는 것이 아니라 용도와 관련된 합리적인 기대치 집합과 컨트롤의 원리를 의미합니다.</span><span class="sxs-lookup"><span data-stu-id="4e7dc-123">Common usage does not imply any specific visual appearance, but rather the philosophy of the control and a reasonable set of expectations about its usage.</span></span> <span data-ttu-id="4e7dc-124">이 의미를 파악하면 일반적인 용도에서 스타일 정의된 컨트롤 동작과 컴퍼지션 모델을 가정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4e7dc-124">This understanding allows you to make some assumptions about the composition model and the style-defined behaviors of the control in the common case.</span></span> <span data-ttu-id="4e7dc-125">경우 <xref:System.Windows.Controls.ComboBox>, 예를 들어, 일반 용도 이해을 제공 하지 않습니다 모든 정보에 대 한 특정 여부를 <xref:System.Windows.Controls.ComboBox> 둥근된 모서리 되었지만 팩트에 대 한 정보 제공 하는 <xref:System.Windows.Controls.ComboBox> 필요할 팝업 창 및 가 열려 있는지 여부를 설정/해제의 몇 가지 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="4e7dc-125">In the case of <xref:System.Windows.Controls.ComboBox>, for example, understanding the common usage won't give you any insight about whether a particular <xref:System.Windows.Controls.ComboBox> has rounded corners, but it will give you insight into the fact that the <xref:System.Windows.Controls.ComboBox> probably needs a pop-up window and some way of toggling whether it is open.</span></span>  
  
<a name="General_Guidelines"></a>   
## <a name="general-guidelines"></a><span data-ttu-id="4e7dc-126">일반 지침</span><span class="sxs-lookup"><span data-stu-id="4e7dc-126">General Guidelines</span></span>  
  
-   <span data-ttu-id="4e7dc-127">**템플릿 계약을 엄격하게 적용하지 마세요.**</span><span class="sxs-lookup"><span data-stu-id="4e7dc-127">**Do not strictly enforce template contracts.**</span></span> <span data-ttu-id="4e7dc-128">컨트롤의 템플릿 계약은 컨트롤이 제대로 작동하는 데 필요한 요소, 명령, 바인딩, 트리거 또는 속성 설정으로 구성될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4e7dc-128">The template contract of a control might consist of elements, commands, bindings, triggers, or even property settings that are required or expected for a control to function properly.</span></span>  
  
    -   <span data-ttu-id="4e7dc-129">계약을 가능한 최소화합니다.</span><span class="sxs-lookup"><span data-stu-id="4e7dc-129">Minimize contracts as much as possible.</span></span>  
  
    -   <span data-ttu-id="4e7dc-130">디자인 시(즉, 디자인 도구를 사용할 때) 일반적으로 컨트롤 템플릿이 미완성 상태에 있도록 기대치를 디자인합니다.</span><span class="sxs-lookup"><span data-stu-id="4e7dc-130">Design around the expectation that during design time (that is, when using a design tool) it is common for a control template to be in an incomplete state.</span></span> [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]<span data-ttu-id="4e7dc-131">에서는 “작성” 상태 인프라를 제공하지 않으므로, 해당 상태가 올바른 것으로 기대치를 설정하여 컨트롤을 빌드해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4e7dc-131">does not offer a "composing" state infrastructure, so controls have to be built with the expectation that such a state might be valid.</span></span>  
  
    -   <span data-ttu-id="4e7dc-132">템플릿 계약의 요소를 이행하지 않을 때 예외 처리하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="4e7dc-132">Do not throw exceptions when any aspect of a template contract is not followed.</span></span> <span data-ttu-id="4e7dc-133">이러한 선을 따라 하위가 너무 많거나 너무 적을 경우 패널에서 예외 처리하지 않아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4e7dc-133">Along these lines, panels should not throw exceptions if they have too many or too few children.</span></span>  
  
-   <span data-ttu-id="4e7dc-134">**주변 기능을 템플릿 도우미 요소로 포함시킵니다.**</span><span class="sxs-lookup"><span data-stu-id="4e7dc-134">**Factor peripheral functionality into template helper elements.**</span></span> <span data-ttu-id="4e7dc-135">각 컨트롤은 핵심 기능과 참 값 제안에 집중해야 하며 컨트롤의 일반적 사용으로 정의해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4e7dc-135">Each control should be focused on its core functionality and true value proposition and defined by the control's common usage.</span></span> <span data-ttu-id="4e7dc-136">이를 위해 템플릿 내의 컴퍼지션 및 도우미 요소를 사용하여 주변 동작과 시각화(즉, 컨트롤의 핵심 기능에 기여하지 않는 동작 및 시각화)를 사용으로 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="4e7dc-136">To that end, use composition and helper elements within the template to enable peripheral behaviors and visualizations, that is, those behaviors and visualizations that do not contribute to the core functionality of the control.</span></span> <span data-ttu-id="4e7dc-137">도우미 요소는 다음 세 가지 범주로 구분됩니다.</span><span class="sxs-lookup"><span data-stu-id="4e7dc-137">Helper elements fall into three categories:</span></span>  
  
    -   <span data-ttu-id="4e7dc-138">**독립 실행형** 도움말 형식은 공용이며, 템플릿에서 “무명”으로 사용되는 재사용 가능 컨트롤 또는 기본 유형입니다. 즉, 도움말 요소와 스타일 지정된 컨트롤에서 서로를 인식하지 못합니다.</span><span class="sxs-lookup"><span data-stu-id="4e7dc-138">**Standalone** helper types are public and reusable controls or primitives that are used "anonymously" in a template, meaning that neither the helper element nor the styled control is aware of the other.</span></span> <span data-ttu-id="4e7dc-139">기술적으로 요소는 무명 형식일 수 있지만, 이 컨텍스트에서 이 용어는 대상 지정된 시나리오를 사용하도록 특수화된 기능을 캡슐화하는 형식을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="4e7dc-139">Technically, any element can be an anonymous type, but in this context the term describes those types that encapsulate specialized functionality to enable targeted scenarios.</span></span>  
  
    -   <span data-ttu-id="4e7dc-140">**형식 기반** 도우미 요소는 특수화된 기능을 캡슐화하는 새 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="4e7dc-140">**Type-based** helper elements are new types that encapsulate specialized functionality.</span></span> <span data-ttu-id="4e7dc-141">일반적으로 이러한 요소는 공용 컨트롤 또는 기본 요소보다 범위를 한정하여 설계합니다.</span><span class="sxs-lookup"><span data-stu-id="4e7dc-141">These elements are typically designed with a narrower range of functionality than common controls or primitives.</span></span> <span data-ttu-id="4e7dc-142">독립 실행형 도우미 요소와 달리, 형식 기반 도우미 요소는 자신이 사용되는 컨텍스트를 인식하며 일반적으로 속해 있는 템플릿의 컨트롤과 데이터를 공유해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4e7dc-142">Unlike standalone helper elements, type-based helper elements are aware of the context in which they are used and typically must share data with the control to whose template they belong.</span></span>  
  
    -   <span data-ttu-id="4e7dc-143">**명명됨** 도우미 요소는 컨트롤이 템플릿에서 이름으로 찾을 수 있어야 하는 공용 컨트롤 또는 기본 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="4e7dc-143">**Named** helper elements are common controls or primitives that a control expects to find within its template by name.</span></span> <span data-ttu-id="4e7dc-144">이러한 요소에는 템플릿에서 잘 알려진 이름이 제공되므로, 컨트롤에서 요소를 찾아 프로그래밍 방식으로 상호 작용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4e7dc-144">These elements are given a well-known name within the template, making it possible for a control to find the element and interact with it programmatically.</span></span> <span data-ttu-id="4e7dc-145">모든 템플릿에서 지정된 이름의 요소는 하나뿐이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4e7dc-145">There can only be one element with a given name in any template.</span></span>  
  
     <span data-ttu-id="4e7dc-146">다음 테이블에서는 오늘 컨트롤 스타일별로 사용된 도우미 요소를 보여줍니다(이 목록은 전체 목록이 아님).</span><span class="sxs-lookup"><span data-stu-id="4e7dc-146">The following table shows helper elements employed by control styles today (this list is not exhaustive):</span></span>  
  
    |<span data-ttu-id="4e7dc-147">요소</span><span class="sxs-lookup"><span data-stu-id="4e7dc-147">Element</span></span>|<span data-ttu-id="4e7dc-148">형식</span><span class="sxs-lookup"><span data-stu-id="4e7dc-148">Type</span></span>|<span data-ttu-id="4e7dc-149">사용 주체</span><span class="sxs-lookup"><span data-stu-id="4e7dc-149">Used by</span></span>|  
    |-------------|----------|-------------|  
    |<xref:System.Windows.Controls.ContentPresenter>|<span data-ttu-id="4e7dc-150">형식 기반</span><span class="sxs-lookup"><span data-stu-id="4e7dc-150">Type-based</span></span>|<span data-ttu-id="4e7dc-151"><xref:System.Windows.Controls.Button>를 <xref:System.Windows.Controls.CheckBox>, <xref:System.Windows.Controls.RadioButton>를 <xref:System.Windows.Controls.Frame>등 (모든 <xref:System.Windows.Controls.ContentControl> 형식)</span><span class="sxs-lookup"><span data-stu-id="4e7dc-151"><xref:System.Windows.Controls.Button>, <xref:System.Windows.Controls.CheckBox>, <xref:System.Windows.Controls.RadioButton>, <xref:System.Windows.Controls.Frame>, and so on (all <xref:System.Windows.Controls.ContentControl> types)</span></span>|  
    |<xref:System.Windows.Controls.ItemsPresenter>|<span data-ttu-id="4e7dc-152">형식 기반</span><span class="sxs-lookup"><span data-stu-id="4e7dc-152">Type-based</span></span>|<span data-ttu-id="4e7dc-153"><xref:System.Windows.Controls.ListBox>를 <xref:System.Windows.Controls.ComboBox>하십시오 <xref:System.Windows.Controls.Menu>등 (모든 <xref:System.Windows.Controls.ItemsControl> 형식)</span><span class="sxs-lookup"><span data-stu-id="4e7dc-153"><xref:System.Windows.Controls.ListBox>, <xref:System.Windows.Controls.ComboBox>, <xref:System.Windows.Controls.Menu>, and so on (all <xref:System.Windows.Controls.ItemsControl> types)</span></span>|  
    |<xref:System.Windows.Controls.Primitives.ToolBarOverflowPanel>|<span data-ttu-id="4e7dc-154">명명됨</span><span class="sxs-lookup"><span data-stu-id="4e7dc-154">Named</span></span>|<xref:System.Windows.Controls.ToolBar>|  
    |<xref:System.Windows.Controls.Primitives.Popup>|<span data-ttu-id="4e7dc-155">독립 실행형</span><span class="sxs-lookup"><span data-stu-id="4e7dc-155">Standalone</span></span>|<span data-ttu-id="4e7dc-156"><xref:System.Windows.Controls.ComboBox>를 <xref:System.Windows.Controls.ToolBar>하십시오 <xref:System.Windows.Controls.Menu>, <xref:System.Windows.Controls.ToolTip>등</span><span class="sxs-lookup"><span data-stu-id="4e7dc-156"><xref:System.Windows.Controls.ComboBox>, <xref:System.Windows.Controls.ToolBar>, <xref:System.Windows.Controls.Menu>, <xref:System.Windows.Controls.ToolTip>, and so on</span></span>|  
    |<xref:System.Windows.Controls.Primitives.RepeatButton>|<span data-ttu-id="4e7dc-157">명명됨</span><span class="sxs-lookup"><span data-stu-id="4e7dc-157">Named</span></span>|<span data-ttu-id="4e7dc-158"><xref:System.Windows.Controls.Slider>를 <xref:System.Windows.Controls.Primitives.ScrollBar>등</span><span class="sxs-lookup"><span data-stu-id="4e7dc-158"><xref:System.Windows.Controls.Slider>, <xref:System.Windows.Controls.Primitives.ScrollBar>, and so on</span></span>|  
    |<xref:System.Windows.Controls.Primitives.ScrollBar>|<span data-ttu-id="4e7dc-159">명명됨</span><span class="sxs-lookup"><span data-stu-id="4e7dc-159">Named</span></span>|<xref:System.Windows.Controls.ScrollViewer>|  
    |<xref:System.Windows.Controls.ScrollViewer>|<span data-ttu-id="4e7dc-160">독립 실행형</span><span class="sxs-lookup"><span data-stu-id="4e7dc-160">Standalone</span></span>|<span data-ttu-id="4e7dc-161"><xref:System.Windows.Controls.ListBox>를 <xref:System.Windows.Controls.ComboBox>하십시오 <xref:System.Windows.Controls.Menu>, <xref:System.Windows.Controls.Frame>등</span><span class="sxs-lookup"><span data-stu-id="4e7dc-161"><xref:System.Windows.Controls.ListBox>, <xref:System.Windows.Controls.ComboBox>, <xref:System.Windows.Controls.Menu>, <xref:System.Windows.Controls.Frame>, and so on</span></span>|  
    |<xref:System.Windows.Controls.Primitives.TabPanel>|<span data-ttu-id="4e7dc-162">독립 실행형</span><span class="sxs-lookup"><span data-stu-id="4e7dc-162">Standalone</span></span>|<xref:System.Windows.Controls.TabControl>|  
    |<xref:System.Windows.Controls.TextBox>|<span data-ttu-id="4e7dc-163">명명됨</span><span class="sxs-lookup"><span data-stu-id="4e7dc-163">Named</span></span>|<xref:System.Windows.Controls.ComboBox>|  
    |<xref:System.Windows.Controls.Primitives.TickBar>|<span data-ttu-id="4e7dc-164">형식 기반</span><span class="sxs-lookup"><span data-stu-id="4e7dc-164">Type-based</span></span>|<xref:System.Windows.Controls.Slider>|  
  
-   <span data-ttu-id="4e7dc-165">**도우미 요소에서 필수 사용자 지정 바인딩 또는 속성 설정을 최소화**.</span><span class="sxs-lookup"><span data-stu-id="4e7dc-165">**Minimize required user-specified bindings or property settings on helper elements**.</span></span> <span data-ttu-id="4e7dc-166">일반적으로 도우미 요소가 컨트롤 템플릿에서 적절하게 작동하려면 특정 바인딩 또는 속성 설정이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="4e7dc-166">It is common for a helper element to require certain bindings or property settings in order to function properly within the control template.</span></span> <span data-ttu-id="4e7dc-167">도우미 요소와 템플릿 지정된 컨트롤은 최대한 이러한 설정을 지정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4e7dc-167">The helper element and templated control should, as much as possible, establish these settings.</span></span> <span data-ttu-id="4e7dc-168">속성을 설정하거나 바인딩을 설정할 때 사용자가 설정한 값을 재정의하지 않도록 주의해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4e7dc-168">When setting properties or establishing bindings, care should be taken to not override values set by the user.</span></span> <span data-ttu-id="4e7dc-169">구체적인 모범 사례는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="4e7dc-169">Specific best practices are as follows:</span></span>  
  
    -   <span data-ttu-id="4e7dc-170">명명된 도우미 요소는 부모가 식별해야 하며, 부모가 도우미 요소에서 필요한 설정을 지정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4e7dc-170">Named helper elements should be identified by the parent and the parent should establish any required settings on the helper element.</span></span>  
  
    -   <span data-ttu-id="4e7dc-171">형식 기반 도우미 요소는 모든 필수 설정을 직접 설정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4e7dc-171">Type-based helper elements should establish any required settings directly on themselves.</span></span> <span data-ttu-id="4e7dc-172">이 작업을 수행하려면 도우미 요소가 `TemplatedParent`(현재 자신이 사용되고 있는 템플릿의 컨트롤 형식)를 포함하여 현재 사용되고 있는 정보 컨텍스트를 쿼리해야 할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4e7dc-172">Doing this may require the helper element to query for information context in which it is being used, including its `TemplatedParent` (the control type of the template in which it is being used).</span></span> <span data-ttu-id="4e7dc-173">예를 들어 <xref:System.Windows.Controls.ContentPresenter> 자동으로 바인딩합니다를 `Content` 속성을 해당 `TemplatedParent` 에 해당 <xref:System.Windows.Controls.ContentPresenter.Content%2A> 속성에 사용 되는 경우를 <xref:System.Windows.Controls.ContentControl> 파생 형식.</span><span class="sxs-lookup"><span data-stu-id="4e7dc-173">For example, <xref:System.Windows.Controls.ContentPresenter> automatically binds the `Content` property of its `TemplatedParent` to its <xref:System.Windows.Controls.ContentPresenter.Content%2A> property when used in a <xref:System.Windows.Controls.ContentControl> derived type.</span></span>  
  
    -   <span data-ttu-id="4e7dc-174">도우미 요소와 상위가 서로를 알지 못하도록 정의되어 있으므로 독립 실행형 도우미 요소는 이 방식으로 최적화할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="4e7dc-174">Standalone helper elements cannot be optimized in this way because, by definition, neither the helper element nor the parent knows about the other.</span></span>  
  
-   <span data-ttu-id="4e7dc-175">**이름 속성을 사용하여 템플릿에서 요소에 플래그 지정**.</span><span class="sxs-lookup"><span data-stu-id="4e7dc-175">**Use the Name property to flag elements within a template**.</span></span> <span data-ttu-id="4e7dc-176">프로그래밍 방식으로 액세스하기 위해 스타일에서 요소를 찾아야 하는 컨트롤은 `Name` 속성과 `FindName` 패러다임을 사용하여 수행해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4e7dc-176">A control that needs to find an element in its style in order to access it programmatically should do so using the `Name` property and the `FindName` paradigm.</span></span> <span data-ttu-id="4e7dc-177">요소를 찾지 못해도 컨트롤에서 예외 처리를 하지 않아야 하며, 해당 요소가 필요한 기능을 자동으로 적절하게 사용 안 함으로 설정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4e7dc-177">A control should not throw an exception when an element is not found, but silently and gracefully disable the functionality which required that element.</span></span>  
  
-   <span data-ttu-id="4e7dc-178">**스타일에서 컨트롤 상태와 동작을 표시하기 위한 모범 사례 사용.**</span><span class="sxs-lookup"><span data-stu-id="4e7dc-178">**Use best practices for expressing control state and behavior in a style.**</span></span> <span data-ttu-id="4e7dc-179">다음은 스타일에서 컨트롤 상태 변경과 동작을 표시하기 위한 모범 사례가 순서대로 정렬된 목록입니다.</span><span class="sxs-lookup"><span data-stu-id="4e7dc-179">The following is an ordered list of best practices for expressing control state changes and behavior in a style.</span></span> <span data-ttu-id="4e7dc-180">시나리오를 사용하게 설정하는 목록의 첫 번째 항목을 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4e7dc-180">You should use the first item on the list that enables your scenario.</span></span>  
  
    1.  <span data-ttu-id="4e7dc-181">속성 바인딩.</span><span class="sxs-lookup"><span data-stu-id="4e7dc-181">Property binding.</span></span> <span data-ttu-id="4e7dc-182">예: 바인딩 간의 <xref:System.Windows.Controls.ComboBox.IsDropDownOpen%2A?displayProperty=nameWithType> 고 <xref:System.Windows.Controls.Primitives.ToggleButton.IsChecked%2A?displayProperty=nameWithType>입니다.</span><span class="sxs-lookup"><span data-stu-id="4e7dc-182">Example: binding between <xref:System.Windows.Controls.ComboBox.IsDropDownOpen%2A?displayProperty=nameWithType> and <xref:System.Windows.Controls.Primitives.ToggleButton.IsChecked%2A?displayProperty=nameWithType>.</span></span>  
  
    2.  <span data-ttu-id="4e7dc-183">트리거된 속성 변경 또는 속성 애니메이션.</span><span class="sxs-lookup"><span data-stu-id="4e7dc-183">Triggered property changes or property animations.</span></span> <span data-ttu-id="4e7dc-184">예:의 가리키기 상태를 <xref:System.Windows.Controls.Button>입니다.</span><span class="sxs-lookup"><span data-stu-id="4e7dc-184">Example: the hover state of a <xref:System.Windows.Controls.Button>.</span></span>  
  
    3.  <span data-ttu-id="4e7dc-185">명령.</span><span class="sxs-lookup"><span data-stu-id="4e7dc-185">Command.</span></span> <span data-ttu-id="4e7dc-186">예: <xref:System.Windows.Controls.Primitives.ScrollBar.LineUpCommand>  /  <xref:System.Windows.Controls.Primitives.ScrollBar.LineDownCommand> 에서 <xref:System.Windows.Controls.Primitives.ScrollBar>합니다.</span><span class="sxs-lookup"><span data-stu-id="4e7dc-186">Example: <xref:System.Windows.Controls.Primitives.ScrollBar.LineUpCommand> / <xref:System.Windows.Controls.Primitives.ScrollBar.LineDownCommand> in <xref:System.Windows.Controls.Primitives.ScrollBar>.</span></span>  
  
    4.  <span data-ttu-id="4e7dc-187">독립 실행형 도우미 요소.</span><span class="sxs-lookup"><span data-stu-id="4e7dc-187">Standalone helper elements.</span></span> <span data-ttu-id="4e7dc-188">예: <xref:System.Windows.Controls.Primitives.TabPanel> 에서 <xref:System.Windows.Controls.TabControl>합니다.</span><span class="sxs-lookup"><span data-stu-id="4e7dc-188">Example: <xref:System.Windows.Controls.Primitives.TabPanel> in <xref:System.Windows.Controls.TabControl>.</span></span>  
  
    5.  <span data-ttu-id="4e7dc-189">형식 기반 도우미 형식.</span><span class="sxs-lookup"><span data-stu-id="4e7dc-189">Type-based helper types.</span></span> <span data-ttu-id="4e7dc-190">예: <xref:System.Windows.Controls.ContentPresenter> 에 <xref:System.Windows.Controls.Button>를 <xref:System.Windows.Controls.Primitives.TickBar> 에서 <xref:System.Windows.Controls.Slider>합니다.</span><span class="sxs-lookup"><span data-stu-id="4e7dc-190">Example: <xref:System.Windows.Controls.ContentPresenter> in <xref:System.Windows.Controls.Button>, <xref:System.Windows.Controls.Primitives.TickBar> in <xref:System.Windows.Controls.Slider>.</span></span>  
  
    6.  <span data-ttu-id="4e7dc-191">명명됨 도우미 요소.</span><span class="sxs-lookup"><span data-stu-id="4e7dc-191">Named helper elements.</span></span> <span data-ttu-id="4e7dc-192">예: <xref:System.Windows.Controls.TextBox> 에서 <xref:System.Windows.Controls.ComboBox>합니다.</span><span class="sxs-lookup"><span data-stu-id="4e7dc-192">Example: <xref:System.Windows.Controls.TextBox> in <xref:System.Windows.Controls.ComboBox>.</span></span>  
  
    7.  <span data-ttu-id="4e7dc-193">명명됨 도우미 유형의 거품형 이벤트.</span><span class="sxs-lookup"><span data-stu-id="4e7dc-193">Bubbled events from named helper types.</span></span> <span data-ttu-id="4e7dc-194">스타일 요소에서 거품형 이벤트를 수신 대기하려면 해당 이벤트를 생성하는 요소를 고유하게 식별할 수 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4e7dc-194">If you listen for bubbled events from a style element, you should require that the element generating the event can be uniquely identified.</span></span> <span data-ttu-id="4e7dc-195">예: <xref:System.Windows.Controls.Primitives.Thumb> 에서 <xref:System.Windows.Controls.ToolBar>합니다.</span><span class="sxs-lookup"><span data-stu-id="4e7dc-195">Example: <xref:System.Windows.Controls.Primitives.Thumb> in <xref:System.Windows.Controls.ToolBar>.</span></span>  
  
    8.  <span data-ttu-id="4e7dc-196">사용자 지정 `OnRender` 동작.</span><span class="sxs-lookup"><span data-stu-id="4e7dc-196">Custom `OnRender` behavior.</span></span> <span data-ttu-id="4e7dc-197">예: <xref:Microsoft.Windows.Themes.ButtonChrome> 에서 <xref:System.Windows.Controls.Button>합니다.</span><span class="sxs-lookup"><span data-stu-id="4e7dc-197">Example: <xref:Microsoft.Windows.Themes.ButtonChrome> in <xref:System.Windows.Controls.Button>.</span></span>  
  
-   <span data-ttu-id="4e7dc-198">**드물게 스타일 트리거 사용(템플릿 트리거와 반대)**.</span><span class="sxs-lookup"><span data-stu-id="4e7dc-198">**Use style triggers (as opposed to template triggers) sparingly**.</span></span> <span data-ttu-id="4e7dc-199">템플릿에서 요소의 속성에 영향을 미치는 트리거를 템플릿에 선언해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4e7dc-199">Triggers that affect properties on elements in the template must be declared in the template.</span></span> <span data-ttu-id="4e7dc-200">템플릿을 변경하면 트리거도 손상되는 경우가 아닌 경우 컨트롤의 속성에 영향을 미치는 트리거(`TargetName`이 없음)는 스타일에 선언할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4e7dc-200">Triggers that affect properties on the control (no `TargetName`) may be declared in the style unless you know that changing the template should also destroy the trigger.</span></span>  
  
-   <span data-ttu-id="4e7dc-201">**기존 스타일링 패턴과 일치.**</span><span class="sxs-lookup"><span data-stu-id="4e7dc-201">**Be consistent with existing styling patterns.**</span></span> <span data-ttu-id="4e7dc-202">문제를 해결하는 방법이 여러 가지인 경우가 많습니다.</span><span class="sxs-lookup"><span data-stu-id="4e7dc-202">Many times there are multiple ways to solve a problem.</span></span> <span data-ttu-id="4e7dc-203">기존 컨트롤 스타일 지정 패턴을 인식하고 가능한 경우 이 패턴과 일치시킵니다.</span><span class="sxs-lookup"><span data-stu-id="4e7dc-203">Be aware of and, when possible, consistent with existing control styling patterns.</span></span> <span data-ttu-id="4e7dc-204">이 동일한 기본 형식에서 파생 되는 컨트롤에 대 한 특히 중요 (예를 들어 <xref:System.Windows.Controls.ContentControl>, <xref:System.Windows.Controls.ItemsControl>, <xref:System.Windows.Controls.Primitives.RangeBase>등).</span><span class="sxs-lookup"><span data-stu-id="4e7dc-204">This is especially important for controls that derive from the same base type (for example, <xref:System.Windows.Controls.ContentControl>, <xref:System.Windows.Controls.ItemsControl>, <xref:System.Windows.Controls.Primitives.RangeBase>, and so on).</span></span>  
  
-   <span data-ttu-id="4e7dc-205">**다시 템플릿을 지정하지 않고 공용 사용자 지정 시나리오를 사용하도록 속성 노출**.</span><span class="sxs-lookup"><span data-stu-id="4e7dc-205">**Expose properties to enable common customization scenarios without retemplating**.</span></span> [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]<span data-ttu-id="4e7dc-206">에서는 플러그형/사용자 지정 가능 파트를 지원하지 않으므로, 컨트롤 사용자는 속성을 직접 설정하거나 스타일을 사용하여 속성을 설정하는 식의 두 가지 방법으로만 사용자 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4e7dc-206">does not support pluggable/customizable parts, so a control user is left with only two methods of customization: setting properties directly or setting properties using styles.</span></span> <span data-ttu-id="4e7dc-207">이 점을 염두에 두고 매우 일반적이며 우선 순위가 높은 사용자 지정 시나리오에서 대상으로 지정된 제한된 수의 속성을 공개하는 것이 적절합니다. 그렇지 않으면 다시 템플릿을 지정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4e7dc-207">With that in mind, it is appropriate to surface a limited number of properties targeted at very common, high-priority customization scenarios which would otherwise require the retemplating.</span></span> <span data-ttu-id="4e7dc-208">다음은 사용자 지정 시나리오를 사용하도록 설정하는 시기와 방법에 관한 모범 사례입니다.</span><span class="sxs-lookup"><span data-stu-id="4e7dc-208">Here are best practices for when and how to enable customization scenarios:</span></span>  
  
    -   <span data-ttu-id="4e7dc-209">매우 일반적인 사용자 지정을 컨트롤의 속성으로 노출하여 템플릿에서 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4e7dc-209">Very common customizations should be exposed as properties on the control and consumed by the template.</span></span>  
  
    -   <span data-ttu-id="4e7dc-210">덜 일반적인(드물지는 않음) 사용자 지정은 연결된 속성으로 노출하여 템플릿에서 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4e7dc-210">Less common (though not rare) customizations should be exposed as attached properties and consumed by the template.</span></span>  
  
    -   <span data-ttu-id="4e7dc-211">알려져 있지만 드문 사용자 지정은 다시 템플릿을 지정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4e7dc-211">It is acceptable for known but rare customizations to require retemplating.</span></span>  
  
<a name="Theme_Considerations"></a>   
## <a name="theme-considerations"></a><span data-ttu-id="4e7dc-212">테마 고려 사항</span><span class="sxs-lookup"><span data-stu-id="4e7dc-212">Theme Considerations</span></span>  
  
-   <span data-ttu-id="4e7dc-213">**테마 스타일은 모든 테마에서 일관된 속성 의미 체계를 유지하려고 시도하지만 보장되지는 않습니다**.</span><span class="sxs-lookup"><span data-stu-id="4e7dc-213">**Theme styles should attempt to have consistent property semantics across all themes, but make no guarantee**.</span></span> <span data-ttu-id="4e7dc-214">컨트롤에는 설명서의 일부로 컨트롤의 속성 의미 체계, 즉 컨트롤의 속성 “의미”를 설명하는 문서가 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4e7dc-214">As part of its documentation, your control should have a document describing the control's property semantics, that is, the "meaning" of a property for a control.</span></span> <span data-ttu-id="4e7dc-215">예를 들어 합니다 <xref:System.Windows.Controls.ComboBox> 컨트롤의 의미를 정의 해야 합니다 <xref:System.Windows.Controls.Control.Background%2A> 내에서 속성 <xref:System.Windows.Controls.ComboBox>합니다.</span><span class="sxs-lookup"><span data-stu-id="4e7dc-215">For example, the <xref:System.Windows.Controls.ComboBox> control should define the meaning of the <xref:System.Windows.Controls.Control.Background%2A> property within <xref:System.Windows.Controls.ComboBox>.</span></span> <span data-ttu-id="4e7dc-216">컨트롤의 기본 스타일은 모든 테마에서 해당 문서에 정의된 의미 체계를 따라야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4e7dc-216">The default styles for your control should attempt to follow the semantics defined in that document across all themes.</span></span> <span data-ttu-id="4e7dc-217">한편 컨트롤 사용자는 해당 속성 의미 체계가 테마 간에 변경될 수 있음을 알아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4e7dc-217">Control users, on the other hand, should be aware that property semantics can change from theme to theme.</span></span> <span data-ttu-id="4e7dc-218">경우에 따라 특정 테마에 필요한 시각적 제약 조건때문에 지정된 속성이 표시되지 못할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4e7dc-218">In certain cases, a given property may not be expressible under the visual constraints required by a particular theme.</span></span> <span data-ttu-id="4e7dc-219">(예를 들어, 클래식 테마에는 여러 컨트롤에 대해 `Thickness`를 적용할 수 있는 단일 테두리가 없습니다.)</span><span class="sxs-lookup"><span data-stu-id="4e7dc-219">(The Classic theme, for example, does not have a single border to which `Thickness` can be applied for many controls.)</span></span>  
  
-   <span data-ttu-id="4e7dc-220">**모든 테마에서 테마 스타일의 트리거 의미 체계는 일관되지 않아도 됩니다**.</span><span class="sxs-lookup"><span data-stu-id="4e7dc-220">**Theme styles do not need to have consistent trigger semantics across all themes**.</span></span> <span data-ttu-id="4e7dc-221">트리거 또는 애니메이션을 통해 컨트롤 스타일이 노출한 동작은 테마마다 달라질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4e7dc-221">The behavior exposed by a control style through triggers or animations may vary from theme to theme.</span></span> <span data-ttu-id="4e7dc-222">컨트롤 사용자는 모든 테마에서 특정 동작을 수행하기 위해 컨트롤에서 동일한 메커니즘을 채택하지 않아도 된다는 점을 알아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4e7dc-222">Control users should be aware that a control will not necessarily employ the same mechanism to achieve a particular behavior across all themes.</span></span> <span data-ttu-id="4e7dc-223">예를 들어, 한 테마에서는 애니메이션을 사용하여 가리키기 동작을 표현하며, 다른 테마에서는 트리거를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="4e7dc-223">One theme, for example, may use an animation to express hover behavior where another theme uses a trigger.</span></span> <span data-ttu-id="4e7dc-224">그러면 사용자 지정된 컨트롤에서 동작이 일관되지 않게 유지될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4e7dc-224">This can result in inconsistencies in behavior preservation on customized controls.</span></span> <span data-ttu-id="4e7dc-225">(예를 들어, 트리거를 사용하여 해당 상태를 표현하는 경우 배경 속성을 변경해도 컨트롤의 가리키기 상태에 영향을 미치지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="4e7dc-225">(Changing the background property, for example, might not affect the hover state of the control if that state is expressed using a trigger.</span></span> <span data-ttu-id="4e7dc-226">그러나 애니메이션을 사용하여 가리키기 상태를 구현하는 경우 배경을 중단하면 애니메이션이 복구할 수 없게 손상될 수 있으므로 상태가 전환됩니다.)</span><span class="sxs-lookup"><span data-stu-id="4e7dc-226">However, if the hover state is implemented using an animation, changing to background could irreparably break the animation and therefore the state transition.)</span></span>  
  
-   <span data-ttu-id="4e7dc-227">**모든 테마에서 테마 스타일의 “레이아웃”의미 체계는 일관되지 않아도 됩니다**.</span><span class="sxs-lookup"><span data-stu-id="4e7dc-227">**Theme styles do not need to have consistent "layout" semantics across all themes**.</span></span> <span data-ttu-id="4e7dc-228">예를 들어, 기본 스타일에서는 모든 테마에서 컨트롤이 반드시 동일한 크기를 차지하거나 컨트롤이 모든 테마에서 반드시 동일한 콘텐츠 여백 / 안쪽 여백을 유지하지 않아도 됩니다.</span><span class="sxs-lookup"><span data-stu-id="4e7dc-228">For example, the default style does not need to guarantee that a control will occupy the same amount of size in all themes or guarantee that a control will have the same content margins / padding across all themes.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="4e7dc-229">참고자료</span><span class="sxs-lookup"><span data-stu-id="4e7dc-229">See also</span></span>
- [<span data-ttu-id="4e7dc-230">스타일 지정 및 템플릿</span><span class="sxs-lookup"><span data-stu-id="4e7dc-230">Styling and Templating</span></span>](../../../../docs/framework/wpf/controls/styling-and-templating.md)
- [<span data-ttu-id="4e7dc-231">컨트롤 제작 개요</span><span class="sxs-lookup"><span data-stu-id="4e7dc-231">Control Authoring Overview</span></span>](../../../../docs/framework/wpf/controls/control-authoring-overview.md)

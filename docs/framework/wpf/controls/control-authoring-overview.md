---
title: 컨트롤 제작 개요
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- controls [WPF], authoring overview
- authoring overview for controls [WPF]
ms.assetid: 3d864748-cff0-4e63-9b23-d8e5a635b28f
ms.openlocfilehash: 2326520039085beb5f5294e23db67b67f9d7d7da
ms.sourcegitcommit: 7980a91f90ae5eca859db7e6bfa03e23e76a1a50
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 04/13/2020
ms.locfileid: "81243273"
---
# <a name="control-authoring-overview"></a><span data-ttu-id="3957b-102">작성 개요 제어</span><span class="sxs-lookup"><span data-stu-id="3957b-102">Control authoring overview</span></span>

<span data-ttu-id="3957b-103">[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] 컨트롤 모델의 확장성 덕분에 새 컨트롤을 만들 필요성이 상당히 줄어들었습니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-103">The extensibility of the [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] control model greatly reduces the need to create a new control.</span></span> <span data-ttu-id="3957b-104">그러나 어떤 경우에는 여전히 사용자 지정 컨트롤을 만들어야 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-104">However, in certain cases you may still need to create a custom control.</span></span> <span data-ttu-id="3957b-105">이 항목에서는 [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]에서 사용자 지정 컨트롤과 다양한 컨트롤 제작 모델을 만들 필요성을 최소화시키는 기능에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-105">This topic discusses the features that minimize your need to create a custom control and the different control authoring models in [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)].</span></span> <span data-ttu-id="3957b-106">또한 새 컨트롤을 만드는 방법을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-106">This topic also demonstrates how to create a new control.</span></span>

<a name="when_to_write_a_new_control"></a>

## <a name="alternatives-to-writing-a-new-control"></a><span data-ttu-id="3957b-107">새 컨트롤 작성에 대한 대안</span><span class="sxs-lookup"><span data-stu-id="3957b-107">Alternatives to Writing a New Control</span></span>

<span data-ttu-id="3957b-108">지금까지 기존 컨트롤에서 사용자 지정 환경을 구현하려고 하면 배경색, 테두리 너비 및 글꼴 크기와 같은 컨트롤의 표준 속성을 변경하는 것으로 제한되어 있었습니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-108">Historically, if you wanted to get a customized experience from an existing control, you were limited to changing the standard properties of the control, such as background color, border width, and font size.</span></span> <span data-ttu-id="3957b-109">미리 정의된 이러한 매개 변수 이상으로 컨트롤의 모양이나 동작을 확장하려면 일반적으로 기존 컨트롤에서 상속받게 하고 컨트롤 그리기를 담당하는 메서드를 재정의하여 새 컨트롤을 만들어야 했습니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-109">If you wished to extend the appearance or behavior of a control beyond these predefined parameters, you would need to create a new control, usually by inheriting from an existing control and overriding the method responsible for drawing the control.</span></span>  <span data-ttu-id="3957b-110">여전히 옵션이기는 하지만 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]를 사용하면 풍부한 콘텐츠 모델, 스타일, 템플릿 및 트리거를 사용하여 기존 컨트롤을 사용자 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-110">Although that is still an option, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] enables to you customize existing controls by using its rich content model, styles, templates, and triggers.</span></span> <span data-ttu-id="3957b-111">다음 목록에는 새 컨트롤을 만들지 않고 이러한 기능을 사용하여 사용자 지정 및 일관된 환경을 만드는 예제가 나와 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-111">The following list gives examples of how these features can be used to create custom and consistent experiences without having to create a new control.</span></span>

- <span data-ttu-id="3957b-112">**풍부한 콘텐츠.**</span><span class="sxs-lookup"><span data-stu-id="3957b-112">**Rich Content.**</span></span> <span data-ttu-id="3957b-113">많은 표준 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 컨트롤이 풍부한 콘텐츠를 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-113">Many of the standard [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] controls support rich content.</span></span> <span data-ttu-id="3957b-114">예를 들어 a의 <xref:System.Windows.Controls.Button> 콘텐츠 속성은 <xref:System.Object>형식이므로 이론적으로 모든 것을 <xref:System.Windows.Controls.Button>에 표시할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-114">For example, the content property of a <xref:System.Windows.Controls.Button> is of type <xref:System.Object>, so theoretically anything can be displayed on a <xref:System.Windows.Controls.Button>.</span></span>  <span data-ttu-id="3957b-115">단추에 이미지와 텍스트를 표시하려면 <xref:System.Windows.Controls.TextBlock> 이미지와 a를 추가하여 <xref:System.Windows.Controls.StackPanel> <xref:System.Windows.Controls.StackPanel> <xref:System.Windows.Controls.ContentControl.Content%2A> 속성에 할당할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-115">To have a button display an image and text, you can add an image and a <xref:System.Windows.Controls.TextBlock> to a <xref:System.Windows.Controls.StackPanel> and assign the <xref:System.Windows.Controls.StackPanel> to the <xref:System.Windows.Controls.ContentControl.Content%2A> property.</span></span> <span data-ttu-id="3957b-116">이러한 컨트롤은 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 시각적 요소와 임의의 데이터를 표시할 수 있기 때문에 복잡한 시각화를 지원하기 위해 새 컨트롤을 만들거나 기존 컨트롤을 수정할 필요성이 적습니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-116">Because the controls can display [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] visual elements and arbitrary data, there is less need to create a new control or to modify an existing control to support a complex visualization.</span></span> <span data-ttu-id="3957b-117">의 콘텐츠 모델 및 <xref:System.Windows.Controls.Button> 기타 콘텐츠 모델에 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]대한 자세한 내용은 [WPF 콘텐츠 모델을](wpf-content-model.md)참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="3957b-117">For more information about the content model for <xref:System.Windows.Controls.Button> and other content models in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], see [WPF Content Model](wpf-content-model.md).</span></span>

- <span data-ttu-id="3957b-118">**스타일.**</span><span class="sxs-lookup"><span data-stu-id="3957b-118">**Styles.**</span></span> <span data-ttu-id="3957b-119">A는 <xref:System.Windows.Style> 컨트롤의 속성을 나타내는 값의 컬렉션입니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-119">A <xref:System.Windows.Style> is a collection of values that represent properties for a control.</span></span> <span data-ttu-id="3957b-120">스타일을 사용하면 새 컨트롤을 작성하지 않고도 원하는 컨트롤 모양과 동작을 재사용 가능한 표현으로 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-120">By using styles, you can create a reusable representation of a desired control appearance and behavior without writing a new control.</span></span> <span data-ttu-id="3957b-121">예를 들어 모든 <xref:System.Windows.Controls.TextBlock> 컨트롤에 글꼴 크기가 14인 Arial 글꼴을 빨간색으로 설정한다고 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-121">For example, assume that you want all of your <xref:System.Windows.Controls.TextBlock> controls to have red, Arial font with a font size of 14.</span></span> <span data-ttu-id="3957b-122">스타일을 리소스로 만들고 이에 따라 적절한 속성을 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-122">You can create a style as a resource and set the appropriate properties accordingly.</span></span> <span data-ttu-id="3957b-123">그런 <xref:System.Windows.Controls.TextBlock> 다음 응용 프로그램에 추가하는 모든 모양이 동일합니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-123">Then every <xref:System.Windows.Controls.TextBlock> that you add to your application will have the same appearance.</span></span>

- <span data-ttu-id="3957b-124">**데이터 템플릿.**</span><span class="sxs-lookup"><span data-stu-id="3957b-124">**Data Templates.**</span></span> <span data-ttu-id="3957b-125">A를 <xref:System.Windows.DataTemplate> 사용하면 컨트롤에 데이터가 표시되는 방식을 사용자 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-125">A <xref:System.Windows.DataTemplate> enables you to customize how data is displayed on a control.</span></span> <span data-ttu-id="3957b-126">예를 들어, <xref:System.Windows.DataTemplate> 에 데이터가 표시되는 방법을 지정하는 <xref:System.Windows.Controls.ListBox>데 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-126">For example, a <xref:System.Windows.DataTemplate> can be used to specify how data is displayed in a <xref:System.Windows.Controls.ListBox>.</span></span>  <span data-ttu-id="3957b-127">이에 대한 예제는 [데이터 템플릿 개요](../data/data-templating-overview.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="3957b-127">For an example of this, see [Data Templating Overview](../data/data-templating-overview.md).</span></span>  <span data-ttu-id="3957b-128">데이터 모양을 사용자 지정하는 것 <xref:System.Windows.DataTemplate> 외에도 사용자 지정 UI에서 많은 유연성을 제공하는 UI 요소가 포함될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-128">In addition to customizing the appearance of data, a <xref:System.Windows.DataTemplate> can include UI elements, which gives you a lot of flexibility in custom UIs.</span></span>  <span data-ttu-id="3957b-129">예를 들어 <xref:System.Windows.DataTemplate>을 사용하여 각 항목에 <xref:System.Windows.Controls.ComboBox> 확인란이 포함된 를 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-129">For example, by using a <xref:System.Windows.DataTemplate>, you can create a <xref:System.Windows.Controls.ComboBox> in which each item contains a check box.</span></span>

- <span data-ttu-id="3957b-130">**제어 템플릿.**</span><span class="sxs-lookup"><span data-stu-id="3957b-130">**Control Templates.**</span></span> <span data-ttu-id="3957b-131">컨트롤을 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] <xref:System.Windows.Controls.ControlTemplate> 사용하여 컨트롤의 모양과 컨트롤의 기능을 구분하는 컨트롤의 구조와 모양을 정의하는 데 사용되는 많은 컨트롤이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-131">Many controls in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] use a <xref:System.Windows.Controls.ControlTemplate> to define the control's structure and appearance, which separates the appearance of a control from the functionality of the control.</span></span> <span data-ttu-id="3957b-132">을 재정의하여 컨트롤의 모양을 크게 <xref:System.Windows.Controls.ControlTemplate>변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-132">You can drastically change the appearance of a control by redefining its <xref:System.Windows.Controls.ControlTemplate>.</span></span>  <span data-ttu-id="3957b-133">예를 들어 신호등 모양의 컨트롤이 필요하다고 가정해 보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-133">For example, suppose you want a control that looks like a stoplight.</span></span> <span data-ttu-id="3957b-134">이 컨트롤에는 간단한 사용자 인터페이스 및 기능이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-134">This control has a simple user interface and functionality.</span></span>  <span data-ttu-id="3957b-135">컨트롤은 세 개의 원으로, 한 번에 하나씩만 불을 켤 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-135">The control is three circles, only one of which can be lit up at a time.</span></span> <span data-ttu-id="3957b-136">일부 리플렉션 후 <xref:System.Windows.Controls.RadioButton> 한 번에 하나만 선택되는 기능을 제공하지만 기본 모양은 <xref:System.Windows.Controls.RadioButton> 스톱라이트의 라이트와 같은 모양이 아니라는 것을 알게 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-136">After some reflection, you might realize that a <xref:System.Windows.Controls.RadioButton> offers the functionality of only one being selected at a time, but the default appearance of the <xref:System.Windows.Controls.RadioButton> looks nothing like the lights on a stoplight.</span></span>  <span data-ttu-id="3957b-137">컨트롤 <xref:System.Windows.Controls.RadioButton> 템플릿을 사용하여 모양을 정의하기 때문에 컨트롤의 요구 <xref:System.Windows.Controls.ControlTemplate> 사항에 맞게 을 재정의하고 라디오 단추를 사용하여 스톱라이트를 만드는 것이 쉽습니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-137">Because the <xref:System.Windows.Controls.RadioButton> uses a control template to define its appearance, it is easy to redefine the <xref:System.Windows.Controls.ControlTemplate> to fit the requirements of the control, and use radio buttons to make your stoplight.</span></span>

  > [!NOTE]
  > <span data-ttu-id="3957b-138">a를 <xref:System.Windows.Controls.RadioButton> 사용할 <xref:System.Windows.DataTemplate>수 <xref:System.Windows.DataTemplate> 있지만 a는 이 예제에서는 충분하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-138">Although a <xref:System.Windows.Controls.RadioButton> can use a <xref:System.Windows.DataTemplate>, a <xref:System.Windows.DataTemplate> is not sufficient in this example.</span></span>  <span data-ttu-id="3957b-139">는 <xref:System.Windows.DataTemplate> 컨트롤의 내용의 모양을 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-139">The <xref:System.Windows.DataTemplate> defines the appearance of the content of a control.</span></span> <span data-ttu-id="3957b-140">의 경우 <xref:System.Windows.Controls.RadioButton>, 콘텐츠는 선택 여부를 나타내는 원의 오른쪽에 나타나는 <xref:System.Windows.Controls.RadioButton> 무엇이든이다.</span><span class="sxs-lookup"><span data-stu-id="3957b-140">In the case of a <xref:System.Windows.Controls.RadioButton>, the content is whatever appears to the right of the circle that indicates whether the <xref:System.Windows.Controls.RadioButton> is selected.</span></span>  <span data-ttu-id="3957b-141">신호등의 예제에서 라디오 버튼은 "불을 켤 수 있는" 원이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-141">In the example of the stoplight, the radio button needs just be a circle that can "light up."</span></span> <span data-ttu-id="3957b-142">스톱라이트에 대한 모양 요구 사항은 의 기본 모양과 너무 다르기 <xref:System.Windows.Controls.RadioButton>때문에 <xref:System.Windows.Controls.ControlTemplate>을 재정의할 필요가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-142">Because the appearance requirement for the stoplight is so different than the default appearance of the <xref:System.Windows.Controls.RadioButton>, it is necessary to redefine the <xref:System.Windows.Controls.ControlTemplate>.</span></span>  <span data-ttu-id="3957b-143">일반적으로 a는 <xref:System.Windows.DataTemplate> 컨트롤의 컨텐터(또는 데이터)를 정의하는 <xref:System.Windows.Controls.ControlTemplate> 데 사용되며, a는 컨트롤의 구조화 방식을 정의하는 데 사용된다.</span><span class="sxs-lookup"><span data-stu-id="3957b-143">In general a <xref:System.Windows.DataTemplate> is used for defining the content (or data) of a control, and a <xref:System.Windows.Controls.ControlTemplate> is used for defining how a control is structured.</span></span>

- <span data-ttu-id="3957b-144">**트리거.**</span><span class="sxs-lookup"><span data-stu-id="3957b-144">**Triggers.**</span></span> <span data-ttu-id="3957b-145">A를 <xref:System.Windows.Trigger> 사용하면 새 컨트롤을 만들지 않고도 컨트롤의 모양과 동작을 동적으로 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-145">A <xref:System.Windows.Trigger> allows you to dynamically change the appearance and behavior of a control without creating a new control.</span></span> <span data-ttu-id="3957b-146">예를 들어 응용 프로그램에 <xref:System.Windows.Controls.ListBox> 여러 컨트롤이 있고 각 <xref:System.Windows.Controls.ListBox> 항목이 선택될 때 굵게 및 빨간색으로 표시하려고 한다고 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-146">For example, suppose you have multiple <xref:System.Windows.Controls.ListBox> controls in your application and want the items in each <xref:System.Windows.Controls.ListBox> to be bold and red when they are selected.</span></span> <span data-ttu-id="3957b-147">첫 번째 본능은 선택한 항목의 모양을 <xref:System.Windows.Controls.ListBox> 변경하는 <xref:System.Windows.Controls.Primitives.Selector.OnSelectionChanged%2A> 메서드를 상속하고 재정의하는 클래스를 만드는 것이지만 더 나은 방법은 선택한 <xref:System.Windows.Controls.ListBoxItem> 항목의 모양을 변경하는 a의 스타일에 트리거를 추가하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-147">Your first instinct might be to create a class that inherits from <xref:System.Windows.Controls.ListBox> and override the <xref:System.Windows.Controls.Primitives.Selector.OnSelectionChanged%2A> method to change the appearance of the selected item, but a better approach is to add a trigger to a style of a <xref:System.Windows.Controls.ListBoxItem> that changes the appearance of the selected item.</span></span> <span data-ttu-id="3957b-148">트리거를 사용하면 속성 값을 변경하거나 속성 값을 기반으로 작업을 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-148">A trigger enables you to change property values or take actions based on the value of a property.</span></span> <span data-ttu-id="3957b-149">A를 <xref:System.Windows.EventTrigger> 사용하면 이벤트가 발생할 때 작업을 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-149">An <xref:System.Windows.EventTrigger> enables you to take actions when an event occurs.</span></span>

<span data-ttu-id="3957b-150">스타일, 템플릿 및 트리거에 대한 자세한 내용은 [스타일 지정 및 템플릿](styling-and-templating.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="3957b-150">For more information about styles, templates, and triggers, see [Styling and Templating](styling-and-templating.md).</span></span>

<span data-ttu-id="3957b-151">일반적으로 컨트롤이 기존 컨트롤의 기능을 반영하지만 컨트롤이 다르게 보이게 하려면 이 섹션에서 설명하는 메서드 중 하나를 사용하여 기존 컨트롤의 모양을 변경할 수 있는지 여부를 먼저 고려해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-151">In general, if your control mirrors the functionality of an existing control, but you want the control to look different, you should first consider whether you can use any of the methods discussed in this section to change the existing control's appearance.</span></span>

<a name="models_for_control_authoring"></a>

## <a name="models-for-control-authoring"></a><span data-ttu-id="3957b-152">컨트롤 제작 모델</span><span class="sxs-lookup"><span data-stu-id="3957b-152">Models for Control Authoring</span></span>

<span data-ttu-id="3957b-153">풍부한 콘텐츠 모델, 스타일, 템플릿 및 트리거를 사용하면 새 컨트롤을 만들어야 하는 필요성이 최소화됩니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-153">The rich content model, styles, templates, and triggers minimize the need for you to create a new control.</span></span> <span data-ttu-id="3957b-154">그러나 새 컨트롤을 만들어야 한다면 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]의 다양한 컨트롤 제작 모델을 이해하는 것이 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-154">However, if you do need to create a new control, it is important to understand the different control authoring models in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)].</span></span> [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]<span data-ttu-id="3957b-155">는 컨트롤을 만들기 위해 세 가지 일반적인 모델을 제공하며 각 모델은 서로 다른 일련의 기능과 유연성 수준을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-155">provides three general models for creating a control, each of which provides a different set of features and level of flexibility.</span></span> <span data-ttu-id="3957b-156">세 모델의 기본 클래스는 <xref:System.Windows.Controls.Control>및 <xref:System.Windows.FrameworkElement>. <xref:System.Windows.Controls.UserControl></span><span class="sxs-lookup"><span data-stu-id="3957b-156">The base classes for the three models are <xref:System.Windows.Controls.UserControl>, <xref:System.Windows.Controls.Control>, and <xref:System.Windows.FrameworkElement>.</span></span>

### <a name="deriving-from-usercontrol"></a><span data-ttu-id="3957b-157">UserControl에서 파생</span><span class="sxs-lookup"><span data-stu-id="3957b-157">Deriving from UserControl</span></span>

<span data-ttu-id="3957b-158">에서 컨트롤을 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 만드는 가장 간단한 방법은 <xref:System.Windows.Controls.UserControl>에서 파생하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-158">The simplest way to create a control in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] is to derive from <xref:System.Windows.Controls.UserControl>.</span></span> <span data-ttu-id="3957b-159">에서 <xref:System.Windows.Controls.UserControl>상속하는 컨트롤을 빌드할 때 <xref:System.Windows.Controls.UserControl>의 에서 기존 구성 요소를 추가 합니다. [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)]</span><span class="sxs-lookup"><span data-stu-id="3957b-159">When you build a control that inherits from <xref:System.Windows.Controls.UserControl>, you add existing components to the <xref:System.Windows.Controls.UserControl>, name the components, and reference event handlers in [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)].</span></span> <span data-ttu-id="3957b-160">그런 다음 코드에서 명명된 요소를 참조하고 이벤트 처리기를 정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-160">You can then reference the named elements and define the event handlers in code.</span></span> <span data-ttu-id="3957b-161">이 개발 모델은 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]의 애플리케이션 개발에 사용된 모델과 매우 유사합니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-161">This development model is very similar to the model used for application development in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)].</span></span>

<span data-ttu-id="3957b-162">올바르게 빌드된 <xref:System.Windows.Controls.UserControl> 경우 a는 풍부한 콘텐츠, 스타일 및 트리거의 이점을 활용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-162">If built correctly, a <xref:System.Windows.Controls.UserControl> can take advantage of the benefits of rich content, styles, and triggers.</span></span> <span data-ttu-id="3957b-163">그러나 컨트롤이 <xref:System.Windows.Controls.UserControl>에서 상속되는 경우 컨트롤을 사용하는 사용자는 을 <xref:System.Windows.DataTemplate> 사용하거나 <xref:System.Windows.Controls.ControlTemplate> 모양을 사용자 지정할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-163">However, if your control inherits from <xref:System.Windows.Controls.UserControl>, people who use your control will not be able to use a <xref:System.Windows.DataTemplate> or <xref:System.Windows.Controls.ControlTemplate> to customize its appearance.</span></span>  <span data-ttu-id="3957b-164">템플릿을 지원하는 사용자 <xref:System.Windows.Controls.Control> 지정 컨트롤을 만들려면 클래스 또는 <xref:System.Windows.Controls.UserControl>파생 클래스 중 하나에서 파생해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-164">It is necessary to derive from the <xref:System.Windows.Controls.Control> class or one of its derived classes (other than <xref:System.Windows.Controls.UserControl>) to create a custom control that supports templates.</span></span>

#### <a name="benefits-of-deriving-from-usercontrol"></a><span data-ttu-id="3957b-165">UserControl에서 파생하는 이점</span><span class="sxs-lookup"><span data-stu-id="3957b-165">Benefits of Deriving from UserControl</span></span>

<span data-ttu-id="3957b-166">다음이 모두 <xref:System.Windows.Controls.UserControl> 적용되는지 파생하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-166">Consider deriving from <xref:System.Windows.Controls.UserControl> if all of the following apply:</span></span>

- <span data-ttu-id="3957b-167">애플리케이션을 빌드하는 방법과 유사하게 컨트롤을 빌드하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-167">You want to build your control similarly to how you build an application.</span></span>

- <span data-ttu-id="3957b-168">컨트롤이 기존 구성 요소로만 구성됩니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-168">Your control consists only of existing components.</span></span>

- <span data-ttu-id="3957b-169">복잡한 사용자 지정을 지원하지 않아도 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-169">You don't need to support complex customization.</span></span>

### <a name="deriving-from-control"></a><span data-ttu-id="3957b-170">Control에서 파생</span><span class="sxs-lookup"><span data-stu-id="3957b-170">Deriving from Control</span></span>

<span data-ttu-id="3957b-171"><xref:System.Windows.Controls.Control> 클래스에서 파생되는 모델은 대부분의 기존 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 컨트롤에서 사용되는 모델입니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-171">Deriving from the <xref:System.Windows.Controls.Control> class is the model used by most of the existing [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] controls.</span></span> <span data-ttu-id="3957b-172">클래스에서 상속하는 컨트롤을 <xref:System.Windows.Controls.Control> 만들 때 템플릿을 사용하여 모양을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-172">When you create a control that inherits from the <xref:System.Windows.Controls.Control> class, you define its appearance by using templates.</span></span> <span data-ttu-id="3957b-173">그렇게 함으로써 작동 논리를 시각적 표현과 분리합니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-173">By doing so, you separate the operational logic from the visual representation.</span></span> <span data-ttu-id="3957b-174">또한 이벤트 대신 명령과 바인딩을 사용하고 가능하면 요소를 참조하지 않도록 하여 UI와 논리의 <xref:System.Windows.Controls.ControlTemplate> 분리를 보장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-174">You can also ensure the decoupling of the UI and logic by using commands and bindings instead of events and avoiding referencing elements in the <xref:System.Windows.Controls.ControlTemplate> whenever possible.</span></span>  <span data-ttu-id="3957b-175">컨트롤의 UI와 논리가 제대로 분리된 경우 컨트롤의 사용자가 컨트롤의 모양을 <xref:System.Windows.Controls.ControlTemplate> 사용자 지정하도록 컨트롤을 재정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-175">If the UI and logic of your control are properly decoupled, a user of your control can redefine the control's <xref:System.Windows.Controls.ControlTemplate> to customize its appearance.</span></span> <span data-ttu-id="3957b-176">사용자 지정을 <xref:System.Windows.Controls.Control> 빌드하는 것은 <xref:System.Windows.Controls.UserControl>을 빌드하는 <xref:System.Windows.Controls.Control> 것만큼 간단하지는 않지만 사용자 지정은 가장 유연하게 합니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-176">Although building a custom <xref:System.Windows.Controls.Control> is not as simple as building a <xref:System.Windows.Controls.UserControl>, a custom <xref:System.Windows.Controls.Control> provides the most flexibility.</span></span>

#### <a name="benefits-of-deriving-from-control"></a><span data-ttu-id="3957b-177">Control에서 파생하는 이점</span><span class="sxs-lookup"><span data-stu-id="3957b-177">Benefits of Deriving from Control</span></span>

<span data-ttu-id="3957b-178">다음 중 한 <xref:System.Windows.Controls.Control> 가지라도 <xref:System.Windows.Controls.UserControl> 적용되는 경우 클래스를 사용하는 대신 파생하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-178">Consider deriving from <xref:System.Windows.Controls.Control> instead of using the <xref:System.Windows.Controls.UserControl> class if any of the following apply:</span></span>

- <span data-ttu-id="3957b-179">을 통해 컨트롤의 모양을 사용자 지정할 <xref:System.Windows.Controls.ControlTemplate>수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-179">You want the appearance of your control to be customizable via the <xref:System.Windows.Controls.ControlTemplate>.</span></span>

- <span data-ttu-id="3957b-180">컨트롤이 다른 테마를 지원하게 하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-180">You want your control to support different themes.</span></span>

### <a name="deriving-from-frameworkelement"></a><span data-ttu-id="3957b-181">FrameworkElement에서 파생</span><span class="sxs-lookup"><span data-stu-id="3957b-181">Deriving from FrameworkElement</span></span>

<span data-ttu-id="3957b-182">기존 요소에서 <xref:System.Windows.Controls.UserControl> <xref:System.Windows.Controls.Control> 파생되거나 구성에 의존하는 컨트롤입니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-182">Controls that derive from <xref:System.Windows.Controls.UserControl> or <xref:System.Windows.Controls.Control> rely upon composing existing elements.</span></span> <span data-ttu-id="3957b-183">많은 시나리오에서 상속되는 모든 개체가 <xref:System.Windows.FrameworkElement> <xref:System.Windows.Controls.ControlTemplate>에 있을 수 있으므로 이 솔루션은 허용 가능한 솔루션입니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-183">For many scenarios, this is an acceptable solution, because any object that inherits from <xref:System.Windows.FrameworkElement> can be in a <xref:System.Windows.Controls.ControlTemplate>.</span></span> <span data-ttu-id="3957b-184">그러나 컨트롤의 모양이 단순한 요소 컴퍼지션 이상의 기능을 필요로 하는 경우가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-184">However, there are times when a control's appearance requires more than the functionality of simple element composition.</span></span> <span data-ttu-id="3957b-185">이러한 시나리오에서는 구성 요소를 <xref:System.Windows.FrameworkElement> 기반으로 하는 것이 올바른 선택입니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-185">For these scenarios, basing a component on <xref:System.Windows.FrameworkElement> is the right choice.</span></span>

<span data-ttu-id="3957b-186">직접 렌더링 및 사용자 <xref:System.Windows.FrameworkElement>지정 요소 컴포지션의 두 가지 기본 구성 요소를 빌드하는 방법에는 두 가지가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-186">There are two standard methods for building <xref:System.Windows.FrameworkElement>-based components: direct rendering and custom element composition.</span></span> <span data-ttu-id="3957b-187">직접 렌더링에는 구성 <xref:System.Windows.UIElement.OnRender%2A> 요소 <xref:System.Windows.FrameworkElement> 시각적 <xref:System.Windows.Media.DrawingContext> 개체를 명시적으로 정의하는 메서드를 재정의하고 제공하는 작업이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-187">Direct rendering involves overriding the <xref:System.Windows.UIElement.OnRender%2A> method of <xref:System.Windows.FrameworkElement> and providing <xref:System.Windows.Media.DrawingContext> operations that explicitly define the component visuals.</span></span> <span data-ttu-id="3957b-188">이 방법은 및 <xref:System.Windows.Controls.Image> <xref:System.Windows.Controls.Border>에서 사용하는 메서드입니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-188">This is the method used by <xref:System.Windows.Controls.Image> and <xref:System.Windows.Controls.Border>.</span></span> <span data-ttu-id="3957b-189">사용자 지정 요소 컴포지션에는 형식의 <xref:System.Windows.Media.Visual> 개체를 사용하여 구성 요소의 모양을 구성합니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-189">Custom element composition involves using objects of type <xref:System.Windows.Media.Visual> to compose the appearance of your component.</span></span> <span data-ttu-id="3957b-190">예제는 [DrawingVisual 개체 사용](../graphics-multimedia/using-drawingvisual-objects.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="3957b-190">For an example, see [Using DrawingVisual Objects](../graphics-multimedia/using-drawingvisual-objects.md).</span></span> <span data-ttu-id="3957b-191"><xref:System.Windows.Controls.Primitives.Track>사용자 지정 요소 컴포지션을 사용하는 컨트롤의 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 예입니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-191"><xref:System.Windows.Controls.Primitives.Track> is an example of a control in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] that uses custom element composition.</span></span> <span data-ttu-id="3957b-192">직접 렌더링과 사용자 지정 요소 컴퍼지션을 같은 컨트롤에서 혼합하여 사용할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-192">It is also possible to mix direct rendering and custom element composition in the same control.</span></span>

#### <a name="benefits-of-deriving-from-frameworkelement"></a><span data-ttu-id="3957b-193">FrameworkElement에서 파생하는 이점</span><span class="sxs-lookup"><span data-stu-id="3957b-193">Benefits of Deriving from FrameworkElement</span></span>

<span data-ttu-id="3957b-194">다음 중 어느 <xref:System.Windows.FrameworkElement> 것이 적용되는지 에서 파생하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-194">Consider deriving from <xref:System.Windows.FrameworkElement> if any of the following apply:</span></span>

- <span data-ttu-id="3957b-195">단순한 요소 컴퍼지션에서 제공하는 기능 이상으로 컨트롤의 모양을 정확하게 제어하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-195">You want to have precise control over the appearance of your control beyond what is provided by simple element composition.</span></span>

- <span data-ttu-id="3957b-196">자체 렌더링 논리를 정의하여 컨트롤의 모양을 정의하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-196">You want to define the appearance of your control by defining your own render logic.</span></span>

- <span data-ttu-id="3957b-197">기존 요소를 가능한 것 이상으로 새로운 방식으로 <xref:System.Windows.Controls.UserControl> 구성하려고 합니다. <xref:System.Windows.Controls.Control></span><span class="sxs-lookup"><span data-stu-id="3957b-197">You want to compose existing elements in novel ways that go beyond what is possible with <xref:System.Windows.Controls.UserControl> and <xref:System.Windows.Controls.Control>.</span></span>

<a name="control_authoring_basics"></a>

## <a name="control-authoring-basics"></a><span data-ttu-id="3957b-198">컨트롤 제작 기본 사항</span><span class="sxs-lookup"><span data-stu-id="3957b-198">Control Authoring Basics</span></span>

<span data-ttu-id="3957b-199">앞에서 설명한 것처럼 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]의 가장 강력한 기능 중 하나는 컨트롤의 기본 속성 설정 이상으로 모양 및 동작을 변경하면서 사용자 지정 컨트롤을 만들지 않아도 되는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-199">As discussed earlier, one of the most powerful features of [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] is the ability to go beyond setting basic properties of a control to change its appearance and behavior, yet still not needing to create a custom control.</span></span> <span data-ttu-id="3957b-200">스타일 지정, 데이터 바인딩 및 트리거 기능은 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 속성 시스템 및 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 이벤트 시스템에 의해 가능합니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-200">The styling, data binding, and trigger features are made possible by the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] property system and the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] event system.</span></span> <span data-ttu-id="3957b-201">다음 섹션에서는 사용자 지정 컨트롤을 만드는 데 사용하는 모델에 관계없이 따라야 하는 몇 가지 방법을 설명합니다. 이에 따라 사용자 지정 컨트롤의 사용자는 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]에 포함된 컨트롤의 경우처럼 이러한 기능을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-201">The following sections describe some practices that you should follow, regardless of the model you use to create the custom control, so that users of your custom control can use these features just as they would for a control that is included with [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)].</span></span>

### <a name="use-dependency-properties"></a><span data-ttu-id="3957b-202">종속성 속성 사용</span><span class="sxs-lookup"><span data-stu-id="3957b-202">Use Dependency Properties</span></span>

<span data-ttu-id="3957b-203">속성이 종속성 속성인 경우 다음을 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-203">When a property is a dependency property, it is possible to do the following:</span></span>

- <span data-ttu-id="3957b-204">스타일에서 속성을 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-204">Set the property in a style.</span></span>

- <span data-ttu-id="3957b-205">속성을 데이터 소스에 바인딩합니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-205">Bind the property to a data source.</span></span>

- <span data-ttu-id="3957b-206">속성의 값으로 동적 리소스를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-206">Use a dynamic resource as the property's value.</span></span>

- <span data-ttu-id="3957b-207">속성에 애니메이션 효과를 줍니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-207">Animate the property.</span></span>

<span data-ttu-id="3957b-208">컨트롤의 속성이 이 기능을 지원하도록 하려면 종속성 속성으로 구현해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-208">If you want a property of your control to support any of this functionality, you should implement it as a dependency property.</span></span> <span data-ttu-id="3957b-209">다음 예제에서는 다음을 수행하여 `Value`라는 종속성 속성을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-209">The following example defines a dependency property named `Value` by doing the following:</span></span>

- <span data-ttu-id="3957b-210">필드로 <xref:System.Windows.DependencyProperty> 명명된 `ValueProperty` 식별자를 정의합니다. `public` `static` `readonly`</span><span class="sxs-lookup"><span data-stu-id="3957b-210">Define a <xref:System.Windows.DependencyProperty> identifier named `ValueProperty` as a `public` `static` `readonly` field.</span></span>

- <span data-ttu-id="3957b-211">을 호출하여 <xref:System.Windows.DependencyProperty.Register%2A?displayProperty=nameWithType>속성 이름을 속성 시스템에 등록하여 다음을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-211">Register the property name with the property system, by calling <xref:System.Windows.DependencyProperty.Register%2A?displayProperty=nameWithType>, to specify the following:</span></span>

  - <span data-ttu-id="3957b-212">속성의 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-212">The name of the property.</span></span>

  - <span data-ttu-id="3957b-213">속성의 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-213">The type of the property.</span></span>

  - <span data-ttu-id="3957b-214">속성을 소유하는 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-214">The type that owns the property.</span></span>

  - <span data-ttu-id="3957b-215">속성의 메타데이터입니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-215">The metadata for the property.</span></span> <span data-ttu-id="3957b-216">메타데이터에는 속성의 기본값, <xref:System.Windows.CoerceValueCallback> a <xref:System.Windows.PropertyChangedCallback>및 a가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-216">The metadata contains the property's default value, a <xref:System.Windows.CoerceValueCallback> and a <xref:System.Windows.PropertyChangedCallback>.</span></span>

- <span data-ttu-id="3957b-217">속성 `Value` `get` 및 `set` 접근자를 구현하여 종속성 속성을 등록하는 데 사용되는 이름과 동일한 이름의 CLR 래퍼 속성을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-217">Define a CLR wrapper property named `Value`, which is the same name that is used to register the dependency property, by implementing the property's `get` and `set` accessors.</span></span> <span data-ttu-id="3957b-218">`get` 및 `set` 접근자는 각각 호출하고 <xref:System.Windows.DependencyObject.GetValue%2A> <xref:System.Windows.DependencyObject.SetValue%2A> 각각 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-218">Note that the `get` and `set` accessors only call <xref:System.Windows.DependencyObject.GetValue%2A> and <xref:System.Windows.DependencyObject.SetValue%2A> respectively.</span></span> <span data-ttu-id="3957b-219">종속성 속성의 접근자는 클라이언트와 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 호출을 <xref:System.Windows.DependencyObject.GetValue%2A> <xref:System.Windows.DependencyObject.SetValue%2A> 우회할 수 있으므로 추가 논리를 포함하지 않는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-219">It is recommended that the accessors of dependency properties not contain additional logic because clients and [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] can bypass the accessors and call <xref:System.Windows.DependencyObject.GetValue%2A> and <xref:System.Windows.DependencyObject.SetValue%2A> directly.</span></span> <span data-ttu-id="3957b-220">예를 들어 속성이 데이터 소스에 바인딩되면 해당 속성의 `set` 접근자가 호출되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-220">For example, when a property is bound to a data source, the property's `set` accessor is not called.</span></span>  <span data-ttu-id="3957b-221">get 및 set 접근자에 추가 논리를 추가하는 <xref:System.Windows.ValidateValueCallback> <xref:System.Windows.CoerceValueCallback>대신 <xref:System.Windows.PropertyChangedCallback> 에서 를 사용하고 대리인은 에 응답하거나 변경될 때 값을 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-221">Instead of adding additional logic to the get and set accessors, use the <xref:System.Windows.ValidateValueCallback>, <xref:System.Windows.CoerceValueCallback>, and <xref:System.Windows.PropertyChangedCallback> delegates to respond to or check the value when it changes.</span></span>  <span data-ttu-id="3957b-222">이 콜백에 대한 자세한 내용은 [종속성 속성 콜백 및 유효성 검사](../advanced/dependency-property-callbacks-and-validation.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="3957b-222">For more information on these callbacks, see [Dependency Property Callbacks and Validation](../advanced/dependency-property-callbacks-and-validation.md).</span></span>

- <span data-ttu-id="3957b-223">명명된 `CoerceValue`에 <xref:System.Windows.CoerceValueCallback> 대한 메서드를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-223">Define a method for the <xref:System.Windows.CoerceValueCallback> named `CoerceValue`.</span></span> <span data-ttu-id="3957b-224">`CoerceValue`는 `Value`가 `MinValue`보다 크거나 같고 `MaxValue`보다 작거나 같도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-224">`CoerceValue` ensures that `Value` is greater or equal to `MinValue` and less than or equal to `MaxValue`.</span></span>

- <span data-ttu-id="3957b-225"><xref:System.Windows.PropertyChangedCallback>에 대한 메서드를 `OnValueChanged`정의합니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-225">Define a method for the <xref:System.Windows.PropertyChangedCallback>, named `OnValueChanged`.</span></span> <span data-ttu-id="3957b-226">`OnValueChanged`을 <xref:System.Windows.RoutedPropertyChangedEventArgs%601> 사용하여 개체를 만들고 `ValueChanged` 라우트된 이벤트를 발생시킬 준비를 합니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-226">`OnValueChanged` creates a <xref:System.Windows.RoutedPropertyChangedEventArgs%601> object and prepares to raise the `ValueChanged` routed event.</span></span> <span data-ttu-id="3957b-227">라우트된 이벤트는 다음 섹션에서 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-227">Routed events are discussed in the next section.</span></span>

[!code-csharp[UserControlNumericUpDown#DependencyProperty](~/samples/snippets/csharp/VS_Snippets_Wpf/UserControlNumericUpDown/CSharp/NumericUpDown.xaml.cs#dependencyproperty)]
[!code-vb[UserControlNumericUpDown#DependencyProperty](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UserControlNumericUpDown/visualbasic/numericupdown.xaml.vb#dependencyproperty)]

<span data-ttu-id="3957b-228">자세한 내용은 [사용자 지정 종속성 속성](../advanced/custom-dependency-properties.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="3957b-228">For more information, see [Custom Dependency Properties](../advanced/custom-dependency-properties.md).</span></span>

### <a name="use-routed-events"></a><span data-ttu-id="3957b-229">라우트된 이벤트 사용</span><span class="sxs-lookup"><span data-stu-id="3957b-229">Use Routed Events</span></span>

<span data-ttu-id="3957b-230">종속성 속성이 추가 기능을 사용하여 CLR 속성의 개념을 확장하는 것처럼 라우트된 이벤트는 표준 CLR 이벤트의 개념을 확장합니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-230">Just as dependency properties extend the notion of CLR properties with additional functionality, routed events extend the notion of standard CLR events.</span></span> <span data-ttu-id="3957b-231">라우트된 이벤트는 다음 동작을 지원하기 때문에 새로운 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 컨트롤을 만들 때 이벤트를 라우트된 이벤트로 구현하는 것도 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-231">When you create a new [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] control, it is also good practice to implement your event as a routed event because a routed event supports the following behavior:</span></span>

- <span data-ttu-id="3957b-232">이벤트는 여러 컨트롤의 부모에서 처리될 수 ​​있습니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-232">Events can be handled on a parent of multiple controls.</span></span> <span data-ttu-id="3957b-233">이벤트가 버블링 이벤트인 경우 요소 트리의 단일 부모가 이벤트를 구독할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-233">If an event is a bubbling event, a single parent in the element tree can subscribe to the event.</span></span> <span data-ttu-id="3957b-234">그런 다음 애플리케이션 작성자는 하나의 처리기를 사용하여 여러 컨트롤의 이벤트에 응답할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-234">Then application authors can use one handler to respond to the event of multiple controls.</span></span> <span data-ttu-id="3957b-235">예를 들어 컨트롤이 a에 <xref:System.Windows.Controls.ListBox> 포함되어 <xref:System.Windows.DataTemplate>있기 때문에) 각 항목의 일부인 경우 응용 프로그램 개발자는 <xref:System.Windows.Controls.ListBox>에서 컨트롤의 이벤트에 대한 이벤트 처리기를 정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-235">For example, if your control is a part of each item in a <xref:System.Windows.Controls.ListBox> (because it is included in a <xref:System.Windows.DataTemplate>), the application developer can define the event handler for your control's event on the <xref:System.Windows.Controls.ListBox>.</span></span> <span data-ttu-id="3957b-236">이벤트가 컨트롤 중 하나에서 발생할 때마다 이벤트 처리기가 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-236">Whenever the event occurs on any of the controls, the event handler is called.</span></span>

- <span data-ttu-id="3957b-237">응용 프로그램 개발자가 스타일 <xref:System.Windows.EventSetter>내에서 이벤트의 처리기를 지정할 수 있는 는 에서 라우트된 이벤트를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-237">Routed events can be used in an <xref:System.Windows.EventSetter>, which enables application developers to specify the handler of an event within a style.</span></span>

- <span data-ttu-id="3957b-238">라우트된 이벤트를 <xref:System.Windows.EventTrigger>사용할 수 있습니다. [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]</span><span class="sxs-lookup"><span data-stu-id="3957b-238">Routed events can be used in an <xref:System.Windows.EventTrigger>, which is useful for animating properties by using [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)].</span></span> <span data-ttu-id="3957b-239">자세한 내용은 [애니메이션 개요를](../graphics-multimedia/animation-overview.md)참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="3957b-239">For more information, see [Animation Overview](../graphics-multimedia/animation-overview.md).</span></span>

<span data-ttu-id="3957b-240">다음 예제는 다음을 수행하여 라우트된 이벤트를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-240">The following example defines a routed event by doing the following:</span></span>

- <span data-ttu-id="3957b-241">필드로 <xref:System.Windows.RoutedEvent> 명명된 `ValueChangedEvent` 식별자를 정의합니다. `public` `static` `readonly`</span><span class="sxs-lookup"><span data-stu-id="3957b-241">Define a <xref:System.Windows.RoutedEvent> identifier named `ValueChangedEvent` as a `public` `static` `readonly` field.</span></span>

- <span data-ttu-id="3957b-242">메서드를 호출하여 라우트된 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A?displayProperty=nameWithType> 이벤트를 등록합니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-242">Register the routed event by calling the <xref:System.Windows.EventManager.RegisterRoutedEvent%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="3957b-243">이 예제는 호출할 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>때 다음 정보를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-243">The example specifies the following information when it calls <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>:</span></span>

  - <span data-ttu-id="3957b-244">이벤트의 이름은 `ValueChanged`입니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-244">The name of the event is `ValueChanged`.</span></span>

  - <span data-ttu-id="3957b-245">라우팅 전략은 <xref:System.Windows.RoutingStrategy.Bubble>소스의 이벤트 처리기(이벤트를 발생시키는 개체)가 먼저 호출된 다음 가장 가까운 상위 요소의 이벤트 처리기로 시작하여 소스의 부모 요소에 대한 이벤트 처리기가 연속적으로 호출된다는 것을 의미합니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-245">The routing strategy is <xref:System.Windows.RoutingStrategy.Bubble>, which means that an event handler on the source (the object that raises the event) is called first, and then event handlers on the source's parent elements are called in succession, starting with the event handler on the closest parent element.</span></span>

  - <span data-ttu-id="3957b-246">이벤트 처리기의 형식은 <xref:System.Windows.RoutedPropertyChangedEventHandler%601>type으로 <xref:System.Decimal> 생성됩니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-246">The type of the event handler is <xref:System.Windows.RoutedPropertyChangedEventHandler%601>, constructed with a <xref:System.Decimal> type.</span></span>

  - <span data-ttu-id="3957b-247">이벤트의 소유 형식은 `NumericUpDown`입니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-247">The owning type of the event is `NumericUpDown`.</span></span>

- <span data-ttu-id="3957b-248">`ValueChanged`라는 공용 이벤트를 선언하고 이벤트 접근자 선언을 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-248">Declare a public event named `ValueChanged` and includes event-accessor declarations.</span></span> <span data-ttu-id="3957b-249">이 예제는 `add` 접근자 선언및 <xref:System.Windows.UIElement.RemoveHandler%2A> `remove` 접근자 선언에서 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 이벤트 서비스를 사용하여 호출합니다. <xref:System.Windows.UIElement.AddHandler%2A></span><span class="sxs-lookup"><span data-stu-id="3957b-249">The example calls <xref:System.Windows.UIElement.AddHandler%2A> in the `add` accessor declaration and <xref:System.Windows.UIElement.RemoveHandler%2A> in the `remove` accessor declaration to use the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] event services.</span></span>

- <span data-ttu-id="3957b-250">`ValueChanged` 이벤트를 발생시키는 `OnValueChanged`라는 보호된 가상 메서드를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-250">Create a protected, virtual method named `OnValueChanged` that raises the `ValueChanged` event.</span></span>

[!code-csharp[UserControlNumericUpDown#RoutedEvent](~/samples/snippets/csharp/VS_Snippets_Wpf/UserControlNumericUpDown/CSharp/NumericUpDown.xaml.cs#routedevent)]
[!code-vb[UserControlNumericUpDown#RoutedEvent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UserControlNumericUpDown/visualbasic/numericupdown.xaml.vb#routedevent)]

<span data-ttu-id="3957b-251">자세한 내용은 [라우트된 이벤트 개요](../advanced/routed-events-overview.md) 및 [사용자 지정 라우트된 이벤트 만들기](../advanced/how-to-create-a-custom-routed-event.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="3957b-251">For more information, see [Routed Events Overview](../advanced/routed-events-overview.md) and [Create a Custom Routed Event](../advanced/how-to-create-a-custom-routed-event.md).</span></span>

### <a name="use-binding"></a><span data-ttu-id="3957b-252">바인딩 사용</span><span class="sxs-lookup"><span data-stu-id="3957b-252">Use Binding</span></span>

<span data-ttu-id="3957b-253">해당 논리에서 컨트롤의 UI를 분리하려면 데이터 바인딩 사용을 고려합니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-253">To decouple the UI of your control from its logic, consider using data binding.</span></span> <span data-ttu-id="3957b-254">을 사용하여 컨트롤의 모양을 정의하는 경우 특히 <xref:System.Windows.Controls.ControlTemplate>중요합니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-254">This is particularly important if you define the appearance of your control by using a <xref:System.Windows.Controls.ControlTemplate>.</span></span> <span data-ttu-id="3957b-255">데이터 바인딩을 사용하면 코드에서 UI의 특정 부분을 참조하지 않아도 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-255">When you use data binding, you might be able to eliminate the need to reference specific parts of the UI from the code.</span></span> <span data-ttu-id="3957b-256">코드가 에 있는 <xref:System.Windows.Controls.ControlTemplate> 요소를 <xref:System.Windows.Controls.ControlTemplate> 참조하고 <xref:System.Windows.Controls.ControlTemplate> 변경될 때 참조된 요소를 새 <xref:System.Windows.Controls.ControlTemplate>에 포함해야 하기 때문에 에 있는 요소를 참조하지 않는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-256">It's a good idea to avoid referencing elements that are in the <xref:System.Windows.Controls.ControlTemplate> because when the code references elements that are in the <xref:System.Windows.Controls.ControlTemplate> and the <xref:System.Windows.Controls.ControlTemplate> is changed, the referenced element needs to be included in the new <xref:System.Windows.Controls.ControlTemplate>.</span></span>

<span data-ttu-id="3957b-257">다음 예제에서는 <xref:System.Windows.Controls.TextBlock> `NumericUpDown` 컨트롤의 이름을 지정 하 고 코드에서 이름으로 텍스트 상자를 참조 하는 컨트롤을 업데이트 합니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-257">The following example updates the <xref:System.Windows.Controls.TextBlock> of the `NumericUpDown` control, assigning a name to it and referencing the textbox by name in code.</span></span>

[!code-xaml[UserControlNumericUpDownSimple#UIRefMarkup](~/samples/snippets/csharp/VS_Snippets_Wpf/UserControlNumericUpDownSimple/CSharp/NumericUpDown.xaml#uirefmarkup)]

[!code-csharp[UserControlNumericUpDownSimple#UIRefCode](~/samples/snippets/csharp/VS_Snippets_Wpf/UserControlNumericUpDownSimple/CSharp/NumericUpDown.xaml.cs#uirefcode)]
[!code-vb[UserControlNumericUpDownSimple#UIRefCode](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UserControlNumericUpDownSimple/VisualBasic/NumericUpDown.xaml.vb#uirefcode)]

<span data-ttu-id="3957b-258">다음 예제에서는 바인딩을 사용하여 동일한 작업을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-258">The following example uses binding to accomplish the same thing.</span></span>

[!code-xaml[UserControlNumericUpDown#Binding](~/samples/snippets/csharp/VS_Snippets_Wpf/UserControlNumericUpDown/CSharp/NumericUpDown.xaml#binding)]

<span data-ttu-id="3957b-259">데이터 바인딩에 대한 자세한 내용은 [데이터 바인딩 개요](../../../desktop-wpf/data/data-binding-overview.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="3957b-259">For more information about data binding, see [Data Binding Overview](../../../desktop-wpf/data/data-binding-overview.md).</span></span>

### <a name="design-for-designers"></a><span data-ttu-id="3957b-260">디자이너를 위한 디자인</span><span class="sxs-lookup"><span data-stu-id="3957b-260">Design for Designers</span></span>

<span data-ttu-id="3957b-261">비주얼 스튜디오용 WPF 디자이너에서 사용자 지정 WPF 컨트롤에 대한 지원을 받으려면(예: 속성 창으로 속성 편집) 다음 지침을 따르십시오.</span><span class="sxs-lookup"><span data-stu-id="3957b-261">To receive support for custom WPF controls in the WPF Designer for Visual Studio (for example, property editing with the Properties window), follow these guidelines.</span></span>  <span data-ttu-id="3957b-262">WPF 디자이너를 위한 개발에 대한 자세한 내용은 [Visual Studio의 디자인 XAML을](/visualstudio/xaml-tools/designing-xaml-in-visual-studio)참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="3957b-262">For more information on developing for the WPF Designer, see [Design XAML in Visual Studio](/visualstudio/xaml-tools/designing-xaml-in-visual-studio).</span></span>

#### <a name="dependency-properties"></a><span data-ttu-id="3957b-263">종속성 속성</span><span class="sxs-lookup"><span data-stu-id="3957b-263">Dependency Properties</span></span>

<span data-ttu-id="3957b-264">앞에서 설명한 대로 `get` `set` "종속성 속성 사용"에서 CLR 및 접근자를 구현해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-264">Be sure to implement CLR `get` and `set` accessors as described earlier, in "Use Dependency Properties."</span></span> <span data-ttu-id="3957b-265">디자이너는 래퍼를 사용하여 종속성 속성의 존재를 감지할 수 있지만 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 및 컨트롤의 클라이언트와 마찬가지로 속성을 가져오거나 설정할 때 접근자를 호출할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-265">Designers may use the wrapper to detect the presence of a dependency property, but they, like [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] and clients of the control, are not required to call the accessors when getting or setting the property.</span></span>

#### <a name="attached-properties"></a><span data-ttu-id="3957b-266">연결된 속성</span><span class="sxs-lookup"><span data-stu-id="3957b-266">Attached Properties</span></span>

<span data-ttu-id="3957b-267">다음 지침을 사용하여 사용자 지정 컨트롤에서 연결된 속성을 구현해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-267">You should implement attached properties on custom controls using the following guidelines:</span></span>

- <span data-ttu-id="3957b-268">`public` `Property` <xref:System.Windows.DependencyProperty.RegisterAttached%2A> 메서드를 사용하여 만든 속성 Name 형식이 있습니다. *PropertyName* `static` `readonly` <xref:System.Windows.DependencyProperty></span><span class="sxs-lookup"><span data-stu-id="3957b-268">Have a `public` `static` `readonly` <xref:System.Windows.DependencyProperty> of the form *PropertyName*`Property` that was creating using the <xref:System.Windows.DependencyProperty.RegisterAttached%2A> method.</span></span> <span data-ttu-id="3957b-269">전달되는 <xref:System.Windows.DependencyProperty.RegisterAttached%2A> 속성 이름은 *PropertyName*을 일치해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-269">The property name that is passed to <xref:System.Windows.DependencyProperty.RegisterAttached%2A> must match *PropertyName*.</span></span>

- <span data-ttu-id="3957b-270">`Set`*PropertyName* 및 `Get`*PropertyName*이라는 `public` `static` CLR 메서드 쌍을 구현합니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-270">Implement a pair of `public` `static` CLR methods named `Set`*PropertyName* and `Get`*PropertyName*.</span></span> <span data-ttu-id="3957b-271">두 메서드 모두 첫 번째 <xref:System.Windows.DependencyProperty> 인수에서 파생된 클래스를 수락해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-271">Both methods should accept a class derived from <xref:System.Windows.DependencyProperty> as their first argument.</span></span> <span data-ttu-id="3957b-272">`Set`*PropertyName* 메서드는 그 형식이 속성의 등록된 데이터 형식과 일치하는 인수도 수락합니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-272">The `Set`*PropertyName* method also accepts an argument whose type matches the registered data type for the property.</span></span> <span data-ttu-id="3957b-273">`Get`*PropertyName* 메서드는 동일한 형식의 값을 반환해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-273">The `Get`*PropertyName* method should return a value of the same type.</span></span> <span data-ttu-id="3957b-274">`Set`*PropertyName* 메서드가 누락된 경우 속성이 읽기 전용으로 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-274">If the `Set`*PropertyName* method is missing, the property is marked read-only.</span></span>

- <span data-ttu-id="3957b-275">`Set`*PropertyName* `Get`및 *PropertyName* 대상 <xref:System.Windows.DependencyObject.GetValue%2A> 종속성 개체에 대 한 메서드와 <xref:System.Windows.DependencyObject.SetValue%2A> 메서드에 직접 라우팅 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-275">`Set` *PropertyName* and `Get`*PropertyName* must route directly to the <xref:System.Windows.DependencyObject.GetValue%2A> and <xref:System.Windows.DependencyObject.SetValue%2A> methods on the target dependency object, respectively.</span></span> <span data-ttu-id="3957b-276">디자이너는 메서드 래퍼를 통해 호출하거나 대상 종속성 개체를 직접 호출하여 연결된 속성에 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-276">Designers may access the attached property by calling through the method wrapper or making a direct call to the target dependency object.</span></span>

<span data-ttu-id="3957b-277">연결된 속성에 대한 자세한 내용은 [연결된 속성 개요](../advanced/attached-properties-overview.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="3957b-277">For more information on attached properties, see [Attached Properties Overview](../advanced/attached-properties-overview.md).</span></span>

### <a name="define-and-use-shared-resources"></a><span data-ttu-id="3957b-278">공유 리소스 정의 및 사용</span><span class="sxs-lookup"><span data-stu-id="3957b-278">Define and Use Shared Resources</span></span>

<span data-ttu-id="3957b-279">애플리케이션과 동일한 어셈블리에 컨트롤을 포함하거나 여러 애플리케이션에서 사용할 수 있는 별도의 어셈블리에 컨트롤을 패키지화할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-279">You can include your control in the same assembly as your application, or you can package your control in a separate assembly that can be used in multiple applications.</span></span> <span data-ttu-id="3957b-280">대부분, 이 항목에서 설명하는 정보는 사용하는 메서드에 관계없이 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-280">For the most part, the information discussed in this topic applies regardless of the method you use.</span></span>  <span data-ttu-id="3957b-281">그러나 주목할 만한 차이점이 하나 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-281">There is one difference worth noting, however.</span></span>  <span data-ttu-id="3957b-282">애플리케이션과 동일한 어셈블리에 컨트롤을 배치하면 App.xaml 파일에 전역 리소스를 자유롭게 추가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-282">When you put a control in the same assembly as an application, you are free to add global resources to the App.xaml file.</span></span> <span data-ttu-id="3957b-283">그러나 컨트롤만 포함하는 어셈블리에는 <xref:System.Windows.Application> 연결된 개체가 없으므로 App.xaml 파일을 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-283">But an assembly that contains only controls does not have an <xref:System.Windows.Application> object associated with it, so an App.xaml file is not available.</span></span>

<span data-ttu-id="3957b-284">애플리케이션이 리소스를 찾을 때 다음 순서로 세 가지 수준을 조사합니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-284">When an application looks for a resource, it looks at three levels in the following order:</span></span>

1. <span data-ttu-id="3957b-285">요소 수준</span><span class="sxs-lookup"><span data-stu-id="3957b-285">The element level.</span></span>

   <span data-ttu-id="3957b-286">시스템이 리소스를 참조하는 요소로 시작한 다음 루트 요소에 도달할 때까지 논리 부모 등의 리소스를 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-286">The system starts with the element that references the resource and then searches resources of the logical parent and so forth until the root element is reached.</span></span>

2. <span data-ttu-id="3957b-287">애플리케이션 수준</span><span class="sxs-lookup"><span data-stu-id="3957b-287">The application level.</span></span>

   <span data-ttu-id="3957b-288">개체에 의해 <xref:System.Windows.Application> 정의된 리소스입니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-288">Resources defined by the <xref:System.Windows.Application> object.</span></span>

3. <span data-ttu-id="3957b-289">테마 수준</span><span class="sxs-lookup"><span data-stu-id="3957b-289">The theme level.</span></span>

   <span data-ttu-id="3957b-290">테마 수준 사전은 Themes라는 하위 폴더에 저장됩니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-290">Theme-level dictionaries are stored in a subfolder named Themes.</span></span>  <span data-ttu-id="3957b-291">Themes 폴더의 파일은 테마에 해당합니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-291">The files in the Themes folder correspond to themes.</span></span>  <span data-ttu-id="3957b-292">예를 들어 Aero.NormalColor.xaml, Luna.NormalColor.xaml, Royale.NormalColor.xaml 등이 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-292">For example, you might have Aero.NormalColor.xaml, Luna.NormalColor.xaml, Royale.NormalColor.xaml, and so on.</span></span>  <span data-ttu-id="3957b-293">generic.xaml이라는 파일이 있을 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-293">You can also have a file named generic.xaml.</span></span>  <span data-ttu-id="3957b-294">시스템이 테마 수준에서 리소스를 찾으면 먼저 테마별 파일에서 찾은 다음 generic.xaml에서 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-294">When the system looks for a resource at the themes level, it first looks for it in the theme-specific file and then looks for it in generic.xaml.</span></span>

<span data-ttu-id="3957b-295">컨트롤이 애플리케이션과 별도의 어셈블리에 있을 때는 전역 리소스를 요소 수준이나 테마 수준에 배치해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-295">When your control is in an assembly that is separate from the application, you must put your global resources at the element level or at the theme level.</span></span> <span data-ttu-id="3957b-296">두 가지 방법 모두 장점이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-296">Both methods have their advantages.</span></span>

#### <a name="defining-resources-at-the-element-level"></a><span data-ttu-id="3957b-297">요소 수준에서 리소스 정의</span><span class="sxs-lookup"><span data-stu-id="3957b-297">Defining Resources at the Element Level</span></span>

<span data-ttu-id="3957b-298">사용자 지정 리소스 사전을 만들고 컨트롤의 리소스 사전과 병합하여 요소 수준에서 공유 리소스를 정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-298">You can define shared resources at the element level by creating a custom resource dictionary and merging it with your control's resource dictionary.</span></span>  <span data-ttu-id="3957b-299">이 메서드를 사용하면 리소스 파일의 이름을 원하는 대로 지정할 수 있으며 컨트롤과 동일한 폴더에 배치할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-299">When you use this method, you can name your resource file anything you want, and it can be in the same folder as your controls.</span></span> <span data-ttu-id="3957b-300">요소 수준의 리소스는 간단한 문자열을 키로 사용할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-300">Resources at the element level can also use simple strings as keys.</span></span> <span data-ttu-id="3957b-301">다음 예제는 <xref:System.Windows.Media.LinearGradientBrush> Dictionary1.xaml이라는 리소스 파일을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-301">The following example creates a <xref:System.Windows.Media.LinearGradientBrush> resource file named Dictionary1.xaml.</span></span>

[!code-xaml[SharedResources#1](~/samples/snippets/csharp/VS_Snippets_Wpf/SharedResources/CS/Dictionary1.xaml#1)]

<span data-ttu-id="3957b-302">사전을 정의한 후에는 컨트롤의 리소스 사전과 병합해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-302">Once you have defined your dictionary, you need to merge it with your control's resource dictionary.</span></span>  <span data-ttu-id="3957b-303">[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] 또는 코드를 사용하여 이 작업을 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-303">You can do this by using [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] or code.</span></span>

<span data-ttu-id="3957b-304">다음 예제는 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]을 사용하여 리소스 사전을 병합합니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-304">The following example merges a resource dictionary by using [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)].</span></span>

[!code-xaml[SharedResources#2](~/samples/snippets/csharp/VS_Snippets_Wpf/SharedResources/CS/ShapeResizer.xaml#2)]

<span data-ttu-id="3957b-305">이 방법의 단점은 객체를 참조할 <xref:System.Windows.ResourceDictionary> 때마다 개체가 생성된다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-305">The disadvantage to this approach is that a <xref:System.Windows.ResourceDictionary> object is created each time you reference it.</span></span>  <span data-ttu-id="3957b-306">예를 들어 라이브러리에 10개의 사용자 지정 컨트롤이 있고 XAML을 사용하여 각 컨트롤에 대한 공유 <xref:System.Windows.ResourceDictionary> 리소스 사전을 병합하는 경우 10개의 동일한 개체를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-306">For example, if you have 10 custom controls in your library and merge the shared resource dictionaries for each control by using XAML, you create 10 identical <xref:System.Windows.ResourceDictionary> objects.</span></span>  <span data-ttu-id="3957b-307">코드에서 리소스를 병합 하고 결과 <xref:System.Windows.ResourceDictionary>반환 하는 정적 클래스를 만들어이 작업을 방지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-307">You can avoid this by creating a static class that merges the resources in code and returns the resulting <xref:System.Windows.ResourceDictionary>.</span></span>

<span data-ttu-id="3957b-308">다음 예제는 공유 <xref:System.Windows.ResourceDictionary>를 반환 하는 클래스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-308">The following example creates a class that returns a shared <xref:System.Windows.ResourceDictionary>.</span></span>

[!code-csharp[SharedResources#3](~/samples/snippets/csharp/VS_Snippets_Wpf/SharedResources/CS/SharedDictionaryManager.cs#3)]

<span data-ttu-id="3957b-309">다음 예제에서는 공유 리소스를 `InitializeComponent`를 호출하기 전에 컨트롤의 생성자에 있는 사용자 지정 컨트롤의 리소스와 병합합니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-309">The following example merges the shared resource with the resources of a custom control in the control's constructor before it calls `InitializeComponent`.</span></span>  <span data-ttu-id="3957b-310">는 `SharedDictionaryManager.SharedDictionary` 정적 속성이므로 <xref:System.Windows.ResourceDictionary> 한 번만 만들어집니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-310">Because the `SharedDictionaryManager.SharedDictionary` is a static property, the <xref:System.Windows.ResourceDictionary> is created only once.</span></span> <span data-ttu-id="3957b-311">`InitializeComponent`가 호출되기 전에 리소스 사전이 병합되었기 때문에 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] 파일의 컨트롤에서 리소스를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-311">Because the resource dictionary was merged before `InitializeComponent` was called, the resources are available to the control in its [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] file.</span></span>

[!code-csharp[SharedResources#4](~/samples/snippets/csharp/VS_Snippets_Wpf/SharedResources/CS/ShapeResizer.xaml.cs#4)]

#### <a name="defining-resources-at-the-theme-level"></a><span data-ttu-id="3957b-312">테마 수준에서 리소스 정의</span><span class="sxs-lookup"><span data-stu-id="3957b-312">Defining Resources at the Theme Level</span></span>

[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]<span data-ttu-id="3957b-313">를 사용하면 다양한 Windows 테마를 위한 리소스를 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-313">enables you to create resources for different Windows themes.</span></span>  <span data-ttu-id="3957b-314">컨트롤 작성자는 특정 테마의 리소스를 정의하여 사용 중인 테마에 따라 컨트롤의 모양을 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-314">As a control author, you can define a resource for a specific theme to change your control's appearance depending on what theme is in use.</span></span> <span data-ttu-id="3957b-315">예를 들어 Windows 클래식 <xref:System.Windows.Controls.Button> 테마(Windows 2000의 기본 테마)의 모양은 각 <xref:System.Windows.Controls.Button> 테마마다 다른 <xref:System.Windows.Controls.Button> <xref:System.Windows.Controls.ControlTemplate> 테마를 사용하기 때문에 Windows Luna 테마(Windows XP의 기본 테마)와 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-315">For example, the appearance of a <xref:System.Windows.Controls.Button> in the Windows Classic theme (the default theme for Windows 2000) differs from a <xref:System.Windows.Controls.Button> in the Windows Luna theme (the default theme for Windows XP) because the <xref:System.Windows.Controls.Button> uses a different <xref:System.Windows.Controls.ControlTemplate> for each theme.</span></span>

<span data-ttu-id="3957b-316">테마와 관련된 리소스는 특정 파일 이름의 리소스 사전에 보관됩니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-316">Resources that are specific to a theme are kept in a resource dictionary with a specific file name.</span></span> <span data-ttu-id="3957b-317">이러한 파일은 컨트롤이 포함된 폴더의 하위 폴더인 `Themes`라는 폴더에 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-317">These files must be in a folder named `Themes` that is a subfolder of the folder that contains the control.</span></span> <span data-ttu-id="3957b-318">다음 표에는 각 파일과 관련된 리소스 사전 파일과 테마가 나와 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-318">The following table lists the resource dictionary files and the theme that is associated with each file:</span></span>

|<span data-ttu-id="3957b-319">리소스 사전 파일 이름</span><span class="sxs-lookup"><span data-stu-id="3957b-319">Resource dictionary file name</span></span>|<span data-ttu-id="3957b-320">Windows 테마</span><span class="sxs-lookup"><span data-stu-id="3957b-320">Windows theme</span></span>|
|-----------------------------------|-------------------|
|`Classic.xaml`|<span data-ttu-id="3957b-321">Windows XP의 고전 Windows 9x/2000 모양</span><span class="sxs-lookup"><span data-stu-id="3957b-321">Classic Windows 9x/2000 look on Windows XP</span></span>|
|`Luna.NormalColor.xaml`|<span data-ttu-id="3957b-322">Windows XP의 기본 파란색 테마</span><span class="sxs-lookup"><span data-stu-id="3957b-322">Default blue theme on Windows XP</span></span>|
|`Luna.Homestead.xaml`|<span data-ttu-id="3957b-323">Windows XP의 올리브색 테마</span><span class="sxs-lookup"><span data-stu-id="3957b-323">Olive theme on Windows XP</span></span>|
|`Luna.Metallic.xaml`|<span data-ttu-id="3957b-324">Windows XP의 은색 테마</span><span class="sxs-lookup"><span data-stu-id="3957b-324">Silver theme on Windows XP</span></span>|
|`Royale.NormalColor.xaml`|<span data-ttu-id="3957b-325">Windows XP Media Center Edition의 기본 테마</span><span class="sxs-lookup"><span data-stu-id="3957b-325">Default theme on Windows XP Media Center Edition</span></span>|
|`Aero.NormalColor.xaml`|<span data-ttu-id="3957b-326">Windows Vista의 기본 테마</span><span class="sxs-lookup"><span data-stu-id="3957b-326">Default theme on Windows Vista</span></span>|

<span data-ttu-id="3957b-327">모든 테마에 대해 리소스를 정의할 필요는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-327">You do not need to define a resource for every theme.</span></span> <span data-ttu-id="3957b-328">특정 테마에 대해 리소스가 정의되지 않은 경우 컨트롤이 리소스에 대해 `Classic.xaml`을 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-328">If a resource is not defined for a specific theme, then the control checks `Classic.xaml` for the resource.</span></span> <span data-ttu-id="3957b-329">현재 테마에 해당하는 파일 또는 `Classic.xaml`에 리소스가 정의되지 않은 경우 컨트롤이 `generic.xaml`이라는 리소스 사전 파일에 있는 제네릭 리소스를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-329">If the resource is not defined in the file that corresponds to the current theme or in `Classic.xaml`, the control uses the generic resource, which is in a resource dictionary file named `generic.xaml`.</span></span>  <span data-ttu-id="3957b-330">`generic.xaml` 파일은 테마별 리소스 사전 파일과 같은 폴더에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-330">The `generic.xaml` file is located in the same folder as the theme-specific resource dictionary files.</span></span> <span data-ttu-id="3957b-331">`generic.xaml`은 특정 Windows 테마에 해당하지 않지만 여전히 테마 수준의 사전입니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-331">Although `generic.xaml` does not correspond to a specific Windows theme, it is still a theme-level dictionary.</span></span>

<span data-ttu-id="3957b-332">테마 및 UI 자동화 지원 샘플이 있는 [C#](https://github.com/dotnet/docs/tree/master/samples/snippets/csharp/VS_Snippets_Wpf/CustomControlNumericUpDown/CSharp) 또는 [Visual Basic](https://github.com/dotnet/docs/tree/master/samples/snippets/visualbasic/VS_Snippets_Wpf/CustomControlNumericUpDown/visualbasic) NumericUpDown `NumericUpDown` 사용자 지정 컨트롤에는 컨트롤에 대한 두 가지 리소스 사전이 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-332">The [C#](https://github.com/dotnet/docs/tree/master/samples/snippets/csharp/VS_Snippets_Wpf/CustomControlNumericUpDown/CSharp) or [Visual Basic](https://github.com/dotnet/docs/tree/master/samples/snippets/visualbasic/VS_Snippets_Wpf/CustomControlNumericUpDown/visualbasic) NumericUpDown custom control with theme and UI automation support sample contains two resource dictionaries for the `NumericUpDown` control: one is in generic.xaml, and the other is in Luna.NormalColor.xaml.</span></span>

<span data-ttu-id="3957b-333">테마별 리소스 <xref:System.Windows.Controls.ControlTemplate> 사전 파일에 를 넣을 때 컨트롤에 대한 정적 생성자(정적 생성자)를 만들고 다음 예제와 같이 에 <xref:System.Windows.DependencyProperty.OverrideMetadata%28System.Type%2CSystem.Windows.PropertyMetadata%29> 메서드를 <xref:System.Windows.FrameworkElement.DefaultStyleKey%2A>호출해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-333">When you put a <xref:System.Windows.Controls.ControlTemplate> in any of the theme-specific resource dictionary files, you must create a static constructor for your control and call the <xref:System.Windows.DependencyProperty.OverrideMetadata%28System.Type%2CSystem.Windows.PropertyMetadata%29> method on the <xref:System.Windows.FrameworkElement.DefaultStyleKey%2A>, as shown in the following example.</span></span>

[!code-csharp[CustomControlNumericUpDownOneProject#StaticConstructor](~/samples/snippets/csharp/VS_Snippets_Wpf/CustomControlNumericUpDownOneProject/CSharp/NumericUpDown.cs#staticconstructor)]
[!code-vb[CustomControlNumericUpDownOneProject#StaticConstructor](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CustomControlNumericUpDownOneProject/visualbasic/numericupdown.vb#staticconstructor)]

##### <a name="defining-and-referencing-keys-for-theme-resources"></a><span data-ttu-id="3957b-334">테마 리소스에 대한 키 정의 및 참조</span><span class="sxs-lookup"><span data-stu-id="3957b-334">Defining and Referencing Keys for Theme Resources</span></span>

<span data-ttu-id="3957b-335">요소 레벨에서 리소스를 정의할 때 문자열을 키로 지정하고 문자열을 통해 리소스에 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-335">When you define a resource at the element level, you can assign a string as its key and access the resource via the string.</span></span> <span data-ttu-id="3957b-336">테마 수준에서 리소스를 정의할 때는 을 <xref:System.Windows.ComponentResourceKey> 키로 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-336">When you define a resource at the theme level, you must use a <xref:System.Windows.ComponentResourceKey> as the key.</span></span>  <span data-ttu-id="3957b-337">다음 예제에서는 generic.xaml에서 리소스를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-337">The following example defines a resource in generic.xaml.</span></span>

[!code-xaml[ThemeResourcesControlLibrary#5](~/samples/snippets/csharp/VS_Snippets_Wpf/ThemeResourcesControlLibrary/CS/Themes/generic.xaml#5)]

<span data-ttu-id="3957b-338">다음 예제는 를 <xref:System.Windows.ComponentResourceKey> 키로 지정하여 리소스를 참조합니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-338">The following example references the resource by specifying the <xref:System.Windows.ComponentResourceKey> as the key.</span></span>

[!code-xaml[ThemeResourcesControlLibrary#6](~/samples/snippets/csharp/VS_Snippets_Wpf/ThemeResourcesControlLibrary/CS/NumericUpDown.xaml#6)]

##### <a name="specifying-the-location-of-theme-resources"></a><span data-ttu-id="3957b-339">테마 리소스의 위치 지정</span><span class="sxs-lookup"><span data-stu-id="3957b-339">Specifying the Location of Theme Resources</span></span>

<span data-ttu-id="3957b-340">컨트롤에 대한 리소스를 찾으려면 호스팅 애플리케이션이 어셈블리에 컨트롤 관련 리소스가 있는지 알아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-340">To find the resources for a control, the hosting application needs to know that the assembly contains control-specific resources.</span></span> <span data-ttu-id="3957b-341">컨트롤을 포함하는 <xref:System.Windows.ThemeInfoAttribute> 어셈블리에 추가하여 이를 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-341">You can accomplish that by adding the <xref:System.Windows.ThemeInfoAttribute> to the assembly that contains the control.</span></span> <span data-ttu-id="3957b-342">에는 <xref:System.Windows.ThemeInfoAttribute> 일반 <xref:System.Windows.ThemeInfoAttribute.GenericDictionaryLocation%2A> 리소스의 위치를 지정하는 <xref:System.Windows.ThemeInfoAttribute.ThemeDictionaryLocation%2A> 속성과 테마별 리소스의 위치를 지정하는 속성이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-342">The <xref:System.Windows.ThemeInfoAttribute> has a <xref:System.Windows.ThemeInfoAttribute.GenericDictionaryLocation%2A> property that specifies the location of generic resources, and a <xref:System.Windows.ThemeInfoAttribute.ThemeDictionaryLocation%2A> property that specifies the location of the theme-specific resources.</span></span>

<span data-ttu-id="3957b-343">다음 예제에서는 <xref:System.Windows.ThemeInfoAttribute.GenericDictionaryLocation%2A> 및 <xref:System.Windows.ThemeInfoAttribute.ThemeDictionaryLocation%2A> 속성을 <xref:System.Windows.ResourceDictionaryLocation.SourceAssembly>로 설정하여 일반 및 테마별 리소스가 컨트롤과 동일한 어셈블리에 있는지 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="3957b-343">The following example sets the <xref:System.Windows.ThemeInfoAttribute.GenericDictionaryLocation%2A> and <xref:System.Windows.ThemeInfoAttribute.ThemeDictionaryLocation%2A> properties to <xref:System.Windows.ResourceDictionaryLocation.SourceAssembly>, to specify that the generic and theme-specific resources are in the same assembly as the control.</span></span>

[!code-csharp[CustomControlNumericUpDown#ThemesSection](~/samples/snippets/csharp/VS_Snippets_Wpf/CustomControlNumericUpDown/CSharp/CustomControlLibrary/Properties/AssemblyInfo.cs#themessection)]
[!code-vb[CustomControlNumericUpDown#ThemesSection](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CustomControlNumericUpDown/visualbasic/customcontrollibrary/my project/assemblyinfo.vb#themessection)]

## <a name="see-also"></a><span data-ttu-id="3957b-344">참고 항목</span><span class="sxs-lookup"><span data-stu-id="3957b-344">See also</span></span>

- [<span data-ttu-id="3957b-345">Visual Studio에서 XAML 디자인</span><span class="sxs-lookup"><span data-stu-id="3957b-345">Design XAML in Visual Studio</span></span>](/visualstudio/xaml-tools/designing-xaml-in-visual-studio)
- [<span data-ttu-id="3957b-346">WPF의 Pack URI</span><span class="sxs-lookup"><span data-stu-id="3957b-346">Pack URIs in WPF</span></span>](../app-development/pack-uris-in-wpf.md)
- [<span data-ttu-id="3957b-347">컨트롤 사용자 지정</span><span class="sxs-lookup"><span data-stu-id="3957b-347">Control Customization</span></span>](control-customization.md)

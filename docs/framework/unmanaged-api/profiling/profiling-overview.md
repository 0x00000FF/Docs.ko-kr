---
title: 프로파일링 개요
ms.date: 03/30/2017
helpviewer_keywords:
- managed code, profiling API support
- unmanaged code, combining with managed code in profiling
- notification threads [.NET Framework profiling]
- unmanaged code, profiling
- profiling API [.NET Framework], and COM
- profiling API [.NET Framework], unmanaged code profiling
- profilers, writing
- profiling API [.NET Framework], call stacks
- code profilers, writing
- profiling API [.NET Framework], security considerations
- profiling API [.NET Framework], managed code support
- common language runtime, profiling
- profiling API [.NET Framework], notification threads
- call stacks [.NET Framework profiling]
- profiling API [.NET Framework], stack depth
- common language runtime, writing a profiler
- profiling API [.NET Framework], information retrieval interfaces
- shadow stacks [.NET Framework profiling]
- COM, using in the profiling API
- stack snapshots [.NET Framework profiling]
- profiling API [.NET Framework], supported features
- profiling API [.NET Framework], overview
- security, profiling API considerations
- stack depth [.NET Framework profiling]
ms.assetid: 864c2344-71dc-46f9-96b2-ed59fb6427a8
ms.openlocfilehash: 3836b562d969726a6587d702d3edf45abb147d10
ms.sourcegitcommit: 961ec21c22d2f1d55c9cc8a7edf2ade1d1fd92e3
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 04/02/2020
ms.locfileid: "80588500"
---
# <a name="profiling-overview"></a><span data-ttu-id="396d0-102">프로파일링 개요</span><span class="sxs-lookup"><span data-stu-id="396d0-102">Profiling Overview</span></span>

<span data-ttu-id="396d0-103">프로파일러는 다른 응용 프로그램의 실행을 모니터링하는 도구입니다.</span><span class="sxs-lookup"><span data-stu-id="396d0-103">A profiler is a tool that monitors the execution of another application.</span></span> <span data-ttu-id="396d0-104">CLR(공용 언어 런타임) 프로파일러는 프로 파일링 API를 사용하여 CLR에서 메시지를 받고 보내는 함수로 구성된 DLL(동적 연결 라이브러리)입니다.</span><span class="sxs-lookup"><span data-stu-id="396d0-104">A common language runtime (CLR) profiler is a dynamic link library (DLL) that consists of functions that receive messages from, and send messages to, the CLR by using the profiling API.</span></span> <span data-ttu-id="396d0-105">프로파일러 DLL은 런타임에 CLR에 의해 로드됩니다.</span><span class="sxs-lookup"><span data-stu-id="396d0-105">The profiler DLL is loaded by the CLR at run time.</span></span>

<span data-ttu-id="396d0-106">기존의 프로파일링 도구는 애플리케이션의 실행 측정에 중점을 둡니다.</span><span class="sxs-lookup"><span data-stu-id="396d0-106">Traditional profiling tools focus on measuring the execution of the application.</span></span> <span data-ttu-id="396d0-107">즉, 각 함수에서 소요된 시간이나 시간 경과에 따른 애플리케이션의 메모리 사용량을 측정합니다.</span><span class="sxs-lookup"><span data-stu-id="396d0-107">That is, they measure the time that is spent in each function or the memory usage of the application over time.</span></span> <span data-ttu-id="396d0-108">프로파일링 API는 코드 검사 유틸리티 및 고급 디버깅 지원과 같은 광범위한 진단 도구 클래스를 대상으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="396d0-108">The profiling API targets a broader class of diagnostic tools such as code-coverage utilities and even advanced debugging aids.</span></span> <span data-ttu-id="396d0-109">이러한 사용은 본질적으로 모두 진단입니다.</span><span class="sxs-lookup"><span data-stu-id="396d0-109">These uses are all diagnostic in nature.</span></span> <span data-ttu-id="396d0-110">프로파일링 API는 애플리케이션의 실행을 측정할 뿐 아니라 모니터링합니다.</span><span class="sxs-lookup"><span data-stu-id="396d0-110">The profiling API not only measures but also monitors the execution of an application.</span></span> <span data-ttu-id="396d0-111">이러한 이유로 프로파일링 API는 애플리케이션 자체에서 사용하면 안 되며, 애플리케이션의 실행이 프로파일러에 종속되거나 영향을 받아서도 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="396d0-111">For this reason, the profiling API should never be used by the application itself, and the application’s execution should not depend on (or be affected by) the profiler.</span></span>

<span data-ttu-id="396d0-112">CLR 애플리케이션을 프로파일링하려면 기존의 컴파일된 기계어 코드를 프로파일링하는 것보다 많은 지원이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="396d0-112">Profiling a CLR application requires more support than profiling conventionally compiled machine code.</span></span> <span data-ttu-id="396d0-113">이는 CLR에서 애플리케이션 도메인, 가비지 컬렉션, 관리되는 예외 처리, 코드의 JIT(Just-In-Time) 컴파일(Microsoft Intermediate Language, 즉 MSIL 코드를 네이티브 기계어 코드로 변환) 및 비슷한 기능과 같은 개념을 도입하기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="396d0-113">This is because the CLR introduces concepts such as application domains, garbage collection, managed exception handling, just-in-time (JIT) compilation of code (converting Microsoft intermediate language, or MSIL, code into native machine code), and similar features.</span></span> <span data-ttu-id="396d0-114">기존의 프로파일링 메커니즘은 이러한 기능에 대한 유용한 정보를 식별하거나 제공할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="396d0-114">Conventional profiling mechanisms cannot identify or provide useful information about these features.</span></span> <span data-ttu-id="396d0-115">프로파일링 API는 CLR 및 프로파일링된 애플리케이션의 성능에 미치는 영향을 최소화하여 이 누락된 정보를 효율적으로 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="396d0-115">The profiling API provides this missing information efficiently, with minimal effect on the performance of the CLR and the profiled application.</span></span>

<span data-ttu-id="396d0-116">런타임의 JIT 컴파일은 프로파일링에 좋은 기회를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="396d0-116">JIT compilation at run time provides good opportunities for profiling.</span></span> <span data-ttu-id="396d0-117">프로파일링 API를 통해 프로파일러는 JIT 컴파일되기 전에 루틴에 대한 메모리 내 MSIL 코드 스트림을 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="396d0-117">The profiling API enables a profiler to change the in-memory MSIL code stream for a routine before it is JIT-compiled.</span></span> <span data-ttu-id="396d0-118">이런 방식으로 프로파일러는 더 세부적인 조사가 필요한 특정 루틴에 계측 코드를 동적으로 추가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="396d0-118">In this manner, the profiler can dynamically add instrumentation code to particular routines that need deeper investigation.</span></span> <span data-ttu-id="396d0-119">이 접근 방식은 기존 시나리오에서도 가능하지만 프로파일링 API를 사용하여 CLR에 대해 구현하는 것이 훨씬 더 쉽습니다.</span><span class="sxs-lookup"><span data-stu-id="396d0-119">Although this approach is possible in conventional scenarios, it is much easier to implement for the CLR by using the profiling API.</span></span>

## <a name="the-profiling-api"></a><span data-ttu-id="396d0-120">프로파일링 API</span><span class="sxs-lookup"><span data-stu-id="396d0-120">The Profiling API</span></span>

<span data-ttu-id="396d0-121">일반적으로 프로파일링 API는 관리되는 응용 프로그램의 실행을 모니터링하는 프로그램인 *코드 프로파일러를*작성하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="396d0-121">Typically, the profiling API is used to write a *code profiler*, which is a program that monitors the execution of a managed application.</span></span>

<span data-ttu-id="396d0-122">프로파일링 API는 프로파일링되는 애플리케이션과 동일한 프로세스에 로드된 프로파일러 DLL에서 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="396d0-122">The profiling API is used by a profiler DLL, which is loaded into the same process as the application that is being profiled.</span></span> <span data-ttu-id="396d0-123">프로파일러 DLL은 콜백 인터페이스(.NET Framework 버전 1.0 및 1.1의[ICorProfilerCallback,](icorprofilercallback-interface.md) 버전 2.0 이상에서 [ICorProfilerCallback2)를](icorprofilercallback2-interface.md) 구현합니다.</span><span class="sxs-lookup"><span data-stu-id="396d0-123">The profiler DLL implements a callback interface ([ICorProfilerCallback](icorprofilercallback-interface.md) in the .NET Framework version 1.0 and 1.1, [ICorProfilerCallback2](icorprofilercallback2-interface.md) in version 2.0 and later).</span></span> <span data-ttu-id="396d0-124">CLR은 해당 인터페이스의 메서드를 호출하여 프로파일링된 프로세스의 이벤트를 프로파일러에 알립니다.</span><span class="sxs-lookup"><span data-stu-id="396d0-124">The CLR calls the methods in that interface to notify the profiler of events in the profiled process.</span></span> <span data-ttu-id="396d0-125">프로파일러는 [ICorProfilerInfo](icorprofilerinfo-interface.md) 및 [ICorProfilerInfo2](icorprofilerinfo2-interface.md) 인터페이스의 메서드를 사용하여 프로파일된 응용 프로그램의 상태에 대한 정보를 얻어런타임으로 다시 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="396d0-125">The profiler can call back into the runtime by using the methods in the [ICorProfilerInfo](icorprofilerinfo-interface.md) and [ICorProfilerInfo2](icorprofilerinfo2-interface.md) interfaces to obtain information about the state of the profiled application.</span></span>

> [!NOTE]
> <span data-ttu-id="396d0-126">프로파일러 솔루션의 데이터 수집 부분만 프로파일링된 애플리케이션과 동일한 프로세스에서 실행되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="396d0-126">Only the data-gathering part of the profiler solution should be running in the same process as the profiled application.</span></span> <span data-ttu-id="396d0-127">모든 사용자 인터페이스 및 데이터 분석은 별도 프로세스에서 수행되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="396d0-127">All user interface and data analysis should be performed in a separate process.</span></span>

<span data-ttu-id="396d0-128">다음 그림에서는 프로파일러 DLL이 프로파일링되는 애플리케이션 및 CLR과 상호 작용하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="396d0-128">The following illustration shows how the profiler DLL interacts with the application that is being profiled and the CLR.</span></span>

![프로파일링 아키텍처를 보여 주는 스크린샷입니다.](./media/profiling-overview/profiling-architecture.png)

### <a name="the-notification-interfaces"></a><span data-ttu-id="396d0-130">알림 인터페이스</span><span class="sxs-lookup"><span data-stu-id="396d0-130">The Notification Interfaces</span></span>

<span data-ttu-id="396d0-131">[ICorProfilerCallback](icorprofilercallback-interface.md) 및 [ICorProfilerCallback2는](icorprofilercallback2-interface.md) 알림 인터페이스로 간주될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="396d0-131">[ICorProfilerCallback](icorprofilercallback-interface.md) and [ICorProfilerCallback2](icorprofilercallback2-interface.md) can be considered notification interfaces.</span></span> <span data-ttu-id="396d0-132">이러한 인터페이스는 [ClassLoadStarted,](icorprofilercallback-classloadstarted-method.md) [클래스로드완료](icorprofilercallback-classloadfinished-method.md)및 [JIT컴파일시작과](icorprofilercallback-jitcompilationstarted-method.md)같은 메서드로 구성됩니다.</span><span class="sxs-lookup"><span data-stu-id="396d0-132">These interfaces consist of methods such as [ClassLoadStarted](icorprofilercallback-classloadstarted-method.md), [ClassLoadFinished](icorprofilercallback-classloadfinished-method.md), and [JITCompilationStarted](icorprofilercallback-jitcompilationstarted-method.md).</span></span> <span data-ttu-id="396d0-133">CLR은 클래스를 로드 또는 언로드하고 함수를 컴파일할 때마다 프로파일러의 `ICorProfilerCallback` 또는 `ICorProfilerCallback2` 인터페이스에서 해당 메서드를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="396d0-133">Each time the CLR loads or unloads a class, compiles a function, and so on, it calls the corresponding method in the profiler's `ICorProfilerCallback` or `ICorProfilerCallback2` interface.</span></span>

<span data-ttu-id="396d0-134">예를 들어 프로파일러는 두 가지 알림 함수인 [FunctionEnter2](functionenter2-function.md) 및 [FunctionLeave2를](functionleave2-function.md)통해 코드 성능을 측정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="396d0-134">For example, a profiler could measure code performance through two notification functions: [FunctionEnter2](functionenter2-function.md) and [FunctionLeave2](functionleave2-function.md).</span></span> <span data-ttu-id="396d0-135">단순히 각 알림에 타임스탬프를 지정하고, 결과를 누적한 다음 애플리케이션 실행 중에 가장 많은 CPU 또는 벽시계 시간을 사용한 함수를 나타내는 목록을 출력합니다.</span><span class="sxs-lookup"><span data-stu-id="396d0-135">It just time-stamps each notification, accumulates results, and outputs a list that indicates which functions consumed the most CPU or wall-clock time during the execution of the application.</span></span>

### <a name="the-information-retrieval-interfaces"></a><span data-ttu-id="396d0-136">정보 검색 인터페이스</span><span class="sxs-lookup"><span data-stu-id="396d0-136">The Information Retrieval Interfaces</span></span>

<span data-ttu-id="396d0-137">프로파일링과 관련된 다른 주요 인터페이스는 [ICorProfilerInfo](icorprofilerinfo-interface.md) 및 [ICorProfilerInfo2](icorprofilerinfo2-interface.md)입니다.</span><span class="sxs-lookup"><span data-stu-id="396d0-137">The other main interfaces involved in profiling are [ICorProfilerInfo](icorprofilerinfo-interface.md) and [ICorProfilerInfo2](icorprofilerinfo2-interface.md).</span></span> <span data-ttu-id="396d0-138">프로파일러는 필요에 따라 이러한 인터페이스를 호출하여 분석에 도움이 되는 자세한 정보를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="396d0-138">The profiler calls these interfaces as required to obtain more information to help its analysis.</span></span> <span data-ttu-id="396d0-139">예를 들어 CLR이 [FunctionEnter2](functionenter2-function.md) 함수를 호출할 때마다 함수 식별자를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="396d0-139">For example, whenever the CLR calls the [FunctionEnter2](functionenter2-function.md) function, it supplies a function identifier.</span></span> <span data-ttu-id="396d0-140">프로파일러는 [ICorProfilerInfo2::GetFunctionInfo2](icorprofilerinfo2-getfunctioninfo2-method.md) 메서드를 호출하여 함수의 부모 클래스, 이름 등을 검색하여 해당 함수에 대한 자세한 정보를 얻을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="396d0-140">The profiler can get more information about that function by calling the [ICorProfilerInfo2::GetFunctionInfo2](icorprofilerinfo2-getfunctioninfo2-method.md) method to discover the function's parent class, its name, and so on.</span></span>

## <a name="supported-features"></a><span data-ttu-id="396d0-141">지원되는 기능</span><span class="sxs-lookup"><span data-stu-id="396d0-141">Supported Features</span></span>

<span data-ttu-id="396d0-142">프로파일링 API는 공용 언어 런타임에서 발생하는 다양한 이벤트와 작업에 대한 정보를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="396d0-142">The profiling API provides information about a variety of events and actions that occur in the common language runtime.</span></span> <span data-ttu-id="396d0-143">이 정보를 사용하여 프로세스의 내부 작업을 모니터링하고 .NET Framework 애플리케이션의 성능을 분석할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="396d0-143">You can use this information to monitor the inner workings of processes and to analyze the performance of your .NET Framework application.</span></span>

<span data-ttu-id="396d0-144">프로파일링 API는 CLR에서 발생하는 다음 작업 및 이벤트에 대한 정보를 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="396d0-144">The profiling API retrieves information about the following actions and events that occur in the CLR:</span></span>

- <span data-ttu-id="396d0-145">CLR 시작 및 종료 이벤트</span><span class="sxs-lookup"><span data-stu-id="396d0-145">CLR startup and shutdown events.</span></span>

- <span data-ttu-id="396d0-146">애플리케이션 도메인 생성 및 종료 이벤트</span><span class="sxs-lookup"><span data-stu-id="396d0-146">Application domain creation and shutdown events.</span></span>

- <span data-ttu-id="396d0-147">어셈블리 로드 및 언로드 이벤트</span><span class="sxs-lookup"><span data-stu-id="396d0-147">Assembly loading and unloading events.</span></span>

- <span data-ttu-id="396d0-148">모듈 로드 및 언로드 이벤트</span><span class="sxs-lookup"><span data-stu-id="396d0-148">Module loading and unloading events.</span></span>

- <span data-ttu-id="396d0-149">COM vtable 생성 및 소멸 이벤트</span><span class="sxs-lookup"><span data-stu-id="396d0-149">COM vtable creation and destruction events.</span></span>

- <span data-ttu-id="396d0-150">JIT(Just-In-Time) 컴파일 및 코드 피칭 이벤트</span><span class="sxs-lookup"><span data-stu-id="396d0-150">Just-in-time (JIT) compilation and code-pitching events.</span></span>

- <span data-ttu-id="396d0-151">클래스 로드 및 언로드 이벤트</span><span class="sxs-lookup"><span data-stu-id="396d0-151">Class loading and unloading events.</span></span>

- <span data-ttu-id="396d0-152">스레드 생성 및 소멸 이벤트</span><span class="sxs-lookup"><span data-stu-id="396d0-152">Thread creation and destruction events.</span></span>

- <span data-ttu-id="396d0-153">함수 진입 및 종료 이벤트</span><span class="sxs-lookup"><span data-stu-id="396d0-153">Function entry and exit events.</span></span>

- <span data-ttu-id="396d0-154">예외.</span><span class="sxs-lookup"><span data-stu-id="396d0-154">Exceptions.</span></span>

- <span data-ttu-id="396d0-155">관리 코드와 비관리 코드 실행 간의 전환</span><span class="sxs-lookup"><span data-stu-id="396d0-155">Transitions between managed and unmanaged code execution.</span></span>

- <span data-ttu-id="396d0-156">다양한 런타임 컨텍스트 간의 전환</span><span class="sxs-lookup"><span data-stu-id="396d0-156">Transitions between different runtime contexts.</span></span>

- <span data-ttu-id="396d0-157">런타임 일시 중단에 대한 정보</span><span class="sxs-lookup"><span data-stu-id="396d0-157">Information about runtime suspensions.</span></span>

- <span data-ttu-id="396d0-158">런타임 메모리 힙 및 가비지 수집 작업에 대한 정보</span><span class="sxs-lookup"><span data-stu-id="396d0-158">Information about the runtime memory heap and garbage collection activity.</span></span>

<span data-ttu-id="396d0-159">모든(관리되지 않는) COM 호환 언어에서 프로파일링 API를 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="396d0-159">The profiling API can be called from any (non-managed) COM-compatible language.</span></span>

<span data-ttu-id="396d0-160">이 API는 CPU 및 메모리 사용과 관련해서 효율적입니다.</span><span class="sxs-lookup"><span data-stu-id="396d0-160">The API is efficient with regard to CPU and memory consumption.</span></span> <span data-ttu-id="396d0-161">프로파일링에서는 프로파일링된 애플리케이션에 대해 잘못된 결과를 일으킬 만큼 중요한 변경 작업을 수행하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="396d0-161">Profiling does not involve changes to the profiled application that are significant enough to cause misleading results.</span></span>

<span data-ttu-id="396d0-162">프로파일링 API는 샘플링 및 비샘플링 프로파일러 둘 다에 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="396d0-162">The profiling API is useful to both sampling and non-sampling profilers.</span></span> <span data-ttu-id="396d0-163">*샘플링 프로파일러는* 5밀리초 간격으로 일반 클럭 틱에서 프로파일을 검사합니다.</span><span class="sxs-lookup"><span data-stu-id="396d0-163">A *sampling profiler* inspects the profile at regular clock ticks, say, at 5 milliseconds apart.</span></span> <span data-ttu-id="396d0-164">*비 샘플링 프로파일러는* 이벤트를 일으키는 스레드와 동기적으로 이벤트에 대한 알림을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="396d0-164">A *non-sampling profiler* is informed of an event synchronously with the thread that causes the event.</span></span>

### <a name="unsupported-functionality"></a><span data-ttu-id="396d0-165">지원되지 않는 기능</span><span class="sxs-lookup"><span data-stu-id="396d0-165">Unsupported Functionality</span></span>

<span data-ttu-id="396d0-166">프로파일링 API에서는 다음 기능을 지원하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="396d0-166">The profiling API does not support the following functionality:</span></span>

- <span data-ttu-id="396d0-167">기존의 Win32 메서드를 통해 프로파일링해야 하는 비관리 코드.</span><span class="sxs-lookup"><span data-stu-id="396d0-167">Unmanaged code, which must be profiled using conventional Win32 methods.</span></span> <span data-ttu-id="396d0-168">그러나 CLR 프로파일러에는 관리 코드와 비관리 코드 간의 경계를 결정하는 전환 이벤트가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="396d0-168">However, the CLR profiler includes transition events to determine the boundaries between managed and unmanaged code.</span></span>

- <span data-ttu-id="396d0-169">관점 지향 프로그래밍과 같은 목적을 위해 해당 코드를 수정하는 자체 수정 애플리케이션</span><span class="sxs-lookup"><span data-stu-id="396d0-169">Self-modifying applications that modify their own code for purposes such as aspect-oriented programming.</span></span>

- <span data-ttu-id="396d0-170">범위 검사. 프로파일링 API에서 이 정보를 제공하지 않기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="396d0-170">Bounds checking, because the profiling API does not provide this information.</span></span> <span data-ttu-id="396d0-171">CLR은 모든 관리 코드의 범위 검사를 기본적으로 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="396d0-171">The CLR provides intrinsic support for bounds checking of all managed code.</span></span>

- <span data-ttu-id="396d0-172">원격 프로파일링. 다음과 같은 이유로 지원되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="396d0-172">Remote profiling, which is not supported for the following reasons:</span></span>

  - <span data-ttu-id="396d0-173">원격 프로파일링은 실행 시간을 연장합니다.</span><span class="sxs-lookup"><span data-stu-id="396d0-173">Remote profiling extends execution time.</span></span> <span data-ttu-id="396d0-174">프로파일링 인터페이스를 사용하는 경우 프로파일링 결과가 과도한 영향을 받지 않도록 실행 시간을 최소화해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="396d0-174">When you use the profiling interfaces, you must minimize execution time so that profiling results will not be unduly affected.</span></span> <span data-ttu-id="396d0-175">이는 실행 성능을 모니터링하는 경우 특히 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="396d0-175">This is especially true when execution performance is being monitored.</span></span> <span data-ttu-id="396d0-176">그러나 원격 프로파일링은 프로파일링 인터페이스를 사용하여 메모리 사용량을 모니터링하거나 스택 프레임, 개체 등에 대한 런타임 정보를 가져올 때 제한 사항이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="396d0-176">However, remote profiling is not a limitation when the profiling interfaces are used to monitor memory usage or to obtain run-time information about stack frames, objects, and so on.</span></span>

  - <span data-ttu-id="396d0-177">CLR 코드 프로파일러는 프로파일링된 애플리케이션이 실행되고 있는 로컬 컴퓨터에서 런타임에 하나 이상의 콜백 인터페이스를 등록해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="396d0-177">The CLR code profiler must register one or more callback interfaces with the runtime on the local computer on which the profiled application is running.</span></span> <span data-ttu-id="396d0-178">이로 인해 원격 코드 프로파일러를 만드는 기능이 제한됩니다.</span><span class="sxs-lookup"><span data-stu-id="396d0-178">This limits the ability to create a remote code profiler.</span></span>

## <a name="notification-threads"></a><span data-ttu-id="396d0-179">알림 스레드</span><span class="sxs-lookup"><span data-stu-id="396d0-179">Notification Threads</span></span>

<span data-ttu-id="396d0-180">대부분의 경우 이벤트를 생성하는 스레드도 알림을 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="396d0-180">In most cases, the thread that generates an event also executes notifications.</span></span> <span data-ttu-id="396d0-181">이러한 알림(예: [FunctionEnter](functionenter-function.md) 및 [FunctionLeave)은](functionleave-function.md)explicit `ThreadID`을 제공할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="396d0-181">Such notifications (for example, [FunctionEnter](functionenter-function.md) and [FunctionLeave](functionleave-function.md)) do not need to supply the explicit `ThreadID`.</span></span> <span data-ttu-id="396d0-182">또한 프로파일러는 영향을 받는 스레드의 `ThreadID`에 따라, 전역 스토리지의 분석 블록을 인덱싱하는 대신 스레드 로컬 스토리지를 사용하여 분석 블록을 저장 및 업데이트할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="396d0-182">Also, the profiler might decide to use thread-local storage to store and update its analysis blocks instead of indexing the analysis blocks in global storage, based on the `ThreadID` of the affected thread.</span></span>

<span data-ttu-id="396d0-183">이러한 콜백은 직렬화되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="396d0-183">Note that these callbacks are not serialized.</span></span> <span data-ttu-id="396d0-184">사용자는 스레드로부터 안전한 데이터 구조를 만들고 여러 스레드에서의 병렬 액세스를 방지하기 위해 필요에 따라 프로파일러 코드를 잠가 코드를 보호해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="396d0-184">Users must protect their code by creating thread-safe data structures and by locking the profiler code where necessary to prevent parallel access from multiple threads.</span></span> <span data-ttu-id="396d0-185">따라서 특정 경우에서는 사용자가 평소와 다른 콜백 시퀀스를 받을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="396d0-185">Therefore, in certain cases you can receive an unusual sequence of callbacks.</span></span> <span data-ttu-id="396d0-186">예를 들어 관리되는 애플리케이션이 동일한 코드를 실행하는 두 스레드를 생성한다고 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="396d0-186">For example, assume that a managed application is spawning two threads that are executing identical code.</span></span> <span data-ttu-id="396d0-187">이 경우 [ICorProfilerCallback::JITCompilation](icorprofilercallback-jitcompilationstarted-method.md) `FunctionEnter` [ICorProfilerCallback::JIT컴파일완료](icorprofilercallback-jitcompilationfinished-method.md) 콜백을 받기 전에 한 스레드에서 일부 함수와 다른 스레드에서 콜백에 대한 호출시작 이벤트를 수신할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="396d0-187">In this case, it is possible to receive a [ICorProfilerCallback::JITCompilationStarted](icorprofilercallback-jitcompilationstarted-method.md) event for some function from one thread and a `FunctionEnter` callback from the other thread before receiving the [ICorProfilerCallback::JITCompilationFinished](icorprofilercallback-jitcompilationfinished-method.md) callback.</span></span> <span data-ttu-id="396d0-188">이 경우에는 사용자가 아직 완전히 JIT(Just-In-Time) 컴파일되지 않았을 수 있는 함수에 대해 `FunctionEnter` 콜백을 받는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="396d0-188">In this case, the user will receive a `FunctionEnter` callback for a function that may not have been fully just-in-time (JIT) compiled yet.</span></span>

## <a name="security"></a><span data-ttu-id="396d0-189">보안</span><span class="sxs-lookup"><span data-stu-id="396d0-189">Security</span></span>

<span data-ttu-id="396d0-190">프로파일러 DLL은 공용 언어 런타임 실행 엔진의 일부로 실행되는 관리되지 않는 DLL입니다.</span><span class="sxs-lookup"><span data-stu-id="396d0-190">A profiler DLL is an unmanaged DLL that runs as part of the common language runtime execution engine.</span></span> <span data-ttu-id="396d0-191">따라서 프로파일러 DLL의 코드에 관리 코드 액세스 보안의 제한이 적용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="396d0-191">As a result, the code in the profiler DLL is not subject to the restrictions of managed code access security.</span></span> <span data-ttu-id="396d0-192">프로파일러 DLL에 대한 유일한 제한 사항은 운영 체제에서 프로파일링된 애플리케이션을 실행하는 사용자에 대해 적용하는 제한입니다.</span><span class="sxs-lookup"><span data-stu-id="396d0-192">The only limitations on the profiler DLL are those imposed by the operating system on the user who is running the profiled application.</span></span>

<span data-ttu-id="396d0-193">프로파일러 작성자는 보안 관련 문제를 방지하기 위해 적절한 예방 조치를 취해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="396d0-193">Profiler authors should take appropriate precautions to avoid security-related issues.</span></span> <span data-ttu-id="396d0-194">예를 들어 악의적인 사용자가 수정할 수 없도록 설치 중에 프로파일러 DLL을 ACL(액세스 제어 목록)에 추가해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="396d0-194">For example, during installation, a profiler DLL should be added to an access control list (ACL) so that a malicious user cannot modify it.</span></span>

## <a name="combining-managed-and-unmanaged-code-in-a-code-profiler"></a><span data-ttu-id="396d0-195">코드 프로파일러에서 관리 코드와 비관리 코드 결합</span><span class="sxs-lookup"><span data-stu-id="396d0-195">Combining Managed and Unmanaged Code in a Code Profiler</span></span>

<span data-ttu-id="396d0-196">잘못 작성된 프로파일러는 자체 순환 참조를 생성하여 예기치 않은 동작이 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="396d0-196">An incorrectly written profiler can cause circular references to itself, resulting in unpredictable behavior.</span></span>

<span data-ttu-id="396d0-197">CLR 프로파일링 API를 검토하면 COM interop 또는 간접 호출을 통해 서로 호출하는 관리되는 구성 요소와 관리되지 않는 구성 요소를 포함하는 프로파일러를 작성할 수 있다는 인상을 받을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="396d0-197">A review of the CLR profiling API may create the impression that you can write a profiler that contains managed and unmanaged components that call each other through COM interop or indirect calls.</span></span>

<span data-ttu-id="396d0-198">디자인 관점에서는 가능하지만 프로파일링 API는 관리되는 구성 요소를 지원하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="396d0-198">Although this is possible from a design perspective, the profiling API does not support managed components.</span></span> <span data-ttu-id="396d0-199">CLR 프로파일러는 완전히 관리되지 않아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="396d0-199">A CLR profiler must be completely unmanaged.</span></span> <span data-ttu-id="396d0-200">CLR 프로파일러에서 관리 코드와 비관리 코드를 결합하려고 하면 액세스 위반, 프로그램 오류 또는 교착 상태가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="396d0-200">Attempts to combine managed and unmanaged code in a CLR profiler may cause access violations, program failure, or deadlocks.</span></span> <span data-ttu-id="396d0-201">프로파일러의 관리되는 구성 요소는 관리되지 않는 해당 구성 요소로 다시 이벤트를 발생시키고, 이후에 이 구성 요소가 관리되는 구성 요소를 다시 호출하여 순환 참조가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="396d0-201">The managed components of the profiler will fire events back to their unmanaged components, which would subsequently call the managed components again, resulting in circular references.</span></span>

<span data-ttu-id="396d0-202">CLR 프로파일러가 관리 코드를 안전하게 호출할 수 있는 유일한 위치는 메서드의 MSIL(Microsoft Intermediate Language) 본문입니다.</span><span class="sxs-lookup"><span data-stu-id="396d0-202">The only location where a CLR profiler can call managed code safely is in the Microsoft intermediate language (MSIL) body of a method.</span></span> <span data-ttu-id="396d0-203">MSIL 본문을 수정하는 데 권장되는 방법은 [ICorProfilerCallback4](icorprofilercallback4-interface.md) 인터페이스에서 JIT 재컴파일 메서드를 사용하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="396d0-203">The recommended practice for modifying the MSIL body is to use the  JIT recompilation methods in the [ICorProfilerCallback4](icorprofilercallback4-interface.md) interface.</span></span>

<span data-ttu-id="396d0-204">오래된 계측 메서드를 사용하여 MSIL을 수정할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="396d0-204">It is also possible to use the older instrumentation methods to modify MSIL.</span></span> <span data-ttu-id="396d0-205">함수의 적시(JIT) 컴파일이 완료되기 전에 프로파일러는 메서드의 MSIL 본문에 관리되는 호출을 삽입한 다음 JIT 컴파일할 수 [있습니다(ICorProfilerInfo:GetILFunctionBody](icorprofilerinfo-getilfunctionbody-method.md) 메서드 참조).</span><span class="sxs-lookup"><span data-stu-id="396d0-205">Before the just-in-time (JIT) compilation of a function is completed, the profiler can insert managed calls in the MSIL body of a method and then JIT-compile it (see the [ICorProfilerInfo::GetILFunctionBody](icorprofilerinfo-getilfunctionbody-method.md) method).</span></span> <span data-ttu-id="396d0-206">이 기술은 관리 코드의 선택적 계측이나 JIT에 대한 통계 및 성능 데이터 수집을 위해 성공적으로 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="396d0-206">This technique can successfully be used for selective instrumentation of managed code, or to gather statistics and performance data about the JIT.</span></span>

<span data-ttu-id="396d0-207">또는 코드 프로파일러가 비관리 코드를 호출하는 모든 관리되는 함수의 MSIL 본문에 네이티브 후크를 삽입할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="396d0-207">Alternatively, a code profiler can insert native hooks in the MSIL body of every managed function that calls into unmanaged code.</span></span> <span data-ttu-id="396d0-208">이 기술은 계측 및 검사에 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="396d0-208">This technique can be used for instrumentation and coverage.</span></span> <span data-ttu-id="396d0-209">예를 들어 코드 프로파일러가 모든 MSIL 블록 뒤에 계측 후크를 삽입하여 블록이 실행되었는지 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="396d0-209">For example, a code profiler could insert instrumentation hooks after every MSIL block to ensure that the block has been executed.</span></span> <span data-ttu-id="396d0-210">메서드의 MSIL 본문 수정은 매우 정교한 작업이며 여러 가지 요인을 고려해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="396d0-210">The modification of the MSIL body of a method is a very delicate operation, and there are many factors that should be taken into consideration.</span></span>

## <a name="profiling-unmanaged-code"></a><span data-ttu-id="396d0-211">비관리 코드 프로파일링</span><span class="sxs-lookup"><span data-stu-id="396d0-211">Profiling Unmanaged Code</span></span>

<span data-ttu-id="396d0-212">CLR(공용 언어 런타임) 프로파일링 API는 비관리 코드 프로파일링에 대해 최소한의 지원을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="396d0-212">The common language runtime (CLR) profiling API provides minimal support for profiling unmanaged code.</span></span> <span data-ttu-id="396d0-213">다음 기능이 제공됩니다.</span><span class="sxs-lookup"><span data-stu-id="396d0-213">The following functionality is provided:</span></span>

- <span data-ttu-id="396d0-214">스택 체인 열거형.</span><span class="sxs-lookup"><span data-stu-id="396d0-214">Enumeration of stack chains.</span></span> <span data-ttu-id="396d0-215">이 기능을 통해 코드 프로파일러는 관리 코드와 비관리 코드 사이의 경계를 결정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="396d0-215">This feature enables a code profiler to determine the boundary between managed code and unmanaged code.</span></span>

- <span data-ttu-id="396d0-216">스택 체인이 관리 코드에 해당하는지 또는 네이티브 코드에 해당하는지를 결정합니다.</span><span class="sxs-lookup"><span data-stu-id="396d0-216">Determination whether a stack chain corresponds to managed code or native code.</span></span>

<span data-ttu-id="396d0-217">.NET Framework 버전 1.0 및 1.1에서는 CLR 디버깅 API의 in-process 하위 집합을 통해 이러한 메서드를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="396d0-217">In the .NET Framework versions 1.0 and 1.1, these methods are available through the in-process subset of the CLR debugging API.</span></span> <span data-ttu-id="396d0-218">CorDebug.idl 파일에서 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="396d0-218">They are defined in the CorDebug.idl file.</span></span>

<span data-ttu-id="396d0-219">.NET 프레임워크 2.0 이상에서는 이 기능에 [대해 ICorProfilerInfo2::DoStackSnapshot](icorprofilerinfo2-dostacksnapshot-method.md) 메서드를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="396d0-219">In the .NET Framework 2.0 and later, you can use the [ICorProfilerInfo2::DoStackSnapshot](icorprofilerinfo2-dostacksnapshot-method.md) method for this functionality.</span></span>

## <a name="using-com"></a><span data-ttu-id="396d0-220">COM 사용</span><span class="sxs-lookup"><span data-stu-id="396d0-220">Using COM</span></span>

<span data-ttu-id="396d0-221">프로파일링 인터페이스는 COM 인터페이스로 정의되지만 CLR(공용 언어 런타임)에서 실제로 이러한 인터페이스를 사용하도록 COM를 초기화하지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="396d0-221">Although the profiling interfaces are defined as COM interfaces, the common language runtime (CLR) does not actually initialize COM to use these interfaces.</span></span> <span data-ttu-id="396d0-222">그 이유는 관리되는 응용 프로그램이 원하는 스레딩 모델을 지정하기 전에 [CoInitialize](/windows/desktop/api/objbase/nf-objbase-coinitialize) 함수를 사용하여 스레딩 모델을 설정하지 않아도 되기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="396d0-222">The reason is to avoid having to set the threading model by using the [CoInitialize](/windows/desktop/api/objbase/nf-objbase-coinitialize) function before the managed application has had a chance to specify its desired threading model.</span></span> <span data-ttu-id="396d0-223">마찬가지로, 프로파일러 자체는 프로파일링되는 애플리케이션과 호환되지 않는 스레딩 모델을 선택하여 애플리케이션이 실패하게 만들 수 있으므로 `CoInitialize`를 호출하면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="396d0-223">Similarly, the profiler itself should not call `CoInitialize`, because it may pick a threading model that is incompatible with the application being profiled and may cause the application to fail.</span></span>

## <a name="call-stacks"></a><span data-ttu-id="396d0-224">호출 스택</span><span class="sxs-lookup"><span data-stu-id="396d0-224">Call Stacks</span></span>

<span data-ttu-id="396d0-225">프로파일링 API는 호출 스택을 가져오는 두 가지 방법을 제공합니다. 스택 스냅샷 메서드는 호출 스택의 스파스 수집을 가능하게 하고 섀도 스택 메서드는 모든 순간에 호출 스택을 추적합니다.</span><span class="sxs-lookup"><span data-stu-id="396d0-225">The profiling API provides two ways to obtain call stacks: a stack snapshot method, which enables sparse gathering of call stacks, and a shadow stack method, which tracks the call stack at every instant.</span></span>

### <a name="stack-snapshot"></a><span data-ttu-id="396d0-226">스택 스냅샷</span><span class="sxs-lookup"><span data-stu-id="396d0-226">Stack Snapshot</span></span>

<span data-ttu-id="396d0-227">스택 스냅샷은 한 순간의 스레드 스택 추적입니다.</span><span class="sxs-lookup"><span data-stu-id="396d0-227">A stack snapshot is a trace of the stack of a thread at an instant in time.</span></span> <span data-ttu-id="396d0-228">프로파일링 API는 스택에서 관리되는 함수의 추적을 지원하지만 관리되지 않는 함수의 추적은 프로파일러의 자체 스택 워크에 맡깁니다.</span><span class="sxs-lookup"><span data-stu-id="396d0-228">The profiling API supports the tracing of managed functions on the stack, but it leaves the tracing of unmanaged functions to the profiler's own stack walker.</span></span>

<span data-ttu-id="396d0-229">프로파일러가 관리되는 스택을 보도록 프로그래밍하는 방법에 대한 자세한 내용은 이 설명서 세트의 [ICorProfilerInfo2::DoStackSnapshot](icorprofilerinfo2-dostacksnapshot-method.md) 메서드 및 [.NET Framework 2.0: 기본 및 그 너머에서 프로파일러 스택 걷기를](https://docs.microsoft.com/previous-versions/dotnet/articles/bb264782(v=msdn.10))참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="396d0-229">For more information about how to program the profiler to walk managed stacks, see the [ICorProfilerInfo2::DoStackSnapshot](icorprofilerinfo2-dostacksnapshot-method.md) method in this documentation set, and [Profiler Stack Walking in the .NET Framework 2.0: Basics and Beyond](https://docs.microsoft.com/previous-versions/dotnet/articles/bb264782(v=msdn.10)).</span></span>

### <a name="shadow-stack"></a><span data-ttu-id="396d0-230">섀도 스택</span><span class="sxs-lookup"><span data-stu-id="396d0-230">Shadow Stack</span></span>

<span data-ttu-id="396d0-231">스냅샷 메서드를 너무 자주 사용하면 성능 문제가 빠르게 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="396d0-231">Using the snapshot method too frequently can quickly create a performance issue.</span></span> <span data-ttu-id="396d0-232">스택 추적을 자주 수행하려면 프로파일러가 [FunctionEnter2,](functionenter2-function.md) [FunctionLeave2,](functionleave2-function.md) [FunctionTailcall2](functiontailcall2-function.md)및 [ICorProfilerCallback2](icorprofilercallback2-interface.md) 예외 콜백을 사용하여 섀도 스택을 빌드해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="396d0-232">If you want to take stack traces frequently, your profiler should instead build a shadow stack by using the [FunctionEnter2](functionenter2-function.md), [FunctionLeave2](functionleave2-function.md), [FunctionTailcall2](functiontailcall2-function.md), and [ICorProfilerCallback2](icorprofilercallback2-interface.md) exception callbacks.</span></span> <span data-ttu-id="396d0-233">섀도 스택은 항상 최신 상태이며 스택 스냅샷이 필요할 때마다 스토리지로 빠르게 복사될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="396d0-233">The shadow stack is always current and can quickly be copied to storage whenever a stack snapshot is needed.</span></span>

<span data-ttu-id="396d0-234">섀도 스택은 함수 인수, 반환 값 및 제네릭 인스턴스화에 대한 정보를 얻을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="396d0-234">A shadow stack may obtain function arguments, return values, and information about generic instantiations.</span></span> <span data-ttu-id="396d0-235">이 정보는 섀도 스택을 통해서만 제공되며 컨트롤이 함수에 전달될 때 얻을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="396d0-235">This information is available only through the shadow stack and may be obtained when control is handed to a function.</span></span> <span data-ttu-id="396d0-236">그러나 나중에 함수 실행 중에는 이 정보는 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="396d0-236">However, this information may not be available later during the run of the function.</span></span>

## <a name="callbacks-and-stack-depth"></a><span data-ttu-id="396d0-237">콜백 및 스택 수준</span><span class="sxs-lookup"><span data-stu-id="396d0-237">Callbacks and Stack Depth</span></span>

<span data-ttu-id="396d0-238">프로파일러 콜백은 스택이 매우 제한된 환경에서 실행할 수 있으며, 프로파일러 콜백의 스택 오버플로로 인해 즉시 프로세스가 종료됩니다.</span><span class="sxs-lookup"><span data-stu-id="396d0-238">Profiler callbacks may be issued in very stack-constrained circumstances, and a stack overflow in a profiler callback will lead to an immediate process exit.</span></span> <span data-ttu-id="396d0-239">프로파일러는 콜백에 대한 응답으로 가능한 한 적은 스택을 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="396d0-239">A profiler should make sure to use as little stack as possible in response to callbacks.</span></span> <span data-ttu-id="396d0-240">프로파일러가 스택 오버플로에 대해 강력한 프로세스에 사용하기 위한 것이면 프로파일러 자체에서 스택 오버플로 트리거도 피해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="396d0-240">If the profiler is intended for use against processes that are robust against stack overflow, the profiler itself should also avoid triggering stack overflow.</span></span>

## <a name="related-topics"></a><span data-ttu-id="396d0-241">관련 항목</span><span class="sxs-lookup"><span data-stu-id="396d0-241">Related Topics</span></span>

|<span data-ttu-id="396d0-242">제목</span><span class="sxs-lookup"><span data-stu-id="396d0-242">Title</span></span>|<span data-ttu-id="396d0-243">설명</span><span class="sxs-lookup"><span data-stu-id="396d0-243">Description</span></span>|
|-----------|-----------------|
|[<span data-ttu-id="396d0-244">프로파일링 환경 설정</span><span class="sxs-lookup"><span data-stu-id="396d0-244">Setting Up a Profiling Environment</span></span>](setting-up-a-profiling-environment.md)|<span data-ttu-id="396d0-245">프로파일러를 초기화하고, 이벤트 알림을 설정하고, Windows 서비스를 프로파일링하는 방법을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="396d0-245">Explains how to initialize a profiler, set event notifications, and profile a Windows Service.</span></span>|
|[<span data-ttu-id="396d0-246">프로파일링 인터페이스</span><span class="sxs-lookup"><span data-stu-id="396d0-246">Profiling Interfaces</span></span>](profiling-interfaces.md)|<span data-ttu-id="396d0-247">프로파일링 API에서 사용하는 관리되지 않는 인터페이스를 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="396d0-247">Describes the unmanaged interfaces that the profiling API uses.</span></span>|
|[<span data-ttu-id="396d0-248">프로파일링 전역 정적 함수</span><span class="sxs-lookup"><span data-stu-id="396d0-248">Profiling Global Static Functions</span></span>](profiling-global-static-functions.md)|<span data-ttu-id="396d0-249">프로파일링 API에서 사용하는 관리되지 않는 전역 정적 함수를 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="396d0-249">Describes the unmanaged global static functions that the profiling API uses.</span></span>|
|[<span data-ttu-id="396d0-250">프로파일링 열거형</span><span class="sxs-lookup"><span data-stu-id="396d0-250">Profiling Enumerations</span></span>](profiling-enumerations.md)|<span data-ttu-id="396d0-251">프로파일링 API에서 사용하는 관리되지 않는 열거형을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="396d0-251">Describes the unmanaged enumerations that the profiling API uses.</span></span>|
|[<span data-ttu-id="396d0-252">프로파일링 구조체</span><span class="sxs-lookup"><span data-stu-id="396d0-252">Profiling Structures</span></span>](profiling-structures.md)|<span data-ttu-id="396d0-253">프로파일링 API에서 사용하는 관리되지 않는 구조체를 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="396d0-253">Describes the unmanaged structures that the profiling API uses.</span></span>|

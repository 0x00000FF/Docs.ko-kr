---
title: 프로파일링 개요
ms.date: 03/30/2017
helpviewer_keywords:
- managed code, profiling API support
- unmanaged code, combining with managed code in profiling
- notification threads [.NET Framework profiling]
- unmanaged code, profiling
- profiling API [.NET Framework], and COM
- profiling API [.NET Framework], unmanaged code profiling
- profilers, writing
- profiling API [.NET Framework], call stacks
- code profilers, writing
- profiling API [.NET Framework], security considerations
- profiling API [.NET Framework], managed code support
- common language runtime, profiling
- profiling API [.NET Framework], notification threads
- call stacks [.NET Framework profiling]
- profiling API [.NET Framework], stack depth
- common language runtime, writing a profiler
- profiling API [.NET Framework], information retrieval interfaces
- shadow stacks [.NET Framework profiling]
- COM, using in the profiling API
- stack snapshots [.NET Framework profiling]
- profiling API [.NET Framework], supported features
- profiling API [.NET Framework], overview
- security, profiling API considerations
- stack depth [.NET Framework profiling]
ms.assetid: 864c2344-71dc-46f9-96b2-ed59fb6427a8
author: mairaw
ms.author: mairaw
ms.openlocfilehash: b38b64e1c86174bea11086e722ed86b0a0046e2c
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 05/04/2018
ms.locfileid: "33461915"
---
# <a name="profiling-overview"></a><span data-ttu-id="895b7-102">프로파일링 개요</span><span class="sxs-lookup"><span data-stu-id="895b7-102">Profiling Overview</span></span>
<a name="top"></a> <span data-ttu-id="895b7-103">프로파일러는 다른 응용 프로그램의 실행을 모니터링 하는 도구입니다.</span><span class="sxs-lookup"><span data-stu-id="895b7-103">A profiler is a tool that monitors the execution of another application.</span></span> <span data-ttu-id="895b7-104">CLR(공용 언어 런타임) 프로파일러는 프로 파일링 API를 사용하여 CLR에서 메시지를 받고 보내는 함수로 구성된 DLL(동적 연결 라이브러리)입니다.</span><span class="sxs-lookup"><span data-stu-id="895b7-104">A common language runtime (CLR) profiler is a dynamic link library (DLL) that consists of functions that receive messages from, and send messages to, the CLR by using the profiling API.</span></span> <span data-ttu-id="895b7-105">프로파일러 DLL은 런타임에 CLR에 의해 로드됩니다.</span><span class="sxs-lookup"><span data-stu-id="895b7-105">The profiler DLL is loaded by the CLR at run time.</span></span>  
  
 <span data-ttu-id="895b7-106">기존의 프로파일링 도구는 응용 프로그램의 실행 측정에 중점을 둡니다.</span><span class="sxs-lookup"><span data-stu-id="895b7-106">Traditional profiling tools focus on measuring the execution of the application.</span></span> <span data-ttu-id="895b7-107">즉, 각 함수에서 소요된 시간이나 시간 경과에 따른 응용 프로그램의 메모리 사용량을 측정합니다.</span><span class="sxs-lookup"><span data-stu-id="895b7-107">That is, they measure the time that is spent in each function or the memory usage of the application over time.</span></span> <span data-ttu-id="895b7-108">프로파일링 API는 코드 검사 유틸리티 및 고급 디버깅 지원과 같은 광범위한 진단 도구 클래스를 대상으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="895b7-108">The profiling API targets a broader class of diagnostic tools such as code-coverage utilities and even advanced debugging aids.</span></span> <span data-ttu-id="895b7-109">이러한 사용은 본질적으로 모두 진단입니다.</span><span class="sxs-lookup"><span data-stu-id="895b7-109">These uses are all diagnostic in nature.</span></span> <span data-ttu-id="895b7-110">프로파일링 API는 응용 프로그램의 실행을 측정할 뿐 아니라 모니터링합니다.</span><span class="sxs-lookup"><span data-stu-id="895b7-110">The profiling API not only measures but also monitors the execution of an application.</span></span> <span data-ttu-id="895b7-111">이러한 이유로 프로파일링 API는 응용 프로그램 자체에서 사용하면 안 되며, 응용 프로그램의 실행이 프로파일러에 종속되거나 영향을 받아서도 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="895b7-111">For this reason, the profiling API should never be used by the application itself, and the application’s execution should not depend on (or be affected by) the profiler.</span></span>  
  
 <span data-ttu-id="895b7-112">CLR 응용 프로그램을 프로파일링하려면 기존의 컴파일된 기계어 코드를 프로파일링하는 것보다 많은 지원이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="895b7-112">Profiling a CLR application requires more support than profiling conventionally compiled machine code.</span></span> <span data-ttu-id="895b7-113">이는 CLR에서 응용 프로그램 도메인, 가비지 수집, 관리되는 예외 처리, 코드의 JIT(Just-In-Time) 컴파일(Microsoft Intermediate Language, 즉 MSIL 코드를 네이티브 기계어 코드로 변환) 및 비슷한 기능과 같은 개념을 도입하기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="895b7-113">This is because the CLR introduces concepts such as application domains, garbage collection, managed exception handling, just-in-time (JIT) compilation of code (converting Microsoft intermediate language, or MSIL, code into native machine code), and similar features.</span></span> <span data-ttu-id="895b7-114">기존의 프로파일링 메커니즘은 이러한 기능에 대한 유용한 정보를 식별하거나 제공할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="895b7-114">Conventional profiling mechanisms cannot identify or provide useful information about these features.</span></span> <span data-ttu-id="895b7-115">프로파일링 API는 CLR 및 프로파일링된 응용 프로그램의 성능에 미치는 영향을 최소화하여 이 누락된 정보를 효율적으로 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="895b7-115">The profiling API provides this missing information efficiently, with minimal effect on the performance of the CLR and the profiled application.</span></span>  
  
 <span data-ttu-id="895b7-116">런타임의 JIT 컴파일은 프로파일링에 좋은 기회를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="895b7-116">JIT compilation at run time provides good opportunities for profiling.</span></span> <span data-ttu-id="895b7-117">프로파일링 API를 통해 프로파일러는 JIT 컴파일되기 전에 루틴에 대한 메모리 내 MSIL 코드 스트림을 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="895b7-117">The profiling API enables a profiler to change the in-memory MSIL code stream for a routine before it is JIT-compiled.</span></span> <span data-ttu-id="895b7-118">이런 방식으로 프로파일러는 더 세부적인 조사가 필요한 특정 루틴에 계측 코드를 동적으로 추가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="895b7-118">In this manner, the profiler can dynamically add instrumentation code to particular routines that need deeper investigation.</span></span> <span data-ttu-id="895b7-119">이 접근 방식은 기존 시나리오에서도 가능하지만 프로파일링 API를 사용하여 CLR에 대해 구현하는 것이 훨씬 더 쉽습니다.</span><span class="sxs-lookup"><span data-stu-id="895b7-119">Although this approach is possible in conventional scenarios, it is much easier to implement for the CLR by using the profiling API.</span></span>  
  
 <span data-ttu-id="895b7-120">이 개요는 다음과 같은 섹션으로 구성되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="895b7-120">This overview consists of the following sections:</span></span>  
  
-   [<span data-ttu-id="895b7-121">프로 파일링 API</span><span class="sxs-lookup"><span data-stu-id="895b7-121">The Profiling API</span></span>](#profiling_api)  
  
-   [<span data-ttu-id="895b7-122">지원 되는 기능</span><span class="sxs-lookup"><span data-stu-id="895b7-122">Supported Features</span></span>](#support)  
  
-   [<span data-ttu-id="895b7-123">알림 스레드</span><span class="sxs-lookup"><span data-stu-id="895b7-123">Notification Threads</span></span>](#notification_threads)  
  
-   [<span data-ttu-id="895b7-124">보안</span><span class="sxs-lookup"><span data-stu-id="895b7-124">Security</span></span>](#security)  
  
-   [<span data-ttu-id="895b7-125">코드와 비관리 코드 프로파일러에서 코드 결합</span><span class="sxs-lookup"><span data-stu-id="895b7-125">Combining Managed and Unmanaged Code in a Code Profiler</span></span>](#combining_managed_unmanaged)  
  
-   [<span data-ttu-id="895b7-126">비관리 코드 프로 파일링</span><span class="sxs-lookup"><span data-stu-id="895b7-126">Profiling Unmanaged Code</span></span>](#unmanaged)  
  
-   [<span data-ttu-id="895b7-127">COM 사용</span><span class="sxs-lookup"><span data-stu-id="895b7-127">Using COM</span></span>](#com)  
  
-   [<span data-ttu-id="895b7-128">호출 스택</span><span class="sxs-lookup"><span data-stu-id="895b7-128">Call stacks</span></span>](#call_stacks)  
  
-   [<span data-ttu-id="895b7-129">콜백 및 스택 수준</span><span class="sxs-lookup"><span data-stu-id="895b7-129">Callbacks and Stack Depth</span></span>](#callbacks)  
  
-   [<span data-ttu-id="895b7-130">관련 항목</span><span class="sxs-lookup"><span data-stu-id="895b7-130">Related Topics</span></span>](#related_topics)  
  
<a name="profiling_api"></a>   
## <a name="the-profiling-api"></a><span data-ttu-id="895b7-131">프로파일링 API</span><span class="sxs-lookup"><span data-stu-id="895b7-131">The Profiling API</span></span>  
 <span data-ttu-id="895b7-132">프로 파일링 API 쓰는 데 사용 되는 일반적으로 *코드 프로파일러*, 관리 되는 응용 프로그램의 실행을 모니터링 하는 프로그램인 합니다.</span><span class="sxs-lookup"><span data-stu-id="895b7-132">Typically, the profiling API is used to write a *code profiler*, which is a program that monitors the execution of a managed application.</span></span>  
  
 <span data-ttu-id="895b7-133">프로파일링 API는 프로파일링되는 응용 프로그램과 동일한 프로세스에 로드된 프로파일러 DLL에서 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="895b7-133">The profiling API is used by a profiler DLL, which is loaded into the same process as the application that is being profiled.</span></span> <span data-ttu-id="895b7-134">콜백 인터페이스를 구현 하는 프로파일러 DLL ([ICorProfilerCallback](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-interface.md) .NET framework 버전 1.0 및 1.1에서는 [ICorProfilerCallback2](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback2-interface.md) 버전 2.0 이상에서).</span><span class="sxs-lookup"><span data-stu-id="895b7-134">The profiler DLL implements a callback interface ([ICorProfilerCallback](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-interface.md) in the .NET Framework version 1.0 and 1.1, [ICorProfilerCallback2](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback2-interface.md) in version 2.0 and later).</span></span> <span data-ttu-id="895b7-135">CLR은 해당 인터페이스의 메서드를 호출하여 프로파일링된 프로세스의 이벤트를 프로파일러에 알립니다.</span><span class="sxs-lookup"><span data-stu-id="895b7-135">The CLR calls the methods in that interface to notify the profiler of events in the profiled process.</span></span> <span data-ttu-id="895b7-136">프로파일러 수에 콜백 하 여 런타임에에서 메서드를 사용 하는 [ICorProfilerInfo](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo-interface.md) 및 [ICorProfilerInfo2](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo2-interface.md) 프로 파일링 된 응용 프로그램의 상태에 대 한 정보를 가져오는 인터페이스입니다.</span><span class="sxs-lookup"><span data-stu-id="895b7-136">The profiler can call back into the runtime by using the methods in the [ICorProfilerInfo](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo-interface.md) and [ICorProfilerInfo2](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo2-interface.md) interfaces to obtain information about the state of the profiled application.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="895b7-137">프로파일러 솔루션의 데이터 수집 부분만 프로파일링된 응용 프로그램과 동일한 프로세스에서 실행되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="895b7-137">Only the data-gathering part of the profiler solution should be running in the same process as the profiled application.</span></span> <span data-ttu-id="895b7-138">모든 사용자 인터페이스 및 데이터 분석은 별도 프로세스에서 수행되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="895b7-138">All user interface and data analysis should be performed in a separate process.</span></span>  
  
 <span data-ttu-id="895b7-139">다음 그림에서는 프로파일러 DLL이 프로파일링되는 응용 프로그램 및 CLR과 상호 작용하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="895b7-139">The following illustration shows how the profiler DLL interacts with the application that is being profiled and the CLR.</span></span>  
  
 <span data-ttu-id="895b7-140">![프로 파일링 아키텍처](../../../../docs/framework/unmanaged-api/profiling/media/profilingarch.png "ProfilingArch")</span><span class="sxs-lookup"><span data-stu-id="895b7-140">![Profiling Architecture](../../../../docs/framework/unmanaged-api/profiling/media/profilingarch.png "ProfilingArch")</span></span>  
<span data-ttu-id="895b7-141">프로파일링 아키텍처</span><span class="sxs-lookup"><span data-stu-id="895b7-141">Profiling architecture</span></span>  
  
### <a name="the-notification-interfaces"></a><span data-ttu-id="895b7-142">알림 인터페이스</span><span class="sxs-lookup"><span data-stu-id="895b7-142">The Notification Interfaces</span></span>  
 <span data-ttu-id="895b7-143">[ICorProfilerCallback](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-interface.md) 및 [ICorProfilerCallback2](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback2-interface.md) 알림 인터페이스로 간주 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="895b7-143">[ICorProfilerCallback](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-interface.md) and [ICorProfilerCallback2](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback2-interface.md) can be considered notification interfaces.</span></span> <span data-ttu-id="895b7-144">이러한 인터페이스와 같은 방법으로 구성 [ClassLoadStarted](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-classloadstarted-method.md), [ClassLoadFinished](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-classloadfinished-method.md), 및 [JITCompilationStarted](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-jitcompilationstarted-method.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="895b7-144">These interfaces consist of methods such as [ClassLoadStarted](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-classloadstarted-method.md), [ClassLoadFinished](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-classloadfinished-method.md), and [JITCompilationStarted](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-jitcompilationstarted-method.md).</span></span> <span data-ttu-id="895b7-145">CLR은 클래스를 로드 또는 언로드하고 함수를 컴파일할 때마다 프로파일러의 `ICorProfilerCallback` 또는 `ICorProfilerCallback2` 인터페이스에서 해당 메서드를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="895b7-145">Each time the CLR loads or unloads a class, compiles a function, and so on, it calls the corresponding method in the profiler's `ICorProfilerCallback` or `ICorProfilerCallback2` interface.</span></span>  
  
 <span data-ttu-id="895b7-146">프로파일러는 두 알림 기능을 통해 코드 성능을 측정할 수 예를 들어: [FunctionEnter2](../../../../docs/framework/unmanaged-api/profiling/functionenter2-function.md) 및 [FunctionLeave2](../../../../docs/framework/unmanaged-api/profiling/functionleave2-function.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="895b7-146">For example, a profiler could measure code performance through two notification functions: [FunctionEnter2](../../../../docs/framework/unmanaged-api/profiling/functionenter2-function.md) and [FunctionLeave2](../../../../docs/framework/unmanaged-api/profiling/functionleave2-function.md).</span></span> <span data-ttu-id="895b7-147">단순히 각 알림에 타임스탬프를 지정하고, 결과를 누적한 다음 응용 프로그램 실행 중에 가장 많은 CPU 또는 벽시계 시간을 사용한 함수를 나타내는 목록을 출력합니다.</span><span class="sxs-lookup"><span data-stu-id="895b7-147">It just time-stamps each notification, accumulates results, and outputs a list that indicates which functions consumed the most CPU or wall-clock time during the execution of the application.</span></span>  
  
### <a name="the-information-retrieval-interfaces"></a><span data-ttu-id="895b7-148">정보 검색 인터페이스</span><span class="sxs-lookup"><span data-stu-id="895b7-148">The Information Retrieval Interfaces</span></span>  
 <span data-ttu-id="895b7-149">다른 주요 인터페이스 프로 파일링에 관련 된는 [ICorProfilerInfo](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo-interface.md) 및 [ICorProfilerInfo2](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo2-interface.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="895b7-149">The other main interfaces involved in profiling are [ICorProfilerInfo](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo-interface.md) and [ICorProfilerInfo2](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo2-interface.md).</span></span> <span data-ttu-id="895b7-150">프로파일러는 필요에 따라 이러한 인터페이스를 호출하여 분석에 도움이 되는 자세한 정보를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="895b7-150">The profiler calls these interfaces as required to obtain more information to help its analysis.</span></span> <span data-ttu-id="895b7-151">CLR이 호출할 때마다 예를 들어는 [FunctionEnter2](../../../../docs/framework/unmanaged-api/profiling/functionenter2-function.md) 함수를 함수 식별자를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="895b7-151">For example, whenever the CLR calls the [FunctionEnter2](../../../../docs/framework/unmanaged-api/profiling/functionenter2-function.md) function, it supplies a function identifier.</span></span> <span data-ttu-id="895b7-152">프로파일러를 호출 하 여 해당 함수에 대 한 자세한 정보를 얻을 수는 [icorprofilerinfo2:: Getfunctioninfo2](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo2-getfunctioninfo2-method.md) 함수의 부모 클래스, 이름 및 등을 검색 하는 메서드.</span><span class="sxs-lookup"><span data-stu-id="895b7-152">The profiler can get more information about that function by calling the [ICorProfilerInfo2::GetFunctionInfo2](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo2-getfunctioninfo2-method.md) method to discover the function's parent class, its name, and so on.</span></span>  
  
 [<span data-ttu-id="895b7-153">맨 위로 이동</span><span class="sxs-lookup"><span data-stu-id="895b7-153">Back to top</span></span>](#top)  
  
<a name="support"></a>   
## <a name="supported-features"></a><span data-ttu-id="895b7-154">지원되는 기능</span><span class="sxs-lookup"><span data-stu-id="895b7-154">Supported Features</span></span>  
 <span data-ttu-id="895b7-155">프로파일링 API는 공용 언어 런타임에서 발생하는 다양한 이벤트와 작업에 대한 정보를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="895b7-155">The profiling API provides information about a variety of events and actions that occur in the common language runtime.</span></span> <span data-ttu-id="895b7-156">이 정보를 사용하여 프로세스의 내부 작업을 모니터링하고 .NET Framework 응용 프로그램의 성능을 분석할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="895b7-156">You can use this information to monitor the inner workings of processes and to analyze the performance of your .NET Framework application.</span></span>  
  
 <span data-ttu-id="895b7-157">프로파일링 API는 CLR에서 발생하는 다음 작업 및 이벤트에 대한 정보를 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="895b7-157">The profiling API retrieves information about the following actions and events that occur in the CLR:</span></span>  
  
-   <span data-ttu-id="895b7-158">CLR 시작 및 종료 이벤트</span><span class="sxs-lookup"><span data-stu-id="895b7-158">CLR startup and shutdown events.</span></span>  
  
-   <span data-ttu-id="895b7-159">응용 프로그램 도메인 생성 및 종료 이벤트</span><span class="sxs-lookup"><span data-stu-id="895b7-159">Application domain creation and shutdown events.</span></span>  
  
-   <span data-ttu-id="895b7-160">어셈블리 로드 및 언로드 이벤트</span><span class="sxs-lookup"><span data-stu-id="895b7-160">Assembly loading and unloading events.</span></span>  
  
-   <span data-ttu-id="895b7-161">모듈 로드 및 언로드 이벤트</span><span class="sxs-lookup"><span data-stu-id="895b7-161">Module loading and unloading events.</span></span>  
  
-   <span data-ttu-id="895b7-162">COM vtable 생성 및 소멸 이벤트</span><span class="sxs-lookup"><span data-stu-id="895b7-162">COM vtable creation and destruction events.</span></span>  
  
-   <span data-ttu-id="895b7-163">JIT(Just-In-Time) 컴파일 및 코드 피칭 이벤트</span><span class="sxs-lookup"><span data-stu-id="895b7-163">Just-in-time (JIT) compilation and code-pitching events.</span></span>  
  
-   <span data-ttu-id="895b7-164">클래스 로드 및 언로드 이벤트</span><span class="sxs-lookup"><span data-stu-id="895b7-164">Class loading and unloading events.</span></span>  
  
-   <span data-ttu-id="895b7-165">스레드 생성 및 소멸 이벤트</span><span class="sxs-lookup"><span data-stu-id="895b7-165">Thread creation and destruction events.</span></span>  
  
-   <span data-ttu-id="895b7-166">함수 진입 및 종료 이벤트</span><span class="sxs-lookup"><span data-stu-id="895b7-166">Function entry and exit events.</span></span>  
  
-   <span data-ttu-id="895b7-167">예외</span><span class="sxs-lookup"><span data-stu-id="895b7-167">Exceptions.</span></span>  
  
-   <span data-ttu-id="895b7-168">관리 코드와 비관리 코드 실행 간의 전환</span><span class="sxs-lookup"><span data-stu-id="895b7-168">Transitions between managed and unmanaged code execution.</span></span>  
  
-   <span data-ttu-id="895b7-169">다양한 런타임 컨텍스트 간의 전환</span><span class="sxs-lookup"><span data-stu-id="895b7-169">Transitions between different runtime contexts.</span></span>  
  
-   <span data-ttu-id="895b7-170">런타임 일시 중단에 대한 정보</span><span class="sxs-lookup"><span data-stu-id="895b7-170">Information about runtime suspensions.</span></span>  
  
-   <span data-ttu-id="895b7-171">런타임 메모리 힙 및 가비지 수집 작업에 대한 정보</span><span class="sxs-lookup"><span data-stu-id="895b7-171">Information about the runtime memory heap and garbage collection activity.</span></span>  
  
 <span data-ttu-id="895b7-172">모든(관리되지 않는) COM 호환 언어에서 프로파일링 API를 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="895b7-172">The profiling API can be called from any (non-managed) COM-compatible language.</span></span>  
  
 <span data-ttu-id="895b7-173">이 API는 CPU 및 메모리 사용과 관련해서 효율적입니다.</span><span class="sxs-lookup"><span data-stu-id="895b7-173">The API is efficient with regard to CPU and memory consumption.</span></span> <span data-ttu-id="895b7-174">프로파일링에서는 프로파일링된 응용 프로그램에 대해 잘못된 결과를 일으킬 만큼 중요한 변경 작업을 수행하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="895b7-174">Profiling does not involve changes to the profiled application that are significant enough to cause misleading results.</span></span>  
  
 <span data-ttu-id="895b7-175">프로파일링 API는 샘플링 및 비샘플링 프로파일러 둘 다에 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="895b7-175">The profiling API is useful to both sampling and non-sampling profilers.</span></span> <span data-ttu-id="895b7-176">A *샘플링 프로파일러* 는 프로 파일을 검사 일정 한 시계 눈금 예를 들어, 더 많이 떨어져 있는 5 밀리초입니다.</span><span class="sxs-lookup"><span data-stu-id="895b7-176">A *sampling profiler* inspects the profile at regular clock ticks, say, at 5 milliseconds apart.</span></span> <span data-ttu-id="895b7-177">A *비 샘플링 프로파일러* 는 동기적으로 이벤트 및 이벤트를 발생 시키는 스레드에의 한 알림을 받습니다.</span><span class="sxs-lookup"><span data-stu-id="895b7-177">A *non-sampling profiler* is informed of an event synchronously with the thread that causes the event.</span></span>  
  
### <a name="unsupported-functionality"></a><span data-ttu-id="895b7-178">지원되지 않는 기능</span><span class="sxs-lookup"><span data-stu-id="895b7-178">Unsupported Functionality</span></span>  
 <span data-ttu-id="895b7-179">프로파일링 API에서는 다음 기능을 지원하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="895b7-179">The profiling API does not support the following functionality:</span></span>  
  
-   <span data-ttu-id="895b7-180">기존의 Win32 메서드를 통해 프로파일링해야 하는 비관리 코드.</span><span class="sxs-lookup"><span data-stu-id="895b7-180">Unmanaged code, which must be profiled using conventional Win32 methods.</span></span> <span data-ttu-id="895b7-181">그러나 CLR 프로파일러에는 관리 코드와 비관리 코드 간의 경계를 결정하는 전환 이벤트가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="895b7-181">However, the CLR profiler includes transition events to determine the boundaries between managed and unmanaged code.</span></span>  
  
-   <span data-ttu-id="895b7-182">관점 지향 프로그래밍과 같은 목적을 위해 해당 코드를 수정하는 자체 수정 응용 프로그램</span><span class="sxs-lookup"><span data-stu-id="895b7-182">Self-modifying applications that modify their own code for purposes such as aspect-oriented programming.</span></span>  
  
-   <span data-ttu-id="895b7-183">범위 검사. 프로파일링 API에서 이 정보를 제공하지 않기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="895b7-183">Bounds checking, because the profiling API does not provide this information.</span></span> <span data-ttu-id="895b7-184">CLR은 모든 관리 코드의 범위 검사를 기본적으로 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="895b7-184">The CLR provides intrinsic support for bounds checking of all managed code.</span></span>  
  
-   <span data-ttu-id="895b7-185">원격 프로파일링. 다음과 같은 이유로 지원되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="895b7-185">Remote profiling, which is not supported for the following reasons:</span></span>  
  
    -   <span data-ttu-id="895b7-186">원격 프로파일링은 실행 시간을 연장합니다.</span><span class="sxs-lookup"><span data-stu-id="895b7-186">Remote profiling extends execution time.</span></span> <span data-ttu-id="895b7-187">프로파일링 인터페이스를 사용하는 경우 프로파일링 결과가 과도한 영향을 받지 않도록 실행 시간을 최소화해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="895b7-187">When you use the profiling interfaces, you must minimize execution time so that profiling results will not be unduly affected.</span></span> <span data-ttu-id="895b7-188">이는 실행 성능을 모니터링하는 경우 특히 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="895b7-188">This is especially true when execution performance is being monitored.</span></span> <span data-ttu-id="895b7-189">그러나 원격 프로파일링은 프로파일링 인터페이스를 사용하여 메모리 사용량을 모니터링하거나 스택 프레임, 개체 등에 대한 런타임 정보를 가져올 때 제한 사항이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="895b7-189">However, remote profiling is not a limitation when the profiling interfaces are used to monitor memory usage or to obtain run-time information about stack frames, objects, and so on.</span></span>  
  
    -   <span data-ttu-id="895b7-190">CLR 코드 프로파일러는 프로파일링된 응용 프로그램이 실행되고 있는 로컬 컴퓨터에서 런타임에 하나 이상의 콜백 인터페이스를 등록해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="895b7-190">The CLR code profiler must register one or more callback interfaces with the runtime on the local computer on which the profiled application is running.</span></span> <span data-ttu-id="895b7-191">이로 인해 원격 코드 프로파일러를 만드는 기능이 제한됩니다.</span><span class="sxs-lookup"><span data-stu-id="895b7-191">This limits the ability to create a remote code profiler.</span></span>  
  
-   <span data-ttu-id="895b7-192">고가용성 요구 사항이 있는 프로덕션 환경의 프로파일링.</span><span class="sxs-lookup"><span data-stu-id="895b7-192">Profiling in production environments with high-availability requirements.</span></span> <span data-ttu-id="895b7-193">프로파일링 API는 개발 시 진단을 지원하기 위해 만들어졌습니다.</span><span class="sxs-lookup"><span data-stu-id="895b7-193">The profiling API was created to support development-time diagnostics.</span></span> <span data-ttu-id="895b7-194">프로덕션 환경을 지원하는 데 필요한 엄격한 테스트를 받지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="895b7-194">It has not undergone the rigorous testing required to support production environments.</span></span>  
  
 [<span data-ttu-id="895b7-195">맨 위로 이동</span><span class="sxs-lookup"><span data-stu-id="895b7-195">Back to top</span></span>](#top)  
  
<a name="notification_threads"></a>   
## <a name="notification-threads"></a><span data-ttu-id="895b7-196">알림 스레드</span><span class="sxs-lookup"><span data-stu-id="895b7-196">Notification Threads</span></span>  
 <span data-ttu-id="895b7-197">대부분의 경우 이벤트를 생성하는 스레드도 알림을 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="895b7-197">In most cases, the thread that generates an event also executes notifications.</span></span> <span data-ttu-id="895b7-198">이러한 알림 (예를 들어 [FunctionEnter](../../../../docs/framework/unmanaged-api/profiling/functionenter-function.md) 및 [FunctionLeave](../../../../docs/framework/unmanaged-api/profiling/functionleave-function.md)) 명시적 제공할 필요가 없습니다 `ThreadID`합니다.</span><span class="sxs-lookup"><span data-stu-id="895b7-198">Such notifications (for example, [FunctionEnter](../../../../docs/framework/unmanaged-api/profiling/functionenter-function.md) and [FunctionLeave](../../../../docs/framework/unmanaged-api/profiling/functionleave-function.md)) do not need to supply the explicit `ThreadID`.</span></span> <span data-ttu-id="895b7-199">또한 프로파일러는 영향을 받는 스레드의 `ThreadID`에 따라, 전역 저장소의 분석 블록을 인덱싱하는 대신 스레드 로컬 저장소를 사용하여 분석 블록을 저장 및 업데이트할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="895b7-199">Also, the profiler might decide to use thread-local storage to store and update its analysis blocks instead of indexing the analysis blocks in global storage, based on the `ThreadID` of the affected thread.</span></span>  
  
 <span data-ttu-id="895b7-200">이러한 콜백은 직렬화되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="895b7-200">Note that these callbacks are not serialized.</span></span> <span data-ttu-id="895b7-201">사용자는 스레드로부터 안전한 데이터 구조를 만들고 여러 스레드에서의 병렬 액세스를 방지하기 위해 필요에 따라 프로파일러 코드를 잠가 코드를 보호해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="895b7-201">Users must protect their code by creating thread-safe data structures and by locking the profiler code where necessary to prevent parallel access from multiple threads.</span></span> <span data-ttu-id="895b7-202">따라서 특정 경우에서는 사용자가 평소와 다른 콜백 시퀀스를 받을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="895b7-202">Therefore, in certain cases you can receive an unusual sequence of callbacks.</span></span> <span data-ttu-id="895b7-203">예를 들어 관리되는 응용 프로그램이 동일한 코드를 실행하는 두 스레드를 생성한다고 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="895b7-203">For example, assume that a managed application is spawning two threads that are executing identical code.</span></span> <span data-ttu-id="895b7-204">이 경우에 받을 수는 [icorprofilercallback:: Jitcompilationstarted](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-jitcompilationstarted-method.md) 한 스레드에서 일부 함수에 대 한 이벤트 및 `FunctionEnter` 콜백을 받기 전에 다른 스레드에서 [ Icorprofilercallback:: Jitcompilationfinished](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-jitcompilationfinished-method.md) 콜백 합니다.</span><span class="sxs-lookup"><span data-stu-id="895b7-204">In this case, it is possible to receive a [ICorProfilerCallback::JITCompilationStarted](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-jitcompilationstarted-method.md) event for some function from one thread and a `FunctionEnter` callback from the other thread before receiving the [ICorProfilerCallback::JITCompilationFinished](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-jitcompilationfinished-method.md) callback.</span></span> <span data-ttu-id="895b7-205">이 경우에는 사용자가 아직 완전히 JIT(Just-In-Time) 컴파일되지 않았을 수 있는 함수에 대해 `FunctionEnter` 콜백을 받는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="895b7-205">In this case, the user will receive a `FunctionEnter` callback for a function that may not have been fully just-in-time (JIT) compiled yet.</span></span>  
  
 [<span data-ttu-id="895b7-206">맨 위로 이동</span><span class="sxs-lookup"><span data-stu-id="895b7-206">Back to top</span></span>](#top)  
  
<a name="security"></a>   
## <a name="security"></a><span data-ttu-id="895b7-207">보안</span><span class="sxs-lookup"><span data-stu-id="895b7-207">Security</span></span>  
 <span data-ttu-id="895b7-208">프로파일러 DLL은 공용 언어 런타임 실행 엔진의 일부로 실행되는 관리되지 않는 DLL입니다.</span><span class="sxs-lookup"><span data-stu-id="895b7-208">A profiler DLL is an unmanaged DLL that runs as part of the common language runtime execution engine.</span></span> <span data-ttu-id="895b7-209">따라서 프로파일러 DLL의 코드에 관리 코드 액세스 보안의 제한이 적용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="895b7-209">As a result, the code in the profiler DLL is not subject to the restrictions of managed code access security.</span></span> <span data-ttu-id="895b7-210">프로파일러 DLL에 대한 유일한 제한 사항은 운영 체제에서 프로파일링된 응용 프로그램을 실행하는 사용자에 대해 적용하는 제한입니다.</span><span class="sxs-lookup"><span data-stu-id="895b7-210">The only limitations on the profiler DLL are those imposed by the operating system on the user who is running the profiled application.</span></span>  
  
 <span data-ttu-id="895b7-211">프로파일러 작성자는 보안 관련 문제를 방지하기 위해 적절한 예방 조치를 취해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="895b7-211">Profiler authors should take appropriate precautions to avoid security-related issues.</span></span> <span data-ttu-id="895b7-212">예를 들어 악의적인 사용자가 수정할 수 없도록 설치 중에 프로파일러 DLL을 ACL(액세스 제어 목록)에 추가해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="895b7-212">For example, during installation, a profiler DLL should be added to an access control list (ACL) so that a malicious user cannot modify it.</span></span>  
  
 [<span data-ttu-id="895b7-213">맨 위로 이동</span><span class="sxs-lookup"><span data-stu-id="895b7-213">Back to top</span></span>](#top)  
  
<a name="combining_managed_unmanaged"></a>   
## <a name="combining-managed-and-unmanaged-code-in-a-code-profiler"></a><span data-ttu-id="895b7-214">코드 프로파일러에서 관리 코드와 비관리 코드 결합</span><span class="sxs-lookup"><span data-stu-id="895b7-214">Combining Managed and Unmanaged Code in a Code Profiler</span></span>  
 <span data-ttu-id="895b7-215">잘못 작성된 프로파일러는 자체 순환 참조를 생성하여 예기치 않은 동작이 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="895b7-215">An incorrectly written profiler can cause circular references to itself, resulting in unpredictable behavior.</span></span>  
  
 <span data-ttu-id="895b7-216">CLR 프로파일링 API를 검토하면 COM interop 또는 간접 호출을 통해 서로 호출하는 관리되는 구성 요소와 관리되지 않는 구성 요소를 포함하는 프로파일러를 작성할 수 있다는 인상을 받을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="895b7-216">A review of the CLR profiling API may create the impression that you can write a profiler that contains managed and unmanaged components that call each other through COM interop or indirect calls.</span></span>  
  
 <span data-ttu-id="895b7-217">디자인 관점에서는 가능하지만 프로파일링 API는 관리되는 구성 요소를 지원하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="895b7-217">Although this is possible from a design perspective, the profiling API does not support managed components.</span></span> <span data-ttu-id="895b7-218">CLR 프로파일러는 완전히 관리되지 않아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="895b7-218">A CLR profiler must be completely unmanaged.</span></span> <span data-ttu-id="895b7-219">CLR 프로파일러에서 관리 코드와 비관리 코드를 결합하려고 하면 액세스 위반, 프로그램 오류 또는 교착 상태가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="895b7-219">Attempts to combine managed and unmanaged code in a CLR profiler may cause access violations, program failure, or deadlocks.</span></span> <span data-ttu-id="895b7-220">프로파일러의 관리되는 구성 요소는 관리되지 않는 해당 구성 요소로 다시 이벤트를 발생시키고, 이후에 이 구성 요소가 관리되는 구성 요소를 다시 호출하여 순환 참조가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="895b7-220">The managed components of the profiler will fire events back to their unmanaged components, which would subsequently call the managed components again, resulting in circular references.</span></span>  
  
 <span data-ttu-id="895b7-221">CLR 프로파일러가 관리 코드를 안전하게 호출할 수 있는 유일한 위치는 메서드의 MSIL(Microsoft Intermediate Language) 본문입니다.</span><span class="sxs-lookup"><span data-stu-id="895b7-221">The only location where a CLR profiler can call managed code safely is in the Microsoft intermediate language (MSIL) body of a method.</span></span> <span data-ttu-id="895b7-222">MSIL 본문을 수정 하기 위한 권장된 방법에서 JIT 재컴파일 메서드를 사용 하는 것은 [ICorProfilerCallback4](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback4-interface.md) 인터페이스입니다.</span><span class="sxs-lookup"><span data-stu-id="895b7-222">The recommended practice for modifying the MSIL body is to use the  JIT recompilation methods in the [ICorProfilerCallback4](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback4-interface.md) interface.</span></span>  
  
 <span data-ttu-id="895b7-223">오래된 계측 메서드를 사용하여 MSIL을 수정할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="895b7-223">It is also possible to use the older instrumentation methods to modify MSIL.</span></span> <span data-ttu-id="895b7-224">프로파일러는 메서드 및 다음 JIT 컴파일 MSIL 본문에 관리 되는 호출을 삽입할 수 함수의 컴파일 타임 JIT ()이 완료 되기 전에 것 (참조는 [icorprofilerinfo:: Getilfunctionbody](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo-getilfunctionbody-method.md) 메서드).</span><span class="sxs-lookup"><span data-stu-id="895b7-224">Before the just-in-time (JIT) compilation of a function is completed, the profiler can insert managed calls in the MSIL body of a method and then JIT-compile it (see the [ICorProfilerInfo::GetILFunctionBody](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo-getilfunctionbody-method.md) method).</span></span> <span data-ttu-id="895b7-225">이 기술은 관리 코드의 선택적 계측이나 JIT에 대한 통계 및 성능 데이터 수집을 위해 성공적으로 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="895b7-225">This technique can successfully be used for selective instrumentation of managed code, or to gather statistics and performance data about the JIT.</span></span>  
  
 <span data-ttu-id="895b7-226">또는 코드 프로파일러가 비관리 코드를 호출하는 모든 관리되는 함수의 MSIL 본문에 네이티브 후크를 삽입할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="895b7-226">Alternatively, a code profiler can insert native hooks in the MSIL body of every managed function that calls into unmanaged code.</span></span> <span data-ttu-id="895b7-227">이 기술은 계측 및 검사에 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="895b7-227">This technique can be used for instrumentation and coverage.</span></span> <span data-ttu-id="895b7-228">예를 들어 코드 프로파일러가 모든 MSIL 블록 뒤에 계측 후크를 삽입하여 블록이 실행되었는지 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="895b7-228">For example, a code profiler could insert instrumentation hooks after every MSIL block to ensure that the block has been executed.</span></span> <span data-ttu-id="895b7-229">메서드의 MSIL 본문 수정은 매우 정교한 작업이며 여러 가지 요인을 고려해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="895b7-229">The modification of the MSIL body of a method is a very delicate operation, and there are many factors that should be taken into consideration.</span></span>  
  
 [<span data-ttu-id="895b7-230">맨 위로 이동</span><span class="sxs-lookup"><span data-stu-id="895b7-230">Back to top</span></span>](#top)  
  
<a name="unmanaged"></a>   
## <a name="profiling-unmanaged-code"></a><span data-ttu-id="895b7-231">비관리 코드 프로파일링</span><span class="sxs-lookup"><span data-stu-id="895b7-231">Profiling Unmanaged Code</span></span>  
 <span data-ttu-id="895b7-232">CLR(공용 언어 런타임) 프로파일링 API는 비관리 코드 프로파일링에 대해 최소한의 지원을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="895b7-232">The common language runtime (CLR) profiling API provides minimal support for profiling unmanaged code.</span></span> <span data-ttu-id="895b7-233">다음 기능이 제공됩니다.</span><span class="sxs-lookup"><span data-stu-id="895b7-233">The following functionality is provided:</span></span>  
  
-   <span data-ttu-id="895b7-234">스택 체인 열거형.</span><span class="sxs-lookup"><span data-stu-id="895b7-234">Enumeration of stack chains.</span></span> <span data-ttu-id="895b7-235">이 기능을 통해 코드 프로파일러는 관리 코드와 비관리 코드 사이의 경계를 결정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="895b7-235">This feature enables a code profiler to determine the boundary between managed code and unmanaged code.</span></span>  
  
-   <span data-ttu-id="895b7-236">스택 체인이 관리 코드에 해당하는지 또는 네이티브 코드에 해당하는지를 결정합니다.</span><span class="sxs-lookup"><span data-stu-id="895b7-236">Determination whether a stack chain corresponds to managed code or native code.</span></span>  
  
 <span data-ttu-id="895b7-237">.NET Framework 버전 1.0 및 1.1에서는 CLR 디버깅 API의 in-process 하위 집합을 통해 이러한 메서드를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="895b7-237">In the .NET Framework versions 1.0 and 1.1, these methods are available through the in-process subset of the CLR debugging API.</span></span> <span data-ttu-id="895b7-238">CorDebug.idl 파일에서 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="895b7-238">They are defined in the CorDebug.idl file.</span></span>  
  
 <span data-ttu-id="895b7-239">.NET Framework 2.0에서 이상 버전에서는 사용할 수 있습니다는 [icorprofilerinfo2:: Dostacksnapshot](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo2-dostacksnapshot-method.md) 이 기능에 대 한 메서드.</span><span class="sxs-lookup"><span data-stu-id="895b7-239">In the .NET Framework 2.0 and later, you can use the [ICorProfilerInfo2::DoStackSnapshot](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo2-dostacksnapshot-method.md) method for this functionality.</span></span>  
  
 [<span data-ttu-id="895b7-240">맨 위로 이동</span><span class="sxs-lookup"><span data-stu-id="895b7-240">Back to top</span></span>](#top)  
  
<a name="com"></a>   
## <a name="using-com"></a><span data-ttu-id="895b7-241">COM 사용</span><span class="sxs-lookup"><span data-stu-id="895b7-241">Using COM</span></span>  
 <span data-ttu-id="895b7-242">프로파일링 인터페이스는 COM 인터페이스로 정의되지만 CLR(공용 언어 런타임)에서 실제로 이러한 인터페이스를 사용하도록 COM를 초기화하지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="895b7-242">Although the profiling interfaces are defined as COM interfaces, the common language runtime (CLR) does not actually initialize COM to use these interfaces.</span></span> <span data-ttu-id="895b7-243">사용 하 여 스레딩 모델을 설정 하지 않도록 하기 위해서입니다는 [CoInitialize](http://msdn.microsoft.com/library/windows/desktop/ms678543\(v=vs.85\).aspx) 관리 되는 응용 프로그램에는 필요한 스레딩 모델을 지정 하기 전에 작동 합니다.</span><span class="sxs-lookup"><span data-stu-id="895b7-243">The reason is to avoid having to set the threading model by using the [CoInitialize](http://msdn.microsoft.com/library/windows/desktop/ms678543\(v=vs.85\).aspx) function before the managed application has had a chance to specify its desired threading model.</span></span> <span data-ttu-id="895b7-244">마찬가지로, 프로파일러 자체는 프로파일링되는 응용 프로그램과 호환되지 않는 스레딩 모델을 선택하여 응용 프로그램이 실패하게 만들 수 있으므로 `CoInitialize`를 호출하면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="895b7-244">Similarly, the profiler itself should not call `CoInitialize`, because it may pick a threading model that is incompatible with the application being profiled and may cause the application to fail.</span></span>  
  
 [<span data-ttu-id="895b7-245">맨 위로 이동</span><span class="sxs-lookup"><span data-stu-id="895b7-245">Back to top</span></span>](#top)  
  
<a name="call_stacks"></a>   
## <a name="call-stacks"></a><span data-ttu-id="895b7-246">호출 스택</span><span class="sxs-lookup"><span data-stu-id="895b7-246">Call Stacks</span></span>  
 <span data-ttu-id="895b7-247">프로파일링 API는 호출 스택을 가져오는 두 가지 방법을 제공합니다. 스택 스냅숏 메서드는 호출 스택의 스파스 수집을 가능하게 하고 섀도 스택 메서드는 모든 순간에 호출 스택을 추적합니다.</span><span class="sxs-lookup"><span data-stu-id="895b7-247">The profiling API provides two ways to obtain call stacks: a stack snapshot method, which enables sparse gathering of call stacks, and a shadow stack method, which tracks the call stack at every instant.</span></span>  
  
### <a name="stack-snapshot"></a><span data-ttu-id="895b7-248">스택 스냅숏</span><span class="sxs-lookup"><span data-stu-id="895b7-248">Stack Snapshot</span></span>  
 <span data-ttu-id="895b7-249">스택 스냅숏은 한 순간의 스레드 스택 추적입니다.</span><span class="sxs-lookup"><span data-stu-id="895b7-249">A stack snapshot is a trace of the stack of a thread at an instant in time.</span></span> <span data-ttu-id="895b7-250">프로파일링 API는 스택에서 관리되는 함수의 추적을 지원하지만 관리되지 않는 함수의 추적은 프로파일러의 자체 스택 워크에 맡깁니다.</span><span class="sxs-lookup"><span data-stu-id="895b7-250">The profiling API supports the tracing of managed functions on the stack, but it leaves the tracing of unmanaged functions to the profiler's own stack walker.</span></span>  
  
 <span data-ttu-id="895b7-251">프로파일러는 관리 되는 스택 워크를 프로그래밍 하는 방법에 대 한 자세한 내용은 참조는 [icorprofilerinfo2:: Dostacksnapshot](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo2-dostacksnapshot-method.md) 이 설명서 집합에서 메서드 및 [.NET Framework 2.0의 프로파일러 스택 워크: 기본 사항 및 기능 이외에](http://go.microsoft.com/fwlink/?LinkId=73638)합니다.</span><span class="sxs-lookup"><span data-stu-id="895b7-251">For more information about how to program the profiler to walk managed stacks, see the [ICorProfilerInfo2::DoStackSnapshot](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo2-dostacksnapshot-method.md) method in this documentation set, and [Profiler Stack Walking in the .NET Framework 2.0: Basics and Beyond](http://go.microsoft.com/fwlink/?LinkId=73638).</span></span>
  
### <a name="shadow-stack"></a><span data-ttu-id="895b7-252">섀도 스택</span><span class="sxs-lookup"><span data-stu-id="895b7-252">Shadow Stack</span></span>  
 <span data-ttu-id="895b7-253">스냅숏 메서드를 너무 자주 사용하면 성능 문제가 빠르게 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="895b7-253">Using the snapshot method too frequently can quickly create a performance issue.</span></span> <span data-ttu-id="895b7-254">프로파일러를 사용 하 여 섀도 스택을 생성할 대신 해야 스택 추적을 자주 수행 하려는 경우는 [FunctionEnter2](../../../../docs/framework/unmanaged-api/profiling/functionenter2-function.md), [FunctionLeave2](../../../../docs/framework/unmanaged-api/profiling/functionleave2-function.md), [FunctionTailcall2](../../../../docs/framework/unmanaged-api/profiling/functiontailcall2-function.md), 및 [ICorProfilerCallback2](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback2-interface.md) 예외 콜백을 합니다.</span><span class="sxs-lookup"><span data-stu-id="895b7-254">If you want to take stack traces frequently, your profiler should instead build a shadow stack by using the [FunctionEnter2](../../../../docs/framework/unmanaged-api/profiling/functionenter2-function.md), [FunctionLeave2](../../../../docs/framework/unmanaged-api/profiling/functionleave2-function.md), [FunctionTailcall2](../../../../docs/framework/unmanaged-api/profiling/functiontailcall2-function.md), and [ICorProfilerCallback2](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback2-interface.md) exception callbacks.</span></span> <span data-ttu-id="895b7-255">섀도 스택은 항상 최신 상태이며 스택 스냅숏이 필요할 때마다 저장소로 빠르게 복사될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="895b7-255">The shadow stack is always current and can quickly be copied to storage whenever a stack snapshot is needed.</span></span>  
  
 <span data-ttu-id="895b7-256">섀도 스택은 함수 인수, 반환 값 및 제네릭 인스턴스화에 대한 정보를 얻을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="895b7-256">A shadow stack may obtain function arguments, return values, and information about generic instantiations.</span></span> <span data-ttu-id="895b7-257">이 정보는 섀도 스택을 통해서만 제공되며 컨트롤이 함수에 전달될 때 얻을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="895b7-257">This information is available only through the shadow stack and may be obtained when control is handed to a function.</span></span> <span data-ttu-id="895b7-258">그러나 나중에 함수 실행 중에는 이 정보는 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="895b7-258">However, this information may not be available later during the run of the function.</span></span>  
  
 [<span data-ttu-id="895b7-259">맨 위로 이동</span><span class="sxs-lookup"><span data-stu-id="895b7-259">Back to top</span></span>](#top)  
  
<a name="callbacks"></a>   
## <a name="callbacks-and-stack-depth"></a><span data-ttu-id="895b7-260">콜백 및 스택 수준</span><span class="sxs-lookup"><span data-stu-id="895b7-260">Callbacks and Stack Depth</span></span>  
 <span data-ttu-id="895b7-261">프로파일러 콜백은 스택이 매우 제한된 환경에서 실행할 수 있으며, 프로파일러 콜백의 스택 오버플로로 인해 즉시 프로세스가 종료됩니다.</span><span class="sxs-lookup"><span data-stu-id="895b7-261">Profiler callbacks may be issued in very stack-constrained circumstances, and a stack overflow in a profiler callback will lead to an immediate process exit.</span></span> <span data-ttu-id="895b7-262">프로파일러는 콜백에 대한 응답으로 가능한 한 적은 스택을 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="895b7-262">A profiler should make sure to use as little stack as possible in response to callbacks.</span></span> <span data-ttu-id="895b7-263">프로파일러가 스택 오버플로에 대해 강력한 프로세스에 사용하기 위한 것이면 프로파일러 자체에서 스택 오버플로 트리거도 피해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="895b7-263">If the profiler is intended for use against processes that are robust against stack overflow, the profiler itself should also avoid triggering stack overflow.</span></span>  
  
 [<span data-ttu-id="895b7-264">맨 위로 이동</span><span class="sxs-lookup"><span data-stu-id="895b7-264">Back to top</span></span>](#top)  
  
<a name="related_topics"></a>   
## <a name="related-topics"></a><span data-ttu-id="895b7-265">관련 항목</span><span class="sxs-lookup"><span data-stu-id="895b7-265">Related Topics</span></span>  
  
|<span data-ttu-id="895b7-266">제목</span><span class="sxs-lookup"><span data-stu-id="895b7-266">Title</span></span>|<span data-ttu-id="895b7-267">설명</span><span class="sxs-lookup"><span data-stu-id="895b7-267">Description</span></span>|  
|-----------|-----------------|  
|[<span data-ttu-id="895b7-268">프로파일링 환경 설정</span><span class="sxs-lookup"><span data-stu-id="895b7-268">Setting Up a Profiling Environment</span></span>](../../../../docs/framework/unmanaged-api/profiling/setting-up-a-profiling-environment.md)|<span data-ttu-id="895b7-269">프로파일러를 초기화하고, 이벤트 알림을 설정하고, Windows 서비스를 프로파일링하는 방법을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="895b7-269">Explains how to initialize a profiler, set event notifications, and profile a Windows Service.</span></span>|  
|[<span data-ttu-id="895b7-270">프로파일링 인터페이스</span><span class="sxs-lookup"><span data-stu-id="895b7-270">Profiling Interfaces</span></span>](../../../../docs/framework/unmanaged-api/profiling/profiling-interfaces.md)|<span data-ttu-id="895b7-271">프로파일링 API에서 사용하는 관리되지 않는 인터페이스를 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="895b7-271">Describes the unmanaged interfaces that the profiling API uses.</span></span>|  
|[<span data-ttu-id="895b7-272">프로파일링 전역 정적 함수</span><span class="sxs-lookup"><span data-stu-id="895b7-272">Profiling Global Static Functions</span></span>](../../../../docs/framework/unmanaged-api/profiling/profiling-global-static-functions.md)|<span data-ttu-id="895b7-273">프로파일링 API에서 사용하는 관리되지 않는 전역 정적 함수를 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="895b7-273">Describes the unmanaged global static functions that the profiling API uses.</span></span>|  
|[<span data-ttu-id="895b7-274">프로파일링 열거형</span><span class="sxs-lookup"><span data-stu-id="895b7-274">Profiling Enumerations</span></span>](../../../../docs/framework/unmanaged-api/profiling/profiling-enumerations.md)|<span data-ttu-id="895b7-275">프로파일링 API에서 사용하는 관리되지 않는 열거형을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="895b7-275">Describes the unmanaged enumerations that the profiling API uses.</span></span>|  
|[<span data-ttu-id="895b7-276">프로파일링 구조체</span><span class="sxs-lookup"><span data-stu-id="895b7-276">Profiling Structures</span></span>](../../../../docs/framework/unmanaged-api/profiling/profiling-structures.md)|<span data-ttu-id="895b7-277">프로파일링 API에서 사용하는 관리되지 않는 구조체를 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="895b7-277">Describes the unmanaged structures that the profiling API uses.</span></span>|

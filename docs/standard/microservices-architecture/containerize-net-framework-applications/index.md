---
title: Windows 컨테이너로 레거시 모놀리식 .NET Framework 응용 프로그램 마이그레이션
description: 컨테이너화된 .NET 응용 프로그램을 위한 .NET 마이크로 서비스 아키텍처 | Windows 컨테이너로 레거시 모놀리식 .NET Framework 응용 프로그램 마이그레이션
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 05/26/2017
ms.openlocfilehash: a12012f115629a79734c18c3bc75733ae2fc8195
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 05/04/2018
ms.locfileid: "33578835"
---
# <a name="migrating-legacy-monolithic-net-framework-applications-to-windows-containers"></a><span data-ttu-id="c8dc0-103">Windows 컨테이너로 레거시 모놀리식 .NET Framework 응용 프로그램 마이그레이션</span><span class="sxs-lookup"><span data-stu-id="c8dc0-103">Migrating Legacy Monolithic .NET Framework Applications to Windows Containers</span></span>

<span data-ttu-id="c8dc0-104">*Windows 컨테이너는 개발 및 테스트 환경을 향상하는 방법 및 Web* *Forms와 같은 레거시 .NET Framework 기술을 기반으로 하는 응용 프로그램을 배포하는 방법으로 사용할 수 있습니다. 이러한 방식으로 레거시 응용 프로그램에 컨테이너를 사용하는 것을 “리프트 앤 시프트” 시나리오라고 합니다.*</span><span class="sxs-lookup"><span data-stu-id="c8dc0-104">*Windows Containers can be used as a way to improve development and test environments, and to deploy applications that are based on legacy .NET Framework technologies like Web* *Forms. Using containers for legacy applications in this way is referred to as a “lift and shift” scenario.*</span></span>

<span data-ttu-id="c8dc0-105">이 가이드의 이전 섹션에서는 비즈니스 응용 프로그램이 각각 소규모의 집중적인 서비스를 실행하는 서로 다른 컨테이너 사이에 배포되는 마이크로 서비스 아키텍처를 긍정적으로 설명했습니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-105">Earlier sections of this guide have championed a microservices architecture where business applications are distributed among different containers, each running a small, focused service.</span></span> <span data-ttu-id="c8dc0-106">그 목표에는 많은 이점이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-106">That goal has many benefits.</span></span> <span data-ttu-id="c8dc0-107">새로운 개발에서는 이러한 접근 방식을 적극적으로 권장합니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-107">In new development, that approach is strongly recommended.</span></span> <span data-ttu-id="c8dc0-108">또한 엔터프라이즈에 중요한 응용 프로그램은 아키텍처 및 구현을 다시 수행하는 비용을 감수할 수 있을 만큼 충분히 유익합니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-108">Enterprise-critical applications will also benefit enough to justify the cost of a rearchitecture and reimplementation.</span></span>

<span data-ttu-id="c8dc0-109">그러나 일부 응용 프로그램은 비용을 감수할 정도로 충분히 유익하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-109">But not every application will benefit enough to justify the cost.</span></span> <span data-ttu-id="c8dc0-110">그렇다고 해서 해당 응용 프로그램을 컨테이너 시나리오에서 사용할 수 없다는 의미는 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-110">That does not mean that those applications cannot be used in container scenarios.</span></span>

<span data-ttu-id="c8dc0-111">이 섹션에서는 그림 7-1에 나와 있는 eShopOnContainers 응용 프로그램을 살펴보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-111">In this section, we will explore an application for eShopOnContainers, shown in Figure 7-1.</span></span> <span data-ttu-id="c8dc0-112">이 응용 프로그램은 eShopOnContainers 엔터프라이즈 팀의 구성원이 제품 카탈로그를 보고 편집하는 데 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-112">This application would be used by members of the eShopOnContainers enterprise team to view and edit the product catalog.</span></span>

![](./media/image1.png)

<span data-ttu-id="c8dc0-113">**그림 7-1**.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-113">**Figure 7-1**.</span></span> <span data-ttu-id="c8dc0-114">Windows 컨테이너의 ASP.NET Web Forms 응용 프로그램(레거시 기술)</span><span class="sxs-lookup"><span data-stu-id="c8dc0-114">ASP.NET Web Forms application (legacy technology) on a Windows Container</span></span>

<span data-ttu-id="c8dc0-115">이 응용 프로그램은 카탈로그 항목을 찾아보고 수정하는 데 사용하는 Web Forms 응용 프로그램입니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-115">This is a Web Forms application that is used to browse and modify the catalog entries.</span></span> <span data-ttu-id="c8dc0-116">Web Forms 종속성은 이 응용 프로그램이 Web Forms 없이 다시 작성되지 않고 대신 ASP.NET Core MVC를 사용하지 않는 한 .NET Core에서 실행되지 않는다는 것을 의미합니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-116">The Web Forms dependency means this application will not run on .NET Core unless it is rewritten without Web Forms and instead uses ASP.NET Core MVC.</span></span> <span data-ttu-id="c8dc0-117">여러분은 변경 없이 컨테이너에서 이러한 응용 프로그램을 실행하는 방법을 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-117">You will see how you can run applications like these in containers without changes.</span></span> <span data-ttu-id="c8dc0-118">또한 일부 기능이 별도의 마이크로 서비스로 이동되었지만 대부분의 기능은 모놀리식 응용 프로그램에 그대로 남아 있는 하이브리드 모드에서 작업할 수 있도록 최소한의 변경만 수행할 수 있는 방법도 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-118">You will also see how you can make minimal changes to work in a hybrid mode where some functionality has been moved into a separate microservice, but most functionality remains in the monolithic application.</span></span>

## <a name="benefits-of-containerizing-a-monolithic-application"></a><span data-ttu-id="c8dc0-119">모놀리식 응용 프로그램을 컨테이너화할 경우의 이점</span><span class="sxs-lookup"><span data-stu-id="c8dc0-119">Benefits of containerizing a monolithic application</span></span>

<span data-ttu-id="c8dc0-120">Catalog.WebForms 응용 프로그램은 eShopOnContainers GitHub 리포지토리(<https://github.com/dotnet/eShopOnContainers>)에 제공됩니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-120">The Catalog.WebForms application is available in the eShopOnContainers GitHub repository (<https://github.com/dotnet/eShopOnContainers>).</span></span> <span data-ttu-id="c8dc0-121">이 응용 프로그램은 고가용성 데이터 저장소에 액세스하는 독립 실행형 웹 응용 프로그램입니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-121">This application is a standalone web application accessing a high-availability data store.</span></span> <span data-ttu-id="c8dc0-122">그렇기는 하지만, 컨테이너에서 응용 프로그램을 실행하면 이점이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-122">Even so, there are advantages to running the application in a container.</span></span> <span data-ttu-id="c8dc0-123">응용 프로그램의 이미지를 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-123">You create an image for the application.</span></span> <span data-ttu-id="c8dc0-124">이 시점부터는 모든 배포가 동일한 환경에서 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-124">From that point forward, every deployment runs in the same environment.</span></span> <span data-ttu-id="c8dc0-125">모든 컨테이너가 동일한 OS 버전을 사용하며, 동일한 버전의 종속성이 설치되고, 동일한 프레임워크를 사용하며, 동일한 프로세스를 사용하여 빌드됩니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-125">Every container uses the same OS version, has the same version of dependencies installed, uses the same framework, and is built using the same process.</span></span> <span data-ttu-id="c8dc0-126">그림 7-2에서는 Visual Studio 2017에 로드된 응용 프로그램을 볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-126">You can see the application loaded in Visual Studio 2017 in Figure 7-2.</span></span>

![](./media/image2.png)

<span data-ttu-id="c8dc0-127">**그림 7-2**.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-127">**Figure 7-2**.</span></span> <span data-ttu-id="c8dc0-128">Visual Studio 2017의 카탈로그 관리 Web Forms 응용 프로그램</span><span class="sxs-lookup"><span data-stu-id="c8dc0-128">Catalog management Web Forms application in Visual Studio 2017</span></span>

<span data-ttu-id="c8dc0-129">또한 개발자는 이 일관된 환경에서 응용 프로그램을 모두 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-129">In addition, developers can all run the application in this consistent environment.</span></span> <span data-ttu-id="c8dc0-130">특정 버전에만 나타나는 문제가 스테이징 환경 또는 프로덕션 환경에서는 드러나지 않고 개발자에게 즉시 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-130">Issues that only appear with certain versions will appear immediately for developers rather than surfacing in a staging or production environment.</span></span> <span data-ttu-id="c8dc0-131">응용 프로그램이 컨테이너에서 실행되면 개발 팀 사이의 개발 환경 간 차이가 덜 중요해집니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-131">Differences between the development environments among the development team matter less once applications run in containers.</span></span>

<span data-ttu-id="c8dc0-132">마지막으로, 컨테이너화된 응용 프로그램은 더욱 수평으로 확장된 곡선을 갖습니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-132">Finally, containerized applications have a flatter scale-out curve.</span></span> <span data-ttu-id="c8dc0-133">컨테이너화된 앱을 통해 어떻게 VM 또는 물리적 컴퓨터에서 더 많은 컨테이너를 사용할 수 있는지에 대해 알아보았습니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-133">You have learned how containerized apps enable more containers in a VM or more containers in a physical machine.</span></span> <span data-ttu-id="c8dc0-134">이는 밀도가 높아지고 필요한 자원이 줄어든다는 것을 의미합니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-134">This translates to higher density and fewer required resources.</span></span>

<span data-ttu-id="c8dc0-135">이러한 모든 이유로 “리프트 앤 시프트” 작업을 사용하여 Docker 컨테이너에서 레거시 모놀리식 앱을 실행하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-135">For all these reasons, consider running legacy monolithic apps in a Docker container using a “lift-and-shift” operation.</span></span> <span data-ttu-id="c8dc0-136">“리프트 앤 시프트”라는 문구는 작업의 범위를 설명합니다. 즉, 물리적 컴퓨터나 가상 머신에서 전체 응용 프로그램을 들어 올린(리프트) 후 컨테이너로 옮깁니다(시프트).</span><span class="sxs-lookup"><span data-stu-id="c8dc0-136">The phrase “lift and shift” describes the scope of the task: you *lift* the entire application from a physical or virtual machine, and *shift* it into a container.</span></span> <span data-ttu-id="c8dc0-137">이상적인 상황에서는 응용 프로그램 코드를 컨테이너에서 실행하기 위해 해당 코드를 변경할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-137">In ideal situations, you do not need to make any changes to the application code to run it in a container.</span></span>

## <a name="possible-migration-paths"></a><span data-ttu-id="c8dc0-138">가능한 마이그레이션 경로</span><span class="sxs-lookup"><span data-stu-id="c8dc0-138">Possible migration paths</span></span>

<span data-ttu-id="c8dc0-139">모놀리식 응용 프로그램으로서 Catalog.Webforms 응용 프로그램은 데이터 액세스 라이브러리를 비롯하여 모든 코드가 포함된 하나의 웹 응용 프로그램입니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-139">As a monolithic application, the Catalog.Webforms application is one web application containing all the code, including the data access libraries.</span></span> <span data-ttu-id="c8dc0-140">데이터베이스는 별도의 고가용성 컴퓨터에서 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-140">The database runs on a separate high-availability machine.</span></span> <span data-ttu-id="c8dc0-141">해당 구성은 모의 ​​카탈로그 서비스를 사용하여 샘플 코드에서 시뮬레이션됩니다. 즉, 해당 모조 데이터에 대해 Catalog.WebForms 응용 프로그램을 실행하여 순수한 리프트 앤 시프트 시나리오를 시뮬레이션할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-141">That configuration is simulated in the sample code by using a mock catalog service: you can run the Catalog.WebForms application against that fake data to simulate a pure lift-and-shift scenario.</span></span> <span data-ttu-id="c8dc0-142">이는 코드를 전혀 변경하지 않고 컨테이너에서 실행하기 위해 기존 자산을 이동하는 가장 간단한 마이그레이션 경로를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-142">This demonstrates the simplest migration path, where you move existing assets to run in a container without any code changes at all.</span></span> <span data-ttu-id="c8dc0-143">이 경로는 마이크로 서비스로 이동할 기능과의 상호 작용을 최소화하는 완전한 응용 프로그램에 적합합니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-143">This path is appropriate for applications that are complete and that have minimal interaction with functionality that you are moving to microservices.</span></span>

<span data-ttu-id="c8dc0-144">그러나 eShopOnContainers 웹 사이트는 이미 다른 시나리오에 마이크로 서비스를 사용하여 데이터 저장소에 액세스하고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-144">However, the eShopOnContainers website is already accessing the data storage using microservices for different scenarios.</span></span> <span data-ttu-id="c8dc0-145">카탈로그 데이터 저장소에 직접 액세스하는 대신 카탈로그 마이크로 서비스를 활용하기 위해 카탈로그 편집기를 추가로 약간 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-145">Some small additional changes can be made to the catalog editor to leverage the catalog microservice instead of accessing the catalog data storage directly.</span></span>

<span data-ttu-id="c8dc0-146">이러한 변경 사항은 고유한 응용 프로그램에 대한 연속을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-146">These changes demonstrate the continuum for your own applications.</span></span> <span data-ttu-id="c8dc0-147">변경 없이 기존 응용 프로그램을 컨테이너로 이동하는 작업부터 기존 응용 프로그램이 새로운 마이크로 서비스의 일부에 액세스할 수 있도록 약간 변경하는 작업, 새로운 마이크로 서비스 기반 아키텍처에 완벽히 참여하도록 응용 프로그램을 완전히 다시 작성하는 작업에 이르기까지 무엇이든 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-147">You can do anything from moving an existing application without change into containers, to making small changes that enable existing applications to access some of the new microservices, to completely rewriting an application to fully participate in a new microservice-based architecture.</span></span> <span data-ttu-id="c8dc0-148">적절한 경로는 마이그레이션 비용과 마이그레이션의 이점에 따라 달라집니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-148">The right path depends on both the cost of the migration and the benefits from any migration.</span></span>

## <a name="application-tour"></a><span data-ttu-id="c8dc0-149">응용 프로그램 둘러보기</span><span class="sxs-lookup"><span data-stu-id="c8dc0-149">Application tour</span></span>

<span data-ttu-id="c8dc0-150">Catalog.WebForms 솔루션을 로드하여 응용 프로그램을 독립 실행형 응용 프로그램으로 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-150">You can load the Catalog.WebForms solution and run the application as a standalone application.</span></span> <span data-ttu-id="c8dc0-151">이 구성에서는 영구 저장소 데이터베이스 대신 응용 프로그램에서 가짜 서비스를 사용하여 데이터를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-151">In this configuration, instead of a persistent storage database, the application uses a fake service to return data.</span></span> <span data-ttu-id="c8dc0-152">응용 프로그램은 Autofac(<https://autofac.org/>)을 IOC(Inversion of Control) 컨테이너로 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-152">The application uses Autofac (<https://autofac.org/>) as an inversion of control (IOC) container.</span></span> <span data-ttu-id="c8dc0-153">DI(종속성 주입)를 사용하면 모조 데이터 또는 라이브 카탈로그 데이터 서비스를 사용하도록 응용 프로그램을 구성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-153">Using Dependency Injection (DI), you can configure the application to use the fake data or the live catalog data service.</span></span> <span data-ttu-id="c8dc0-154">(DI에 대해서는 바로 뒤에 더 자세히 설명하겠습니다.) 시작 코드는 web.config 파일에서 useFake 설정을 읽고, 모조 데이터 서비스 또는 라이브 카탈로그 서비스를 주입하도록 Autofac 컨테이너를 구성합니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-154">(We will explain more about DI shortly.) The startup code reads a useFake setting from the web.config files, and configures the Autofac container to inject either the fake data service or the live catalog service.</span></span> <span data-ttu-id="c8dc0-155">web.config 파일에서 useFake를 false로 설정하여 응용 프로그램을 실행하는 경우 Web Forms 응용 프로그램에서 카탈로그 데이터가 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-155">If you run the application with useFake set to false in the web.config file, you see the Web Forms application displaying the catalog data.</span></span>

<span data-ttu-id="c8dc0-156">이 응용 프로그램에서 사용된 대부분의 기술은 Web Forms를 사용하는 모든 사람에게 매우 친숙해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-156">Most of the techniques used in this application should be very familiar to anyone who has used Web Forms.</span></span> <span data-ttu-id="c8dc0-157">그러나 카탈로그 마이크로 서비스는 일반적으로 친숙하지 않을 수 있는 두 가지 기술을 도입했는데, 이는 바로 앞에서 언급한 DI(종속성 주입) 및 Web Forms의 비동기 데이터 저장소 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-157">However, the catalog microservice introduces two techniques that might be unfamiliar: Dependency Injection (DI), which was mentioned earlier, and working with asynchronous data stores in Web Forms.</span></span>

<span data-ttu-id="c8dc0-158">DI는 필요한 모든 리소스를 할당하는 클래스를 작성하는 일반적인 개체 지향 전략을 반대로 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-158">DI inverts the typical object-oriented strategy of writing classes that allocate all needed resources.</span></span> <span data-ttu-id="c8dc0-159">대신 클래스가 서비스 컨테이너에서 해당 종속성을 요청합니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-159">Instead, classes request their dependencies from a service container.</span></span> <span data-ttu-id="c8dc0-160">DI의 이점은 외부 서비스를 모조(모의)로 대체하여 테스트 또는 기타 환경을 지원할 수 있다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-160">The advantage of DI is that you can replace external services with fakes (mocks) to support testing or other environments.</span></span>

<span data-ttu-id="c8dc0-161">DI 컨테이너는 web.config appSettings 구성을 사용하여 모조 카탈로그 데이터를 사용할지 또는 실행 중인 서비스의 라이브 데이터를 사용할지 여부를 제어합니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-161">The DI container uses the web.config appSettings configuration to control whether to use the fake catalog data or the live data from the running service.</span></span> <span data-ttu-id="c8dc0-162">응용 프로그램은 컨테이너를 빌드하는 HttpModule 개체를 등록하고, 종속성을 주입하기 위한 사전 요청 처리기를 등록합니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-162">The application registers an HttpModule object that builds the container and registers a pre-request handler to inject dependencies.</span></span> <span data-ttu-id="c8dc0-163">다음 예제와 같이 Modules/AutoFacHttpModule.cs 파일에서 해당 코드를 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-163">You can see that code in the Modules/AutoFacHttpModule.cs file, which looks like the following example:</span></span>

```cs
private static IContainer CreateContainer()
{
  // Configure AutoFac:
  // Register Containers:

  var settings = WebConfigurationManager.AppSettings;
  var useFake = settings["usefake"];
  bool fake = useFake == "true";
  var builder = new ContainerBuilder();

  if (fake)
  {
    builder.RegisterType<CatalogMockService>()
    .As<ICatalogService>();
  }
  else
  {
    builder.RegisterType<CatalogService>()
    .As<ICatalogService>();
    builder.RegisterType<RequestProvider>()
    .As<IRequestProvider>();
  }

  var container = builder.Build();
  return container;
}

private void InjectDependencies()
{
  if (HttpContext.Current.CurrentHandler is Page page)
  {
    // Get the code-behind class that we may have written
    var pageType = page.GetType().BaseType;

    // Determine if there is a constructor to inject, and grab it
    var ctor = (from c in pageType.GetConstructors()
                where c.GetParameters().Length > 0
                select c).FirstOrDefault();

    if (ctor != null)
    {
      // Resolve the parameters for the constructor
      var args = (from parm in ctor.GetParameters()
                  select Container.Resolve(parm.ParameterType))
                  .ToArray();

      // Execute the constructor method with the arguments resolved
      ctor.Invoke(page, args);
    }

    // Use the Autofac method to inject any
    // properties that can be filled by Autofac
    Container.InjectProperties(page);
  }
}
```

<span data-ttu-id="c8dc0-164">응용 프로그램의 페이지(Default.aspx.cs 및 EditPage.aspx.cs)는 이러한 종속성을 사용하는 생성자를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-164">The application’s pages (Default.aspx.cs and EditPage.aspx.cs) define constructors that take these dependencies.</span></span> <span data-ttu-id="c8dc0-165">기본 생성자가 여전히 있으며 액세스 가능합니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-165">Note that the default constructor is still present and accessible.</span></span> <span data-ttu-id="c8dc0-166">인프라에는 다음 코드가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-166">The infrastructure needs the following code.</span></span>

```cs
protected _Default() { }

public _Default(ICatalogService catalog) => this.catalog = catalog;
```

<span data-ttu-id="c8dc0-167">카탈로그 API는 모두 비동기 메서드입니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-167">The catalog APIs are all asynchronous methods.</span></span> <span data-ttu-id="c8dc0-168">Web Forms는 이제 모든 데이터 컨트롤에 대해 이러한 메서드를 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-168">Web Forms now supports these for all data controls.</span></span> <span data-ttu-id="c8dc0-169">Catalog.WebForms 응용 프로그램은 목록 및 편집 페이지에 모델 바인딩을 사용합니다. 페이지의 컨트롤은 작업 반환 비동기 작업을 지정하는 SelectMethod, UpdateMethod, InsertMethod 및 DeleteMethod 속성을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-169">The Catalog.WebForms application uses model binding for the list and edit pages; controls on the pages define SelectMethod, UpdateMethod, InsertMethod, and DeleteMethod properties that specify Task-returning asynchronous operations.</span></span> <span data-ttu-id="c8dc0-170">Web Forms 컨트롤은 컨트롤에 바인딩된 메서드가 비동기적인 경우를 파악합니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-170">Web Forms controls understand when the methods bound to a control are asynchronous.</span></span> <span data-ttu-id="c8dc0-171">비동기 select 메서드를 사용할 때 발생하는 유일한 제한은 페이징을 지원할 수 없다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-171">The only restriction you encounter when using asynchronous select methods is that you cannot support paging.</span></span> <span data-ttu-id="c8dc0-172">페이징 시그니처에는 out 매개 변수가 필요하며, 비동기 메서드에는 out 매개 변수가 있을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-172">The paging signature requires an out parameter, and asynchronous methods cannot have out parameters.</span></span> <span data-ttu-id="c8dc0-173">이 같은 기술은 카탈로그 서비스의 데이터가 필요한 다른 페이지에서 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-173">This same technique is used on other pages that require data from the catalog service.</span></span>

<span data-ttu-id="c8dc0-174">카탈로그 Web Forms 응용 프로그램의 기본 구성은 catalog.api 서비스의 모의 구현을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-174">The default configuration for the catalog Web Forms application uses a mock implementation of the catalog.api service.</span></span> <span data-ttu-id="c8dc0-175">이 모의에서는 해당 데이터에 하드 코드된 데이터 집합을 사용하므로, 개발 환경에서 catalog.api 서비스에 대한 종속성을 제거함으로써 일부 작업이 간소화됩니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-175">This mock uses a hard-coded dataset for its data, which simplifies some tasks by removing the dependency on the catalog.api service in development environments.</span></span>

## <a name="lifting-and-shifting"></a><span data-ttu-id="c8dc0-176">리프트 앤 시프트 작업</span><span class="sxs-lookup"><span data-stu-id="c8dc0-176">Lifting and shifting</span></span>

<span data-ttu-id="c8dc0-177">Visual Studio는 응용 프로그램을 컨테이너화하는 데 많은 지원을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-177">Visual Studio provides great support for containerizing an application.</span></span> <span data-ttu-id="c8dc0-178">프로젝트 노드를 마우스 오른쪽 단추로 클릭한 후 **추가**, **Docker 지원**을 차례로 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-178">You right-click the project node and then select **Add** and **Docker Support**.</span></span> <span data-ttu-id="c8dc0-179">Docker 프로젝트 템플릿은 **docker-compose**라는 솔루션에 새 프로젝트를 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-179">The Docker project template adds a new project to the solution called **docker-compose**.</span></span> <span data-ttu-id="c8dc0-180">그림 7-3과 같이 프로젝트는 필요한 이미지를 구성(또는 빌드)하는 Docker 자산을 포함하고 있으며, 필수 컨테이너를 실행하기 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-180">The project contains the Docker assets that compose (or build) the images you need, and starts running the necessary containers, as shown in Figure 7-3.</span></span>

<span data-ttu-id="c8dc0-181">가장 간단한 리프트 앤 시프트 시나리오에서 응용 프로그램은 Web Forms 응용 프로그램에 사용되는 단일 서비스입니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-181">In the simplest lift-and-shift scenarios, the application will be the single service that you use for the Web Forms application.</span></span> <span data-ttu-id="c8dc0-182">또한 템플릿은 **docker-compose** 프로젝트를 가리키도록 시작 프로젝트를 변경합니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-182">The template also changes your startup project to point to the **docker-compose** project.</span></span> <span data-ttu-id="c8dc0-183">이제 Ctrl+F5 또는 F5 키를 누르면 Docker 이미지가 생성되고 Docker 컨테이너가 시작됩니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-183">Pressing Ctrl+F5 or F5 now creates the Docker image and launches the Docker container.</span></span>

![](./media/image3.png)

<span data-ttu-id="c8dc0-184">**그림 7-3**.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-184">**Figure 7-3**.</span></span> <span data-ttu-id="c8dc0-185">Web Forms 솔루션의 **docker-compose** 프로젝트</span><span class="sxs-lookup"><span data-stu-id="c8dc0-185">The **docker-compose** project in the Web Forms solution</span></span>

<span data-ttu-id="c8dc0-186">솔루션을 실행하기 전에 Windows 컨테이너를 사용하도록 Docker를 구성했는지 확인해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-186">Before you run the solution, you must make sure that you configure Docker to use Windows Containers.</span></span> <span data-ttu-id="c8dc0-187">그렇게 하려면 그림 7-4와 같이 Windows에서 Docker 작업 표시줄 아이콘을 마우스 오른쪽 단추로 클릭하고 **Windows 컨테이너로 전환**을 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-187">To do that, you right-click the Docker taskbar icon in Windows and select **Switch to Windows Containers**, as shown in Figure 7-4.</span></span>

![](./media/image4.png)

<span data-ttu-id="c8dc0-188">**그림 7-4**.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-188">**Figure 7-4**.</span></span> <span data-ttu-id="c8dc0-189">Windows의 Docker 작업표시줄 아이콘에서 Windows 컨테이너로 전환</span><span class="sxs-lookup"><span data-stu-id="c8dc0-189">Switching to Windows Containers from the Docker taskbar icon in Windows</span></span>

<span data-ttu-id="c8dc0-190">메뉴 항목에 **Linux 컨테이너로 전환**이 표시되면 Windows 컨테이너가 있는 Docker가 이미 실행 중입니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-190">If the menu item says **Switch to Linux containers**, you are already running Docker with Windows Containers.</span></span>

<span data-ttu-id="c8dc0-191">솔루션을 실행하면 Docker 호스트가 다시 시작됩니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-191">Running the solution restarts the Docker host.</span></span> <span data-ttu-id="c8dc0-192">빌드할 때 Web Forms 프로젝트에 대한 응용 프로그램 및 Docker 이미지를 빌드합니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-192">When you build, you build the application and the Docker image for the Web Forms project.</span></span> <span data-ttu-id="c8dc0-193">처음으로 이 작업을 수행하면 상당한 시간이 걸립니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-193">The first time you do this, it takes considerable time.</span></span> <span data-ttu-id="c8dc0-194">빌드 프로세스가 기본 Windows Server 이미지 및 ASP.NET용 추가 이미지를 가져오기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-194">This is because the build process pulls down the base Windows Server image and the additional image for ASP.NET.</span></span> <span data-ttu-id="c8dc0-195">후속 빌드 및 실행 주기는 훨씬 빨라집니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-195">Subsequent build and run cycles will be much faster.</span></span>

<span data-ttu-id="c8dc0-196">Docker 프로젝트 템플릿에 의해 추가된 파일에 대해 더 자세히 살펴보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-196">Let’s take a deeper look at the files added by the Docker project template.</span></span> <span data-ttu-id="c8dc0-197">이 템플릿은 여러 파일을 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-197">It created several files for you.</span></span> <span data-ttu-id="c8dc0-198">Visual Studio에서는 이러한 파일을 사용하여 Docker 이미지를 만들고 컨테이너를 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-198">Visual Studio uses these files to create the Docker image and launch a container.</span></span> <span data-ttu-id="c8dc0-199">CLI에서 동일한 파일을 사용하여 Docker 명령을 수동으로 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-199">You can use the same files from the CLI to run Docker commands manually.</span></span>

<span data-ttu-id="c8dc0-200">다음 Dockerfile 예제는 ASP.NET 사이트를 실행하는 Windows ASP.NET 이미지를 기반으로 하여 Docker 이미지를 빌드하기 위한 기본 설정을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-200">The following Dockerfile example shows the basic settings for building a Docker image based on the Windows ASP.NET image that runs an ASP.NET site.</span></span>

```
FROM microsoft/aspnet

ARG source

WORKDIR /inetpub/wwwroot

COPY ${source:-obj/Docker/publish} .
```

<span data-ttu-id="c8dc0-201">이 Dockerfile은 Linux 컨테이너에서 ASP.NET Core 응용 프로그램을 실행하기 위해 생성된 것과 매우 비슷해 보입니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-201">This Dockerfile will look very similar to those created for running an ASP.NET Core application in Linux containers.</span></span> <span data-ttu-id="c8dc0-202">그러나 몇 가지 중요한 차이점이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-202">However, there are a few important differences.</span></span> <span data-ttu-id="c8dc0-203">가장 중요한 차이는 기본 이미지가 microsoft/aspnet이며, 이는 .NET Framework가 포함된 현재 Windows Server 이미지라는 점입니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-203">The most important difference is that the base image is microsoft/aspnet, which is the current Windows Server image that includes the .NET Framework.</span></span> <span data-ttu-id="c8dc0-204">다른 차이는 소스 디렉터리에서 복사된 디렉터리가 다르다는 점입니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-204">Other differences are that the directories copied from your source directory are different.</span></span>

<span data-ttu-id="c8dc0-205">**docker-compose** 프로젝트의 기타 파일은 컨테이너를 빌드하고 구성하는 데 필요한 Docker 자산입니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-205">The other files in the **docker-compose** project are the Docker assets needed to build and configure the containers.</span></span> <span data-ttu-id="c8dc0-206">Visual Studio에서는 다양한 docker-compose.yml 파일을 한 노드 아래에 배치하여 어떻게 사용되는지를 강조 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-206">Visual Studio puts the various docker-compose.yml files under one node to highlight how they are used.</span></span> <span data-ttu-id="c8dc0-207">기본 docker-compose 파일에는 모든 구성에 공통적인 지시문이 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-207">The base docker-compose file contains the directives that are common to all configurations.</span></span> <span data-ttu-id="c8dc0-208">docker-compose.override.yml 파일에는 개발자 구성에 대한 환경 변수 및 관련 재정의가 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-208">The docker-compose.override.yml file contains environment variables and related overrides for a developer configuration.</span></span> <span data-ttu-id="c8dc0-209">.vs.debug 및 .vs.release를 사용하는 변형은 Visual Studio에서 실행 중인 컨테이너에 연결하고 이 컨테이너를 관리할 수 있도록 하는 환경 설정을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-209">The variants with .vs.debug and .vs.release provide environment settings that enable Visual Studio to attach to and manage the running container.</span></span>

<span data-ttu-id="c8dc0-210">Visual Studio 통합은 솔루션에 Docker 지원을 추가하는 과정의 일부이지만, 이전 섹션에서 살펴보았듯이 docker-compose up 명령을 사용하여 명령줄에서 빌드하고 실행할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-210">While Visual Studio integration is part of adding Docker support to your solution, you can also build and run from the command line, using the docker-compose up command, as you saw in previous sections.</span></span>

## <a name="getting-data-from-the-existing-catalog-net-core-microservice"></a><span data-ttu-id="c8dc0-211">기존 카탈로그 .NET Core 마이크로 서비스에서 데이터 가져오기</span><span class="sxs-lookup"><span data-stu-id="c8dc0-211">Getting data from the existing catalog .NET Core microservice</span></span>

<span data-ttu-id="c8dc0-212">모조 데이터를 사용하는 대신 데이터를 가져오는 데 eShopOnContainers 카탈로그 마이크로 서비스를 사용하도록 Web Forms 응용 프로그램을 구성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-212">You can configure the Web Forms application to use the eShopOnContainers catalog microservice to get data instead of using fake data.</span></span> <span data-ttu-id="c8dc0-213">이렇게 하려면 web.config 파일을 편집하여 useFake 키의 값을 false로 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-213">To do this, you edit the web.config file and set the value of the useFake key to false.</span></span> <span data-ttu-id="c8dc0-214">DI 컨테이너는 하드 코드된 데이터를 반환하는 클래스 대신 라이브 카탈로그 마이크로 서비스에 액세스하는 클래스를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-214">The DI container will use the class that accesses the live catalog microservice instead of the class that returns the hard-coded data.</span></span> <span data-ttu-id="c8dc0-215">다른 코드 변경은 필요하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-215">No other code changes are needed.</span></span>

<span data-ttu-id="c8dc0-216">라이브 카탈로그 서비스에 액세스하려면 **docker-compose** 프로젝트를 업데이트하여 카탈로그 서비스 이미지를 빌드하고 카탈로그 서비스 컨테이너를 시작해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-216">Accessing the live catalog service does mean you need to update the **docker-compose** project to build the catalog service image and launch the catalog service container.</span></span> <span data-ttu-id="c8dc0-217">Windows용 Docker CE는 Linux 컨테이너와 Windows 컨테이너를 모두 지원하지만, 동시에 지원하지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-217">Docker CE for Windows supports both Linux containers and Windows Containers, but not at the same time.</span></span> <span data-ttu-id="c8dc0-218">카탈로그 마이크로 서비스를 실행하려면 Windows 기반 컨테이너 위에 카탈로그 마이크로 서비스를 실행하는 이미지를 빌드해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-218">To run the catalog microservice, you need to build an image that runs the catalog microservice on top of a Windows-based container.</span></span> <span data-ttu-id="c8dc0-219">이 접근법은 이전 섹션에서 살펴보았던 것과는 다른 마이크로 서비스 프로젝트용 Dockerfile이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-219">This approach requires a different Dockerfile for the microservices project than you have seen in earlier sections.</span></span> <span data-ttu-id="c8dc0-220">Dockerfile.windows 파일은 카탈로그 API 컨테이너 이미지를 빌드하기 위한 구성 설정을 포함하고 있으므로 Windows 컨테이너에서 실행됩니다(예: Windows Nano Docker 이미지를 사용하기 위해).</span><span class="sxs-lookup"><span data-stu-id="c8dc0-220">The Dockerfile.windows file contains the configuration settings to build the catalog API container image so that it runs on a Windows container—for example, to use a Windows Nano Docker image.</span></span>

<span data-ttu-id="c8dc0-221">카탈로그 마이크로 서비스는 SQL Server 데이터베이스를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-221">The catalog microservice relies on the SQL Server database.</span></span> <span data-ttu-id="c8dc0-222">따라서 Windows 기반 SQL Server Docker 이미지도 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-222">Therefore, you need to use a Windows-based SQL Server Docker image as well.</span></span>

<span data-ttu-id="c8dc0-223">이러한 변경 이후 docker-compose 프로젝트는 응용 프로그램을 시작하는 데 더 많은 작업을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-223">After these changes, the docker-compose project does more to start the application.</span></span> <span data-ttu-id="c8dc0-224">이제 프로젝트는 Windows 기반 SQL Server 이미지를 사용하여 SQL Server를 시작하며,</span><span class="sxs-lookup"><span data-stu-id="c8dc0-224">The project now starts the SQL Server using the Windows based SQL Server image.</span></span> <span data-ttu-id="c8dc0-225">Windows 컨테이너에서 카탈로그 마이크로 서비스를 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-225">It starts the catalog microservice in a Windows container.</span></span> <span data-ttu-id="c8dc0-226">또한 Windows 컨테이너에서 Web Forms 카탈로그 편집기 컨테이너도 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-226">And it starts the Web Forms catalog editor container, also in a Windows container.</span></span> <span data-ttu-id="c8dc0-227">이미지 중 하나라도 빌드가 필요한 경우 이미지가 먼저 생성됩니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-227">If any of the images need building, the images are created first.</span></span>

## <a name="development-and-production-environments"></a><span data-ttu-id="c8dc0-228">개발 및 프로덕션 환경</span><span class="sxs-lookup"><span data-stu-id="c8dc0-228">Development and production environments</span></span>

<span data-ttu-id="c8dc0-229">개발 구성과 프로덕션 구성 간에는 몇 가지 차이가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-229">There are a couple of differences between the development configuration and a production configuration.</span></span> <span data-ttu-id="c8dc0-230">개발 환경에서는 Windows 컨테이너에서 Web Forms 응용 프로그램, 카탈로그 마이크로 서비스 및 SQL Server를 동일한 Docker 호스트의 일부로 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-230">In the development environment, you run the Web Forms application, the catalog microservice, and SQL Server in Windows Containers, as part of the same Docker host.</span></span> <span data-ttu-id="c8dc0-231">이전 섹션에서 Linux 기반 Docker 호스트의 기타 .NET Core 기반 서비스와 동일한 Docker 호스트에 배포된 SQL Server 이미지에 대해 언급했습니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-231">In earlier sections, we mentioned SQL Server images deployed in the same Docker host as the other .NET Core-based services on a Linux-based Docker host.</span></span> <span data-ttu-id="c8dc0-232">동일한 Docker 호스트(또는 클러스터)에서 여러 마이크로 서비스를 실행하면 네트워크 통신이 줄어들고 컨테이너 간 통신 대기 시간이 짧아지는 이점이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-232">The advantage of running the multiple microservices in the same Docker host (or cluster) is that there is less network communication and the communication between containers has lower latency.</span></span>

<span data-ttu-id="c8dc0-233">개발 환경에서는 동일한 OS에서 모든 컨테이너를 실행해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-233">In the development environment, you must run all the containers in the same OS.</span></span> <span data-ttu-id="c8dc0-234">Windows용 Docker CE는 Windows 기반 컨테이너와 Linux 기반 컨테이너의 실행을 동시에 지원하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-234">Docker CE for Windows does not support running Windows- and Linux-based containers at the same time.</span></span> <span data-ttu-id="c8dc0-235">프로덕션 환경에서는 단일 Docker 호스트(또는 클러스터)의 Windows 컨테이너에서 카탈로그 마이크로 서비스를 실행할지 아니면 다른 Docker 호스트의 Linux 컨테이너에서 실행 중인 카탈로그 마이크로 서비스 인스턴스와 Web Forms 응용 프로그램을 통신하도록 설정할지 결정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-235">In production, you can decide if you want to run the catalog microservice in a Windows container in a single Docker host (or cluster), or have the Web Forms application communicate with an instance of the catalog microservice running in a Linux container on a different Docker host.</span></span> <span data-ttu-id="c8dc0-236">이는 네트워크 대기 시간을 최적화하려는 방법에 따라 달라집니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-236">It depends on how you want to optimize for network latency.</span></span> <span data-ttu-id="c8dc0-237">대부분의 경우 간편한 배포 및 통신 대기 시간 단축을 위해 응용 프로그램에서 사용하는 마이크로 서비스가 동일한 Docker 호스트(또는 Swarm)에서 실행되기를 원합니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-237">In most cases, you want the microservices that your applications depend on running in the same Docker host (or swarm) for ease of deployment and lower communication latency.</span></span> <span data-ttu-id="c8dc0-238">이러한 구성에서는 마이크로 서비스 인스턴스와 영구 데이터 저장소를 위한 고가용성 서버 간 통신만 유일하게 비용이 많이 듭니다.</span><span class="sxs-lookup"><span data-stu-id="c8dc0-238">In those configurations, the only costly communications is between the microservice instances and the high-availability servers for the persistent data storage.</span></span>

>[!div class="step-by-step"]
<span data-ttu-id="c8dc0-239">[이전](../net-core-single-containers-linux-windows-server-hosts/index.md) [다음](../multi-container-microservice-net-applications/index.md)</span><span class="sxs-lookup"><span data-stu-id="c8dc0-239">[Previous] (../net-core-single-containers-linux-windows-server-hosts/index.md) [Next] (../multi-container-microservice-net-applications/index.md)</span></span>

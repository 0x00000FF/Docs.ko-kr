---
title: "DDD 지향 마이크로 서비스를 디자인합니다."
description: "컨테이너 화 된.NET 응용 프로그램에 대 한.NET Microservices 아키텍처 | DDD 지향 마이크로 서비스를 디자인합니다."
keywords: "Docker, 마이크로 서비스, ASP.NET, 컨테이너"
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 05/26/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.topic: article
ms.openlocfilehash: df45441089fd59d5e0e52b4bcec409adcc11fb71
ms.sourcegitcommit: bd1ef61f4bb794b25383d3d72e71041a5ced172e
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 10/18/2017
---
# <a name="designing-a-ddd-oriented-microservice"></a>DDD 지향 마이크로 서비스를 디자인합니다.

Business 사용 사례와 관련 된 현실에 따라 모델링을 대표 하는 도메인 기반 디자인 (DDD). 응용 프로그램을 구축의 컨텍스트에서 DDD 문제에 대 한 도메인으로 설명 합니다. 경계가 지정 된 컨텍스트도 독립적인 문제 영역에 설명 (각 경계가 지정 된 컨텍스트 상관 관계를 지정 하는 마이크로 서비스), 그리고 이러한 문제에 대해 설명 하는 공용 언어를 강조 합니다. 많은 기술 개념 및 패턴, 풍부한 모델 도메인 엔터티와 같이 제안 (없음 [anemic 도메인 모델](https://martinfowler.com/bliki/AnemicDomainModel.html)), 내부 구현을 지원 하기 위해 규칙 값 개체, 집계 및 집계 루트 (또는 루트 엔터티)입니다. 이 섹션에서는 설계 및 구현 내부 패턴 중를 소개 합니다.

경우에 따라 이러한 DDD 기술 규칙과 패턴 DDD 접근 방식을 구현 하기 위한 배우기 있는 장애물으로 인식 되는지에 합니다. 하지만 중요 한 부분은 하지 패턴 자체에 있지만 비즈니스 문제에 부합 되므로 코드를 구성 및 동일한 비즈니스 용어 (유비쿼터스 언어)를 사용 하 여 합니다. 또한 DDD 방법이 중요 한 비즈니스 규칙을 사용한 복잡 한 microservices를 구현 하는 경우에 적용 되어야 합니다. CRUD 서비스 처럼 간단 책임을 간단한 방법으로 관리할 수 있습니다.

경계를 그릴 위치가 디자인 및는 마이크로 서비스를 정의 하는 경우 중요 한 작업이입니다. DDD 패턴 도메인의 복잡성을 이해 하는 데 도움이 됩니다. 각 경계가 지정 된 컨텍스트에 대 한 도메인 모델에 대 한 식별 하 고 엔터티, 값 개체 및 도메인을 모델링 하는 집계를 정의 합니다. 빌드 및 컨텍스트를 정의 하는 경계 내에 포함 된 도메인 모델을 구체화 합니다. 있고는 마이크로 서비스의 형태로 매우 명시적입니다. 해당 경계 내에서 구성 요소 프로그램 microservices 되 고 하지만 일부 경우 BC a에 되거나 비즈니스 microservices 몇 가지 물리적 서비스도 구성 될 수 있습니다. DDD 경계에 대 한는 함께 microservices 있습니다.

## <a name="keep-the-microservice-context-boundaries-relatively-small"></a>마이크로 서비스의 컨텍스트 경계 상대적으로 작게 유지

두 개의 경쟁 목표 조정 경계가 지정 된 컨텍스트 간에 경계를 배치할 위치를 결정 합니다. 먼저 만들려는 처음 가장 작은 가능한 microservices 주 드라이버; 되지 않아야 하는 있지만 응집력 필요한 부분이 주위의 경계를 만들어야 합니다. 둘째, microservices 간의 수 다 스러운 통신을 방지 하려고 합니다. 이러한 목표는 서로 상충 수 있습니다. 가능한 한 신속 하 게 증가 하 고 각 추가 시도 새 경계가 지정 된 컨텍스트를 구분 하는 통신 경계를 표시 될 때까지 작은 microservices 시스템 분해 하 여 해당를 조정 해야 합니다. 응집력은 단일 bounded 컨텍스트 내에서 키입니다.

비슷합니다는 [부적절 한 관계 코드 냄새](https://sourcemaking.com/refactoring/smells/inappropriate-intimacy) 클래스를 구현 하는 경우. 두 개의 microservices를 훨씬 상호 협력 해야 할 경우 동일한 마이크로 서비스 아마도 수 있어야 합니다.

다른이 방법은 자율성입니다. 마이크로 서비스를 직접 요청을 처리 하는 다른 서비스를 사용 해야 하는 경우 실제로 자치있지 않습니다.

## <a name="layers-in-ddd-microservices"></a>DDD microservices의 계층

중요 한 비즈니스 및 기술 복잡성 대부분 엔터프라이즈 응용 프로그램은 여러 계층에 의해 정의 됩니다. 레이어 논리 아티팩트 되며 서비스의 배포와 관련이 없습니다. 이러한 코드의 복잡성을 관리 하는 개발자가 존재 합니다. 요구 하는 이러한 형식을 번역 경우 다른 형식으로 서로 다른 계층 (예: 도메인 모델 등 프레젠테이션 계층 및 계층)에 있을 수 있습니다.

예를 들어 데이터베이스에서 엔터티를 로드할 수 없습니다. 그런 다음 해당 정보를 또는 다른 엔터티에서 추가 데이터를 포함 하 여 정보에 대 한 집계의 일부 UI REST 웹 API를 통해 클라이언트에 보낼 수 있습니다. 여기 된다는 사실을 도메인 엔터티는 도메인 모델 계층 내에 포함 된 속해 있지 않아서, 같은 프레젠테이션 계층에 있는 다른 영역에 전파할 수 없습니다.

항상 유효한 엔터티 해야 또한 (참조는 [도메인 모델 계층에서 유효성 검사를 디자인](#designing-validations-in-the-domain-model-layer) 섹션) 집계 루트 (루트 엔터티)에 의해 제어 됩니다. 따라서 엔터티 바인딩되지 않아야 클라이언트 보기에 UI 수준에서 일부 데이터 수 여전히 되지 유효성을 확인할 수 있습니다. 이 ViewModel입니다. ViewModel은 프레젠테이션 계층의 요구 사항에 대 한 단독으로 데이터 모델입니다. 도메인 엔터티 ViewModel에 직접 속해 있지 않습니다. 대신, Viewmodel 및 도메인 엔터티 간 또는 그 반대로 변환 해야 합니다.

단일 항목을 통해 엔터티 (집계) 해당 그룹 수행 하는 작업량과 복잡성은 것이 중요 한 도메인 모델이 모든 고정 및 규칙에 관련 되었는지 확인 하는 집계 루트 (살펴보기이 자세히 나중에)에 의해 제어 될 때 수행 됩니다. 포인트 또는 게이트를 집계 루트입니다.

그림 9-5 eShopOnContainers 응용 프로그램에 계층화 된 디자인을 구현 하는 방법을 보여 줍니다.

![](./media/image6.png)

**그림 9-5**합니다. DDD 레이어 eShopOnContainers에 정렬 마이크로 서비스를

각 계층만 통신 합니다. 다른 계층의 특정 되도록 시스템을 디자인 하려고 합니다. 보다 쉽게 됩니다. 어떤 종속 라이브러리 간에 설정를 명확 하 게 식별할 수 있으므로 서로 다른 클래스 라이브러리로 계층 구현 된 경우를 적용할 수 있을 수 있습니다. 예를 들어, 도메인 모델 계층 걸리지 않습니다 종속성 다른 계층에 (일반 이전 CLR 개체 되어야 하는 도메인 모델 클래스 또는 [POCO](https://en.wikipedia.org/wiki/Plain_Old_CLR_Object), 클래스). 그림 9-6에 나와 있는 것 처럼는 **Ordering.Domain** 레이어 라이브러리에 종속성만에.NET Core 라이브러리만 다른 사용자 지정 라이브러리 (데이터 라이브러리, 지 속성 라이브러리 등).

![](./media/image7.PNG)

**그림 9-6**합니다. 레이어 라이브러리 레이어 간의 종속성을 보다 효율적으로 제어할 수 있도록 하는 대로 구현

### <a name="the-domain-model-layer"></a>도메인 모델 계층

Eric Evans 뛰어난 책 [도메인 기반 디자인](http://domainlanguage.com/ddd/) 도메인 모델 계층 및 응용 프로그램 계층에 대해 다음 언급이 없습니다.

**도메인 모델 계층**: 비즈니스, 비즈니스 상황 및 비즈니스 규칙에 대 한 정보에 대 한 개념을 나타내는 작업을 담당 합니다. 비즈니스 상황을 반영 하는 상태가 되어 제어 하 고 있지만 기술적 세부 정보가 저장 하는 인프라에 위임 되며 여기서 사용 하는 합니다. 이 계층은 비즈니스 소프트웨어의 핵심입니다.

도메인 모델 계층은 비즈니스 표현 됩니다. .NET에서 마이크로 서비스 도메인 모델 계층을 구현할 때 해당 계층은 데이터 + 동작 (논리로 사용 하는 메서드)를 캡처하는 도메인 엔터티와 클래스 라이브러리로 코딩 됩니다.

다음은 [지 속성 무시](http://deviq.com/persistence-ignorance/) 및 [인프라 무시](https://ayende.com/blog/3137/infrastructure-ignorance) 원칙,이 계층 데이터 지 속성 세부 정보를 완전히 무시 해야 합니다. 이러한 지 속성 작업 인프라 계층에서 수행 되어야 합니다. 따라서이 계층 걸리지 않습니다 직접 종속성에는 중요 한 규칙은 도메인 모델 엔터티 클래스가 있어야 함을 의미 하는 인프라를 [POCO](https://en.wikipedia.org/wiki/Plain_Old_CLR_Object)s입니다.

도메인 엔터티 (예: 기본 클래스에서 파생) 직접 종속성 NHibernate 또는 Entity Framework와 같은 데이터 액세스 인프라 프레임 워크에 필요는 없습니다. 이상적으로 도메인 엔터티 해야에서 파생 되지 않거나 모든 인프라 프레임 워크에 정의 된 모든 형식을 구현 합니다.

Entity Framework Core와 같은 대부분의 요즘 ORM 프레임 워크 도메인 모델 클래스는 인프라에 결합 되지 않도록이 방법을 사용을 허용 합니다. 그러나 POCO 엔터티 필요 불가능 항상 특정 NoSQL 데이터베이스 및 행위자 및 Azure 서비스 패브릭에서 신뢰할 수 있는 컬렉션 등의 프레임 워크를 사용 하는 경우.

도메인 모델에 대 한 지 속성 무시 원칙에 따라 중요 하다 고 해도 문제를 지 속성 무시 하지 마십시오. 실제 데이터 모델 및 엔터티 개체 모델에 매핑되는 방식 이해 하는 여전히 합니다. 그렇지 않으면 불가능 설계를 만들 수 있습니다.

또한 그렇다고를 관계형 데이터베이스에 대해 디자인 된 모델을 가져와 NoSQL 또는 문서 관련 데이터베이스에 직접 이동할 수 있습니다. 일부 엔터티 모델에 모델을 적합 하 게 하지만 일반적으로 없습니다. 엔터티 모델을 준수 해야, 저장소 기술 및 ORM 기술에 기반 하는 제약 조건을 아직 있습니다.

### <a name="the-application-layer"></a>응용 프로그램 계층

Eric Evans 책을 명시 다시에서는 응용 프로그램 계층으로의 이동 [도메인 기반 디자인](http://domainlanguage.com/ddd/):

**응용 프로그램 계층:** 소프트웨어 되는 작업을 수행 하 고 문제를 파악 하려고 표현 도메인 개체를 안내 하는 작업을 정의 합니다. 이 계층은 역할에 대 한 작업은 비즈니스에 의미 있는 또는 다른 시스템의 응용 프로그램 계층 상호 작용을 위해 필요 합니다. 이 계층은 씬 유지 됩니다. 비즈니스 규칙 또는 정보를 포함 하지 않고 하지만 다운 다음 계층의 도메인 개체의 공동 작업을 좌표 작업 및 대리자만 작동 합니다. 비즈니스 환경에 반영 하는 상태 없는 있지만 사용자나 프로그램에 대 한 작업의 진행 상태를 반영 하는 상태를 가질 수 있습니다.

.NET에서 마이크로 서비스의 응용 프로그램 계층은 일반적으로 ASP.NET Core 웹 API 프로젝트로 코딩 됩니다. 마이크로 서비스의 상호 작용, 원격 네트워크 액세스 및 UI 또는 클라이언트 응용 프로그램에서 사용 되는 외부 웹 Api 프로젝트를 구현 합니다. CQRS를 사용 하 여 적절 한 명령을 마이크로 서비스, 및도 이벤트 구동 간의 통신 microservices (통합 이벤트)에서 허용 하는 경우 쿼리를 포함 합니다. 응용 프로그램 계층을 나타내는 ASP.NET Core 웹 API에는 비즈니스 규칙 또는 도메인 정보 (특히: 트랜잭션이나 업데이트에 대 한 도메인 규칙); 없어야 도메인 모델 클래스 라이브러리에서 소유 해야 합니다. 응용 프로그램 계층 합니다만 좌표 작업 및 저장 하거나 모든 도메인 상태 (도메인 모델)을 정의 해야 합니다. 도메인 모델 클래스는 자체 (집계 루트 및 도메인 엔터티) 궁극적으로 해당 도메인 엔터티 내에서 데이터를 업데이트 하는 비즈니스 규칙의 실행을 위임 합니다.

기본적으로, 응용 프로그램 논리는 지정 된 프런트 엔드에 종속 된 모든 사용 사례를 구현 하는 위치입니다. 예를 들어, 구현 웹 API 서비스와 관련 된입니다.

ֲ 도메인 모델 계층, 고정 해당, 데이터 모델 및 관련된 비즈니스 규칙에는 도메인 논리는 표시 및 응용 프로그램 계층에서 완전히 독립적 이어야 합니다. 가장, 도메인 모델 계층 인프라 프레임 워크에 직접 종속 되지 않아야 합니다.

### <a name="the-infrastructure-layer"></a>인프라 계층

인프라 계층 데이터 처음에 메모리의 도메인 엔터티는 데이터베이스 또는 다른 영구 저장소에 유지 하는 방법을입니다. 예로는 Entity Framework 핵심 코드를 사용 하 여 DBContext를 사용 하 여 관계형 데이터베이스의 데이터를 유지 하는 리포지토리 패턴 클래스를 구현 하는 합니다.

앞에서 언급 한에 따라 [지 속성 무시](http://deviq.com/persistence-ignorance/) 및 [인프라 무시](https://ayende.com/blog/3137/infrastructure-ignorance) 원칙, 인프라 계층 해야 "묻지" 도메인 모델 계층입니다. 하지 프레임 워크에 하드 종속성을 수행 하 여 데이터 (EF 또는 다른 프레임 워크)를 유지 하는 데 사용 하는 인프라에서의 도메인 모델 엔터티 클래스를 알 수 없는 유지 해야 합니다. 도메인 모델 계층 클래스 라이브러리 있어야 사용자 도메인 코드 방금 [POCO](https://en.wikipedia.org/wiki/Plain_Old_CLR_Object) 엔터티 소프트웨어의 핵심을 구현 하는 클래스 및 인프라 기술에서 완전히 분리 합니다.

따라서 레이어 또는 클래스 라이브러리 및 프로젝트 해야 궁극적에 따라 도메인 모델 계층 (라이브러리), 그 반대로 하지 않습니다, 그림 9-7에 표시 된 것 처럼 합니다.

![](./media/image8.png)

**그림 9-7**합니다. Ddd에서 레이어 간의 종속성

이 계층 설계 각 마이크로 서비스에 대 한 영향을 받지 않아야 합니다. 가장 복잡 한 microservices 앞에서 설명한 대로 구현할 수 있습니다를 간단한 방식으로 데이터 기반 구현 간단 하면서 DDD 패턴을 따른 microservices (단일 계층의 간단한 CRUD).

#### <a name="additional-resources"></a>추가 리소스

-   **DevIQ 합니다. 지 속성 무시 원칙**
    [*http://deviq.com/persistence-ignorance/*](http://deviq.com/persistence-ignorance/)

-   **Oren Eini 합니다. 인프라 무시**
    [*https://ayende.com/blog/3137/infrastructure-ignorance*](https://ayende.com/blog/3137/infrastructure-ignorance)

-   **Angel Lopez 합니다. 도메인 기반 디자인의 아키텍처를 계층화**
    [*https://ajlopez.wordpress.com/2008/09/12/layered-architecture-in-domain-driven-design/*](https://ajlopez.wordpress.com/2008/09/12/layered-architecture-in-domain-driven-design/)


>[!div class="step-by-step"]
[이전] (cqrs-마이크로 서비스-reads.md) [다음] (마이크로 서비스 도메인 model.md)

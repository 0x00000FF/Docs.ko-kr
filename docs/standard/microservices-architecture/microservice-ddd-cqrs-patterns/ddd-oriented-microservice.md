---
title: DDD 중심 마이크로 서비스 설계
description: 컨테이너화된 .NET 응용 프로그램을 위한 .NET 마이크로 서비스 아키텍처 | DDD 중심 마이크로 서비스 설계
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 11/06/2017
ms.openlocfilehash: 520f2928eb0d300ab0dc2d328d974455e102e4d7
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 05/04/2018
ms.locfileid: "33579355"
---
# <a name="designing-a-ddd-oriented-microservice"></a><span data-ttu-id="1c3a6-103">DDD 중심 마이크로 서비스 설계</span><span class="sxs-lookup"><span data-stu-id="1c3a6-103">Designing a DDD-oriented microservice</span></span>

<span data-ttu-id="1c3a6-104">DDD(도메인 기반 설계)는 사용 사례와 관련하여 현실의 비즈니스에 근거한 모델링을 대표합니다.</span><span class="sxs-lookup"><span data-stu-id="1c3a6-104">Domain-driven design (DDD) advocates modeling based on the reality of business as relevant to your use cases.</span></span> <span data-ttu-id="1c3a6-105">응용 프로그램 빌드의 컨텍스트에서 DDD는 문제를 도메인으로 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="1c3a6-105">In the context of building applications, DDD talks about problems as domains.</span></span> <span data-ttu-id="1c3a6-106">경계가 정해진 컨텍스트로 독립적인 문제 영역을 설명하며(각 바인딩된 컨텍스트가 마이크로 서비스에 상관됨) 문제 해결에 관해 설명하는 공통 언어를 강조합니다.</span><span class="sxs-lookup"><span data-stu-id="1c3a6-106">It describes independent problem areas as Bounded Contexts (each Bounded Context correlates to a microservice), and emphasizes a common language to talk about these problems.</span></span> <span data-ttu-id="1c3a6-107">내부 구현 지원을 위해 많은 모델([anemic-도메인 모델](https://martinfowler.com/bliki/AnemicDomainModel.html) 없음), 값 개체, 집계 및 집계 루트(또는 루트 엔터티) 규칙이 있는 도메인 엔터티처럼 여러 기술적 개념과 패턴도 제시합니다.</span><span class="sxs-lookup"><span data-stu-id="1c3a6-107">It also suggests many technical concepts and patterns, like domain entities with rich models (no [anemic-domain model](https://martinfowler.com/bliki/AnemicDomainModel.html)), value objects, aggregates and aggregate root (or root entity) rules to support the internal implementation.</span></span> <span data-ttu-id="1c3a6-108">이 섹션에서는 이러한 내부 패턴의 설계와 구현을 소개합니다.</span><span class="sxs-lookup"><span data-stu-id="1c3a6-108">This section introduces the design and implementation of those internal patterns.</span></span>

<span data-ttu-id="1c3a6-109">경우에 따라 이러한 DDD 기술 규칙과 패턴이 DDD 방법의 구현을 위한 학습에 장애처럼 보이기도 합니다.</span><span class="sxs-lookup"><span data-stu-id="1c3a6-109">Sometimes these DDD technical rules and patterns are perceived as obstacles that have a steep learning curve for implementing DDD approaches.</span></span> <span data-ttu-id="1c3a6-110">그러나 중요한 것은 패턴 자체가 아니라 비즈니스 문제에 맞게 코드를 구성하고 동일한 비즈니스 용어(유비쿼터스 언어)를 사용하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="1c3a6-110">But the important part is not the patterns themselves, but organizing the code so it is aligned to the business problems, and using the same business terms (ubiquitous language).</span></span> <span data-ttu-id="1c3a6-111">또한 DDD 방법은 중대한 비즈니스 규칙이 있는 복잡한 마이크로 서비스를 구현할 때만 적용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="1c3a6-111">In addition, DDD approaches should be applied only if you are implementing complex microservices with significant business rules.</span></span> <span data-ttu-id="1c3a6-112">CRUD 서비스처럼 더 간단한 업무는 더 간단한 방법으로 관리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1c3a6-112">Simpler responsibilities, like a CRUD service, can be managed with simpler approaches.</span></span>

<span data-ttu-id="1c3a6-113">마이크로 서비스를 설계 및 정의할 때는 그 경계를 정하는 것이 핵심입니다.</span><span class="sxs-lookup"><span data-stu-id="1c3a6-113">Where to draw the boundaries is the key task when designing and defining a microservice.</span></span> <span data-ttu-id="1c3a6-114">DDD 패턴은 도메인의 복잡성을 이해하는 데 도움이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1c3a6-114">DDD patterns help you understand the complexity in the domain.</span></span> <span data-ttu-id="1c3a6-115">경계가 지정된 각 컨텍스트에 대한 도메인 모델의 경우 도메인을 모델링하기 위한 엔터티, 값 개체 및 집계를 식별하여 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="1c3a6-115">For the domain model for each Bounded Context, you identify and define the entities, value objects, and aggregates that model your domain.</span></span> <span data-ttu-id="1c3a6-116">컨텍스트를 정의하는 경계 안에 포함된 도메인 모델을 빌드하여 구체화합니다.</span><span class="sxs-lookup"><span data-stu-id="1c3a6-116">You build and refine a domain model that is contained within a boundary that defines your context.</span></span> <span data-ttu-id="1c3a6-117">그러고 마이크로 서비스의 형태로 매우 명시적입니다.</span><span class="sxs-lookup"><span data-stu-id="1c3a6-117">And that is very explicit in the form of a microservice.</span></span> <span data-ttu-id="1c3a6-118">일부 경우 BC나 비즈니스 마이크로 서비스가 몇 가지 물리적 서비스로 구성될 수 있으나 이러한 경계 내 구성 요소는 마이크로 서비스로 마무리됩니다.</span><span class="sxs-lookup"><span data-stu-id="1c3a6-118">The components within those boundaries end up being your microservices, although in some cases a BC or business microservices can be composed of several physical services.</span></span> <span data-ttu-id="1c3a6-119">DDD는 경계에 관한 것이며 마이크로 서비스도 마찬가지입니다.</span><span class="sxs-lookup"><span data-stu-id="1c3a6-119">DDD is about boundaries and so are microservices.</span></span>

## <a name="keep-the-microservice-context-boundaries-relatively-small"></a><span data-ttu-id="1c3a6-120">마이크로 서비스 컨텍스트 경계를 상대적으로 작게 유지</span><span class="sxs-lookup"><span data-stu-id="1c3a6-120">Keep the microservice context boundaries relatively small</span></span>

<span data-ttu-id="1c3a6-121">경계가 지정된 컨텍스트 사이에서 어디를 경계로 할 것인지 결정하는 것은 경합하는 두 목표의 균형을 맞추는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="1c3a6-121">Determining where to place boundaries between Bounded Contexts balances two competing goals.</span></span> <span data-ttu-id="1c3a6-122">먼저 가능한 가장 작은 마이크로 서비스를 만들려고 합니다. 이것이 주 목표는 아니며 응집이 필요한 항목 주변의 경계를 만들어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="1c3a6-122">First, you want to initially create the smallest possible microservices, although that should not be the main driver; you should create a boundary around things that need cohesion.</span></span> <span data-ttu-id="1c3a6-123">두 번째로 마이크로 서비스 간의 자잘한 통신은 지양하고자 합니다.</span><span class="sxs-lookup"><span data-stu-id="1c3a6-123">Second, you want to avoid chatty communications between microservices.</span></span> <span data-ttu-id="1c3a6-124">이 두 목표는 서로 상충할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1c3a6-124">These goals can contradict one another.</span></span> <span data-ttu-id="1c3a6-125">추가적으로 경계가 지정된 새 컨텍스트를 분리할 때마다 매번 통신 경계가 신속하게 증대하는 수준이 되도록 시스템을 가능한 작은 규모의 여러 마이크로 서비스로 나누어 그 균형을 맞추어야 합니다. </span><span class="sxs-lookup"><span data-stu-id="1c3a6-125">You should balance them by decomposing the system into as many small microservices as you can until you see communication boundaries growing quickly with each additional attempt to separate a new Bounded Context.</span></span> <span data-ttu-id="1c3a6-126">응집력은 경계가 지정된 단일 컨텍스트에서 핵심입니다.</span><span class="sxs-lookup"><span data-stu-id="1c3a6-126">Cohesion is key within a single bounded context.</span></span>

<span data-ttu-id="1c3a6-127">클래스를 구현할 때 [부적절한 관계 코드 분위기](https://sourcemaking.com/refactoring/smells/inappropriate-intimacy)와 유사합니다.</span><span class="sxs-lookup"><span data-stu-id="1c3a6-127">It is similar to the [Inappropriate Intimacy code smell](https://sourcemaking.com/refactoring/smells/inappropriate-intimacy) when implementing classes.</span></span> <span data-ttu-id="1c3a6-128">두 마이크로 서비스가 서로 협력하는 일이 많을 경우 동일한 마이크로 서비스가 되어야 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1c3a6-128">If two microservices need to collaborate a lot with each other, they should probably be the same microservice.</span></span>

<span data-ttu-id="1c3a6-129">이를 위한 다른 방법은 자율성입니다.</span><span class="sxs-lookup"><span data-stu-id="1c3a6-129">Another way to look at this is autonomy.</span></span> <span data-ttu-id="1c3a6-130">마이크로 서비스가 다른 서비스에 의존하여 요청을 직접 서비스해야 할 경우 진정한 자율성이라 할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="1c3a6-130">If a microservice must rely on another service to directly service a request, it is not truly autonomous.</span></span>

## <a name="layers-in-ddd-microservices"></a><span data-ttu-id="1c3a6-131">DDD 마이크로 서비스의 계층</span><span class="sxs-lookup"><span data-stu-id="1c3a6-131">Layers in DDD microservices</span></span>

<span data-ttu-id="1c3a6-132">비즈니스 및 기술 복잡성이 높은 대부분의 엔터프라이즈 응용 프로그램은 여러 계층으로 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="1c3a6-132">Most enterprise applications with significant business and technical complexity are defined by multiple layers.</span></span> <span data-ttu-id="1c3a6-133">계층은 논리적 아티팩트로, 서비스 배포와는 관련이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="1c3a6-133">The layers are a logical artifact, and are not related to the deployment of the service.</span></span> <span data-ttu-id="1c3a6-134">이들은 개발자가 코드에서 복잡성을 관리하는 데 도움이 되기 위한 것입니다.</span><span class="sxs-lookup"><span data-stu-id="1c3a6-134">They exist to help developers manage the complexity in the code.</span></span> <span data-ttu-id="1c3a6-135">서로 다른 계층(도메인 계층과 프레젠테이션 계층처럼)은 유형이 서로 다를 수 있고 이로 인해 유형 간의 변환이 필요하게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1c3a6-135">Different layers (like the domain model layer versus the presentation layer, etc.) might have different types, which mandates translations between those types.</span></span>

<span data-ttu-id="1c3a6-136">예를 들어 데이터베이스에서 엔터티를 로드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1c3a6-136">For example, an entity could be loaded from the database.</span></span> <span data-ttu-id="1c3a6-137">그런 다음, 이 정보의 일부나, 다른 엔터티의 추가 데이터를 포함한 정보의 집계를 REST Web API를 통해 클라이언트 UI로 보낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1c3a6-137">Then part of that information, or an aggregation of information including additional data from other entities, can be sent to the client UI through a REST Web API.</span></span> <span data-ttu-id="1c3a6-138">여기서의 핵심은 도메인 개체가 도메인 모델 계층 안에 포함된다는 점이며 프레젠테이션 계층처럼 자신이 속하지 않은 다른 영역으로 전파되서는 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1c3a6-138">The point here is that the domain entity is contained within the domain model layer and should not be propagated to other areas that it does not belong to, like to the presentation layer.</span></span>

<span data-ttu-id="1c3a6-139">또한 집계 루트(루트 엔터티)에서 제어되는 항상 유효한 엔터티([도메인 모델 계층의 유효성 검사 설계](#designing-validations-in-the-domain-model-layer) 섹션 참조)가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="1c3a6-139">Additionally, you need to have always-valid entities (see the [Designing validations in the domain model layer](#designing-validations-in-the-domain-model-layer) section) controlled by aggregate roots (root entities).</span></span> <span data-ttu-id="1c3a6-140">따라서 엔터티는 클라이언트 뷰에 바인딩되어서는 안됩니다. UI 수준에서는 일부 데이터가 여전히 유효성 검사되지 않을 수 있기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="1c3a6-140">Therefore, entities should not be bound to client views, because at the UI level some data might still not be validated.</span></span> <span data-ttu-id="1c3a6-141">이 때문에 ViewModel이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1c3a6-141">This is what the ViewModel is for.</span></span> <span data-ttu-id="1c3a6-142">ViewModel은 프레젠테이션 계층에만 필요한 데이터 모델입니다.</span><span class="sxs-lookup"><span data-stu-id="1c3a6-142">The ViewModel is a data model exclusively for presentation layer needs.</span></span> <span data-ttu-id="1c3a6-143">도메인 엔터티는 ViewModel에 직접 속해 있지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="1c3a6-143">The domain entities do not belong directly to the ViewModel.</span></span> <span data-ttu-id="1c3a6-144">대신 Viewmodel과 도메인 엔터티 사이에 상호 변환이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="1c3a6-144">Instead, you need to translate between ViewModels and domain entities and vice versa.</span></span>

<span data-ttu-id="1c3a6-145">복잡성을 해결할 때는 도메인 모델을 엔터티 그룹(집계)과 관련한 모든 고정 및 규칙이 단일 진임 지점 또는 게이트인 집계 루트를 통해 수행되도록 하는 집계 루트에서 제어하는 것이 중요합니다. </span><span class="sxs-lookup"><span data-stu-id="1c3a6-145">When tackling complexity, it is important to have a domain model controlled by aggregate roots that make sure that all the invariants and rules related to that group of entities (aggregate) are performed through a single entry-point or gate, the aggregate root.</span></span>

<span data-ttu-id="1c3a6-146">그림 9-5는 eShopOnContainers 응용 프로그램에서 계층화된 디자인을 구현하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="1c3a6-146">Figure 9-5 shows how a layered design is implemented in the eShopOnContainers application.</span></span>

![](./media/image6.png)

<span data-ttu-id="1c3a6-147">**그림 9-5**.</span><span class="sxs-lookup"><span data-stu-id="1c3a6-147">**Figure 9-5**.</span></span> <span data-ttu-id="1c3a6-148">eShopOnContainers 주문 마이크로 서비스의 DDD 계층</span><span class="sxs-lookup"><span data-stu-id="1c3a6-148">DDD layers in the ordering microservice in eShopOnContainers</span></span>

<span data-ttu-id="1c3a6-149">각 계층이 특정 다른 계층과만 통신하도록 시스템을 설계하려 합니다.</span><span class="sxs-lookup"><span data-stu-id="1c3a6-149">You want to design the system so that each layer communicates only with certain other layers.</span></span> <span data-ttu-id="1c3a6-150">계층이 다른 클래스 라이브러리로 구현된다면 라이브러리 간에 어떠한 종속성이 있는지 분명히 식별할 수 있기 때문에 시행이 더 쉬울 것입니다.</span><span class="sxs-lookup"><span data-stu-id="1c3a6-150">That may be easier to enforce if layers are implemented as different class libraries, because you can clearly identify what dependencies are set between libraries.</span></span> <span data-ttu-id="1c3a6-151">예를 들어, 도메인 모델 계층은 다른 계층에 대해 종속성이 있어서는 안됩니다(도메인 모델 클래스는 일반 기존 CLR 개체이거나 [POCO](https://en.wikipedia.org/wiki/Plain_Old_CLR_Object), 클래스여야 함).</span><span class="sxs-lookup"><span data-stu-id="1c3a6-151">For instance, the domain model layer should not take a dependency on any other layer (the domain model classes should be Plain Old CLR Objects, or [POCO](https://en.wikipedia.org/wiki/Plain_Old_CLR_Object), classes).</span></span> <span data-ttu-id="1c3a6-152">그림 9-6에서 보듯 **Ordering.Domain** 계층 라이브러리에는 .NET Core 라이브러리 또는 NuGet 패키지에 대한 종속성만 있고 데이터 라이브러리나 지속 라이브러리 같은 다른 사용자 지정 라이브러리에는 종속성이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="1c3a6-152">As shown in Figure 9-6, the **Ordering.Domain** layer library has dependencies only on the .NET Core libraries or NuGet packages, but not on any other custom library, such as data library or persistence library.</span></span>

![](./media/image7.PNG)

<span data-ttu-id="1c3a6-153">**그림 9-6**.</span><span class="sxs-lookup"><span data-stu-id="1c3a6-153">**Figure 9-6**.</span></span> <span data-ttu-id="1c3a6-154">라이브러리로 구현되는 계층은 레이어 간의 종속성을 더 잘 제어할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1c3a6-154">Layers implemented as libraries allow better control of dependencies between layers</span></span>

### <a name="the-domain-model-layer"></a><span data-ttu-id="1c3a6-155">도메인 모델 계층</span><span class="sxs-lookup"><span data-stu-id="1c3a6-155">The domain model layer</span></span>

<span data-ttu-id="1c3a6-156">Eric Evans는 훌륭한 저서인 [Domain Driven Design](https://domainlanguage.com/ddd/)에서 도메인 모델 게층과 응용 프로그램 계층을 따르는 것에 대해 설명한 바 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1c3a6-156">Eric Evans's excellent book [Domain Driven Design](https://domainlanguage.com/ddd/) says the following about the domain model layer and the application layer.</span></span>

<span data-ttu-id="1c3a6-157">**도메인 모델 계층**: 비즈니스 개념, 비즈니스 상황 정보, 비즈니스 규칙을 나타내는 작업을 담당합니다.</span><span class="sxs-lookup"><span data-stu-id="1c3a6-157">**Domain Model Layer**: Responsible for representing concepts of the business, information about the business situation, and business rules.</span></span> <span data-ttu-id="1c3a6-158">저장을 위한 기술 세부 정보는 인프라에 위임되지만 비즈니스 상황을 반영한 상태가 여기서 제어 및 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="1c3a6-158">State that reflects the business situation is controlled and used here, even though the technical details of storing it are delegated to the infrastructure.</span></span> <span data-ttu-id="1c3a6-159">이 계층은 비즈니스 소프트웨어의 핵심입니다.</span><span class="sxs-lookup"><span data-stu-id="1c3a6-159">This layer is the heart of business software.</span></span>

<span data-ttu-id="1c3a6-160">도메인 모델 계층은 비즈니스가 표현되는 부분입니다.</span><span class="sxs-lookup"><span data-stu-id="1c3a6-160">The domain model layer is where the business is expressed.</span></span> <span data-ttu-id="1c3a6-161">.NET에서 마이크로 서비스 도메인 모델 계층을 구현할 때 해당 계층은 데이터와 동작(논리가 있는 메서드)을 수집하는 도메인 엔터티가 있는 클래스 라이브러리로 코딩됩니다.</span><span class="sxs-lookup"><span data-stu-id="1c3a6-161">When you implement a microservice domain model layer in .NET, that layer is coded as a class library with the domain entities that capture data plus behavior (methods with logic).</span></span>

<span data-ttu-id="1c3a6-162">[지속성 무시](http://deviq.com/persistence-ignorance/) 및 [인프라 무시](https://ayende.com/blog/3137/infrastructure-ignorance) 원칙에 따라 이 계층은 완전히 데이터 지속성 세부 정보를 무시해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="1c3a6-162">Following the [Persistence Ignorance](http://deviq.com/persistence-ignorance/) and the [Infrastructure Ignorance](https://ayende.com/blog/3137/infrastructure-ignorance) principles, this layer must completely ignore data persistence details.</span></span> <span data-ttu-id="1c3a6-163">이러한 지속성 작업은 인프라 계층에서 수행되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="1c3a6-163">These persistence tasks should be performed by the infrastructure layer.</span></span> <span data-ttu-id="1c3a6-164">따라서 이 계층은 인프라와 직접적인 종속성을 취하지 않습니다. 즉 도메인 모델 엔터티 클래스가 [POCO](https://en.wikipedia.org/wiki/Plain_Old_CLR_Object)여야 하는 것이 중요한 규칙이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1c3a6-164">Therefore, this layer should not take direct dependencies on the infrastructure, which means that an important rule is that your domain model entity classes should be [POCO](https://en.wikipedia.org/wiki/Plain_Old_CLR_Object)s.</span></span>

<span data-ttu-id="1c3a6-165">도메인 엔터티는 Entity Framework 또는 NHibernate 같은 데이터 액세스 인프라 프레임워크에 직접적인 종속성(기준 클래스에서 파생 등)을 갖지 않아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="1c3a6-165">Domain entities should not have any direct dependency (like deriving from a base class) on any data access infrastructure framework like Entity Framework or NHibernate.</span></span> <span data-ttu-id="1c3a6-166">이상적으로 도메인 엔터티는 인프라 프레임워크에서 정의된 어떤 유형으로부터 파생되거나 그러한 유형을 구현해서는 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1c3a6-166">Ideally, your domain entities should not derive from or implement any type defined in any infrastructure framework.</span></span>

<span data-ttu-id="1c3a6-167">Entity Framework Core와 같은 대부분의 최신 ORM 프레임워크에서는 이 방식을 허용하므로 도메인 모델 클래스가 인프라와 연결되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="1c3a6-167">Most modern ORM frameworks like Entity Framework Core allow this approach, so that your domain model classes are not coupled to the infrastructure.</span></span> <span data-ttu-id="1c3a6-168">그러나 Azure Service Fabric에서의 Actors 및 Reliable Collections 같이 특정 NoSQL 데이터베이스와 프레임워크를 사용할 경우, POCO 엔터티가 항상 가능한 것은 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="1c3a6-168">However, having POCO entities is not always possible when using certain NoSQL databases and frameworks, like Actors and Reliable Collections in Azure Service Fabric.</span></span>

<span data-ttu-id="1c3a6-169">도메인 모델에 대해 지속성 무시 원칙을 따르는 것이 중요하다 하더라도 지속성 우려를 무시해서는 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1c3a6-169">Even when it is important to follow the Persistence Ignorance principle for you Domain model, you should not ignore persistence concerns.</span></span> <span data-ttu-id="1c3a6-170">물리적 데이터 모델과, 엔터티 개체 모델과의 매핑 방식을 이해하는 것은 여전히 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="1c3a6-170">It is still very important to understand the physical data model and how it maps to your entity object model.</span></span> <span data-ttu-id="1c3a6-171">그렇지 않으면 불가능한 설계를 만들게 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1c3a6-171">Otherwise you can create impossible designs.</span></span>

<span data-ttu-id="1c3a6-172">또한 이것이 관계형 데이터베이스용으로 설계된 모델을 취하여 직접 NoSQL이나 문서 중심 데이터베이스로 이동할 수 있다는 뜻은 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="1c3a6-172">Also, this does not mean you can take a model designed for a relational database and directly move it to a NoSQL or document-oriented database.</span></span> <span data-ttu-id="1c3a6-173">일부 엔터티 모델에서는 이 모델이 맞을 수 있지만 보통은 그렇지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="1c3a6-173">In some entity models, the model might fit, but usually it does not.</span></span> <span data-ttu-id="1c3a6-174">저장소 기술과 ORM 기술에 모두 근거하여 엔터티 모델이 준수해야 하는 제약이 여전히 존재합니다.</span><span class="sxs-lookup"><span data-stu-id="1c3a6-174">There are still constraints that your entity model must adhere to, based both on the storage technology and ORM technology.</span></span>

### <a name="the-application-layer"></a><span data-ttu-id="1c3a6-175">응용 프로그램 계층</span><span class="sxs-lookup"><span data-stu-id="1c3a6-175">The application layer</span></span>

<span data-ttu-id="1c3a6-176">응용 프로그램 계층을 시작하면서 Eric Evans의 저서 [Domain Driven Design](https://domainlanguage.com/ddd/)을 다시 한 번 살펴보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="1c3a6-176">Moving on to the application layer, we can again cite Eric Evans's book [Domain Driven Design](https://domainlanguage.com/ddd/):</span></span>

<span data-ttu-id="1c3a6-177">**응용 프로그램 계층:** 소프트웨어가 수행할 작업을 정의하고 표현적 도메인 개체가 문제를 해결하도록 지시합니다.</span><span class="sxs-lookup"><span data-stu-id="1c3a6-177">**Application Layer:** Defines the jobs the software is supposed to do and directs the expressive domain objects to work out problems.</span></span> <span data-ttu-id="1c3a6-178">이 계층은이 담당하는 작업은 비즈니스에 유의미하거나, 다른 시스템의 응용 프로그램 계층과의 상호 작용에 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="1c3a6-178">The tasks this layer is responsible for are meaningful to the business or necessary for interaction with the application layers of other systems.</span></span> <span data-ttu-id="1c3a6-179">이 계층은 씬으로 유지됩니다.</span><span class="sxs-lookup"><span data-stu-id="1c3a6-179">This layer is kept thin.</span></span> <span data-ttu-id="1c3a6-180">비즈니스 규칙이나 지식은 포함하지 않으며 작업을 조정하고 다음 하위 계층에서 도메인 계층의 협력을 위해 업무를 위임하기만 합니다.</span><span class="sxs-lookup"><span data-stu-id="1c3a6-180">It does not contain business rules or knowledge, but only coordinates tasks and delegates work to collaborations of domain objects in the next layer down.</span></span> <span data-ttu-id="1c3a6-181">비비즈니스 상환을 반영하는 상태를 갖지 않지만 사용자 또는 프로그램에 대해 작업의 진행 상황을 반영하는 상태는 가질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1c3a6-181">It does not have state reflecting the business situation, but it can have state that reflects the progress of a task for the user or the program.</span></span>

<span data-ttu-id="1c3a6-182">.NET에서 마이크로 서비스의 응용 프로그램 계층은 일반적으로 ASP.NET Core Web API 프로젝트로 코딩됩니다.</span><span class="sxs-lookup"><span data-stu-id="1c3a6-182">A microservice’s application layer in .NET is commonly coded as an ASP.NET Core Web API project.</span></span> <span data-ttu-id="1c3a6-183">프로젝트는 마이크로 서비스의 상호 작용, 원격 네트워크 액세스 및 UI나 클라이언트 앱에서 사용하는 외부 웹 API를 구현합니다.</span><span class="sxs-lookup"><span data-stu-id="1c3a6-183">The project implements the microservice’s interaction, remote network access, and the external Web APIs used from the UI or client apps.</span></span> <span data-ttu-id="1c3a6-184">여기에는 CQRS 방식을 사용할 경우 쿼리, 마이크로 서비스에서 수락되는 명령, 마이크로 서비스 간의 이벤트 중심 통신(통합 이벤트)도 포함됩니다. </span><span class="sxs-lookup"><span data-stu-id="1c3a6-184">It includes queries if using a CQRS approach, commands accepted by the microservice, and even the event-driven communication between microservices (integration events).</span></span> <span data-ttu-id="1c3a6-185">응용 프로그램 계층을 나타내는 ASP.NET Core Web API는 비즈니스 규칙이나 도메인 정보(특히 트랜잭션이나 업데이트에 대한 도메인 규칙)를 포함해서는 안 됩니다. 이런 것은 도메인 모델 클래스 라이브러리가 소유해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="1c3a6-185">The ASP.NET Core Web API that represents the application layer must not contain business rules or domain knowledge (especially domain rules for transactions or updates); these should be owned by the domain model class library.</span></span> <span data-ttu-id="1c3a6-186">응용 프로그램 계층은 작업을 조정하기만 하며 도메인 상태를 보유하거나 정의해서는 안 됩니다(도메인 모델).</span><span class="sxs-lookup"><span data-stu-id="1c3a6-186">The application layer must only coordinate tasks and must not hold or define any domain state (domain model).</span></span> <span data-ttu-id="1c3a6-187">비즈니스 규칙 실행을 도메인 모델 클래스 자체에 위임하며(집계 루트 및 도메인 엔터티) 결과적으로 도메인 엔터티 내에서 데이터를 업데이트합니다.</span><span class="sxs-lookup"><span data-stu-id="1c3a6-187">It delegates the execution of business rules to the domain model classes themselves (aggregate roots and domain entities), which will ultimately update the data within those domain entities.</span></span>

<span data-ttu-id="1c3a6-188">기본적으로 응용 프로그램 논리에서 특정 프런트 엔드에 종속되는 모든 사용 사례를 구현하게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1c3a6-188">Basically, the application logic is where you implement all use cases that depend on a given front end.</span></span> <span data-ttu-id="1c3a6-189">예를 들어, Web API에 연결된 구현입니다.</span><span class="sxs-lookup"><span data-stu-id="1c3a6-189">For example, the implementation related to a Web API service.</span></span>

<span data-ttu-id="1c3a6-190">도메인 모델 계층의 도메인 논리, 고정, 데이터 모델, 관련 비즈니스 규칙이 프레젠테이션 및 응용 프로그램 계층에서 완전히 독립적이 되게 하는 것이 목표입니다.</span><span class="sxs-lookup"><span data-stu-id="1c3a6-190">The goal is that the domain logic in the domain model layer, its invariants, the data model, and related business rules must be completely independent from the presentation and application layers.</span></span> <span data-ttu-id="1c3a6-191">무엇보다 도메인 모델 계층은 인프라 프레임워크에 직접적으로 종속되어서는 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1c3a6-191">Most of all, the domain model layer must not directly depend on any infrastructure framework.</span></span>

### <a name="the-infrastructure-layer"></a><span data-ttu-id="1c3a6-192">인프라 계층</span><span class="sxs-lookup"><span data-stu-id="1c3a6-192">The infrastructure layer</span></span>

<span data-ttu-id="1c3a6-193">인프라 계층은 최초에 도메인 엔터티에 있던 데이터(메모리 내)가 데이터베이스나 기타 영구 저장소에 유지되는 방식입니다.</span><span class="sxs-lookup"><span data-stu-id="1c3a6-193">The infrastructure layer is how the data that is initially held in domain entities (in memory) is persisted in databases or another persistent store.</span></span> <span data-ttu-id="1c3a6-194">Entity Framework Core 코드를 사용하여 관계형 데이터베이스에 데이터를 지속하는 데 DBContext를 사용하는 저장소 패턴 클래스를 구현하는 것을 예로 들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1c3a6-194">An example is using Entity Framework Core code to implement the Repository pattern classes that use a DBContext to persist data in a relational database.</span></span>

<span data-ttu-id="1c3a6-195">앞에서 언급한 [지속성 무시](http://deviq.com/persistence-ignorance/) 및 [인프라 무시](https://ayende.com/blog/3137/infrastructure-ignorance) 원칙에 따라 인프라 계층은 도메인 모델 계층을 "오염" 시키지 않아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="1c3a6-195">In accordance with the previously mentioned [Persistence Ignorance](http://deviq.com/persistence-ignorance/) and [Infrastructure Ignorance](https://ayende.com/blog/3137/infrastructure-ignorance) principles, the infrastructure layer must not “contaminate” the domain model layer.</span></span> <span data-ttu-id="1c3a6-196">프레임워크에 대한 고정 종속성을 지양함으로써 도메인 모델 엔터티 클래스는 데이터 유지에 사용되는 인프라(EF 또는 기타 프레임워크)와는 무관하게 유지해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="1c3a6-196">You must keep the domain model entity classes agnostic from the infrastructure that you use to persist data (EF or any other framework) by not taking hard dependencies on frameworks.</span></span> <span data-ttu-id="1c3a6-197">도메인 모델 계층 클래스 라이브러리에는 자체 도메인 코드인 소프트웨어의 핵심을 구현하는 [POCO](https://en.wikipedia.org/wiki/Plain_Old_CLR_Object) 엔터티 소프트웨어만 있어야 하며 인프라 기술과는 완전히 분리되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="1c3a6-197">Your domain model layer class library should have only your domain code, just [POCO](https://en.wikipedia.org/wiki/Plain_Old_CLR_Object) entity classes implementing the heart of your software and completely decoupled from infrastructure technologies.</span></span>

<span data-ttu-id="1c3a6-198">따라서 그림 9-7에서처럼 계층 또는 클래스 라이브러리와 프로젝트는 결과적으로 도메인 모델 계층(라이브러리)에 종속되어야 하며 그 반대의 경우는 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="1c3a6-198">Thus, your layers or class libraries and projects should ultimately depend on your domain model layer (library), not vice versa, as shown in Figure 9-7.</span></span>

![](./media/image8.png)

<span data-ttu-id="1c3a6-199">**그림 9-7**.</span><span class="sxs-lookup"><span data-stu-id="1c3a6-199">**Figure 9-7**.</span></span> <span data-ttu-id="1c3a6-200">DDD의 계층 간 종속성</span><span class="sxs-lookup"><span data-stu-id="1c3a6-200">Dependencies between layers in DDD</span></span>

<span data-ttu-id="1c3a6-201">이 계층 설계는 각각의 마이크로 서비스마다 독립적입니다.</span><span class="sxs-lookup"><span data-stu-id="1c3a6-201">This layer design should be independent for each microservice.</span></span> <span data-ttu-id="1c3a6-202">앞서 언급한 것처럼 DDD 패턴에 따라 가장 복잡한 마이크로 서비스를 구현할 수 있고 더 간단한 데이터 중심 마이크로 서비스(단일 계층의 간단한 CRUD)는 더 간단한 방법으로 구현합니다.</span><span class="sxs-lookup"><span data-stu-id="1c3a6-202">As noted earlier, you can implement the most complex microservices following DDD patterns, while implementing simpler data-driven microservices (simple CRUD in a single layer) in a simpler way.</span></span>

#### <a name="additional-resources"></a><span data-ttu-id="1c3a6-203">추가 자료</span><span class="sxs-lookup"><span data-stu-id="1c3a6-203">Additional resources</span></span>

-   <span data-ttu-id="1c3a6-204">**DevIQ. 지속성 무시 원칙**
    [*http://deviq.com/persistence-ignorance/*](http://deviq.com/persistence-ignorance/)</span><span class="sxs-lookup"><span data-stu-id="1c3a6-204">**DevIQ. Persistence Ignorance principle**
[*http://deviq.com/persistence-ignorance/*](http://deviq.com/persistence-ignorance/)</span></span>

-   <span data-ttu-id="1c3a6-205">**Oren Eini. 인프라 무시**
    [*https://ayende.com/blog/3137/infrastructure-ignorance*](https://ayende.com/blog/3137/infrastructure-ignorance)</span><span class="sxs-lookup"><span data-stu-id="1c3a6-205">**Oren Eini. Infrastructure Ignorance**
[*https://ayende.com/blog/3137/infrastructure-ignorance*](https://ayende.com/blog/3137/infrastructure-ignorance)</span></span>

-   <span data-ttu-id="1c3a6-206">**Angel Lopez. 도메인 기반 디자인의 계층화된 아키텍처**
    [*https://ajlopez.wordpress.com/2008/09/12/layered-architecture-in-domain-driven-design/*](https://ajlopez.wordpress.com/2008/09/12/layered-architecture-in-domain-driven-design/)</span><span class="sxs-lookup"><span data-stu-id="1c3a6-206">**Angel Lopez. Layered Architecture In Domain-Driven Design**
[*https://ajlopez.wordpress.com/2008/09/12/layered-architecture-in-domain-driven-design/*](https://ajlopez.wordpress.com/2008/09/12/layered-architecture-in-domain-driven-design/)</span></span>


>[!div class="step-by-step"]
<span data-ttu-id="1c3a6-207">[이전] (cqrs-microservice-reads.md) [다음] (microservice-domain-model.md)</span><span class="sxs-lookup"><span data-stu-id="1c3a6-207">[Previous] (cqrs-microservice-reads.md) [Next] (microservice-domain-model.md)</span></span>

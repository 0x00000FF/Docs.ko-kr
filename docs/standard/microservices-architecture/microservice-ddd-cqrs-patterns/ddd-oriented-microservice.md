---
title: "DDD 지향 마이크로 서비스를 디자인합니다."
description: "컨테이너 화 된.NET 응용 프로그램에 대 한.NET Microservices 아키텍처 | DDD 지향 마이크로 서비스를 디자인합니다."
keywords: "Docker, 마이크로 서비스, ASP.NET, 컨테이너"
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 05/26/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.topic: article
ms.openlocfilehash: df45441089fd59d5e0e52b4bcec409adcc11fb71
ms.sourcegitcommit: bd1ef61f4bb794b25383d3d72e71041a5ced172e
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 10/18/2017
---
# <a name="designing-a-ddd-oriented-microservice"></a><span data-ttu-id="44173-104">DDD 지향 마이크로 서비스를 디자인합니다.</span><span class="sxs-lookup"><span data-stu-id="44173-104">Designing a DDD-oriented microservice</span></span>

<span data-ttu-id="44173-105">Business 사용 사례와 관련 된 현실에 따라 모델링을 대표 하는 도메인 기반 디자인 (DDD).</span><span class="sxs-lookup"><span data-stu-id="44173-105">Domain-driven design (DDD) advocates modeling based on the reality of business as relevant to your use cases.</span></span> <span data-ttu-id="44173-106">응용 프로그램을 구축의 컨텍스트에서 DDD 문제에 대 한 도메인으로 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="44173-106">In the context of building applications, DDD talks about problems as domains.</span></span> <span data-ttu-id="44173-107">경계가 지정 된 컨텍스트도 독립적인 문제 영역에 설명 (각 경계가 지정 된 컨텍스트 상관 관계를 지정 하는 마이크로 서비스), 그리고 이러한 문제에 대해 설명 하는 공용 언어를 강조 합니다.</span><span class="sxs-lookup"><span data-stu-id="44173-107">It describes independent problem areas as Bounded Contexts (each Bounded Context correlates to a microservice), and emphasizes a common language to talk about these problems.</span></span> <span data-ttu-id="44173-108">많은 기술 개념 및 패턴, 풍부한 모델 도메인 엔터티와 같이 제안 (없음 [anemic 도메인 모델](https://martinfowler.com/bliki/AnemicDomainModel.html)), 내부 구현을 지원 하기 위해 규칙 값 개체, 집계 및 집계 루트 (또는 루트 엔터티)입니다.</span><span class="sxs-lookup"><span data-stu-id="44173-108">It also suggests many technical concepts and patterns, like domain entities with rich models (no [anemic-domain model](https://martinfowler.com/bliki/AnemicDomainModel.html)), value objects, aggregates and aggregate root (or root entity) rules to support the internal implementation.</span></span> <span data-ttu-id="44173-109">이 섹션에서는 설계 및 구현 내부 패턴 중를 소개 합니다.</span><span class="sxs-lookup"><span data-stu-id="44173-109">This section introduces the design and implementation of those internal patterns.</span></span>

<span data-ttu-id="44173-110">경우에 따라 이러한 DDD 기술 규칙과 패턴 DDD 접근 방식을 구현 하기 위한 배우기 있는 장애물으로 인식 되는지에 합니다.</span><span class="sxs-lookup"><span data-stu-id="44173-110">Sometimes these DDD technical rules and patterns are perceived as obstacles that have a steep learning curve for implementing DDD approaches.</span></span> <span data-ttu-id="44173-111">하지만 중요 한 부분은 하지 패턴 자체에 있지만 비즈니스 문제에 부합 되므로 코드를 구성 및 동일한 비즈니스 용어 (유비쿼터스 언어)를 사용 하 여 합니다.</span><span class="sxs-lookup"><span data-stu-id="44173-111">But the important part is not the patterns themselves, but organizing the code so it is aligned to the business problems, and using the same business terms (ubiquitous language).</span></span> <span data-ttu-id="44173-112">또한 DDD 방법이 중요 한 비즈니스 규칙을 사용한 복잡 한 microservices를 구현 하는 경우에 적용 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="44173-112">In addition, DDD approaches should be applied only if you are implementing complex microservices with significant business rules.</span></span> <span data-ttu-id="44173-113">CRUD 서비스 처럼 간단 책임을 간단한 방법으로 관리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="44173-113">Simpler responsibilities, like a CRUD service, can be managed with simpler approaches.</span></span>

<span data-ttu-id="44173-114">경계를 그릴 위치가 디자인 및는 마이크로 서비스를 정의 하는 경우 중요 한 작업이입니다.</span><span class="sxs-lookup"><span data-stu-id="44173-114">Where to draw the boundaries is the key task when designing and defining a microservice.</span></span> <span data-ttu-id="44173-115">DDD 패턴 도메인의 복잡성을 이해 하는 데 도움이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="44173-115">DDD patterns help you understand the complexity in the domain.</span></span> <span data-ttu-id="44173-116">각 경계가 지정 된 컨텍스트에 대 한 도메인 모델에 대 한 식별 하 고 엔터티, 값 개체 및 도메인을 모델링 하는 집계를 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="44173-116">For the domain model for each Bounded Context, you identify and define the entities, value objects, and aggregates that model your domain.</span></span> <span data-ttu-id="44173-117">빌드 및 컨텍스트를 정의 하는 경계 내에 포함 된 도메인 모델을 구체화 합니다.</span><span class="sxs-lookup"><span data-stu-id="44173-117">You build and refine a domain model that is contained within a boundary that defines your context.</span></span> <span data-ttu-id="44173-118">있고는 마이크로 서비스의 형태로 매우 명시적입니다.</span><span class="sxs-lookup"><span data-stu-id="44173-118">And that is very explicit in the form of a microservice.</span></span> <span data-ttu-id="44173-119">해당 경계 내에서 구성 요소 프로그램 microservices 되 고 하지만 일부 경우 BC a에 되거나 비즈니스 microservices 몇 가지 물리적 서비스도 구성 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="44173-119">The components within those boundaries end up being your microservices, although in some cases a BC or business microservices can be composed of several physical services.</span></span> <span data-ttu-id="44173-120">DDD 경계에 대 한는 함께 microservices 있습니다.</span><span class="sxs-lookup"><span data-stu-id="44173-120">DDD is about boundaries and so are microservices.</span></span>

## <a name="keep-the-microservice-context-boundaries-relatively-small"></a><span data-ttu-id="44173-121">마이크로 서비스의 컨텍스트 경계 상대적으로 작게 유지</span><span class="sxs-lookup"><span data-stu-id="44173-121">Keep the microservice context boundaries relatively small</span></span>

<span data-ttu-id="44173-122">두 개의 경쟁 목표 조정 경계가 지정 된 컨텍스트 간에 경계를 배치할 위치를 결정 합니다.</span><span class="sxs-lookup"><span data-stu-id="44173-122">Determining where to place boundaries between Bounded Contexts balances two competing goals.</span></span> <span data-ttu-id="44173-123">먼저 만들려는 처음 가장 작은 가능한 microservices 주 드라이버; 되지 않아야 하는 있지만 응집력 필요한 부분이 주위의 경계를 만들어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="44173-123">First, you want to initially create the smallest possible microservices, although that should not be the main driver; you should create a boundary around things that need cohesion.</span></span> <span data-ttu-id="44173-124">둘째, microservices 간의 수 다 스러운 통신을 방지 하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="44173-124">Second, you want to avoid chatty communications between microservices.</span></span> <span data-ttu-id="44173-125">이러한 목표는 서로 상충 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="44173-125">These goals can contradict one another.</span></span> <span data-ttu-id="44173-126">가능한 한 신속 하 게 증가 하 고 각 추가 시도 새 경계가 지정 된 컨텍스트를 구분 하는 통신 경계를 표시 될 때까지 작은 microservices 시스템 분해 하 여 해당를 조정 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="44173-126">You should balance them by decomposing the system into as many small microservices as you can until you see communication boundaries growing quickly with each additional attempt to separate a new Bounded Context.</span></span> <span data-ttu-id="44173-127">응집력은 단일 bounded 컨텍스트 내에서 키입니다.</span><span class="sxs-lookup"><span data-stu-id="44173-127">Cohesion is key within a single bounded context.</span></span>

<span data-ttu-id="44173-128">비슷합니다는 [부적절 한 관계 코드 냄새](https://sourcemaking.com/refactoring/smells/inappropriate-intimacy) 클래스를 구현 하는 경우.</span><span class="sxs-lookup"><span data-stu-id="44173-128">It is similar to the [Inappropriate Intimacy code smell](https://sourcemaking.com/refactoring/smells/inappropriate-intimacy) when implementing classes.</span></span> <span data-ttu-id="44173-129">두 개의 microservices를 훨씬 상호 협력 해야 할 경우 동일한 마이크로 서비스 아마도 수 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="44173-129">If two microservices need to collaborate a lot with each other, they should probably be the same microservice.</span></span>

<span data-ttu-id="44173-130">다른이 방법은 자율성입니다.</span><span class="sxs-lookup"><span data-stu-id="44173-130">Another way to look at this is autonomy.</span></span> <span data-ttu-id="44173-131">마이크로 서비스를 직접 요청을 처리 하는 다른 서비스를 사용 해야 하는 경우 실제로 자치있지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="44173-131">If a microservice must rely on another service to directly service a request, it is not truly autonomous.</span></span>

## <a name="layers-in-ddd-microservices"></a><span data-ttu-id="44173-132">DDD microservices의 계층</span><span class="sxs-lookup"><span data-stu-id="44173-132">Layers in DDD microservices</span></span>

<span data-ttu-id="44173-133">중요 한 비즈니스 및 기술 복잡성 대부분 엔터프라이즈 응용 프로그램은 여러 계층에 의해 정의 됩니다.</span><span class="sxs-lookup"><span data-stu-id="44173-133">Most enterprise applications with significant business and technical complexity are defined by multiple layers.</span></span> <span data-ttu-id="44173-134">레이어 논리 아티팩트 되며 서비스의 배포와 관련이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="44173-134">The layers are a logical artifact, and are not related to the deployment of the service.</span></span> <span data-ttu-id="44173-135">이러한 코드의 복잡성을 관리 하는 개발자가 존재 합니다.</span><span class="sxs-lookup"><span data-stu-id="44173-135">They exist to help developers manage the complexity in the code.</span></span> <span data-ttu-id="44173-136">요구 하는 이러한 형식을 번역 경우 다른 형식으로 서로 다른 계층 (예: 도메인 모델 등 프레젠테이션 계층 및 계층)에 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="44173-136">Different layers (like the domain model layer versus the presentation layer, etc.) might have different types, which mandates translations between those types.</span></span>

<span data-ttu-id="44173-137">예를 들어 데이터베이스에서 엔터티를 로드할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="44173-137">For example, an entity could be loaded from the database.</span></span> <span data-ttu-id="44173-138">그런 다음 해당 정보를 또는 다른 엔터티에서 추가 데이터를 포함 하 여 정보에 대 한 집계의 일부 UI REST 웹 API를 통해 클라이언트에 보낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="44173-138">Then part of that information, or an aggregation of information including additional data from other entities, can be sent to the client UI through a REST Web API.</span></span> <span data-ttu-id="44173-139">여기 된다는 사실을 도메인 엔터티는 도메인 모델 계층 내에 포함 된 속해 있지 않아서, 같은 프레젠테이션 계층에 있는 다른 영역에 전파할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="44173-139">The point here is that the domain entity is contained within the domain model layer and should not be propagated to other areas that it does not belong to, like to the presentation layer.</span></span>

<span data-ttu-id="44173-140">항상 유효한 엔터티 해야 또한 (참조는 [도메인 모델 계층에서 유효성 검사를 디자인](#designing-validations-in-the-domain-model-layer) 섹션) 집계 루트 (루트 엔터티)에 의해 제어 됩니다.</span><span class="sxs-lookup"><span data-stu-id="44173-140">Additionally, you need to have always-valid entities (see the [Designing validations in the domain model layer](#designing-validations-in-the-domain-model-layer) section) controlled by aggregate roots (root entities).</span></span> <span data-ttu-id="44173-141">따라서 엔터티 바인딩되지 않아야 클라이언트 보기에 UI 수준에서 일부 데이터 수 여전히 되지 유효성을 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="44173-141">Therefore, entities should not be bound to client views, because at the UI level some data might still not be validated.</span></span> <span data-ttu-id="44173-142">이 ViewModel입니다.</span><span class="sxs-lookup"><span data-stu-id="44173-142">This is what the ViewModel is for.</span></span> <span data-ttu-id="44173-143">ViewModel은 프레젠테이션 계층의 요구 사항에 대 한 단독으로 데이터 모델입니다.</span><span class="sxs-lookup"><span data-stu-id="44173-143">The ViewModel is a data model exclusively for presentation layer needs.</span></span> <span data-ttu-id="44173-144">도메인 엔터티 ViewModel에 직접 속해 있지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="44173-144">The domain entities do not belong directly to the ViewModel.</span></span> <span data-ttu-id="44173-145">대신, Viewmodel 및 도메인 엔터티 간 또는 그 반대로 변환 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="44173-145">Instead, you need to translate between ViewModels and domain entities and vice versa.</span></span>

<span data-ttu-id="44173-146">단일 항목을 통해 엔터티 (집계) 해당 그룹 수행 하는 작업량과 복잡성은 것이 중요 한 도메인 모델이 모든 고정 및 규칙에 관련 되었는지 확인 하는 집계 루트 (살펴보기이 자세히 나중에)에 의해 제어 될 때 수행 됩니다. 포인트 또는 게이트를 집계 루트입니다.</span><span class="sxs-lookup"><span data-stu-id="44173-146">When tackling complexity, it is important to have a domain model controlled by aggregate roots (we go into this in more detail later) that make sure that all the invariants and rules related to that group of entities (aggregate) are performed through a single entry point or gate, the aggregate root.</span></span>

<span data-ttu-id="44173-147">그림 9-5 eShopOnContainers 응용 프로그램에 계층화 된 디자인을 구현 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="44173-147">Figure 9-5 shows how a layered design is implemented in the eShopOnContainers application.</span></span>

![](./media/image6.png)

<span data-ttu-id="44173-148">**그림 9-5**합니다.</span><span class="sxs-lookup"><span data-stu-id="44173-148">**Figure 9-5**.</span></span> <span data-ttu-id="44173-149">DDD 레이어 eShopOnContainers에 정렬 마이크로 서비스를</span><span class="sxs-lookup"><span data-stu-id="44173-149">DDD layers in the ordering microservice in eShopOnContainers</span></span>

<span data-ttu-id="44173-150">각 계층만 통신 합니다. 다른 계층의 특정 되도록 시스템을 디자인 하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="44173-150">You want to design the system so that each layer communicates only with certain other layers.</span></span> <span data-ttu-id="44173-151">보다 쉽게 됩니다. 어떤 종속 라이브러리 간에 설정를 명확 하 게 식별할 수 있으므로 서로 다른 클래스 라이브러리로 계층 구현 된 경우를 적용할 수 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="44173-151">That may be easier to enforce if layers are implemented as different class libraries, because you can clearly identify what dependencies are set between libraries.</span></span> <span data-ttu-id="44173-152">예를 들어, 도메인 모델 계층 걸리지 않습니다 종속성 다른 계층에 (일반 이전 CLR 개체 되어야 하는 도메인 모델 클래스 또는 [POCO](https://en.wikipedia.org/wiki/Plain_Old_CLR_Object), 클래스).</span><span class="sxs-lookup"><span data-stu-id="44173-152">For instance, the domain model layer should not take a dependency on any other layer (the domain model classes should be Plain Old CLR Objects, or [POCO](https://en.wikipedia.org/wiki/Plain_Old_CLR_Object), classes).</span></span> <span data-ttu-id="44173-153">그림 9-6에 나와 있는 것 처럼는 **Ordering.Domain** 레이어 라이브러리에 종속성만에.NET Core 라이브러리만 다른 사용자 지정 라이브러리 (데이터 라이브러리, 지 속성 라이브러리 등).</span><span class="sxs-lookup"><span data-stu-id="44173-153">As shown in Figure 9-6, the **Ordering.Domain** layer library has dependencies only on the .NET Core libraries but not on any other custom library (data library, persistence library, etc.).</span></span>

![](./media/image7.PNG)

<span data-ttu-id="44173-154">**그림 9-6**합니다.</span><span class="sxs-lookup"><span data-stu-id="44173-154">**Figure 9-6**.</span></span> <span data-ttu-id="44173-155">레이어 라이브러리 레이어 간의 종속성을 보다 효율적으로 제어할 수 있도록 하는 대로 구현</span><span class="sxs-lookup"><span data-stu-id="44173-155">Layers implemented as libraries allow better control of dependencies between layers</span></span>

### <a name="the-domain-model-layer"></a><span data-ttu-id="44173-156">도메인 모델 계층</span><span class="sxs-lookup"><span data-stu-id="44173-156">The domain model layer</span></span>

<span data-ttu-id="44173-157">Eric Evans 뛰어난 책 [도메인 기반 디자인](http://domainlanguage.com/ddd/) 도메인 모델 계층 및 응용 프로그램 계층에 대해 다음 언급이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="44173-157">Eric Evans's excellent book [Domain Driven Design](http://domainlanguage.com/ddd/) says the following about the domain model layer and the application layer.</span></span>

<span data-ttu-id="44173-158">**도메인 모델 계층**: 비즈니스, 비즈니스 상황 및 비즈니스 규칙에 대 한 정보에 대 한 개념을 나타내는 작업을 담당 합니다.</span><span class="sxs-lookup"><span data-stu-id="44173-158">**Domain Model Layer**: Responsible for representing concepts of the business, information about the business situation, and business rules.</span></span> <span data-ttu-id="44173-159">비즈니스 상황을 반영 하는 상태가 되어 제어 하 고 있지만 기술적 세부 정보가 저장 하는 인프라에 위임 되며 여기서 사용 하는 합니다.</span><span class="sxs-lookup"><span data-stu-id="44173-159">State that reflects the business situation is controlled and used here, even though the technical details of storing it are delegated to the infrastructure.</span></span> <span data-ttu-id="44173-160">이 계층은 비즈니스 소프트웨어의 핵심입니다.</span><span class="sxs-lookup"><span data-stu-id="44173-160">This layer is the heart of business software.</span></span>

<span data-ttu-id="44173-161">도메인 모델 계층은 비즈니스 표현 됩니다.</span><span class="sxs-lookup"><span data-stu-id="44173-161">The domain model layer is where the business is expressed.</span></span> <span data-ttu-id="44173-162">.NET에서 마이크로 서비스 도메인 모델 계층을 구현할 때 해당 계층은 데이터 + 동작 (논리로 사용 하는 메서드)를 캡처하는 도메인 엔터티와 클래스 라이브러리로 코딩 됩니다.</span><span class="sxs-lookup"><span data-stu-id="44173-162">When you implement a microservice domain model layer in .NET, that layer is coded as a class library with the domain entities that capture data plus behavior (methods with logic).</span></span>

<span data-ttu-id="44173-163">다음은 [지 속성 무시](http://deviq.com/persistence-ignorance/) 및 [인프라 무시](https://ayende.com/blog/3137/infrastructure-ignorance) 원칙,이 계층 데이터 지 속성 세부 정보를 완전히 무시 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="44173-163">Following the [Persistence Ignorance](http://deviq.com/persistence-ignorance/) and the [Infrastructure Ignorance](https://ayende.com/blog/3137/infrastructure-ignorance) principles, this layer must completely ignore data persistence details.</span></span> <span data-ttu-id="44173-164">이러한 지 속성 작업 인프라 계층에서 수행 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="44173-164">These persistence tasks should be performed by the infrastructure layer.</span></span> <span data-ttu-id="44173-165">따라서이 계층 걸리지 않습니다 직접 종속성에는 중요 한 규칙은 도메인 모델 엔터티 클래스가 있어야 함을 의미 하는 인프라를 [POCO](https://en.wikipedia.org/wiki/Plain_Old_CLR_Object)s입니다.</span><span class="sxs-lookup"><span data-stu-id="44173-165">Therefore, this layer should not take direct dependencies on the infrastructure, which means that an important rule is that your domain model entity classes should be [POCO](https://en.wikipedia.org/wiki/Plain_Old_CLR_Object)s.</span></span>

<span data-ttu-id="44173-166">도메인 엔터티 (예: 기본 클래스에서 파생) 직접 종속성 NHibernate 또는 Entity Framework와 같은 데이터 액세스 인프라 프레임 워크에 필요는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="44173-166">Domain entities should not have any direct dependency (like deriving from a base class) on any data access infrastructure framework like Entity Framework or NHibernate.</span></span> <span data-ttu-id="44173-167">이상적으로 도메인 엔터티 해야에서 파생 되지 않거나 모든 인프라 프레임 워크에 정의 된 모든 형식을 구현 합니다.</span><span class="sxs-lookup"><span data-stu-id="44173-167">Ideally, your domain entities should not derive from or implement any type defined in any infrastructure framework.</span></span>

<span data-ttu-id="44173-168">Entity Framework Core와 같은 대부분의 요즘 ORM 프레임 워크 도메인 모델 클래스는 인프라에 결합 되지 않도록이 방법을 사용을 허용 합니다.</span><span class="sxs-lookup"><span data-stu-id="44173-168">Most modern ORM frameworks like Entity Framework Core allow this approach, so that your domain model classes are not coupled to the infrastructure.</span></span> <span data-ttu-id="44173-169">그러나 POCO 엔터티 필요 불가능 항상 특정 NoSQL 데이터베이스 및 행위자 및 Azure 서비스 패브릭에서 신뢰할 수 있는 컬렉션 등의 프레임 워크를 사용 하는 경우.</span><span class="sxs-lookup"><span data-stu-id="44173-169">However, having POCO entities is not always possible when using certain NoSQL databases and frameworks, like Actors and Reliable Collections in Azure Service Fabric.</span></span>

<span data-ttu-id="44173-170">도메인 모델에 대 한 지 속성 무시 원칙에 따라 중요 하다 고 해도 문제를 지 속성 무시 하지 마십시오.</span><span class="sxs-lookup"><span data-stu-id="44173-170">Even when it is important to follow the Persistence Ignorance principle for you Domain model, you should not ignore persistence concerns.</span></span> <span data-ttu-id="44173-171">실제 데이터 모델 및 엔터티 개체 모델에 매핑되는 방식 이해 하는 여전히 합니다.</span><span class="sxs-lookup"><span data-stu-id="44173-171">It is still very important to understand the physical data model and how it maps to your entity object model.</span></span> <span data-ttu-id="44173-172">그렇지 않으면 불가능 설계를 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="44173-172">Otherwise you can create impossible designs.</span></span>

<span data-ttu-id="44173-173">또한 그렇다고를 관계형 데이터베이스에 대해 디자인 된 모델을 가져와 NoSQL 또는 문서 관련 데이터베이스에 직접 이동할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="44173-173">Also, this does not mean you can take a model designed for a relational database and directly move it to a NoSQL or document-oriented database.</span></span> <span data-ttu-id="44173-174">일부 엔터티 모델에 모델을 적합 하 게 하지만 일반적으로 없습니다.</span><span class="sxs-lookup"><span data-stu-id="44173-174">In some entity models, the model might fit, but usually it does not.</span></span> <span data-ttu-id="44173-175">엔터티 모델을 준수 해야, 저장소 기술 및 ORM 기술에 기반 하는 제약 조건을 아직 있습니다.</span><span class="sxs-lookup"><span data-stu-id="44173-175">There are still constraints that your entity model must adhere to, based both on the storage technology and ORM technology.</span></span>

### <a name="the-application-layer"></a><span data-ttu-id="44173-176">응용 프로그램 계층</span><span class="sxs-lookup"><span data-stu-id="44173-176">The application layer</span></span>

<span data-ttu-id="44173-177">Eric Evans 책을 명시 다시에서는 응용 프로그램 계층으로의 이동 [도메인 기반 디자인](http://domainlanguage.com/ddd/):</span><span class="sxs-lookup"><span data-stu-id="44173-177">Moving on to the application layer, we can again cite Eric Evans's book [Domain Driven Design](http://domainlanguage.com/ddd/):</span></span>

<span data-ttu-id="44173-178">**응용 프로그램 계층:** 소프트웨어 되는 작업을 수행 하 고 문제를 파악 하려고 표현 도메인 개체를 안내 하는 작업을 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="44173-178">**Application Layer:** Defines the jobs the software is supposed to do and directs the expressive domain objects to work out problems.</span></span> <span data-ttu-id="44173-179">이 계층은 역할에 대 한 작업은 비즈니스에 의미 있는 또는 다른 시스템의 응용 프로그램 계층 상호 작용을 위해 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="44173-179">The tasks this layer is responsible for are meaningful to the business or necessary for interaction with the application layers of other systems.</span></span> <span data-ttu-id="44173-180">이 계층은 씬 유지 됩니다.</span><span class="sxs-lookup"><span data-stu-id="44173-180">This layer is kept thin.</span></span> <span data-ttu-id="44173-181">비즈니스 규칙 또는 정보를 포함 하지 않고 하지만 다운 다음 계층의 도메인 개체의 공동 작업을 좌표 작업 및 대리자만 작동 합니다.</span><span class="sxs-lookup"><span data-stu-id="44173-181">It does not contain business rules or knowledge, but only coordinates tasks and delegates work to collaborations of domain objects in the next layer down.</span></span> <span data-ttu-id="44173-182">비즈니스 환경에 반영 하는 상태 없는 있지만 사용자나 프로그램에 대 한 작업의 진행 상태를 반영 하는 상태를 가질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="44173-182">It does not have state reflecting the business situation, but it can have state that reflects the progress of a task for the user or the program.</span></span>

<span data-ttu-id="44173-183">.NET에서 마이크로 서비스의 응용 프로그램 계층은 일반적으로 ASP.NET Core 웹 API 프로젝트로 코딩 됩니다.</span><span class="sxs-lookup"><span data-stu-id="44173-183">A microservice’s application layer in .NET is commonly coded as an ASP.NET Core Web API project.</span></span> <span data-ttu-id="44173-184">마이크로 서비스의 상호 작용, 원격 네트워크 액세스 및 UI 또는 클라이언트 응용 프로그램에서 사용 되는 외부 웹 Api 프로젝트를 구현 합니다.</span><span class="sxs-lookup"><span data-stu-id="44173-184">The project implements the microservice’s interaction, remote network access, and the external Web APIs used from the UI or client apps.</span></span> <span data-ttu-id="44173-185">CQRS를 사용 하 여 적절 한 명령을 마이크로 서비스, 및도 이벤트 구동 간의 통신 microservices (통합 이벤트)에서 허용 하는 경우 쿼리를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="44173-185">It includes queries if using a CQRS approach, commands accepted by the microservice, and even the event-driven communication between microservices (integration events).</span></span> <span data-ttu-id="44173-186">응용 프로그램 계층을 나타내는 ASP.NET Core 웹 API에는 비즈니스 규칙 또는 도메인 정보 (특히: 트랜잭션이나 업데이트에 대 한 도메인 규칙); 없어야 도메인 모델 클래스 라이브러리에서 소유 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="44173-186">The ASP.NET Core Web API that represents the application layer must not contain business rules or domain knowledge (especially domain rules for transactions or updates); these should be owned by the domain model class library.</span></span> <span data-ttu-id="44173-187">응용 프로그램 계층 합니다만 좌표 작업 및 저장 하거나 모든 도메인 상태 (도메인 모델)을 정의 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="44173-187">The application layer must only coordinate tasks and must not hold or define any domain state (domain model).</span></span> <span data-ttu-id="44173-188">도메인 모델 클래스는 자체 (집계 루트 및 도메인 엔터티) 궁극적으로 해당 도메인 엔터티 내에서 데이터를 업데이트 하는 비즈니스 규칙의 실행을 위임 합니다.</span><span class="sxs-lookup"><span data-stu-id="44173-188">It delegates the execution of business rules to the domain model classes themselves (aggregate roots and domain entities), which will ultimately update the data within those domain entities.</span></span>

<span data-ttu-id="44173-189">기본적으로, 응용 프로그램 논리는 지정 된 프런트 엔드에 종속 된 모든 사용 사례를 구현 하는 위치입니다.</span><span class="sxs-lookup"><span data-stu-id="44173-189">Basically, the application logic is where you implement all use cases that depend on a given front end.</span></span> <span data-ttu-id="44173-190">예를 들어, 구현 웹 API 서비스와 관련 된입니다.</span><span class="sxs-lookup"><span data-stu-id="44173-190">For example, the implementation related to a Web API service.</span></span>

<span data-ttu-id="44173-191">ֲ 도메인 모델 계층, 고정 해당, 데이터 모델 및 관련된 비즈니스 규칙에는 도메인 논리는 표시 및 응용 프로그램 계층에서 완전히 독립적 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="44173-191">The goal is that the domain logic in the domain model layer, its invariants, the data model, and related business rules must be completely independent from the presentation and application layers.</span></span> <span data-ttu-id="44173-192">가장, 도메인 모델 계층 인프라 프레임 워크에 직접 종속 되지 않아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="44173-192">Most of all, the domain model layer must not directly depend on any infrastructure framework.</span></span>

### <a name="the-infrastructure-layer"></a><span data-ttu-id="44173-193">인프라 계층</span><span class="sxs-lookup"><span data-stu-id="44173-193">The infrastructure layer</span></span>

<span data-ttu-id="44173-194">인프라 계층 데이터 처음에 메모리의 도메인 엔터티는 데이터베이스 또는 다른 영구 저장소에 유지 하는 방법을입니다.</span><span class="sxs-lookup"><span data-stu-id="44173-194">The infrastructure layer is how the data that is initially held in domain entities (in memory) is persisted in databases or another persistent store.</span></span> <span data-ttu-id="44173-195">예로는 Entity Framework 핵심 코드를 사용 하 여 DBContext를 사용 하 여 관계형 데이터베이스의 데이터를 유지 하는 리포지토리 패턴 클래스를 구현 하는 합니다.</span><span class="sxs-lookup"><span data-stu-id="44173-195">An example is using Entity Framework Core code to implement the Repository pattern classes that use a DBContext to persist data in a relational database.</span></span>

<span data-ttu-id="44173-196">앞에서 언급 한에 따라 [지 속성 무시](http://deviq.com/persistence-ignorance/) 및 [인프라 무시](https://ayende.com/blog/3137/infrastructure-ignorance) 원칙, 인프라 계층 해야 "묻지" 도메인 모델 계층입니다.</span><span class="sxs-lookup"><span data-stu-id="44173-196">In accordance with the previously mentioned [Persistence Ignorance](http://deviq.com/persistence-ignorance/) and [Infrastructure Ignorance](https://ayende.com/blog/3137/infrastructure-ignorance) principles, the infrastructure layer must not “contaminate” the domain model layer.</span></span> <span data-ttu-id="44173-197">하지 프레임 워크에 하드 종속성을 수행 하 여 데이터 (EF 또는 다른 프레임 워크)를 유지 하는 데 사용 하는 인프라에서의 도메인 모델 엔터티 클래스를 알 수 없는 유지 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="44173-197">You must keep the domain model entity classes agnostic from the infrastructure that you use to persist data (EF or any other framework) by not taking hard dependencies on frameworks.</span></span> <span data-ttu-id="44173-198">도메인 모델 계층 클래스 라이브러리 있어야 사용자 도메인 코드 방금 [POCO](https://en.wikipedia.org/wiki/Plain_Old_CLR_Object) 엔터티 소프트웨어의 핵심을 구현 하는 클래스 및 인프라 기술에서 완전히 분리 합니다.</span><span class="sxs-lookup"><span data-stu-id="44173-198">Your domain model layer class library should have only your domain code, just [POCO](https://en.wikipedia.org/wiki/Plain_Old_CLR_Object) entity classes implementing the heart of your software and completely decoupled from infrastructure technologies.</span></span>

<span data-ttu-id="44173-199">따라서 레이어 또는 클래스 라이브러리 및 프로젝트 해야 궁극적에 따라 도메인 모델 계층 (라이브러리), 그 반대로 하지 않습니다, 그림 9-7에 표시 된 것 처럼 합니다.</span><span class="sxs-lookup"><span data-stu-id="44173-199">Thus, your layers or class libraries and projects should ultimately depend on your domain model layer (library), not vice versa, as shown in Figure 9-7.</span></span>

![](./media/image8.png)

<span data-ttu-id="44173-200">**그림 9-7**합니다.</span><span class="sxs-lookup"><span data-stu-id="44173-200">**Figure 9-7**.</span></span> <span data-ttu-id="44173-201">Ddd에서 레이어 간의 종속성</span><span class="sxs-lookup"><span data-stu-id="44173-201">Dependencies between layers in DDD</span></span>

<span data-ttu-id="44173-202">이 계층 설계 각 마이크로 서비스에 대 한 영향을 받지 않아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="44173-202">This layer design should be independent for each microservice.</span></span> <span data-ttu-id="44173-203">가장 복잡 한 microservices 앞에서 설명한 대로 구현할 수 있습니다를 간단한 방식으로 데이터 기반 구현 간단 하면서 DDD 패턴을 따른 microservices (단일 계층의 간단한 CRUD).</span><span class="sxs-lookup"><span data-stu-id="44173-203">As noted earlier, you can implement the most complex microservices following DDD patterns, while implementing simpler data-driven microservices (simple CRUD in a single layer) in a simpler way.</span></span>

#### <a name="additional-resources"></a><span data-ttu-id="44173-204">추가 리소스</span><span class="sxs-lookup"><span data-stu-id="44173-204">Additional resources</span></span>

-   <span data-ttu-id="44173-205">**DevIQ 합니다. 지 속성 무시 원칙**
    [*http://deviq.com/persistence-ignorance/*](http://deviq.com/persistence-ignorance/)</span><span class="sxs-lookup"><span data-stu-id="44173-205">**DevIQ. Persistence Ignorance principle**
[*http://deviq.com/persistence-ignorance/*](http://deviq.com/persistence-ignorance/)</span></span>

-   <span data-ttu-id="44173-206">**Oren Eini 합니다. 인프라 무시**
    [*https://ayende.com/blog/3137/infrastructure-ignorance*](https://ayende.com/blog/3137/infrastructure-ignorance)</span><span class="sxs-lookup"><span data-stu-id="44173-206">**Oren Eini. Infrastructure Ignorance**
[*https://ayende.com/blog/3137/infrastructure-ignorance*](https://ayende.com/blog/3137/infrastructure-ignorance)</span></span>

-   <span data-ttu-id="44173-207">**Angel Lopez 합니다. 도메인 기반 디자인의 아키텍처를 계층화**
    [*https://ajlopez.wordpress.com/2008/09/12/layered-architecture-in-domain-driven-design/*](https://ajlopez.wordpress.com/2008/09/12/layered-architecture-in-domain-driven-design/)</span><span class="sxs-lookup"><span data-stu-id="44173-207">**Angel Lopez. Layered Architecture In Domain-Driven Design**
[*https://ajlopez.wordpress.com/2008/09/12/layered-architecture-in-domain-driven-design/*](https://ajlopez.wordpress.com/2008/09/12/layered-architecture-in-domain-driven-design/)</span></span>


>[!div class="step-by-step"]
<span data-ttu-id="44173-208">[이전] (cqrs-마이크로 서비스-reads.md) [다음] (마이크로 서비스 도메인 model.md)</span><span class="sxs-lookup"><span data-stu-id="44173-208">[Previous] (cqrs-microservice-reads.md) [Next] (microservice-domain-model.md)</span></span>

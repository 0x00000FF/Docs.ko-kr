---
title: "마이크로 서비스 도메인 모델 디자인"
description: "컨테이너 화 된.NET 응용 프로그램에 대 한.NET Microservices 아키텍처 | 마이크로 서비스 도메인 모델 디자인"
keywords: "Docker, 마이크로 서비스, ASP.NET, 컨테이너"
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 05/26/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.topic: article
ms.openlocfilehash: 455a2c5a39fb9b765b557610ab108f8c75882dbd
ms.sourcegitcommit: bd1ef61f4bb794b25383d3d72e71041a5ced172e
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 10/18/2017
---
# <a name="designing-a-microservice-domain-model"></a><span data-ttu-id="e61c0-104">마이크로 서비스 도메인 모델 디자인</span><span class="sxs-lookup"><span data-stu-id="e61c0-104">Designing a microservice domain model</span></span>

<span data-ttu-id="e61c0-105">*각 비즈니스 마이크로 서비스 또는 컨텍스트 제한에 대 한 풍부한 도메인 모델을 정의 합니다.*</span><span class="sxs-lookup"><span data-stu-id="e61c0-105">*Define one rich domain model for each business microservice or Bounded Context*</span></span>

<span data-ttu-id="e61c0-106">여기서의 목표는 각 비즈니스 마이크로 서비스 또는 경계가 지정 된 컨텍스트 (BC)에 대 한 단일 화합 도메인 모델을 만드는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="e61c0-106">Your goal is to create a single cohesive domain model for each business microservice or Bounded Context (BC).</span></span> <span data-ttu-id="e61c0-107">그러나 염두에서에 둬야, 있는 a BC 단일 도메인 모델을 공유 하는 몇 가지 실제 서비스의 비즈니스 마이크로 서비스를 구성 될 경우에 따라 또는 합니다.</span><span class="sxs-lookup"><span data-stu-id="e61c0-107">Keep in mind, however, that a BC or business microservice could sometimes be composed of several physical services that share a single domain model.</span></span> <span data-ttu-id="e61c0-108">도메인 모델 규칙, 동작, 비즈니스 언어 및 단일 경계가 지정 된 컨텍스트 또는 표시 되는 비즈니스 마이크로 서비스의 제약 조건을 캡처해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="e61c0-108">The domain model must capture the rules, behavior, business language, and constraints of the single Bounded Context or business microservice that it represents.</span></span>

## <a name="the-domain-entity-pattern"></a><span data-ttu-id="e61c0-109">도메인 엔터티 패턴</span><span class="sxs-lookup"><span data-stu-id="e61c0-109">The Domain Entity pattern</span></span>

<span data-ttu-id="e61c0-110">도메인 개체를 나타내는 엔터티와 주로 의해 정의 id, 연속성 및 시간이 지남에 따라 지 속성을 구성 하는 특성으로 뿐만 아니라 합니다.</span><span class="sxs-lookup"><span data-stu-id="e61c0-110">Entities represent domain objects and are primarily defined by their identity, continuity, and persistence over time, and not only by the attributes that comprise them.</span></span> <span data-ttu-id="e61c0-111">Eric Evans 라고 표시 하는 대로 "기본적으로 해당 id로 정의 하는 개체를 엔터티 라고 합니다."</span><span class="sxs-lookup"><span data-stu-id="e61c0-111">As Eric Evans says, “an object primarily defined by its identity is called an Entity.”</span></span> <span data-ttu-id="e61c0-112">이들은 모델에 대 한 기준 엔터티는 도메인 모델에서 매우 중요 합니다.</span><span class="sxs-lookup"><span data-stu-id="e61c0-112">Entities are very important in the domain model, since they are the base for a model.</span></span> <span data-ttu-id="e61c0-113">따라서 식별 하 고 해당 작업을 신중 하 게 디자인 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="e61c0-113">Therefore, you should identify and design them carefully.</span></span>

<span data-ttu-id="e61c0-114">*여러 microservices 또는 경계가 지정 된 컨텍스트는 엔터티 id 매개자 수 있습니다.*</span><span class="sxs-lookup"><span data-stu-id="e61c0-114">*An entity’s identity can cross multiple microservices or Bounded Contexts.*</span></span>

<span data-ttu-id="e61c0-115">동일한 id (경우에 같은 엔터티 하지) 여러 경계가 지정 된 컨텍스트 또는 microservices 모델링할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e61c0-115">The same identity (though not the same entity) can be modeled across multiple Bounded Contexts or microservices.</span></span> <span data-ttu-id="e61c0-116">그러나 같은 특성 및 논리를 가진 동일한 엔터티를 제한 하는 여러 상황에서 구현 될 것과이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="e61c0-116">However, that does not imply that the same entity, with the same attributes and logic would be implemented in multiple Bounded Contexts.</span></span> <span data-ttu-id="e61c0-117">대신, 각 경계가 지정 된 컨텍스트에서 엔터티 해당 특성 및 해당 제한 컨텍스트 도메인에 필요한 쿼리에만에 동작을 제한합니다.</span><span class="sxs-lookup"><span data-stu-id="e61c0-117">Instead, entities in each Bounded Context limit their attributes and behaviors to those required in that Bounded Context’s domain.</span></span>

<span data-ttu-id="e61c0-118">예를 들어 구매자 엔터티는 대부분의 사용자 엔터티는 프로필 또는 id 마이크로 서비스를 id를 포함 하 여에 정의 되어 있는 사람의 특성의 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e61c0-118">For instance, the buyer entity might have most of a person’s attributes that are defined in the user entity in the profile or identity microservice, including the identity.</span></span> <span data-ttu-id="e61c0-119">이지만 특정 buyer 데이터만 주문 프로세스는 관련이 있으므로 정렬 마이크로 서비스에서 구매자 엔터티 더 적은 수의 특성을 가질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e61c0-119">But the buyer entity in the ordering microservice might have fewer attributes, because only certain buyer data is related to the order process.</span></span> <span data-ttu-id="e61c0-120">각 마이크로 서비스의 컨텍스트 또는 제한 된 상황에 맞는 해당 도메인 모델에 영향을 줍니다.</span><span class="sxs-lookup"><span data-stu-id="e61c0-120">The context of each microservice or Bounded Context impacts its domain model.</span></span>

<span data-ttu-id="e61c0-121">*도메인 엔터티 데이터 특성을 구현 하는 것 외에도 동작을 구현 해야 합니다.*</span><span class="sxs-lookup"><span data-stu-id="e61c0-121">*Domain entities must implement behavior in addition to implementing data attributes*</span></span>

<span data-ttu-id="e61c0-122">Ddd에서 도메인 엔터티는 도메인 논리 또는 데이터와 관련 된 엔터티 (메모리에 액세스 하는 개체) 동작을 구현 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="e61c0-122">A domain entity in DDD must implement the domain logic or behavior related to the entity data (the object accessed in memory).</span></span> <span data-ttu-id="e61c0-123">예를 들어 order 엔터티 클래스의 일부로 있어야 비즈니스 논리 및 작업은 주문 항목, 데이터 유효성 검사 및 총 계산을 추가 하는 등 작업에 대 한 메서드로 구현 합니다.</span><span class="sxs-lookup"><span data-stu-id="e61c0-123">For example, as part of an order entity class you must have business logic and operations implemented as methods for tasks such as adding an order item, data validation, and total calculation.</span></span> <span data-ttu-id="e61c0-124">고정 및 이러한 규칙은 응용 프로그램 계층에 분산 하는 대신 엔터티의 규칙의 엔터티 메서드 주의 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="e61c0-124">The entity’s methods take care of the invariants and rules of the entity instead of having those rules spread across the application layer.</span></span>

<span data-ttu-id="e61c0-125">그림 9-8 뿐만 아니라 데이터 특성 하지만 작업 또는 관련된 도메인 논리를 사용 하 여 메서드를 구현 하는 도메인 엔터티를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="e61c0-125">Figure 9-8 shows a domain entity that implements not only data attributes but operations or methods with related domain logic.</span></span>

![](./media/image9.png)

<span data-ttu-id="e61c0-126">**그림 9-8**합니다.</span><span class="sxs-lookup"><span data-stu-id="e61c0-126">**Figure 9-8**.</span></span> <span data-ttu-id="e61c0-127">데이터와 동작을 구현 하는 도메인 엔터티 디자인의 예</span><span class="sxs-lookup"><span data-stu-id="e61c0-127">Example of a domain entity design implementing data plus behavior</span></span>

<span data-ttu-id="e61c0-128">물론, 경우에 따라 엔터티 클래스의 일부로 모든 논리를 구현 하지 않는 엔터티를 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e61c0-128">Of course, sometimes you can have entities that do not implement any logic as part of the entity class.</span></span> <span data-ttu-id="e61c0-129">이 인해 자식 엔터티가 없는 경우 특별 한 논리 집계 루트에 있는 대부분의 논리 정의 되었기 때문에 자식 엔터티 집계 내에서 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e61c0-129">This can happen in child entities within an aggregate if the child entity does not have any special logic because most of the logic is defined in the aggregate root.</span></span> <span data-ttu-id="e61c0-130">도메인 엔터티 대신 서비스 클래스에 구현 된 논리가 많이 포함 하는 복잡 한 마이크로 서비스를 사용 하도록 설정한 경우 다음 섹션에 설명 된 anemic 도메인 모델에 속하는 있습니다 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="e61c0-130">If you have a complex microservice that has a lot of logic implemented in the service classes instead of in the domain entities, you could be falling into the anemic domain model, explained in the following section.</span></span>

### <a name="rich-domain-model-versus-anemic-domain-model"></a><span data-ttu-id="e61c0-131">Anemic 도메인 모델 및 풍부한 도메인 모델</span><span class="sxs-lookup"><span data-stu-id="e61c0-131">Rich domain model versus anemic domain model</span></span>

<span data-ttu-id="e61c0-132">그의 게시물에 [AnemicDomainModel](https://martinfowler.com/bliki/AnemicDomainModel.html), Martin Fowler이 이렇게 anemic 도메인 모델을 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="e61c0-132">In his post [AnemicDomainModel](https://martinfowler.com/bliki/AnemicDomainModel.html), Martin Fowler describes an anemic domain model this way:</span></span>

<span data-ttu-id="e61c0-133">언뜻 보기에 같다는 실제 처럼는 하는 기본 증상은 Anemic 도메인 모델입니다.</span><span class="sxs-lookup"><span data-stu-id="e61c0-133">The basic symptom of an Anemic Domain Model is that at first blush it looks like the real thing.</span></span> <span data-ttu-id="e61c0-134">개체가에 있는 명사 도메인 공간에 따라 명명 된 많은 및 이러한 개체의 풍부한 관계 및 true 도메인 모델에는 구조와 연결 합니다.</span><span class="sxs-lookup"><span data-stu-id="e61c0-134">There are objects, many named after the nouns in the domain space, and these objects are connected with the rich relationships and structure that true domain models have.</span></span> <span data-ttu-id="e61c0-135">Catch 실현할 경우에 동작을 보면 이러한 개체에서 동작은 거의 모든 봉투 getter 및 setter에 보다 좀 더 쉽게 제공 됩니다.</span><span class="sxs-lookup"><span data-stu-id="e61c0-135">The catch comes when you look at the behavior, and you realize that there is hardly any behavior on these objects, making them little more than bags of getters and setters.</span></span>

<span data-ttu-id="e61c0-136">물론, anemic 도메인 모델을 사용 하면 이러한 데이터 모델에서에서 사용할 서비스 개체의 집합 (일반적으로 명명 된는 *비즈니스 계층*)를 캡처할 모든 도메인 또는 비즈니스 논리입니다.</span><span class="sxs-lookup"><span data-stu-id="e61c0-136">Of course, when you use an anemic domain model, those data models will be used from a set of service objects (traditionally named the *business layer*) which capture all the domain or business logic.</span></span> <span data-ttu-id="e61c0-137">비즈니스 계층 데이터 모델 위에 배치 하 고 데이터와 마찬가지로 데이터 모델을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="e61c0-137">The business layer sits on top of the data model and uses the data model just as data.</span></span>

<span data-ttu-id="e61c0-138">Anemic 도메인 모델에는 절차적 스타일 노드 뿐입니다.</span><span class="sxs-lookup"><span data-stu-id="e61c0-138">The anemic domain model is just a procedural style design.</span></span> <span data-ttu-id="e61c0-139">Anemic 엔터티 개체는 동작 (메서드)를 없기 때문에 실제 개체가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="e61c0-139">Anemic entity objects are not real objects because they lack behavior (methods).</span></span> <span data-ttu-id="e61c0-140">데이터 속성 이므로 저장 며 따라서 없습니다 개체 지향 디자인 합니다.</span><span class="sxs-lookup"><span data-stu-id="e61c0-140">They only hold data properties and thus it is not object-oriented design.</span></span> <span data-ttu-id="e61c0-141">서비스 개체 (비즈니스 계층)에 모든 동작을 축소 입력 하 여 기본적으로 /fd [코드](https://en.wikipedia.org/wiki/Spaghetti_code) 또는 [트랜잭션 스크립트](https://martinfowler.com/eaaCatalog/transactionScript.html), 하는 장점의 손실 따라서 도메인 모델 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="e61c0-141">By putting all the behavior out into service objects (the business layer) you essentially end up with [spaghetti code](https://en.wikipedia.org/wiki/Spaghetti_code) or [transaction scripts](https://martinfowler.com/eaaCatalog/transactionScript.html), and therefore you lose the advantages that a domain model provides.</span></span>

<span data-ttu-id="e61c0-142">마이크로 서비스 또는 경계가 지정 된 컨텍스트는 매우 간단 하는 경우 상관 없이 (CRUD 서비스)에 데이터 속성을 사용 하 여 엔터티 개체의 형태로 anemic 도메인 모델이 적당 수 있습니다 및 더 복잡 한 DDD 패턴 구현 가치가 없을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e61c0-142">Regardless, if your microservice or Bounded Context is very simple (a CRUD service), the anemic domain model in the form of entity objects with just data properties might be good enough, and it might not be worth implementing more complex DDD patterns.</span></span> <span data-ttu-id="e61c0-143">이 경우 됩니다 단순히 지 속성 모델 엔터티 CRUD 목적에 대 한 데이터만 의도적으로 만들었기 때문에.</span><span class="sxs-lookup"><span data-stu-id="e61c0-143">In that case, it will be simply a persistence model, because you have intentionally created an entity with only data for CRUD purposes.</span></span>

<span data-ttu-id="e61c0-144">이 microservices 아키텍처는 각 경계가 지정 된 컨텍스트에 따라 다중 아키텍처 방법에 대 한 완벽 한 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="e61c0-144">That is why microservices architectures are perfect for a multi-architectural approach depending on each Bounded Context.</span></span> <span data-ttu-id="e61c0-145">예를 들어, eShopOnContainers에서 정렬 마이크로 서비스 DDD 패턴을 구현 합니다. 하지만 간단한 CRUD 서비스 카탈로그 마이크로 서비스 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="e61c0-145">For instance, in eShopOnContainers, the ordering microservice implements DDD patterns, but the catalog microservice, which is a simple CRUD service, does not.</span></span>

<span data-ttu-id="e61c0-146">일부 사용자는 안티패턴 anemic 도메인 모델을 말합니다.</span><span class="sxs-lookup"><span data-stu-id="e61c0-146">Some people say that the anemic domain model is an anti-pattern.</span></span> <span data-ttu-id="e61c0-147">실제로 구현 하는 내용에 따라 달라 집니다.</span><span class="sxs-lookup"><span data-stu-id="e61c0-147">It really depends on what you are implementing.</span></span> <span data-ttu-id="e61c0-148">만들려는 마이크로 서비스 이면 단순 충분히 (예를 들어 CRUD 서비스의 경우)는 안티패턴 없으면 anemic 도메인 모델입니다.</span><span class="sxs-lookup"><span data-stu-id="e61c0-148">If the microservice you are creating is simple enough (for example, a CRUD service), following the anemic domain model it is not an anti-pattern.</span></span> <span data-ttu-id="e61c0-149">그러나 끊임없이 변화 하는 비즈니스 규칙의 많은 마이크로 서비스의 도메인의 복잡성을 해결 해야 하는 경우 anemic 도메인 모델 해당 마이크로 서비스 또는 경계가 지정 된 컨텍스트는 안티패턴 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e61c0-149">However, if you need to tackle the complexity of a microservice’s domain that has a lot of ever-changing business rules, the anemic domain model might be an anti-pattern for that microservice or Bounded Context.</span></span> <span data-ttu-id="e61c0-150">이 경우 rich로 디자인 (집계, 개체 등) 추가 DDD 패턴을 구현 뿐만 아니라 데이터 형식과 동작이 포함 된 엔터티를 사용 하 여 모델에는 이러한 마이크로 서비스의 장기적인 성공에 대 한 큰 혜택이 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e61c0-150">In that case, designing it as a rich model with entities containing data plus behavior as well as implementing additional DDD patterns (aggregates, value objects, etc.) might have huge benefits for the long-term success of such a microservice.</span></span>

#### <a name="additional-resources"></a><span data-ttu-id="e61c0-151">추가 리소스</span><span class="sxs-lookup"><span data-stu-id="e61c0-151">Additional resources</span></span>

-   <span data-ttu-id="e61c0-152">**DevIQ 합니다. 도메인 엔터티**
    [*http://deviq.com/entity/*](http://deviq.com/entity/)</span><span class="sxs-lookup"><span data-stu-id="e61c0-152">**DevIQ. Domain Entity**
[*http://deviq.com/entity/*](http://deviq.com/entity/)</span></span>

-   <span data-ttu-id="e61c0-153">**Martin Fowler. 도메인 모델**
    [*https://martinfowler.com/eaaCatalog/domainModel.html*](https://martinfowler.com/eaaCatalog/domainModel.html)</span><span class="sxs-lookup"><span data-stu-id="e61c0-153">**Martin Fowler. The Domain Model**
[*https://martinfowler.com/eaaCatalog/domainModel.html*](https://martinfowler.com/eaaCatalog/domainModel.html)</span></span>

-   <span data-ttu-id="e61c0-154">**Martin Fowler. Anemic 도메인 모델**</span><span class="sxs-lookup"><span data-stu-id="e61c0-154">**Martin Fowler. The Anemic Domain Model**</span></span>

    <span data-ttu-id="e61c0-155"><https://martinfowler.com/bliki/AnemicDomainModel.html></span><span class="sxs-lookup"><span data-stu-id="e61c0-155"><https://martinfowler.com/bliki/AnemicDomainModel.html></span></span>

### <a name="the-value-object-pattern"></a><span data-ttu-id="e61c0-156">값 개체 패턴</span><span class="sxs-lookup"><span data-stu-id="e61c0-156">The Value Object pattern</span></span>

<span data-ttu-id="e61c0-157">Eric Evans 듯이 "많은 개체가 않아도 개념적 identity 됩니다.</span><span class="sxs-lookup"><span data-stu-id="e61c0-157">As Eric Evans has noted, “Many objects do not have conceptual identity.</span></span> <span data-ttu-id="e61c0-158">이 개체를 설명는 작업의 일정 한 특성이 있습니다. "</span><span class="sxs-lookup"><span data-stu-id="e61c0-158">These objects describe certain characteristics of a thing.”</span></span>

<span data-ttu-id="e61c0-159">엔터티 id가 필요 하지만 하지 않는 시스템에 많은 개체가 있는 값 개체 패턴을 선택 합니다.</span><span class="sxs-lookup"><span data-stu-id="e61c0-159">An entity requires an identity, but there are many objects in a system that do not, like the Value Object pattern.</span></span> <span data-ttu-id="e61c0-160">값 개체는 도메인 측면을 설명 하는 개념 없는 id 가진 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="e61c0-160">A value object is an object with no conceptual identity that describes a domain aspect.</span></span> <span data-ttu-id="e61c0-161">이들은 일시적으로 하면 관련 된 디자인 요소를 나타내기 위해 인스턴스화하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="e61c0-161">These are objects that you instantiate to represent design elements that only concern you temporarily.</span></span> <span data-ttu-id="e61c0-162">중요 한 *어떤* 없는, *가* 됩니다.</span><span class="sxs-lookup"><span data-stu-id="e61c0-162">You care about *what* they are, not *who* they are.</span></span> <span data-ttu-id="e61c0-163">예에는 숫자와 문자열을 제외한 특성 그룹의 같은 더 높은 수준의 개념 될 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e61c0-163">Examples include numbers and strings, but can also be higher-level concepts like groups of attributes.</span></span>

<span data-ttu-id="e61c0-164">마이크로 서비스의 엔터티를 해당 기능의 아닐 수 있습니다 다른 마이크로 서비스의 엔터티를 두 번째 경우에는 경계가 지정 된 컨텍스트는 다른 의미 있을 수 있으므로.</span><span class="sxs-lookup"><span data-stu-id="e61c0-164">Something that is an entity in a microservice might not be an entity in another microservice, because in the second case, the Bounded Context might have a different meaning.</span></span> <span data-ttu-id="e61c0-165">예를 들어 전자 상거래 응용 프로그램에 있는 주소 없을 수 있습니다는 id, 이후만 개인 또는 회사에 대 한 고객의 프로필의 특성 그룹을 나타낼 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e61c0-165">For example, an address in an e-commerce application might not have an identity at all, since it might only represent a group of attributes of the customer’s profile for a person or company.</span></span> <span data-ttu-id="e61c0-166">이 경우 주소를 값 개체 분류 해야 할 합니다.</span><span class="sxs-lookup"><span data-stu-id="e61c0-166">In this case, the address should be classified as a value object.</span></span> <span data-ttu-id="e61c0-167">그러나 electric 전원 유틸리티 회사에 대 한 응용 프로그램에서는 고객 주소 비즈니스 도메인 중요 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e61c0-167">However, in an application for an electric power utility company, the customer address could be important for the business domain.</span></span> <span data-ttu-id="e61c0-168">따라서 주소 주소에 청구 시스템을 직접 연결할 수 있도록 id가 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="e61c0-168">Therefore, the address must have an identity so the billing system can be directly linked to the address.</span></span> <span data-ttu-id="e61c0-169">이 경우 주소는 도메인 엔터티로 분류 해야 할 합니다.</span><span class="sxs-lookup"><span data-stu-id="e61c0-169">In that case, an address should be classified as a domain entity.</span></span>

<span data-ttu-id="e61c0-170">이름 및 성을 있는 사용자 엔터티는 일반적으로 사용자 이름 및 성을 다른 값 집합을와 일치 하는 경우에 id를 가진, 때문에 경우와 같이 해당 이름을 의미 하기도 다른 사용자에 게 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e61c0-170">A person with a name and surname is usually an entity because a person has identity, even if the name and surname coincide with another set of values, such as if those names also refers to a different person.</span></span>

<span data-ttu-id="e61c0-171">값 개체는 문서에서 구현 하 고 사용 하 여 쉽게 데이터베이스를 지향 하지만 EF, 같은 Orm 관계형 데이터베이스에서 관리 하기가입니다.</span><span class="sxs-lookup"><span data-stu-id="e61c0-171">Value objects are hard to manage in relational databases and ORMs like EF, whereas in document oriented databases they are easier to implement and use.</span></span>

#### <a name="additional-resources"></a><span data-ttu-id="e61c0-172">추가 리소스</span><span class="sxs-lookup"><span data-stu-id="e61c0-172">Additional resources</span></span>

-   <span data-ttu-id="e61c0-173">**Martin Fowler. 값 개체 패턴**
    [*https://martinfowler.com/bliki/ValueObject.html*](https://martinfowler.com/bliki/ValueObject.html)</span><span class="sxs-lookup"><span data-stu-id="e61c0-173">**Martin Fowler. Value Object pattern**
[*https://martinfowler.com/bliki/ValueObject.html*](https://martinfowler.com/bliki/ValueObject.html)</span></span>

-   <span data-ttu-id="e61c0-174">**개체를 값**
    [*http://deviq.com/value-object/*](http://deviq.com/value-object/)</span><span class="sxs-lookup"><span data-stu-id="e61c0-174">**Value Object**
[*http://deviq.com/value-object/*](http://deviq.com/value-object/)</span></span>

-   <span data-ttu-id="e61c0-175">**값 기반 개발에서 개체**
    [*https://leanpub.com/tdd-ebook/read\#leanpub 자동-값 개체*](https://leanpub.com/tdd-ebook/read#leanpub-auto-value-objects)</span><span class="sxs-lookup"><span data-stu-id="e61c0-175">**Value Objects in Test-Driven Development**
[*https://leanpub.com/tdd-ebook/read\#leanpub-auto-value-objects*](https://leanpub.com/tdd-ebook/read#leanpub-auto-value-objects)</span></span>

-   <span data-ttu-id="e61c0-176">**Eric Evans. 도메인 기반 디자인: 소프트웨어 핵심에서 복잡성을 다루는 합니다.**</span><span class="sxs-lookup"><span data-stu-id="e61c0-176">**Eric Evans. Domain-Driven Design: Tackling Complexity in the Heart of Software.**</span></span> <span data-ttu-id="e61c0-177">(예약; 값 개체에 설명) [ *https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/*](https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/)</span><span class="sxs-lookup"><span data-stu-id="e61c0-177">(Book; includes a discussion of value objects) [*https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/*](https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/)</span></span>

### <a name="the-aggregate-pattern"></a><span data-ttu-id="e61c0-178">집계 패턴</span><span class="sxs-lookup"><span data-stu-id="e61c0-178">The Aggregate pattern</span></span>

<span data-ttu-id="e61c0-179">도메인 모델에 있는 다른 데이터 엔터티 및 중요 한 영역의 구매나 주문 또는 재고 등의 기능을 제어할 수 있는 프로세스의 클러스터를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="e61c0-179">A domain model contains clusters of different data entities and processes that can control a significant area of functionality, such as order fulfilment or inventory.</span></span> <span data-ttu-id="e61c0-180">좀 더 세분화 된 DDD 단위는 클러스터 또는 그룹의 엔터티 및 화합 단위로 처리 될 수 있는 동작을 설명 하는 집계입니다.</span><span class="sxs-lookup"><span data-stu-id="e61c0-180">A more fine-grained DDD unit is the aggregate, which describes a cluster or group of entities and behaviors that can be treated as a cohesive unit.</span></span>

<span data-ttu-id="e61c0-181">일반적으로 필요한 트랜잭션을 기반으로 집계를 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="e61c0-181">You usually define an aggregate based on the transactions that you need.</span></span> <span data-ttu-id="e61c0-182">전형적인 예로 주문 항목 목록이 포함 되는 순서입니다.</span><span class="sxs-lookup"><span data-stu-id="e61c0-182">A classic example is an order that also contains a list of order items.</span></span> <span data-ttu-id="e61c0-183">주문 항목은 엔터티 일반적으로 됩니다.</span><span class="sxs-lookup"><span data-stu-id="e61c0-183">An order item will usually be an entity.</span></span> <span data-ttu-id="e61c0-184">하지만 해당 루트 엔터티로 일반적으로 집계 루트 호출 또한 order 엔터티를 포함 하는 순서 집계 내에서 자식 엔터티가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="e61c0-184">But it will be a child entity within the order aggregate, which will also contain the order entity as its root entity, typically called an aggregate root.</span></span>

<span data-ttu-id="e61c0-185">집계를 식별 하는 것은 어려울 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e61c0-185">Identifying aggregates can be hard.</span></span> <span data-ttu-id="e61c0-186">집계는 서로 일치 해야 하는 개체 그룹에 있지만 방금 개체 그룹을 선택 하 고 집계 레이블을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="e61c0-186">An aggregate is a group of objects that must be consistent together, but you cannot just pick a group of objects and label them an aggregate.</span></span> <span data-ttu-id="e61c0-187">도메인 개념으로 시작 해야 하며 해당 개념과 관련 된 가장 일반적인 트랜잭션에서 사용 되는 엔터티를 고려해 야 합니다.</span><span class="sxs-lookup"><span data-stu-id="e61c0-187">You must start with a domain concept and think about the entities that are used in the most common transactions related to that concept.</span></span> <span data-ttu-id="e61c0-188">트랜잭션 측면에서 일치 해야 하는 이러한 엔터티는 집계를 형성 하는 기능입니다.</span><span class="sxs-lookup"><span data-stu-id="e61c0-188">Those entities that need to be transactionally consistent are what forms an aggregate.</span></span> <span data-ttu-id="e61c0-189">트랜잭션 작업에 대 한 집계를 식별 하는 가장 좋은 방법은 때문일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e61c0-189">Thinking about transaction operations is probably the best way to identify aggregates.</span></span>

### <a name="the-aggregate-root-or-root-entity-pattern"></a><span data-ttu-id="e61c0-190">집계 루트 또는 루트 엔터티 패턴</span><span class="sxs-lookup"><span data-stu-id="e61c0-190">The Aggregate Root or Root Entity pattern</span></span>

<span data-ttu-id="e61c0-191">집계는 엔터티를 하나 이상 이루어져: 루트 엔터티 또는 기본 ientity 라고도 집계 루트입니다.</span><span class="sxs-lookup"><span data-stu-id="e61c0-191">An aggregate is composed of at least one entity: the aggregate root, also called root entity or primary ientity.</span></span> <span data-ttu-id="e61c0-192">또한 여러 개의 자식 엔터티와 모든 엔터티 및 관리자와 함께 필요한 동작 및 트랜잭션을 구현 하는 개체와 함께 값 개체는 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e61c0-192">Additionally, it can have multiple child entities and value objects, with all entities and objects working together to implement required behavior and transactions.</span></span>

<span data-ttu-id="e61c0-193">집계 루트의 목적은; 집계의 일관성을 유지 하는 것 메서드를 통해 집계에 대 한 업데이트에 대 한 유일한 진입점 것 또는 작업 집계 루트 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="e61c0-193">The purpose of an aggregate root is to ensure the consistency of the aggregate; it should be the only entry point for updates to the aggregate through methods or operations in the aggregate root class.</span></span> <span data-ttu-id="e61c0-194">집계 루트를 통해서만 집계 내에서 엔터티를 변경 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="e61c0-194">You should make changes to entities within the aggregate only via the aggregate root.</span></span> <span data-ttu-id="e61c0-195">것이 집계의 일관성 보호자, 모든 고정 및 사용자 집계에 준수 해야 할 수 있습니다 일관성 규칙을 고려 합니다.</span><span class="sxs-lookup"><span data-stu-id="e61c0-195">It is the aggregate’s consistency guardian, taking into account all the invariants and consistency rules you might need to comply with in your aggregate.</span></span> <span data-ttu-id="e61c0-196">자식 엔터티 또는 값 개체를 독립적으로 변경 하면 집계 루트 집계가 유효한 상태 인지를 보장할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="e61c0-196">If you change a child entity or value object independently, the aggregate root cannot ensure that the aggregate is in a valid state.</span></span> <span data-ttu-id="e61c0-197">느슨한 레그 있는 테이블 처럼 됩니다.</span><span class="sxs-lookup"><span data-stu-id="e61c0-197">It would be like a table with a loose leg.</span></span> <span data-ttu-id="e61c0-198">유지 관리 일관성은 집계 루트의 주요 목적은입니다.</span><span class="sxs-lookup"><span data-stu-id="e61c0-198">Maintaining consistency is the main purpose of the aggregate root.</span></span>

<span data-ttu-id="e61c0-199">그림 9-9에서 단일 엔터티 (집계 루트 구매자)를 포함 하는 집계, 구매자와 같은 샘플 집계를 볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e61c0-199">In Figure 9-9, you can see sample aggregates like the buyer aggregate, which contains a single entity (the aggregate root Buyer).</span></span> <span data-ttu-id="e61c0-200">순서 집계는 여러 엔터티 및 값 개체를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="e61c0-200">The order aggregate contains multiple entities and a value object.</span></span>

![](./media/image10.png)

<span data-ttu-id="e61c0-201">**그림 9-9**합니다.</span><span class="sxs-lookup"><span data-stu-id="e61c0-201">**Figure 9-9**.</span></span> <span data-ttu-id="e61c0-202">여러 집계 예제 또는 단일 엔터티</span><span class="sxs-lookup"><span data-stu-id="e61c0-202">Example of aggregates with multiple or single entities</span></span>

<span data-ttu-id="e61c0-203">구매자 집계 분야에 따라 추가 자식 엔터티를 가질 수 있는지와 eShopOnContainers 참조 응용 프로그램에서 주문 마이크로 서비스에서 note 합니다.</span><span class="sxs-lookup"><span data-stu-id="e61c0-203">Note that the Buyer aggregate could have additional child entities, depending on your domain, as it does in the ordering microservice in the eShopOnContainers reference application.</span></span> <span data-ttu-id="e61c0-204">그림 9-9는 방금 구매자의 집계는 집계 루트에만 포함 된 예를 들어 하나의 항목에 지정 된 사례를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="e61c0-204">Figure 9-9 just illustrates a case in which the buyer has a single entity, as an example of an aggregate that contains only an aggregate root.</span></span>

<span data-ttu-id="e61c0-205">집계의 분리를 유지 관리 하 고 간에 명확한 경계를 유지 하기 위해는 것이 좋습니다에서 구현 될 때 집계 및 외래 키 (FK) 필드를 것만 간의 직접 탐색을 허용 하지 않도록 DDD 도메인 모델에 [ 마이크로 서비스 도메인 모델 순서](https://github.com/dotnet-architecture/eShopOnContainers/blob/master/src/Services/Ordering/Ordering.Domain/AggregatesModel/OrderAggregate/Order.cs) eShopOnContainers에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e61c0-205">In order to maintain separation of aggregates and keep clear boundaries between them, it is a good practice in a DDD domain model to disallow direct navigation between aggregates and only having the foreign key (FK) field, as implemented in the [Ordering microservice domain model](https://github.com/dotnet-architecture/eShopOnContainers/blob/master/src/Services/Ordering/Ordering.Domain/AggregatesModel/OrderAggregate/Order.cs) in eShopOnContainers.</span></span> <span data-ttu-id="e61c0-206">Order 엔터티만에 외래 키 필드는 구매자 하지만 하지는 EF 코어 탐색 속성에 대 한 다음 코드에 나와 있는 것 처럼:</span><span class="sxs-lookup"><span data-stu-id="e61c0-206">The Order entity only has a FK field for the buyer, but not an EF Core navigation property, as shown in the following code:</span></span>

```csharp
public class Order : Entity, IAggregateRoot
{
    private DateTime _orderDate;
    public Address Address { get; private set; }
    private int? _buyerId; //FK pointing to a different aggregate root
    public OrderStatus OrderStatus { get; private set; }
}
```

<span data-ttu-id="e61c0-207">식별 하 고 집계 작업 연구와 경험 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="e61c0-207">Identifying and working with aggregates requires research and experience.</span></span> <span data-ttu-id="e61c0-208">자세한 내용은 다음과를 같은 추가 리소스를 참조 하십시오.</span><span class="sxs-lookup"><span data-stu-id="e61c0-208">For more information, see the following Additional resources list.</span></span>

#### <a name="additional-resources"></a><span data-ttu-id="e61c0-209">추가 리소스</span><span class="sxs-lookup"><span data-stu-id="e61c0-209">Additional resources</span></span>

-   <span data-ttu-id="e61c0-210">**Vaughn Vernon. 1 부: 효율적인 집계 디자인-단일 집계를 모델링**
    [*https://vaughnvernon.co/wordpress/wp-content/uploads/2014/10/DDD\_커뮤니티\_세이\_ 집계\_부분\_1. pdf*](https://vaughnvernon.co/wordpress/wp-content/uploads/2014/10/DDD_COMMUNITY_ESSAY_AGGREGATES_PART_1.pdf)</span><span class="sxs-lookup"><span data-stu-id="e61c0-210">**Vaughn Vernon. Effective Aggregate Design - Part I: Modeling a Single Aggregate**
[*https://vaughnvernon.co/wordpress/wp-content/uploads/2014/10/DDD\_COMMUNITY\_ESSAY\_AGGREGATES\_PART\_1.pdf*](https://vaughnvernon.co/wordpress/wp-content/uploads/2014/10/DDD_COMMUNITY_ESSAY_AGGREGATES_PART_1.pdf)</span></span>

-   <span data-ttu-id="e61c0-211">**Vaughn Vernon. 효율적인 집계 디자인-2 부: 만들기 집계 작업 함께**
    *<https://vaughnvernon.co/wordpress/wp-content/uploads/2014/10/DDD_COMMUNITY_ESSAY_AGGREGATES_PART_2.pdf>*</span><span class="sxs-lookup"><span data-stu-id="e61c0-211">**Vaughn Vernon. Effective Aggregate Design - Part II: Making Aggregates Work Together**
*<https://vaughnvernon.co/wordpress/wp-content/uploads/2014/10/DDD_COMMUNITY_ESSAY_AGGREGATES_PART_2.pdf> *</span></span>

-   <span data-ttu-id="e61c0-212">**Vaughn Vernon. 효율적인 집계 디자인-3 부: 검색을 통해 정보를 얻고**
    *<https://vaughnvernon.co/wordpress/wp-content/uploads/2014/10/DDD_COMMUNITY_ESSAY_AGGREGATES_PART_3.pdf>*</span><span class="sxs-lookup"><span data-stu-id="e61c0-212">**Vaughn Vernon. Effective Aggregate Design - Part III: Gaining Insight Through Discovery**
*<https://vaughnvernon.co/wordpress/wp-content/uploads/2014/10/DDD_COMMUNITY_ESSAY_AGGREGATES_PART_3.pdf> *</span></span>

-   <span data-ttu-id="e61c0-213">**Sergey Grybniak 합니다. DDD 전술적 디자인 패턴**
    [*https://www.codeproject.com/Articles/1164363/Domain-Driven-Design-Tactical-Design-Patterns-Part*](https://www.codeproject.com/Articles/1164363/Domain-Driven-Design-Tactical-Design-Patterns-Part)</span><span class="sxs-lookup"><span data-stu-id="e61c0-213">**Sergey Grybniak. DDD Tactical Design Patterns**
[*https://www.codeproject.com/Articles/1164363/Domain-Driven-Design-Tactical-Design-Patterns-Part*](https://www.codeproject.com/Articles/1164363/Domain-Driven-Design-Tactical-Design-Patterns-Part)</span></span>

-   <span data-ttu-id="e61c0-214">**Chris Richardson 합니다. 집계를 사용 하 여 트랜잭션 Microservices 개발**
    [*https://www.infoq.com/articles/microservices-aggregates-events-cqrs-part-1-richardson*](https://www.infoq.com/articles/microservices-aggregates-events-cqrs-part-1-richardson)</span><span class="sxs-lookup"><span data-stu-id="e61c0-214">**Chris Richardson. Developing Transactional Microservices Using Aggregates**
[*https://www.infoq.com/articles/microservices-aggregates-events-cqrs-part-1-richardson*](https://www.infoq.com/articles/microservices-aggregates-events-cqrs-part-1-richardson)</span></span>

-   <span data-ttu-id="e61c0-215">**DevIQ 합니다. 집계 패턴**
    [*http://deviq.com/aggregate-pattern/*](http://deviq.com/aggregate-pattern/)</span><span class="sxs-lookup"><span data-stu-id="e61c0-215">**DevIQ. The Aggregate pattern**
[*http://deviq.com/aggregate-pattern/*](http://deviq.com/aggregate-pattern/)</span></span>


>[!div class="step-by-step"]
<span data-ttu-id="e61c0-216">[이전] (ddd-지향-microservice.md) [다음] (net-코어-마이크로 서비스-도메인-model.md)</span><span class="sxs-lookup"><span data-stu-id="e61c0-216">[Previous] (ddd-oriented-microservice.md) [Next] (net-core-microservice-domain-model.md)</span></span>

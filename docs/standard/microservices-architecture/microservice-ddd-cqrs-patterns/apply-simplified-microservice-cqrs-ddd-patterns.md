---
title: "마이크로 서비스의 단순화 된 CQRS 및 DDD 패턴 적용"
description: "컨테이너 화 된.NET 응용 프로그램에 대 한.NET Microservices 아키텍처 | 마이크로 서비스의 단순화 된 CQRS 및 DDD 패턴 적용"
keywords: "Docker, 마이크로 서비스, ASP.NET, 컨테이너"
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 05/26/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.topic: article
ms.openlocfilehash: 99fd7ce32039742e23f8e01aa4c33cddd7a9f698
ms.sourcegitcommit: bd1ef61f4bb794b25383d3d72e71041a5ced172e
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 10/18/2017
---
# <a name="applying-simplified-cqrs-and-ddd-patterns-in-a-microservice"></a><span data-ttu-id="f7601-104">마이크로 서비스의 단순화 된 CQRS 및 DDD 패턴 적용</span><span class="sxs-lookup"><span data-stu-id="f7601-104">Applying simplified CQRS and DDD patterns in a microservice</span></span>

<span data-ttu-id="f7601-105">CQRS는 데이터 읽기 및 쓰기에 대 한 모델을 구분 하는 아키텍처 패턴입니다.</span><span class="sxs-lookup"><span data-stu-id="f7601-105">CQRS is an architectural pattern that separates the models for reading and writing data.</span></span> <span data-ttu-id="f7601-106">관련된 용어 [명령 쿼리 분리 (CQS)](https://martinfowler.com/bliki/CommandQuerySeparation.html) 저서인 Bertrand 애 하 여 원래 정의 된 *개체 지향 소프트웨어 생성*합니다.</span><span class="sxs-lookup"><span data-stu-id="f7601-106">The related term [Command Query Separation (CQS)](https://martinfowler.com/bliki/CommandQuerySeparation.html) was originally defined by Bertrand Meyer in his book *Object Oriented Software Construction*.</span></span> <span data-ttu-id="f7601-107">기본 개념은 급격 하 게 분리 된 두 가지 범주로 시스템의 작업을 나눌 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f7601-107">The basic idea is that you can divide a system’s operations into two sharply separated categories:</span></span>

-   <span data-ttu-id="f7601-108">쿼리합니다.</span><span class="sxs-lookup"><span data-stu-id="f7601-108">Queries.</span></span> <span data-ttu-id="f7601-109">이러한 결과 반환 하 고 시스템의 상태를 변경 하지 않는 있으며 부작용이 없는 합니다.</span><span class="sxs-lookup"><span data-stu-id="f7601-109">These return a result and do not change the state of the system, and they are free of side effects.</span></span>

-   <span data-ttu-id="f7601-110">명령입니다.</span><span class="sxs-lookup"><span data-stu-id="f7601-110">Commands.</span></span> <span data-ttu-id="f7601-111">이러한 시스템의 상태를 변경 합니다.</span><span class="sxs-lookup"><span data-stu-id="f7601-111">These change the state of a system.</span></span>

<span data-ttu-id="f7601-112">CQS는 간단한 개념 — 동일한 개체 내에서 메서드는 쿼리 또는 명령입니다.</span><span class="sxs-lookup"><span data-stu-id="f7601-112">CQS is a simple concept—it is about methods within the same object being either queries or commands.</span></span> <span data-ttu-id="f7601-113">각 메서드는 상태를 반환 하거나 상태로 설정 되지만 둘 중 하나를 변경 합니다.</span><span class="sxs-lookup"><span data-stu-id="f7601-113">Each method either returns state or mutates state, but not both.</span></span> <span data-ttu-id="f7601-114">단일 리포지토리 패턴 개체도 CQS 따를 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f7601-114">Even a single repository pattern object can comply with CQS.</span></span> <span data-ttu-id="f7601-115">CQS는 CQRS에 대 한 기본 원칙을 간주할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f7601-115">CQS can be considered a foundational principle for CQRS.</span></span>

<span data-ttu-id="f7601-116">[명령 및 쿼리 책임 분리 (CQRS)](https://martinfowler.com/bliki/CQRS.html) Greg young 도입 하 고 강력한 Udi Dahan 및 다른 사용자에 의해 승격 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="f7601-116">[Command and Query Responsibility Segregation (CQRS)](https://martinfowler.com/bliki/CQRS.html) was introduced by Greg Young and strongly promoted by Udi Dahan and others.</span></span> <span data-ttu-id="f7601-117">에 기반 하는 CQS 원칙을 보다 자세히 설명 되어 있지만 합니다.</span><span class="sxs-lookup"><span data-stu-id="f7601-117">It is based on the CQS principle, although it is more detailed.</span></span> <span data-ttu-id="f7601-118">명령 및 이벤트에 더한 필요에 따라 비동기 메시지에 따라 패턴을 생각할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f7601-118">It can be considered a pattern based on commands and events plus optionally on asynchronous messages.</span></span> <span data-ttu-id="f7601-119">대부분의 경우 CQRS (업데이트) 쓰기 보다 읽기가 (쿼리)에 대 한 서로 다른 물리적 데이터베이스 것과 같습니다 더 고급 시나리오와 관련이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f7601-119">In many cases, CQRS is related to more advanced scenarios, like having a different physical database for reads (queries) than for writes (updates).</span></span> <span data-ttu-id="f7601-120">또한 더 진화 CQRS 시스템을 구현할 수 [이벤트 소싱 (ES)](http://codebetter.com/gregyoung/2010/02/20/why-use-event-sourcing/) 업데이트 데이터베이스 이므로에 저장할 수 있습니다 이벤트의 현재 상태 데이터를 저장 하는 대신 도메인 모델입니다.</span><span class="sxs-lookup"><span data-stu-id="f7601-120">Moreover, a more evolved CQRS system might implement [Event-Sourcing (ES)](http://codebetter.com/gregyoung/2010/02/20/why-use-event-sourcing/) for your updates database, so you would only store events in the domain model instead of storing the current-state data.</span></span> <span data-ttu-id="f7601-121">그러나 이것이;이 가이드에서 사용 하는 방법 방금 명령에서 쿼리를 분리 하면 구성 된 단순한 CQRS 방법을 사용 했습니다.</span><span class="sxs-lookup"><span data-stu-id="f7601-121">However, this is not the approach used in this guide; we are using the simplest CQRS approach, which consists of just separating the queries from the commands.</span></span>

<span data-ttu-id="f7601-122">분리 모양의 CQRS는 또 다른 계층에서 명령 및 쿼리 작업에 한 계층을 그룹화 하 여 수행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f7601-122">The separation aspect of CQRS is achieved by grouping query operations in one layer and commands in another layer.</span></span> <span data-ttu-id="f7601-123">각 계층에 데이터 모델이 (참고 말할 모델에서는 다른 데이터베이스를 사용 하지 않을 수도 있음)를 패턴 및 기술 자체 조합을 사용 하 여 만들어집니다.</span><span class="sxs-lookup"><span data-stu-id="f7601-123">Each layer has its own data model (note that we say model, not necessarily a different database) and is built using its own combination of patterns and technologies.</span></span> <span data-ttu-id="f7601-124">무엇 보다도 두 계층 내에서 동일한 계층 또는 마이크로 서비스를 (마이크로 서비스 순서) 예제와 같이이 가이드에 사용 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f7601-124">More importantly, the two layers can be within the same tier or microservice, as in the example (ordering microservice) used for this guide.</span></span> <span data-ttu-id="f7601-125">또는 액세스에 최적화 된 고 서로 영향을 주지 않고 개별적으로 확장할 수 있도록 다른 microservices 또는 프로세스에 구현할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f7601-125">Or they could be implemented on different microservices or processes so they can be optimized and scaled out separately without affecting one another.</span></span>

<span data-ttu-id="f7601-126">CQRS를 다른 컨텍스트에서 하나도 읽기/쓰기 작업에 대 한 두 개체를 것을 의미 합니다.</span><span class="sxs-lookup"><span data-stu-id="f7601-126">CQRS means having two objects for a read/write operation where in other contexts there is one.</span></span> <span data-ttu-id="f7601-127">더 많은 고급 CQRS 홍보 자료에 대해 알아볼 수 있습니다는 정규화 되지 않은 읽기 데이터베이스에 있어야 하는 이유가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f7601-127">There are reasons to have a denormalized reads database, which you can learn about in more advanced CQRS literature.</span></span> <span data-ttu-id="f7601-128">하지만 사용 하지는 여기에서 방법을 ֲ가 좀더 유연한 쿼리를 집계 같은 DDD 패턴에서 제약 조건으로 쿼리를 제한 하는 대신에 위치 합니다.</span><span class="sxs-lookup"><span data-stu-id="f7601-128">But we are not using that approach here, where the goal is to have more flexibility in the queries instead of limiting the queries with constraints from DDD patterns like aggregates.</span></span>

<span data-ttu-id="f7601-129">서비스의 이러한 종류의 예로 eShopOnContainers 참조 응용 프로그램에서 주문 마이크로 서비스.</span><span class="sxs-lookup"><span data-stu-id="f7601-129">An example of this kind of service is the ordering microservice from the eShopOnContainers reference application.</span></span> <span data-ttu-id="f7601-130">이 서비스는 간소화 된 CQRS 접근 방식에 따라 한 마이크로 서비스를 구현 합니다.</span><span class="sxs-lookup"><span data-stu-id="f7601-130">This service implements a microservice based on a simplified CQRS approach.</span></span> <span data-ttu-id="f7601-131">사용 하 여 단일 데이터 원본 또는 데이터베이스에 있지만 두 논리 모델을 함께 DDD 패턴 트랜잭션 도메인에 대 한 그림 9-2에 나와 있는 것 처럼 합니다.</span><span class="sxs-lookup"><span data-stu-id="f7601-131">It uses a single data source or database, but two logical models plus DDD patterns for the transactional domain, as shown in Figure 9-2.</span></span>

![](./media/image2.png)

<span data-ttu-id="f7601-132">**그림 9-2**합니다.</span><span class="sxs-lookup"><span data-stu-id="f7601-132">**Figure 9-2**.</span></span> <span data-ttu-id="f7601-133">간소화 된 CQRS 및 DDD 기반 마이크로 서비스</span><span class="sxs-lookup"><span data-stu-id="f7601-133">Simplified CQRS- and DDD-based microservice</span></span>

<span data-ttu-id="f7601-134">응용 프로그램 계층 웹 API 자체는 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f7601-134">The application layer can be the Web API itself.</span></span> <span data-ttu-id="f7601-135">중요 한 디자인 측면은 명령, 도메인 모델 및 트랜잭션 CQRS 패턴에서 쿼리 및 Viewmodel (특히 클라이언트 응용 프로그램에 대해 생성 된 데이터 모델)은 마이크로 서비스 분할 된입니다.</span><span class="sxs-lookup"><span data-stu-id="f7601-135">The important design aspect here is that the microservice has split the queries and ViewModels (data models especially created for the client applications) from the commands, domain model, and transactions following the CQRS pattern.</span></span> <span data-ttu-id="f7601-136">이 방법은 별개의 제한 사항 및 제약 조건 뒤의 섹션에 설명 된 대로 트랜잭션 및 업데이트에만 의미가 DDD 패턴에서 들어오는 쿼리를 유지 합니다.</span><span class="sxs-lookup"><span data-stu-id="f7601-136">This approach keeps the queries independent from restrictions and constraints coming from DDD patterns that only make sense for transactions and updates, as explained in later sections.</span></span>


>[!div class="step-by-step"]
<span data-ttu-id="f7601-137">[이전] [다음] (eshoponcontainers-cqrs-ddd-microservice.md) (index.md)</span><span class="sxs-lookup"><span data-stu-id="f7601-137">[Previous] (index.md) [Next] (eshoponcontainers-cqrs-ddd-microservice.md)</span></span>

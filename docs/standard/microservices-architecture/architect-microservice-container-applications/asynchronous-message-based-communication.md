---
title: "비동기 메시지 기반 통신"
description: "컨테이너 화 된.NET 응용 프로그램에 대 한.NET Microservices 아키텍처 | 비동기 메시지 기반 통신"
keywords: "Docker, 마이크로 서비스, ASP.NET, 컨테이너"
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 05/26/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.topic: article
ms.openlocfilehash: df39771295d12e122edbe27e91cd899e3318e301
ms.sourcegitcommit: c2e216692ef7576a213ae16af2377cd98d1a67fa
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 10/22/2017
---
# <a name="asynchronous-message-based-communication"></a><span data-ttu-id="7aee2-104">비동기 메시지 기반 통신</span><span class="sxs-lookup"><span data-stu-id="7aee2-104">Asynchronous message-based communication</span></span>

<span data-ttu-id="7aee2-105">비동기 메시징 및 이벤트 기반 통신은 여러 microservices 및 해당 관련된 도메인 모델에서 변경 내용을 전파할 때 중요 합니다.</span><span class="sxs-lookup"><span data-stu-id="7aee2-105">Asynchronous messaging and event-driven communication are critical when propagating changes across multiple microservices and their related domain models.</span></span> <span data-ttu-id="7aee2-106">토론 microservices 및 경계가 지정 된 컨텍스트 BCs ()의 앞부분에 언급 했 듯이 모델 (사용자, 고객, 제품, 계정, 등) 다른 microservices 또는 BCs 게 서로 다른 것을 의미할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7aee2-106">As mentioned earlier in the discussion microservices and Bounded Contexts (BCs), models (User, Customer, Product, Account, etc.) can mean different things to different microservices or BCs.</span></span> <span data-ttu-id="7aee2-107">변경 될 때 여러 모델에 걸쳐 변경 내용을 조정 하는 방법이 필요는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="7aee2-107">That means that when changes occur, you need some way to reconcile changes across the different models.</span></span> <span data-ttu-id="7aee2-108">방법은 결과적 일관성 및 비동기 메시징에 따라 이벤트 기반 통신입니다.</span><span class="sxs-lookup"><span data-stu-id="7aee2-108">A solution is eventual consistency and event-driven communication based on asynchronous messaging.</span></span>

<span data-ttu-id="7aee2-109">메시징를 사용할 경우 프로세스는 비동기적으로 메시지를 교환 하 여 통신 합니다.</span><span class="sxs-lookup"><span data-stu-id="7aee2-109">When using messaging, processes communicate by exchanging messages asynchronously.</span></span> <span data-ttu-id="7aee2-110">클라이언트 서비스를 하는 명령이 나 요청 메시지를 전송 하 여 합니다.</span><span class="sxs-lookup"><span data-stu-id="7aee2-110">A client makes a command or a request to a service by sending it a message.</span></span> <span data-ttu-id="7aee2-111">서비스 회신 하는 경우 클라이언트에 서로 다른 메시지를 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="7aee2-111">If the service needs to reply, it sends a different message back to the client.</span></span> <span data-ttu-id="7aee2-112">메시지 기반 통신 이므로 클라이언트는 회신 수신 되지 않고 즉시 하 고 있을 수 있음을 응답이 전혀 가정 합니다.</span><span class="sxs-lookup"><span data-stu-id="7aee2-112">Since it is a message-based communication, the client assumes that the reply will not be received immediately, and that there might be no response at all.</span></span>

<span data-ttu-id="7aee2-113">메시지 헤더 (예: 식별 또는 보안 정보 메타 데이터)와 본문으로 구성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="7aee2-113">A message is composed by a header (metadata such as identification or security information) and a body.</span></span> <span data-ttu-id="7aee2-114">메시지는 AMQP 같은 비동기 프로토콜을 통해 일반적으로 전송 됩니다.</span><span class="sxs-lookup"><span data-stu-id="7aee2-114">Messages are usually sent through asynchronous protocols like AMQP.</span></span>

<span data-ttu-id="7aee2-115">이러한 유형의 microservices 커뮤니티의 통신에 대 한 기본 인프라는 달리 큰 브로커 및 orchestrators SOA에 사용 되는 간단한 메시지 브로커를입니다.</span><span class="sxs-lookup"><span data-stu-id="7aee2-115">The preferred infrastructure for this type of communication in the microservices community is a lightweight message broker, which is different than the large brokers and orchestrators used in SOA.</span></span> <span data-ttu-id="7aee2-116">간단한 메시지 브로커의 인프라를 일반적으로 "단순," RabbitMQ 또는 Azure 서비스 버스 클라우드의에서 확장 가능한 서비스 버스와 같은 간단한 구현과 함께 메시지 브로커를 으로만 작동 합니다.</span><span class="sxs-lookup"><span data-stu-id="7aee2-116">In a lightweight message broker, the infrastructure is typically “dumb,” acting only as a message broker, with simple implementations such as RabbitMQ or a scalable service bus in the cloud like Azure Service Bus.</span></span> <span data-ttu-id="7aee2-117">이 시나리오에서 대부분의 "스마트" 생각 실리는 생성 하 고 메시지를 사용 하는 끝점에서-즉,는 microservices에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7aee2-117">In this scenario, most of the “smart” thinking still lives in the endpoints that are producing and consuming messages—that is, in the microservices.</span></span>

<span data-ttu-id="7aee2-118">가능한 한을 수행 하려고 노력 해야 다른 규칙은 내부 서비스 간에 비동기 메시징를 사용 하 고 프런트 엔드 서비스 (API 게이트웨이 + 첫 번째 수준에만 클라이언트 앱에서에서 (예: HTTP) 동기 통신을 사용 하도록 microservices).</span><span class="sxs-lookup"><span data-stu-id="7aee2-118">Another rule you should try to follow, as much as possible, is to use only asynchronous messaging between the internal services, and to use synchronous communication (such as HTTP) only from the client apps to the front-end services (API Gateways plus the first level of microservices).</span></span>

<span data-ttu-id="7aee2-119">비동기 메시징 통신의 두 종류가: 단일 수신자 메시지 기반 통신 및 여러 수신기 메시지 기반 통신입니다.</span><span class="sxs-lookup"><span data-stu-id="7aee2-119">There are two kinds of asynchronous messaging communication: single receiver message-based communication, and multiple receivers message-based communication.</span></span> <span data-ttu-id="7aee2-120">다음 섹션에서 세부 정보 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="7aee2-120">In the following sections we provide details about them.</span></span>

## <a name="single-receiver-message-based-communication"></a><span data-ttu-id="7aee2-121">단일 수신기 메시지 기반 통신</span><span class="sxs-lookup"><span data-stu-id="7aee2-121">Single-receiver message-based communication</span></span> 

<span data-ttu-id="7aee2-122">단일 수신자와 비동기 통신 메시지 기반 지점 간 통신 하는 채널을 읽고 메시지를 한 번만 처리 하는 소비자 중 정확히 하나에 메시지를 배달 하는 것을 의미 합니다.</span><span class="sxs-lookup"><span data-stu-id="7aee2-122">Message-based asynchronous communication with a single receiver means there is point-to-point communication that delivers a message to exactly one of the consumers that is reading from the channel, and that the message is processed just once.</span></span> <span data-ttu-id="7aee2-123">그러나 특별 한 경우가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7aee2-123">However, there are special situations.</span></span> <span data-ttu-id="7aee2-124">예를 들어, 오류 로부터 자동으로 복구 하려고 하는 클라우드 시스템에는 동일한 메시지를 보낼 수 여러 번입니다.</span><span class="sxs-lookup"><span data-stu-id="7aee2-124">For instance, in a cloud system that tries to automatically recover from failures, the same message could be sent multiple times.</span></span> <span data-ttu-id="7aee2-125">네트워크 또는 기타 실패로 인해 인해 메시지 보내기를 시도할 수에 대 한 클라이언트 및 서버에서 특정 메시지를 한 번만 처리 하기 위해 idempotent 되도록 작업을 구현 하 합니다.</span><span class="sxs-lookup"><span data-stu-id="7aee2-125">Due to network or other failures, the client has to be able to retry sending messages, and the server has to implement an operation to be idempotent in order to process a particular message just once.</span></span>

<span data-ttu-id="7aee2-126">메시지 기반 통신 수신기 단일 특히 적합에 그림 4-18이이 방법을 보여 주는 같이 다른 비동기 명령을 한 마이크로 서비스에서 전송 합니다.</span><span class="sxs-lookup"><span data-stu-id="7aee2-126">Single-receiver message-based communication is especially well suited for sending asynchronous commands from one microservice to another as shown in Figure 4-18 that illustrates this approach.</span></span>

<span data-ttu-id="7aee2-127">보내는 메시지 기반 통신 (명령 또는 이벤트 중 하나)을 시작 하면 메시지 기반 통신 동기 HTTP 통신을 혼합 하지 마십시오.</span><span class="sxs-lookup"><span data-stu-id="7aee2-127">Once you start sending message-based communication (either with commands or events), you should avoid mixing message-based communication with synchronous HTTP communication.</span></span>

![](./media/image18.PNG)

<span data-ttu-id="7aee2-128">**그림 4-18**합니다.</span><span class="sxs-lookup"><span data-stu-id="7aee2-128">**Figure 4-18**.</span></span> <span data-ttu-id="7aee2-129">비동기 메시지를 수신 하는 단일 마이크로 서비스</span><span class="sxs-lookup"><span data-stu-id="7aee2-129">A single microservice receiving an asynchronous message</span></span>

<span data-ttu-id="7aee2-130">명령이 클라이언트 응용 프로그램에 연결 하는 경우 이러한 구현 될 수 있는지 HTTP 동기 명령으로 참고 합니다.</span><span class="sxs-lookup"><span data-stu-id="7aee2-130">Note that when the commands come from client applications, they can be implemented as HTTP synchronous commands.</span></span> <span data-ttu-id="7aee2-131">보다 높은 확장성을 할 때 또는 비즈니스 메시지 기반 프로세스에서 이미 실행 중인 경우에 메시지 기반 명령을 사용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="7aee2-131">You should use message-based commands when you need higher scalability or when you are already in a message-based business process.</span></span>

## <a name="multiple-receivers-message-based-communication"></a><span data-ttu-id="7aee2-132">여러 수신기 메시지 기반 통신</span><span class="sxs-lookup"><span data-stu-id="7aee2-132">Multiple-receivers message-based communication</span></span> 

<span data-ttu-id="7aee2-133">보다 유연한 방식을로 보낸 사람 으로부터 프로그램 통신 될 또는 외부 응용 프로그램에 추가 구독자 microservices를 사용할 수 있도록 게시/구독 메커니즘을 사용 하 여 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7aee2-133">As a more flexible approach, you might also want to use a publish/subscribe mechanism so that your communication from the sender will be available to additional subscriber microservices or to external applications.</span></span> <span data-ttu-id="7aee2-134">따라서 하도록 지 원하는 따라는 [원칙 열기/닫기](https://en.wikipedia.org/wiki/Open/closed_principle) 보내는 서비스에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7aee2-134">Thus, it helps you to follow the [open/closed principle](https://en.wikipedia.org/wiki/Open/closed_principle) in the sending service.</span></span> <span data-ttu-id="7aee2-135">이런 방식으로 추가 하는 구독자는 보낸 사람에 게 서비스를 수정 하지 않고도 나중에 추가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7aee2-135">That way, additional subscribers can be added in the future without the need to modify the sender service.</span></span>

<span data-ttu-id="7aee2-136">게시/구독 통신을 사용 하면 이벤트 버스 인터페이스를 사용 하 여 모든 구독자에 이벤트 게시를 사용 중일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7aee2-136">When you use a publish/subscribe communication, you might be using an event bus interface to publish events to any subscriber.</span></span>

## <a name="asynchronous-event-driven-communication"></a><span data-ttu-id="7aee2-137">이벤트 기반 비동기 통신</span><span class="sxs-lookup"><span data-stu-id="7aee2-137">Asynchronous event-driven communication</span></span>

<span data-ttu-id="7aee2-138">이벤트 기반 비동기 통신을 사용할 경우 마이크로 서비스는 해당 도메인 내에서 특정 작업이 발생 하 고 다른 마이크로 서비스 제품 카탈로그 마이크로 서비스의 가격 변경 등을 인식 해야 하는 경우 통합 이벤트를 게시 합니다.</span><span class="sxs-lookup"><span data-stu-id="7aee2-138">When using asynchronous event-driven communication, a microservice publishes an integration event when something happens within its domain and another microservice needs to be aware of it, like a price change in a product catalog microservice.</span></span> <span data-ttu-id="7aee2-139">추가 microservices 들을 비동기적으로 받을 수 있도록 이벤트를 구독 합니다.</span><span class="sxs-lookup"><span data-stu-id="7aee2-139">Additional microservices subscribe to the events so they can receive them asynchronously.</span></span> <span data-ttu-id="7aee2-140">이 경우 수신자를 게시할 수 있는 더 많은 통합 이벤트를 일으킬 수 있는 자체 도메인 엔터티를 업데이트할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7aee2-140">When that happens, the receivers might update their own domain entities, which can cause more integration events to be published.</span></span> <span data-ttu-id="7aee2-141">이 게시/구독 시스템은 일반적으로 이벤트 버스의 구현을 사용 하 여 수행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="7aee2-141">This publish/subscribe system is usually performed by using an implementation of an event bus.</span></span> <span data-ttu-id="7aee2-142">이벤트 버스 추상화 또는 구독 또는 이벤트를 구독 취소 하 고 이벤트를 게시 하는 데 필요한 api 인터페이스를 디자인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7aee2-142">The event bus can be designed as an abstraction or interface, with the API that is needed to subscribe or unsubscribe to events and to publish events.</span></span> <span data-ttu-id="7aee2-143">이벤트 버스 있을 수도 있습니다 또는 모든 프로세스 간 및 메시징 브로커 메시징 큐 또는 비동기 통신 및 게시/구독 모델을 지 원하는 서비스 버스와 같은 지역에 더 많은 구현 합니다.</span><span class="sxs-lookup"><span data-stu-id="7aee2-143">The event bus can also have one or more implementations based on any inter-process and messaging broker, like a messaging queue or service bus that supports asynchronous communication and a publish/subscribe model.</span></span>

<span data-ttu-id="7aee2-144">시스템 통합 이벤트에 의해 발생 하는 결과적 일관성을 사용할 경우이 접근 방식을 완전히 지우기 최종 사용자에 게 수 있도록 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="7aee2-144">If a system uses eventual consistency driven by integration events, it is recommended that this approach be made completely clear to the end user.</span></span> <span data-ttu-id="7aee2-145">시스템 통합 이벤트 SignalR 클라이언트에서 폴링 시스템 등을 모방 하는 접근 방식을 사용 하지 마십시오.</span><span class="sxs-lookup"><span data-stu-id="7aee2-145">The system should not use an approach that mimics integration events, like SignalR or polling systems from the client.</span></span> <span data-ttu-id="7aee2-146">최종 사용자와 비즈니스 소유자 명시적으로 시스템에서 결과적 일관성을 그대로 사용 하 고은 명시적으로 대부분의 경우에서 비즈니스 하지 않았는지이 접근 방식으로 모든 문제를 인식 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="7aee2-146">The end user and the business owner have to explicitly embrace eventual consistency in the system and realize that in many cases the business does not have any problem with this approach, as long as it is explicit.</span></span>

<span data-ttu-id="7aee2-147">이전에 설명한 것 처럼는 [문제 및 솔루션에 대 한 분산 데이터 관리](#challenges-and-solutions-for-distributed-data-management) 섹션을 여러 microservices에 걸쳐 있는 비즈니스 작업을 구현 하 통합 이벤트를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7aee2-147">As noted earlier in the [Challenges and solutions for distributed data management](#challenges-and-solutions-for-distributed-data-management) section, you can use integration events to implement business tasks that span multiple microservices.</span></span> <span data-ttu-id="7aee2-148">따라서 해당 서비스 간의 결과적 일관성을 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="7aee2-148">Thus you will have eventual consistency between those services.</span></span> <span data-ttu-id="7aee2-149">결국 일관 된 트랜잭션은 분산된 작업의 컬렉션으로 이루어져 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7aee2-149">An eventually consistent transaction is made up of a collection of distributed actions.</span></span> <span data-ttu-id="7aee2-150">각 동작에서 관련된 마이크로 서비스 도메인 엔터티를 업데이트 하 고 같은 종단 간 비즈니스 태스크 내에서 다음 작업을 발생 시키는 다른 통합 이벤트를 게시 합니다.</span><span class="sxs-lookup"><span data-stu-id="7aee2-150">At each action, the related microservice updates a domain entity and publishes another integration event that raises the next action within the same end-to-end business task.</span></span>

<span data-ttu-id="7aee2-151">중요 한 점은 같은 이벤트를 구독 하는 여러 microservices와 통신 하려는 경우도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7aee2-151">An important point is that you might want to communicate to multiple microservices that are subscribed to the same event.</span></span> <span data-ttu-id="7aee2-152">게시/구독을 사용할 수 있도록 할 메시징 기반으로 이벤트 기반 통신 그림 4-19에 나와 있는 것 처럼 합니다.</span><span class="sxs-lookup"><span data-stu-id="7aee2-152">To do so, you can use publish/subscribe messaging based on event-driven communication, as shown in Figure 4-19.</span></span> <span data-ttu-id="7aee2-153">이 게시/구독 메커니즘은 마이크로 서비스 아키텍처에만 적용 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="7aee2-153">This publish/subscribe mechanism is not exclusive to the microservice architecture.</span></span> <span data-ttu-id="7aee2-154">하는 방식과 유사 [경계가 지정 된 컨텍스트](http://martinfowler.com/bliki/BoundedContext.html) 에 DDD 전달 해야 하거나 읽기의 데이터베이스에 쓰기 데이터베이스에서 업데이트를 전파 하는 방식과 [명령 및 쿼리 책임 분리 (CQRS)](http://martinfowler.com/bliki/CQRS.html)아키텍처 패턴입니다.</span><span class="sxs-lookup"><span data-stu-id="7aee2-154">It is similar to the way [Bounded Contexts](http://martinfowler.com/bliki/BoundedContext.html) in DDD should communicate, or to the way you propagate updates from the write database to the read database in the [Command and Query Responsibility Segregation (CQRS)](http://martinfowler.com/bliki/CQRS.html) architecture pattern.</span></span> <span data-ttu-id="7aee2-155">목표는 분산된 시스템에서 여러 데이터 원본 간의 결과적 일관성을 것입니다.</span><span class="sxs-lookup"><span data-stu-id="7aee2-155">The goal is to have eventual consistency between multiple data sources across your distributed system.</span></span>

![](./media/image19.png)

<span data-ttu-id="7aee2-156">**그림 4-19**합니다.</span><span class="sxs-lookup"><span data-stu-id="7aee2-156">**Figure 4-19**.</span></span> <span data-ttu-id="7aee2-157">이벤트 기반 비동기 메시지 통신</span><span class="sxs-lookup"><span data-stu-id="7aee2-157">Asynchronous event-driven message communication</span></span>

<span data-ttu-id="7aee2-158">이벤트 구동 메시지 기반 통신에 사용할 프로토콜 구현에서 결정 합니다.</span><span class="sxs-lookup"><span data-stu-id="7aee2-158">Your implementation will determine what protocol to use for event-driven, message-based communications.</span></span> <span data-ttu-id="7aee2-159">[AMQP](https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol) 신뢰할 수 있는 대기 중인된 통신을 달성할 수 있게 합니다.</span><span class="sxs-lookup"><span data-stu-id="7aee2-159">[AMQP](https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol) can help achieve reliable queued communication.</span></span>

<span data-ttu-id="7aee2-160">와 같은 메시지 브로커에서 API를 사용 하 여 코드로 클래스에 관련 된 구현에 따라 (예: 이벤트 버스 인터페이스)는 추상화 수준을 사용 하려는 이벤트 버스를 사용 하면 [RabbitMQ](https://www.rabbitmq.com/) 또는 와같은서비스버스[항목을 사용 하 여 azure 서비스 버스](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions)합니다.</span><span class="sxs-lookup"><span data-stu-id="7aee2-160">When you use an event bus, you might want to use an abstraction level (like an event bus interface) based on a related implementation in classes with code using the API from a message broker like [RabbitMQ](https://www.rabbitmq.com/) or a service bus like [Azure Service Bus with Topics](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions).</span></span> <span data-ttu-id="7aee2-161">또는 다음 NServiceBus, MassTransit, 또는 Brighter와 같은 더 높은 수준의 서비스 버스 이벤트 버스 표현 및 게시/구독 시스템을 사용 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="7aee2-161">Alternatively, you might want to use a higher-level service bus like NServiceBus, MassTransit, or Brighter to articulate your event bus and publish/subscribe system.</span></span>

## <a name="a-note-about-messaging-technologies-for-production-systems"></a><span data-ttu-id="7aee2-162">프로덕션 시스템에 대 한 기술 메시징에 대 한 참고</span><span class="sxs-lookup"><span data-stu-id="7aee2-162">A note about messaging technologies for production systems</span></span>

<span data-ttu-id="7aee2-163">추상 이벤트 버스 구현에 사용할 수 있는 메시징 기술을 서로 다른 수준에 노출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="7aee2-163">The messaging technologies available for implementing your abstract event bus are at different levels.</span></span> <span data-ttu-id="7aee2-164">예를 들어, 제품 RabbitMQ (메시징 브로커 전송) 및 Azure 서비스 버스와 같은 다른 같은 제품, NServiceBus, MassTransit, 또는 Brighter RabbitMQ 및 Azure 서비스 버스를 기반으로 사용할 수 있는 보다 낮은 수준에서 앉아 합니다.</span><span class="sxs-lookup"><span data-stu-id="7aee2-164">For instance, products like RabbitMQ (a messaging broker transport) and Azure Service Bus sit at a lower level than other products like, NServiceBus, MassTransit, or Brighter, which can work on top of RabbitMQ and Azure Service Bus.</span></span> <span data-ttu-id="7aee2-165">선택한 응용 프로그램 수준 및 기본적으로 확장성 응용 프로그램에 필요한 개수 다양 한 기능에 따라 달라 집니다.</span><span class="sxs-lookup"><span data-stu-id="7aee2-165">Your choice depends on how many rich features at the application level and out-of-the-box scalability you need for your application.</span></span> <span data-ttu-id="7aee2-166">개발 환경에 대 한 개념 증명 이벤트 버스를 구현 하기 위한 eShopOnContainers 샘플에 했던 대로 Docker 컨테이너에서 실행 중인 RabbitMQ 위에 간단한 구현으로 충분 합니다.</span><span class="sxs-lookup"><span data-stu-id="7aee2-166">For implementing just a proof-of-concept event bus for your development environment, as we have done in the eShopOnContainers sample, a simple implementation on top of RabbitMQ running on a Docker container might be enough.</span></span>

<span data-ttu-id="7aee2-167">그러나 중요 하이퍼 확장성을 필요로 하는 프로덕션 시스템에서는 Azure 서비스 버스를 평가 해야 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7aee2-167">However, for mission-critical and production systems that need hyper-scalability, you might want to evaluate Azure Service Bus.</span></span> <span data-ttu-id="7aee2-168">상위 수준 추상화 및 분산된 응용 프로그램의 개발을 용이 하는 기능에 대 한 Brighter NServiceBus, MassTransit, 등의 다른 상용 및 오픈 소스 서비스 버스를 평가 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="7aee2-168">For high-level abstractions and features that make the development of distributed applications easier, we recommend that you evaluate other commercial and open-source service buses, such as NServiceBus, MassTransit, and Brighter.</span></span> <span data-ttu-id="7aee2-169">물론, RabbitMQ 및 Docker와 같은 하위 수준의 기술 기반으로 서비스 버스 기능을 직접 작성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7aee2-169">Of course, you can build your own service-bus features on top of lower-level technologies like RabbitMQ and Docker.</span></span> <span data-ttu-id="7aee2-170">하지만 배관 작동 하는 수는 사용자 지정 엔터프라이즈 응용 프로그램에 대 한 너무 많은 비용.</span><span class="sxs-lookup"><span data-stu-id="7aee2-170">But that plumbing work might cost too much for a custom enterprise application.</span></span>

## <a name="resiliently-publishing-to-the-event-bus"></a><span data-ttu-id="7aee2-171">탄력적 이벤트 버스에 게시</span><span class="sxs-lookup"><span data-stu-id="7aee2-171">Resiliently publishing to the event bus</span></span>

<span data-ttu-id="7aee2-172">여러 microservices에서 이벤트 기반 아키텍처를 구현 하는 경우 문제는 원자 단위로 탄력적 관련된 통합 이벤트에 따라 어떻게 하 든 이벤트 버스에 게시 하는 동안 원래 마이크로 서비스에서 상태를 업데이트 하는 방법 트랜잭션입니다.</span><span class="sxs-lookup"><span data-stu-id="7aee2-172">A challenge when implementing an event-driven architecture across multiple microservices is how to atomically update state in the original microservice while resiliently publishing its related integration event into the event bus, somehow based on transactions.</span></span> <span data-ttu-id="7aee2-173">다음은 추가 방법은 있을 수 있지만이 수행 하는 몇 가지 방법을 합니다.</span><span class="sxs-lookup"><span data-stu-id="7aee2-173">The following are a few ways to accomplish this, although there could be additional approaches as well.</span></span>

-   <span data-ttu-id="7aee2-174">MSMQ와 같은 트랜잭션 (DTC 기반) 큐를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="7aee2-174">Using a transactional (DTC-based) queue like MSMQ.</span></span> <span data-ttu-id="7aee2-175">그러나 (이것은 레거시 방식입니다.)</span><span class="sxs-lookup"><span data-stu-id="7aee2-175">(However, this is a legacy approach.)</span></span>

-   <span data-ttu-id="7aee2-176">사용 하 여 [트랜잭션 로그 마이닝](http://www.scoop.it/t/sql-server-transaction-log-mining)합니다.</span><span class="sxs-lookup"><span data-stu-id="7aee2-176">Using [transaction log mining](http://www.scoop.it/t/sql-server-transaction-log-mining).</span></span>

-   <span data-ttu-id="7aee2-177">전체를 사용 하 여 [이벤트 소싱](https://msdn.microsoft.com/en-us/library/dn589792.aspx) 패턴입니다.</span><span class="sxs-lookup"><span data-stu-id="7aee2-177">Using full [Event Sourcing](https://msdn.microsoft.com/en-us/library/dn589792.aspx) pattern.</span></span>

-   <span data-ttu-id="7aee2-178">사용 하는 [보낼 편지함 패턴](http://gistlabs.com/2014/05/the-outbox/): 이벤트는 만들고 게시 하는 이벤트 생성자 구성 요소에 대 한 기준 수 있는 메시지 큐로 트랜잭션 데이터베이스 테이블입니다.</span><span class="sxs-lookup"><span data-stu-id="7aee2-178">Using the [Outbox pattern](http://gistlabs.com/2014/05/the-outbox/): a transactional database table as a message queue that will be the base for an event-creator component that would create the event and publish it.</span></span>

<span data-ttu-id="7aee2-179">비동기 통신을 사용할 때 고려해 야 할 추가 항목은 메시지 idempotence 및 메시지 중복을 제거 합니다.</span><span class="sxs-lookup"><span data-stu-id="7aee2-179">Additional topics to consider when using asynchronous communication are message idempotence and message deduplication.</span></span> <span data-ttu-id="7aee2-180">섹션에서 다루는 이러한 항목은 [microservices (통합 이벤트) 간의 이벤트 기반 통신 구현](#implementing_event_based_comms_microserv) 이 가이드의 뒷부분에 나오는 합니다.</span><span class="sxs-lookup"><span data-stu-id="7aee2-180">These topics are covered in the section [Implementing event-based communication between microservices (integration events)](#implementing_event_based_comms_microserv) later in this guide.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="7aee2-181">추가 리소스</span><span class="sxs-lookup"><span data-stu-id="7aee2-181">Additional resources</span></span>

-   <span data-ttu-id="7aee2-182">**이벤트 구동 메시징**
    [*http://soapatterns.org/design\_패턴/이벤트\_구동\_메시징*](http://soapatterns.org/design_patterns/event_driven_messaging)</span><span class="sxs-lookup"><span data-stu-id="7aee2-182">**Event Driven Messaging**
[*http://soapatterns.org/design\_patterns/event\_driven\_messaging*](http://soapatterns.org/design_patterns/event_driven_messaging)</span></span>

-   <span data-ttu-id="7aee2-183">**채널 게시/구독**
    [*http://www.enterpriseintegrationpatterns.com/patterns/messaging/PublishSubscribeChannel.html*](http://www.enterpriseintegrationpatterns.com/patterns/messaging/PublishSubscribeChannel.html)</span><span class="sxs-lookup"><span data-stu-id="7aee2-183">**Publish/Subscribe Channel**
[*http://www.enterpriseintegrationpatterns.com/patterns/messaging/PublishSubscribeChannel.html*](http://www.enterpriseintegrationpatterns.com/patterns/messaging/PublishSubscribeChannel.html)</span></span>

-   <span data-ttu-id="7aee2-184">**Udi Dahan 합니다. CQRS 설명이 명확해졌습니다**
    [*http://udidahan.com/2009/12/09/clarified-cqrs/*](http://udidahan.com/2009/12/09/clarified-cqrs/)</span><span class="sxs-lookup"><span data-stu-id="7aee2-184">**Udi Dahan. Clarified CQRS**
[*http://udidahan.com/2009/12/09/clarified-cqrs/*](http://udidahan.com/2009/12/09/clarified-cqrs/)</span></span>

-   <span data-ttu-id="7aee2-185">**명령 및 책임 분리 (CQRS) 쿼리**
    [*https://docs.microsoft.com/azure/architecture/patterns/cqrs*](https://docs.microsoft.com/azure/architecture/patterns/cqrs)</span><span class="sxs-lookup"><span data-stu-id="7aee2-185">**Command and Query Responsibility Segregation (CQRS)**
[*https://docs.microsoft.com/azure/architecture/patterns/cqrs*](https://docs.microsoft.com/azure/architecture/patterns/cqrs)</span></span>

-   <span data-ttu-id="7aee2-186">**경계가 지정 된 컨텍스트 간 통신**
    [*https://msdn.microsoft.com/library/jj591572.aspx*](https://msdn.microsoft.com/library/jj591572.aspx)</span><span class="sxs-lookup"><span data-stu-id="7aee2-186">**Communicating Between Bounded Contexts**
[*https://msdn.microsoft.com/library/jj591572.aspx*](https://msdn.microsoft.com/library/jj591572.aspx)</span></span>

-   <span data-ttu-id="7aee2-187">**결과적 일관성**
    [*https://en.wikipedia.org/wiki/Eventual\_일관성*](https://en.wikipedia.org/wiki/Eventual_consistency)</span><span class="sxs-lookup"><span data-stu-id="7aee2-187">**Eventual consistency**
[*https://en.wikipedia.org/wiki/Eventual\_consistency*](https://en.wikipedia.org/wiki/Eventual_consistency)</span></span>

-   <span data-ttu-id="7aee2-188">**Jimmy Bogard. 복원 력으로 리팩터링: 결합 평가**
    [*https://jimmybogard.com/refactoring-towards-resilience-evaluating-coupling/*](https://jimmybogard.com/refactoring-towards-resilience-evaluating-coupling/)</span><span class="sxs-lookup"><span data-stu-id="7aee2-188">**Jimmy Bogard. Refactoring Towards Resilience: Evaluating Coupling**
[*https://jimmybogard.com/refactoring-towards-resilience-evaluating-coupling/*](https://jimmybogard.com/refactoring-towards-resilience-evaluating-coupling/)</span></span>


>[!div class="step-by-step"]
<span data-ttu-id="7aee2-189">[이전] (통신-에-마이크로 서비스-architecture.md) [다음] (유지 관리-마이크로 서비스-apis.md)</span><span class="sxs-lookup"><span data-stu-id="7aee2-189">[Previous] (communication-in-microservice-architecture.md) [Next] (maintain-microservice-apis.md)</span></span>

---
title: 마이크로 서비스별 데이터 주권
description: 컨테이너화된 .NET 응용 프로그램을 위한 .NET 마이크로 서비스 아키텍처 | 마이크로 서비스별 데이터 주권
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 05/26/2017
ms.openlocfilehash: 6a3fc0e86de673fea5f8e81c14c6456a2256aaa6
ms.sourcegitcommit: efff8f331fd9467f093f8ab8d23a203d6ecb5b60
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 09/01/2018
ms.locfileid: "43408549"
---
# <a name="data-sovereignty-per-microservice"></a><span data-ttu-id="ffefd-103">마이크로 서비스별 데이터 주권</span><span class="sxs-lookup"><span data-stu-id="ffefd-103">Data sovereignty per microservice</span></span>

<span data-ttu-id="ffefd-104">마이크로 서비스 아키텍처에 대한 중요한 규칙으로, 각 마이크로 서비스는 자체 도메인 데이터와 논리를 갖고 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ffefd-104">An important rule for microservices architecture is that each microservice must own its domain data and logic.</span></span> <span data-ttu-id="ffefd-105">완전한 응용 프로그램이 자체 논리와 데이터를 갖는 것처럼, 각 마이크로 서비스는 자율적 수명 주기에서 자체 논리와 데이터를 가져야 하고, 마이크로 서비스마다 독립적으로 배포되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ffefd-105">Just as a full application owns its logic and data, so must each microservice own its logic and data under an autonomous lifecycle, with independent deployment per microservice.</span></span>

<span data-ttu-id="ffefd-106">즉, 도메인의 개념적 모델이 하위 시스템 또는 마이크로 서비스 간에 달라집니다.</span><span class="sxs-lookup"><span data-stu-id="ffefd-106">This means that the conceptual model of the domain will differ between subsystems or microservices.</span></span> <span data-ttu-id="ffefd-107">CRM(고객 관계 관리) 응용 프로그램, 트랜잭션 구매 하위 시스템, 고객 지원 하위 시스템이 각각 고유한 고객 엔터티 특성 및 데이터를 호출하고 각각 서로 다른 BC(경계가 지정된 컨텍스트)를 사용하는 엔터프라이즈 응용 프로그램을 생각해 보세요.</span><span class="sxs-lookup"><span data-stu-id="ffefd-107">Consider enterprise applications, where customer relationship management (CRM) applications, transactional purchase subsystems, and customer support subsystems each call on unique customer entity attributes and data, and where each employs a different Bounded Context (BC).</span></span>

<span data-ttu-id="ffefd-108">이 원칙은 [DDD(도메인 기반 디자인)](https://en.wikipedia.org/wiki/Domain-driven_design)와 비슷합니다. 각 [경계가 지정된 컨텍스트](https://martinfowler.com/bliki/BoundedContext.html) 또는 자율적 하위 시스템 또는 서비스가 자체 도메인 모델(데이터와 논리 및 동작)을 가져야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ffefd-108">This principle is similar in [Domain-driven design (DDD)](https://en.wikipedia.org/wiki/Domain-driven_design), where each [Bounded Context](https://martinfowler.com/bliki/BoundedContext.html) or autonomous subsystem or service must own its domain model (data plus logic and behavior).</span></span> <span data-ttu-id="ffefd-109">각 DDD 경계가 지정된 컨텍스트는 한 비즈니스 마이크로 서비스(하나 또는 여러 서비스)와 상관 관계가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ffefd-109">Each DDD Bounded Context correlates to one business microservice (one or several services).</span></span> <span data-ttu-id="ffefd-110">(경계가 지정된 컨텍스트 패턴에 대한 내용은 다음 섹션에서 다루겠습니다.)</span><span class="sxs-lookup"><span data-stu-id="ffefd-110">(We expand on this point about the Bounded Context pattern in the next section.)</span></span>

<span data-ttu-id="ffefd-111">반면, 여러 응용 프로그램에 사용되는 전통적인(모놀리식 데이터) 방식은 중앙 집중식 데이터베이스 하나 또는 데이터베이스 몇 개만 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="ffefd-111">On the other hand, the traditional (monolithic data) approach used in many applications is to have a single centralized database or just a few databases.</span></span> <span data-ttu-id="ffefd-112">이는 그림 4-7처럼 종종 전체 응용 프로그램 및 모든 내부 하위 시스템에 사용되는 정규화된 SQL 데이터베이스입니다.</span><span class="sxs-lookup"><span data-stu-id="ffefd-112">This is often a normalized SQL database that is used for the whole application and all its internal subsystems, as shown in Figure 4-7.</span></span>

![](./media/image7.png)

<span data-ttu-id="ffefd-113">**그림 4-7**.</span><span class="sxs-lookup"><span data-stu-id="ffefd-113">**Figure 4-7**.</span></span> <span data-ttu-id="ffefd-114">데이터 주권 비교: 모놀리식 데이터베이스와 마이크로 서비스 비교</span><span class="sxs-lookup"><span data-stu-id="ffefd-114">Data sovereignty comparison: monolithic database versus microservices</span></span>

<span data-ttu-id="ffefd-115">중앙 집중식 데이터베이스 접근 방식은 처음에는 간단해 보이고 엔터티를 여러 하위 시스템에 재사용하여 모든 것을 일관적으로 유지할 수 있는 것처럼 보입니다.</span><span class="sxs-lookup"><span data-stu-id="ffefd-115">The centralized database approach initially looks simpler and seems to enable reuse of entities in different subsystems to make everything consistent.</span></span> <span data-ttu-id="ffefd-116">그러나 결국에는 여러 하위 시스템을 처리하는 거대한 테이블이 생기고, 대부분의 경우 필요 없는 특성과 열이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="ffefd-116">But the reality is you end up with huge tables that serve many different subsystems, and that include attributes and columns that are not needed in most cases.</span></span> <span data-ttu-id="ffefd-117">단거리 하이킹, 하루가 걸리는 자동차 여행 및 지질 연구에 똑같은 물리적 맵을 사용하는 것에 비유할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ffefd-117">It is like trying to use the same physical map for hiking a short trail, taking a day-long car trip, and learning geography.</span></span>

<span data-ttu-id="ffefd-118">일반적으로 단일 관계형 데이터베이스를 사용하는 모놀리식 응용 프로그램의 두 가지 주요 이점은 [ACID 트랜잭션](https://en.wikipedia.org/wiki/ACID) 및 SQL 언어로, 둘 다 응용 프로그램과 관련된 모든 테이블 및 데이터에서 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="ffefd-118">A monolithic application with typically a single relational database has two important benefits: [ACID transactions](https://en.wikipedia.org/wiki/ACID) and the SQL language, both working across all the tables and data related to your application.</span></span> <span data-ttu-id="ffefd-119">이 접근 방식은 여러 테이블의 데이터를 결합하는 쿼리를 손쉽게 작성하는 방법을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="ffefd-119">This approach provides a way to easily write a query that combines data from multiple tables.</span></span>

<span data-ttu-id="ffefd-120">그러나 마이크로 서비스 아키텍처로 전환하면 데이터 액세스가 점점 더 복잡해집니다.</span><span class="sxs-lookup"><span data-stu-id="ffefd-120">However, data access becomes much more complex when you move to a microservices architecture.</span></span> <span data-ttu-id="ffefd-121">마이크로 서비스 또는 경계가 지정된 컨텍스트 내에서 ACID 트랜잭션을 사용할 수 있거나 사용해야 하는 경우에도 각 마이크로 서비스 소유의 데이터는 해당 마이크로 서비스 전용이며 해당 마이크로 서비스 API를 통해서만 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ffefd-121">But even when ACID transactions can or should be used within a microservice or Bounded Context, the data owned by each microservice is private to that microservice and can only be accessed via its microservice API.</span></span> <span data-ttu-id="ffefd-122">데이터를 캡슐화하면 마이크로 서비스가 느슨하게 결합되므로 서로 독립적으로 발전할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ffefd-122">Encapsulating the data ensures that the microservices are loosely coupled and can evolve independently of one another.</span></span> <span data-ttu-id="ffefd-123">여러 서비스가 동일한 데이터에 액세스하는 경우 스키마를 업데이트하려면 모든 서비스에 대한 조정된 업데이트가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="ffefd-123">If multiple services were accessing the same data, schema updates would require coordinated updates to all the services.</span></span> <span data-ttu-id="ffefd-124">이렇게 하면 마이크로 서비스 수명 주기 자율성이 손상됩니다.</span><span class="sxs-lookup"><span data-stu-id="ffefd-124">This would break the microservice lifecycle autonomy.</span></span> <span data-ttu-id="ffefd-125">하지만 분산 데이터 구조는 마이크로 서비스에 단일 ACID 트랜잭션을 만들 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ffefd-125">But distributed data structures mean that you cannot make a single ACID transaction across microservices.</span></span> <span data-ttu-id="ffefd-126">다시 말해서, 비즈니스 프로세스가 여러 마이크로 서비스에 걸쳐 있는 경우 최종 일관성을 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ffefd-126">This in turn means you must use eventual consistency when a business process spans multiple microservices.</span></span> <span data-ttu-id="ffefd-127">간단한 SQL 조인보다 구현하기가 훨씬 어려우며, 마찬가지로 다른 여러 관계형 데이터베이스 기능을 여러 마이크로 서비스에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ffefd-127">This is much harder to implement than simple SQL joins; similarly, many other relational database features are not available across multiple microservices.</span></span>

<span data-ttu-id="ffefd-128">좀 더 깊이 들어가자면, 종종 다양한 마이크로 서비스에서 다양한 *종류의* 데이터베이스를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="ffefd-128">Going even further, different microservices often use different *kinds* of databases.</span></span> <span data-ttu-id="ffefd-129">최신 응용 프로그램은 다양한 종류의 데이터를 저장 및 처리하며, 따라서 관계형 데이터베이스가 언제나 좋은 선택은 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="ffefd-129">Modern applications store and process diverse kinds of data, and a relational database is not always the best choice.</span></span> <span data-ttu-id="ffefd-130">일부 사용 사례에서는 Azure DocumentDB 또는 MongoDB 같은 NoSQL 데이터베이스가 SQL Server 또는 Azure SQL Database 같은 SQL 데이터베이스보다 편리한 데이터 모델과 우수한 성능 및 확장성을 제공할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ffefd-130">For some use cases, a NoSQL database such as Azure DocumentDB or MongoDB might have a more convenient data model and offer better performance and scalability than a SQL database like SQL Server or Azure SQL Database.</span></span> <span data-ttu-id="ffefd-131">그 외에는 여전히 관계형 데이터베이스가 가장 좋은 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="ffefd-131">In other cases, a relational database is still the best approach.</span></span> <span data-ttu-id="ffefd-132">이러한 이유로 마이크로 서비스 기반 응용 프로그램에서는 SQL 및 NoSQL 데이터베이스를 혼합해서 사용하는 경우가 많으며, 이를 [다국어 지속성](https://martinfowler.com/bliki/PolyglotPersistence.html) 접근 방식이라고도 합니다.</span><span class="sxs-lookup"><span data-stu-id="ffefd-132">Therefore, microservices-based applications often use a mixture of SQL and NoSQL databases, which is sometimes called the [polyglot persistence](https://martinfowler.com/bliki/PolyglotPersistence.html) approach.</span></span>

<span data-ttu-id="ffefd-133">데이터 저장소에 사용되는 분할된 다국어 아키텍처는 여러 가지 이점이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ffefd-133">A partitioned, polyglot-persistent architecture for data storage has many benefits.</span></span> <span data-ttu-id="ffefd-134">느슨한 결합과 더 우수한 성능, 확장성, 비용 및 관리성을 예로 들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ffefd-134">These include loosely coupled services and better performance, scalability, costs, and manageability.</span></span> <span data-ttu-id="ffefd-135">하지만 분산 데이터 관리가 어려울 수 있으며, 이에 대한 내용은 이 챕터의 뒷부분에 나오는 "[도메인 모델 경계 식별](#identifying-domain-model-boundaries-for-each-microservice)"에서 다루겠습니다.</span><span class="sxs-lookup"><span data-stu-id="ffefd-135">However, it can introduce some distributed data management challenges, as we will explain in “[Identifying domain-model boundaries](#identifying-domain-model-boundaries-for-each-microservice)” later in this chapter.</span></span>

## <a name="the-relationship-between-microservices-and-the-bounded-context-pattern"></a><span data-ttu-id="ffefd-136">마이크로 서비스와 경계가 지정된 컨텍스트 패턴 사이의 관계</span><span class="sxs-lookup"><span data-stu-id="ffefd-136">The relationship between microservices and the Bounded Context pattern</span></span>

<span data-ttu-id="ffefd-137">마이크로 서비스의 개념은 [DDD(도메인 기반 디자인)](https://en.wikipedia.org/wiki/Domain-driven_design)의 [BC(경계가 지정된 컨텍스트) 패턴](https://martinfowler.com/bliki/BoundedContext.html)에서 파생됩니다.</span><span class="sxs-lookup"><span data-stu-id="ffefd-137">The concept of microservice derives from the [Bounded Context (BC) pattern](https://martinfowler.com/bliki/BoundedContext.html) in [domain-driven design (DDD)](https://en.wikipedia.org/wiki/Domain-driven_design).</span></span> <span data-ttu-id="ffefd-138">DDD는 대형 모델을 여러 BC로 분할하고 경계에 대해 명시적으로 만드는 방식으로 대형 모델을 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="ffefd-138">DDD deals with large models by dividing them into multiple BCs and being explicit about their boundaries.</span></span> <span data-ttu-id="ffefd-139">각 마이크로 서비스에 자체적인 관련 데이터가 있듯이, 각 BC에도 자체적인 모델 및 데이터베이스가 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ffefd-139">Each BC must have its own model and database; likewise, each microservice owns its related data.</span></span> <span data-ttu-id="ffefd-140">또한 일반적으로 각 BC에는 소프트웨어 개발자와 도메인 전문가 간의 통신을 도와주기 위한 자체적인 [유비쿼터스 언어](https://martinfowler.com/bliki/UbiquitousLanguage.html)가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ffefd-140">In addition, each BC usually has its own [ubiquitous language](https://martinfowler.com/bliki/UbiquitousLanguage.html) to help communication between software developers and domain experts.</span></span>

<span data-ttu-id="ffefd-141">유비쿼터스 언어에서 이러한 용어(주로 도메인 엔터티)는 심지어 여러 도메인 엔터티가 동일한 ID(즉, 저장소에서 엔터티를 읽는 데 사용되는 고유의 ID)를 공유하는 경우에도 경계가 지정된 다른 컨텍스트에서 다른 이름을 가질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ffefd-141">Those terms (mainly domain entities) in the ubiquitous language can have different names in different Bounded Contexts, even when different domain entities share the same identity (that is, the unique ID that is used to read the entity from storage).</span></span> <span data-ttu-id="ffefd-142">예를 들어 사용자 프로필 경계가 지정된 컨텍스트에서, 사용자 도메인 엔터티는 주문 경계가 지정된 컨텍스트의 구매자 도메인 엔터티와 ID를 공유할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ffefd-142">For instance, in a user-profile Bounded Context, the User domain entity might share identity with the Buyer domain entity in the ordering Bounded Context.</span></span>

<span data-ttu-id="ffefd-143">이러한 점에서 마이크로 서비스는 경계가 지정된 컨텍스트와 비슷하지만, 거기서 그치지 않고 분산 서비스임을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="ffefd-143">A microservice is therefore like a Bounded Context, but it also specifies that it is a distributed service.</span></span> <span data-ttu-id="ffefd-144">경계가 지정된 각 컨텍스트에 대한 별도의 프로세스로 빌드되며, 앞서 언급했듯이 HTTP/HTTPS, WebSocket 또는 [AMQP](https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol) 같은 분산 프로토콜을 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ffefd-144">It is built as a separate process for each Bounded Context, and it must use the distributed protocols noted earlier, like HTTP/HTTPS, WebSockets, or [AMQP](https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol).</span></span> <span data-ttu-id="ffefd-145">그러나 경계가 지정된 컨텍스트 패턴은 경계가 지정된 컨텍스트가 분산 서비스라고 지정하거나 모놀리식 배포 응용 프로그램 내의 단순한 논리적 경계(예: 제네릭 하위 시스템)라고 지정하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ffefd-145">The Bounded Context pattern, however, does not specify whether the Bounded Context is a distributed service or if it is simply a logical boundary (such as a generic subsystem) within a monolithic-deployment application.</span></span>

<span data-ttu-id="ffefd-146">경계가 지정된 각 컨텍스트에 대한 서비스를 정의하는 것부터 시작하는 것이 좋다고 강조해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ffefd-146">It is important to highlight that defining a service for each Bounded Context is a good place to start.</span></span> <span data-ttu-id="ffefd-147">하지만 디자인을 거기에 제한할 필요는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ffefd-147">But you do not have to constrain your design to it.</span></span> <span data-ttu-id="ffefd-148">경우에 따라 경계가 지정된 컨텍스트를 디자인해야 할 때도 있고 여러 물리적 서비스로 구성된 비즈니스 마이크로 서비스를 디자인해야 할 때도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ffefd-148">Sometimes you must design a Bounded Context or business microservice composed of several physical services.</span></span> <span data-ttu-id="ffefd-149">하지만 궁극적으로 두 패턴, 즉 경계가 지정된 컨텍스트와 마이크로 서비스는 밀접하게 관련되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ffefd-149">But ultimately, both patterns—Bounded Context and microservice—are closely related.</span></span>

<span data-ttu-id="ffefd-150">DDD는 실제 경계를 분산된 마이크로 서비스의 형태로 가져오는 마이크로 서비스의 이점을 활용합니다.</span><span class="sxs-lookup"><span data-stu-id="ffefd-150">DDD benefits from microservices by getting real boundaries in the form of distributed microservices.</span></span> <span data-ttu-id="ffefd-151">하지만 마이크로 서비스 간에 모델을 공유하지 않는 아이디어는 경계가 지정된 컨텍스트에도 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ffefd-151">But ideas like not sharing the model between microservices are what you also want in a Bounded Context.</span></span>

### <a name="additional-resources"></a><span data-ttu-id="ffefd-152">추가 자료</span><span class="sxs-lookup"><span data-stu-id="ffefd-152">Additional resources</span></span>

-   <span data-ttu-id="ffefd-153">**Chris Richardson. 패턴: 서비스별 데이터베이스**
    [*https://microservices.io/patterns/data/database-per-service.html*](https://microservices.io/patterns/data/database-per-service.html)</span><span class="sxs-lookup"><span data-stu-id="ffefd-153">**Chris Richardson. Pattern: Database per service**
[*https://microservices.io/patterns/data/database-per-service.html*](https://microservices.io/patterns/data/database-per-service.html)</span></span>

-   <span data-ttu-id="ffefd-154">**Martin Fowler. BoundedContext**
    [*https://martinfowler.com/bliki/BoundedContext.html*](https://martinfowler.com/bliki/BoundedContext.html)</span><span class="sxs-lookup"><span data-stu-id="ffefd-154">**Martin Fowler. BoundedContext**
[*https://martinfowler.com/bliki/BoundedContext.html*](https://martinfowler.com/bliki/BoundedContext.html)</span></span>

-   <span data-ttu-id="ffefd-155">**Martin Fowler. PolyglotPersistence**
    [*https://martinfowler.com/bliki/PolyglotPersistence.html*](https://martinfowler.com/bliki/PolyglotPersistence.html)</span><span class="sxs-lookup"><span data-stu-id="ffefd-155">**Martin Fowler. PolyglotPersistence**
[*https://martinfowler.com/bliki/PolyglotPersistence.html*](https://martinfowler.com/bliki/PolyglotPersistence.html)</span></span>

-   <span data-ttu-id="ffefd-156">**Alberto Brandolini. 컨텍스트 매핑을 통한 전략적인 도메인 기반 디자인**
    [*https://www.infoq.com/articles/ddd-contextmapping*](https://www.infoq.com/articles/ddd-contextmapping)</span><span class="sxs-lookup"><span data-stu-id="ffefd-156">**Alberto Brandolini. Strategic Domain Driven Design with Context Mapping**
[*https://www.infoq.com/articles/ddd-contextmapping*](https://www.infoq.com/articles/ddd-contextmapping)</span></span>


>[!div class="step-by-step"]
<span data-ttu-id="ffefd-157">[이전](microservices-architecture.md)
[다음](logical-versus-physical-architecture.md)</span><span class="sxs-lookup"><span data-stu-id="ffefd-157">[Previous](microservices-architecture.md)
[Next](logical-versus-physical-architecture.md)</span></span>

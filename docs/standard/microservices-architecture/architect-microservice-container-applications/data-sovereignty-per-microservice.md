---
title: "마이크로 서비스 당 데이터 sovereignty"
description: "컨테이너 화 된.NET 응용 프로그램에 대 한.NET Microservices 아키텍처 | 마이크로 서비스 당 데이터 sovereignty"
keywords: "Docker, 마이크로 서비스, ASP.NET, 컨테이너"
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 05/26/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.topic: article
ms.openlocfilehash: c51daae04215cfa6f5b5b8d2158a8ed1a8949652
ms.sourcegitcommit: c2e216692ef7576a213ae16af2377cd98d1a67fa
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 10/22/2017
---
# <a name="data-sovereignty-per-microservice"></a><span data-ttu-id="dff8c-104">마이크로 서비스 당 데이터 sovereignty</span><span class="sxs-lookup"><span data-stu-id="dff8c-104">Data sovereignty per microservice</span></span>

<span data-ttu-id="dff8c-105">Microservices 아키텍처에 대 한 중요 한 규칙은 도메인 데이터와 논리 각 마이크로 서비스를 소유 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="dff8c-105">An important rule for microservices architecture is that each microservice must own its domain data and logic.</span></span> <span data-ttu-id="dff8c-106">전체 응용 프로그램에서 해당 논리 및 데이터를 소유 하는 것 처럼 하므로 각 마이크로 서비스 소유 해야 해당 논리 및 데이터가 마이크로 서비스 당 독립 배포와는 자치 수명 주기에서 합니다.</span><span class="sxs-lookup"><span data-stu-id="dff8c-106">Just as a full application owns its logic and data, so must each microservice own its logic and data under an autonomous lifecycle, with independent deployment per microservice.</span></span>

<span data-ttu-id="dff8c-107">즉, 도메인의 개념적 모델 하위 시스템 또는 microservices 간에 달라 집니다.</span><span class="sxs-lookup"><span data-stu-id="dff8c-107">This means that the conceptual model of the domain will differ between subsystems or microservices.</span></span> <span data-ttu-id="dff8c-108">엔터프라이즈 응용 프로그램을 고객 관계 관리 (CRM) 응용 프로그램, 트랜잭션 구매 하위 시스템 및 고객 지원 하위 시스템 고유한 고객 엔터티 특성 및 데이터에 대 한 각 호출 하 고 각각 서로 다른 사용 고려 컨텍스트 (BC)을 제한 합니다.</span><span class="sxs-lookup"><span data-stu-id="dff8c-108">Consider enterprise applications, where customer relationship management (CRM) applications, transactional purchase subsystems, and customer support subsystems each call on unique customer entity attributes and data, and where each employs a different Bounded Context (BC).</span></span>

<span data-ttu-id="dff8c-109">이 원칙은 비슷합니다 [도메인 기반 디자인 (DDD)](https://en.wikipedia.org/wiki/Domain-driven_design)여기서 각 [경계가 지정 된 컨텍스트](https://martinfowler.com/bliki/BoundedContext.html) 또는 자치 하위 시스템 또는 서비스의 도메인 모델 (데이터와 논리 및 동작)를 소유 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="dff8c-109">This principle is similar in [Domain-driven design (DDD)](https://en.wikipedia.org/wiki/Domain-driven_design), where each [Bounded Context](https://martinfowler.com/bliki/BoundedContext.html) or autonomous subsystem or service must own its domain model (data plus logic and behavior).</span></span> <span data-ttu-id="dff8c-110">각 DDD 경계가 지정 된 컨텍스트는 한 비즈니스 마이크로 서비스 (하나 또는 여러 서비스)에 연결 됩니다.</span><span class="sxs-lookup"><span data-stu-id="dff8c-110">Each DDD Bounded Context correlates to one business microservice (one or several services).</span></span> <span data-ttu-id="dff8c-111">(여기서 확장 다음 섹션에서 컨텍스트 경계가 지정 된 패턴에 대 한이 지점에서.)</span><span class="sxs-lookup"><span data-stu-id="dff8c-111">(We expand on this point about the Bounded Context pattern in the next section.)</span></span>

<span data-ttu-id="dff8c-112">반면에 단일 중앙 집중식된 데이터베이스 또는 몇 개의 데이터베이스 하는 많은 응용 프로그램에서 사용 하는 일반적인 (모놀리식 데이터) 방법이입니다.</span><span class="sxs-lookup"><span data-stu-id="dff8c-112">On the other hand, the traditional (monolithic data) approach used in many applications is to have a single centralized database or just a few databases.</span></span> <span data-ttu-id="dff8c-113">그림 4-7 같이 전체 응용 프로그램 및 해당 모든 내부 하위 시스템에 사용 되는 SQL 데이터베이스를 정규화 종종입니다.</span><span class="sxs-lookup"><span data-stu-id="dff8c-113">This is often a normalized SQL database that is used for the whole application and all its internal subsystems, as shown in Figure 4-7.</span></span>

![](./media/image7.png)

<span data-ttu-id="dff8c-114">**그림 4-7**합니다.</span><span class="sxs-lookup"><span data-stu-id="dff8c-114">**Figure 4-7**.</span></span> <span data-ttu-id="dff8c-115">데이터 sovereignty 비교: microservices와 모놀리식 데이터베이스</span><span class="sxs-lookup"><span data-stu-id="dff8c-115">Data sovereignty comparison: monolithic database versus microservices</span></span>

<span data-ttu-id="dff8c-116">중앙 집중식된 데이터베이스 접근 방식 처음 간단 모양과 일관성 있는 모든 다른 하위 시스템에 있는 엔터티의 다시 사용할 수 있도록 하는 것 같습니다.</span><span class="sxs-lookup"><span data-stu-id="dff8c-116">The centralized database approach initially looks simpler and seems to enable reuse of entities in different subsystems to make everything consistent.</span></span> <span data-ttu-id="dff8c-117">하지만 여러 다른 하위 시스템을 제공 하는 대부분의 경우 특성 및 필요 하지 않은 열을 포함 하는 큰 테이블 /fd 현실은 합니다.</span><span class="sxs-lookup"><span data-stu-id="dff8c-117">But the reality is you end up with huge tables that serve many different subsystems, and that include attributes and columns that are not needed in most cases.</span></span> <span data-ttu-id="dff8c-118">짧은 내역 하이킹 하루 종일 자동차 여행 가져오고 geography 학습에 대해 동일한 물리적 맵을 사용 하는 동안 같습니다.</span><span class="sxs-lookup"><span data-stu-id="dff8c-118">it is like trying to use the same physical map for hiking a short trail, taking a day-long car trip, and learning geography.</span></span>

<span data-ttu-id="dff8c-119">일반적으로 단일 관계형 데이터베이스와는 모놀리식 응용 프로그램에 중요 한 이점: [ACID 트랜잭션](https://en.wikipedia.org/wiki/ACID) 및 SQL 언어를 모든 테이블 및 응용 프로그램에 관련 된 데이터에서 모두 작동 합니다.</span><span class="sxs-lookup"><span data-stu-id="dff8c-119">A monolithic application with typically a single relational database has two important benefits: [ACID transactions](https://en.wikipedia.org/wiki/ACID) and the SQL language, both working across all the tables and data related to your application.</span></span> <span data-ttu-id="dff8c-120">이 방법은 쉽게 여러 테이블의에서 데이터를 결합 하는 쿼리를 작성 하는 방법을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="dff8c-120">This approach provides a way to easily write a query that combines data from multiple tables.</span></span>

<span data-ttu-id="dff8c-121">그러나 microservices 아키텍처를 이동할 때 데이터 액세스는 훨씬 더 복잡해 집니다.</span><span class="sxs-lookup"><span data-stu-id="dff8c-121">However, data access becomes much more complex when you move to a microservices architecture.</span></span> <span data-ttu-id="dff8c-122">하지만 ACID 트랜잭션 수 또는 마이크로 서비스 또는 경계가 지정 된 컨텍스트 내에서 사용 해야 하는 경우에 각 마이크로 서비스를 소유한 데이터는 해당 마이크로 서비스에 전용 포트 이며 해당 마이크로 서비스 API를 통해 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="dff8c-122">But even when ACID transactions can or should be used within a microservice or Bounded Context, the data owned by each microservice is private to that microservice and can only be accessed via its microservice API.</span></span> <span data-ttu-id="dff8c-123">데이터를 캡슐화 하면는 microservices 느슨하게 결합 된 있고 서로 독립적으로 개발할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="dff8c-123">Encapsulating the data ensures that the microservices are loosely coupled and can evolve independently of one another.</span></span> <span data-ttu-id="dff8c-124">여러 서비스에 동일한 데이터에 액세스 된, 스키마 업데이트는 모든 서비스에 대 한 조정 된 업데이트 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="dff8c-124">If multiple services were accessing the same data, schema updates would require coordinated updates to all the services.</span></span> <span data-ttu-id="dff8c-125">마이크로 서비스 수명 주기 자치를 작동 하지 않으므로이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="dff8c-125">This would break the microservice lifecycle autonomy.</span></span> <span data-ttu-id="dff8c-126">하지만 분산된 데이터 구조 뜻합니다 microservices 간에 단일 ACID 트랜잭션을 만들 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="dff8c-126">But distributed data structures mean that you cannot make a single ACID transaction across microservices.</span></span> <span data-ttu-id="dff8c-127">이 다시 여러 microservices 비즈니스 프로세스에 걸쳐 있는 경우 결과적 일관성을 사용 해야 의미 합니다.</span><span class="sxs-lookup"><span data-stu-id="dff8c-127">This in turn means you must use eventual consistency when a business process spans multiple microservices.</span></span> <span data-ttu-id="dff8c-128">이 단순한 SQL 조인; 보다 구현 하기가 훨씬 쉽다는 점 마찬가지로, 관계형 데이터베이스의 다른 여러 기능이 사용할 수 없는 여러 microservices 에서입니다.</span><span class="sxs-lookup"><span data-stu-id="dff8c-128">This is much harder to implement than simple SQL joins; similarly, many other relational database features are not available across multiple microservices.</span></span>

<span data-ttu-id="dff8c-129">더 나아가 다른 microservices 자주 사용 하 여 다른 *종류* 데이터베이스.</span><span class="sxs-lookup"><span data-stu-id="dff8c-129">Going even further, different microservices often use different *kinds* of databases.</span></span> <span data-ttu-id="dff8c-130">최신 응용 프로그램 저장소 및 다양 한 종류의 데이터를 프로세스와 관계형 데이터베이스 않습니다 항상 가장 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="dff8c-130">Modern applications store and process diverse kinds of data, and a relational database is not always the best choice.</span></span> <span data-ttu-id="dff8c-131">일부에 대 한 사용 사례, Azure DocumentDB 또는 MongoDB와 같은 NoSQL 데이터베이스는 보다 편리한 데이터 모델 및 성능 향상 및 SQL Server와 같은 SQL 데이터베이스 또는 Azure SQL 데이터베이스 보다 확장성을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="dff8c-131">For some use cases, a NoSQL database such as Azure DocumentDB or MongoDB might have a more convenient data model and offer better performance and scalability than a SQL database like SQL Server or Azure SQL Database.</span></span> <span data-ttu-id="dff8c-132">다른 경우 관계형 데이터베이스는 여전히 가장 좋은 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="dff8c-132">In other cases, a relational database is still the best approach.</span></span> <span data-ttu-id="dff8c-133">따라서 microservices 기반 응용 프로그램 자주 사용 하 여 다양 한 SQL 및 NoSQL 데이터베이스 라고도 하는 [polyglot 지 속성](http://martinfowler.com/bliki/PolyglotPersistence.html) 접근 방식입니다.</span><span class="sxs-lookup"><span data-stu-id="dff8c-133">Therefore, microservices-based applications often use a mixture of SQL and NoSQL databases, which is sometimes called the [polyglot persistence](http://martinfowler.com/bliki/PolyglotPersistence.html) approach.</span></span>

<span data-ttu-id="dff8c-134">데이터 저장소에 대 한 분할된 된 polyglot 영구 아키텍처에는 많은 장점이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="dff8c-134">A partitioned, polyglot-persistent architecture for data storage has many benefits.</span></span> <span data-ttu-id="dff8c-135">여기에 느슨하게 연결 된 서비스 및 더 나은 성능, 확장성, 비용 및 관리 효율성 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="dff8c-135">These include loosely coupled services and better performance, scalability, costs, and manageability.</span></span> <span data-ttu-id="dff8c-136">하지만 설명할 것 처럼 분산된 데이터 관리 문제가 발생할 수 있습니다 "[도메인 모델 경계를 식별](#identifying-domain-model-boundaries-for-each-microservice)"를이 참조 합니다.</span><span class="sxs-lookup"><span data-stu-id="dff8c-136">However, it can introduce some distributed data management challenges, as we will explain in “[Identifying domain-model boundaries](#identifying-domain-model-boundaries-for-each-microservice)” later in this chapter.</span></span>

## <a name="the-relationship-between-microservices-and-the-bounded-context-pattern"></a><span data-ttu-id="dff8c-137">Microservices과 컨텍스트 경계가 지정 된 패턴의 관계</span><span class="sxs-lookup"><span data-stu-id="dff8c-137">The relationship between microservices and the Bounded Context pattern</span></span>

<span data-ttu-id="dff8c-138">마이크로 서비스 개념에서 파생 되는 [경계가 지정 된 컨텍스트 (BC) 패턴](http://martinfowler.com/bliki/BoundedContext.html) 에 [도메인 기반 디자인 (DDD)](https://en.wikipedia.org/wiki/Domain-driven_design)합니다.</span><span class="sxs-lookup"><span data-stu-id="dff8c-138">The concept of microservice derives from the [Bounded Context (BC) pattern](http://martinfowler.com/bliki/BoundedContext.html) in [domain-driven design (DDD)](https://en.wikipedia.org/wiki/Domain-driven_design).</span></span> <span data-ttu-id="dff8c-139">DDD 여러 BCs는 및 해당 경계에 대 한 명시적 개방형 큰 모델을 다룹니다.</span><span class="sxs-lookup"><span data-stu-id="dff8c-139">DDD deals with large models by dividing them into multiple BCs and being explicit about their boundaries.</span></span> <span data-ttu-id="dff8c-140">각 BC 자체 모델 및 데이터베이스; 있어야 합니다. 마찬가지로, 각 마이크로 서비스 관련된 데이터를 소유합니다.</span><span class="sxs-lookup"><span data-stu-id="dff8c-140">Each BC must have its own model and database; likewise, each microservice owns its related data.</span></span> <span data-ttu-id="dff8c-141">또한 일반적으로 각 BC에는 자체 [유비쿼터스 언어](http://martinfowler.com/bliki/UbiquitousLanguage.html) 소프트웨어 개발자와 도메인 전문가 간의 통신에 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="dff8c-141">In addition, each BC usually has its own [ubiquitous language](http://martinfowler.com/bliki/UbiquitousLanguage.html) to help communication between software developers and domain experts.</span></span>

<span data-ttu-id="dff8c-142">(즉, 고유 ID 저장소에서 엔터티를 읽는 데 사용 되는) 동일한 id를 공유 하는 다른 경우에 도메인 엔터티를 유비쿼터스 언어에서 용어 (주로 도메인 엔터티) 다른 경계가 지정 된 컨텍스트에서 서로 다른 이름을 가질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="dff8c-142">Those terms (mainly domain entities) in the ubiquitous language can have different names in different Bounded Contexts, even when different domain entities share the same identity (that is, the unique ID that is used to read the entity from storage).</span></span> <span data-ttu-id="dff8c-143">예를 들어, 컨텍스트에서 사용자 프로필 경계가 지정 된 사용자 도메인 엔터티가 공유할 수 identity 정렬 경계가 지정 된 컨텍스트에서 구매자 도메인 엔터티.</span><span class="sxs-lookup"><span data-stu-id="dff8c-143">For instance, in a user-profile Bounded Context, the User domain entity might share identity with the Buyer domain entity in the ordering Bounded Context.</span></span>

<span data-ttu-id="dff8c-144">마이크로 서비스를 제한 하는 컨텍스트를 따라서 비슷합니다. 하지만 또한 분산된 서비스 임을 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="dff8c-144">A microservice is therefore like a Bounded Context, but it also specifies that it is a distributed service.</span></span> <span data-ttu-id="dff8c-145">각 경계가 지정 된 컨텍스트에 대 한 별도 프로세스로 빌드될 및 HTTP/HTTPS, WebSockets, 같은 앞에서 설명한 것 분산된 프로토콜을 사용 해야 하거나 [AMQP](https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol)합니다.</span><span class="sxs-lookup"><span data-stu-id="dff8c-145">It is built as a separate process for each Bounded Context, and it must use the distributed protocols noted earlier, like HTTP/HTTPS, WebSockets, or [AMQP](https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol).</span></span> <span data-ttu-id="dff8c-146">그러나 경계가 지정 된 컨텍스트 패턴 지정 하지 않습니다 경계가 지정 된 컨텍스트는 분산된 서비스 되는지 또는 단순히 (예: 제네릭 하위 시스템)는 논리적 경계 경우 모놀리식 배포 응용 프로그램 내에서.</span><span class="sxs-lookup"><span data-stu-id="dff8c-146">The Bounded Context pattern, however, does not specify whether the Bounded Context is a distributed service or if it is simply a logical boundary (such as a generic subsystem) within a monolithic-deployment application.</span></span>

<span data-ttu-id="dff8c-147">각 경계가 지정 된 컨텍스트에 대 한 서비스를 정의 하려면 먼저 시작할 임을 강조 표시 하는 것이 유용 합니다.</span><span class="sxs-lookup"><span data-stu-id="dff8c-147">It is important to highlight that defining a service for each Bounded Context is a good place to start.</span></span> <span data-ttu-id="dff8c-148">하지만 디자인을 제한할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="dff8c-148">But you do not have to constrain your design to it.</span></span> <span data-ttu-id="dff8c-149">경우에 따라 경계가 지정 된 컨텍스트를 디자인 해야 또는 몇 가지 물리적 서비스는 비즈니스 마이크로 서비스를 구성 합니다.</span><span class="sxs-lookup"><span data-stu-id="dff8c-149">Sometimes you must design a Bounded Context or business microservice composed of several physical services.</span></span> <span data-ttu-id="dff8c-150">하지만 궁극적으로, 두 패턴-경계가 지정 된 컨텍스트 및 마이크로 서비스-밀접 한 관련이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="dff8c-150">But ultimately, both patterns—Bounded Context and microservice—are closely related.</span></span>

<span data-ttu-id="dff8c-151">DDD 분산된 microservices 형식의 실제 경계를 가져와서 microservices에서 활용 합니다.</span><span class="sxs-lookup"><span data-stu-id="dff8c-151">DDD benefits from microservices by getting real boundaries in the form of distributed microservices.</span></span> <span data-ttu-id="dff8c-152">하지만 microservices 간에 모델을 공유 하지 않고 같은 역할을 하는 또한 수행할 경계가 지정 된 컨텍스트에 있는 합니다.</span><span class="sxs-lookup"><span data-stu-id="dff8c-152">But ideas like not sharing the model between microservices are what you also want in a Bounded Context.</span></span>

### <a name="additional-resources"></a><span data-ttu-id="dff8c-153">추가 리소스</span><span class="sxs-lookup"><span data-stu-id="dff8c-153">Additional resources</span></span>

-   <span data-ttu-id="dff8c-154">**Chris Richardson 합니다. 패턴: 서비스 당 데이터베이스**
    [*http://microservices.io/patterns/data/database-per-service.html*](http://microservices.io/patterns/data/database-per-service.html)</span><span class="sxs-lookup"><span data-stu-id="dff8c-154">**Chris Richardson. Pattern: Database per service**
[*http://microservices.io/patterns/data/database-per-service.html*](http://microservices.io/patterns/data/database-per-service.html)</span></span>

-   <span data-ttu-id="dff8c-155">**Martin Fowler. BoundedContext**
    [*http://martinfowler.com/bliki/BoundedContext.html*](http://martinfowler.com/bliki/BoundedContext.html)</span><span class="sxs-lookup"><span data-stu-id="dff8c-155">**Martin Fowler. BoundedContext**
[*http://martinfowler.com/bliki/BoundedContext.html*](http://martinfowler.com/bliki/BoundedContext.html)</span></span>

-   <span data-ttu-id="dff8c-156">**Martin Fowler. PolyglotPersistence**
    [*http://martinfowler.com/bliki/PolyglotPersistence.html*](http://martinfowler.com/bliki/PolyglotPersistence.html)</span><span class="sxs-lookup"><span data-stu-id="dff8c-156">**Martin Fowler. PolyglotPersistence**
[*http://martinfowler.com/bliki/PolyglotPersistence.html*](http://martinfowler.com/bliki/PolyglotPersistence.html)</span></span>

-   <span data-ttu-id="dff8c-157">**Alberto Brandolini 합니다. 전략적 도메인 기반 상황에 맞는 매핑 사용 하 여 디자인**
    [*https://www.infoq.com/articles/ddd-contextmapping*](https://www.infoq.com/articles/ddd-contextmapping)</span><span class="sxs-lookup"><span data-stu-id="dff8c-157">**Alberto Brandolini. Strategic Domain Driven Design with Context Mapping**
[*https://www.infoq.com/articles/ddd-contextmapping*](https://www.infoq.com/articles/ddd-contextmapping)</span></span>


>[!div class="step-by-step"]
<span data-ttu-id="dff8c-158">[이전] (microservices-architecture.md) [다음] (논리적-대-물리적-architecture.md)</span><span class="sxs-lookup"><span data-stu-id="dff8c-158">[Previous] (microservices-architecture.md) [Next] (logical-versus-physical-architecture.md)</span></span>

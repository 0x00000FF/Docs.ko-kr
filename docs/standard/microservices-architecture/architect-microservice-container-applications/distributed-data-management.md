---
title: "문제 및 분산된 데이터 관리를 위한 솔루션"
description: "컨테이너 화 된.NET 응용 프로그램에 대 한.NET Microservices 아키텍처 | 문제 및 분산된 데이터 관리를 위한 솔루션"
keywords: "Docker, 마이크로 서비스, ASP.NET, 컨테이너"
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 05/26/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.topic: article
ms.openlocfilehash: f961475b40c74bf448cff1aeae04ae4866360e52
ms.sourcegitcommit: c2e216692ef7576a213ae16af2377cd98d1a67fa
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 10/22/2017
---
# <a name="challenges-and-solutions-for-distributed-data-management"></a><span data-ttu-id="06193-104">문제 및 분산된 데이터 관리를 위한 솔루션</span><span class="sxs-lookup"><span data-stu-id="06193-104">Challenges and solutions for distributed data management</span></span>

## <a name="challenge-1-how-to-define-the-boundaries-of-each-microservice"></a><span data-ttu-id="06193-105">챌린지 \#1: 각 마이크로 서비스의 경계를 정의 하는 방법</span><span class="sxs-lookup"><span data-stu-id="06193-105">Challenge \#1: How to define the boundaries of each microservice</span></span>

<span data-ttu-id="06193-106">모든 사용자가 발견 한 첫 번째 인증 되었을 마이크로 서비스 경계를 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="06193-106">Defining microservice boundaries is probably the first challenge anyone encounters.</span></span> <span data-ttu-id="06193-107">각 마이크로 서비스 응용 프로그램의 일부일 수 있으며 각 마이크로 서비스 이점과 있는 과제와 자치 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="06193-107">Each microservice has to be a piece of your application and each microservice should be autonomous with all the benefits and challenges that it conveys.</span></span> <span data-ttu-id="06193-108">하지만 이러한 경계를 어떻게 알아볼 수 있을까요?</span><span class="sxs-lookup"><span data-stu-id="06193-108">But how do you identify those boundaries?</span></span>

<span data-ttu-id="06193-109">첫째, 응용 프로그램의 논리 도메인 모델 및 관련된 데이터에 집중 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="06193-109">First, you need to focus on the application’s logical domain models and related data.</span></span> <span data-ttu-id="06193-110">데이터와 같은 응용 프로그램의 다양 한 상황의 분리 된 제도 식별 하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="06193-110">You must try to identify decoupled islands of data and different contexts within the same application.</span></span> <span data-ttu-id="06193-111">컨텍스트마다 다른 비즈니스 언어 (다양 한 비즈니스 용어) 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="06193-111">Each context could have a different business language (different business terms).</span></span> <span data-ttu-id="06193-112">컨텍스트를 정의 하 고 독립적으로 관리 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="06193-112">The contexts should be defined and managed independently.</span></span> <span data-ttu-id="06193-113">용어와 이러한 다양 한 컨텍스트에서 사용 되는 엔터티 수와 마찬가지로 사운드 하지만 특정 컨텍스트에서 있는 다른 컨텍스트에서 다른 용도로 하나가 지정 된 비즈니스 개념이 사용 됩니다 발견할 수 하 고 다른 이름이 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="06193-113">The terms and entities used in those different contexts might sound similar, but you might discover that in a particular context, a business concept with one is used for a different purpose in another context, and might even have a different name.</span></span> <span data-ttu-id="06193-114">예를 들어, 사용자 id 또는 멤버 자격 컨텍스트에서 사용자로 정렬 컨텍스트에서 구매자 CRM 컨텍스트에서 인 고객으로 참조할 수 등.</span><span class="sxs-lookup"><span data-stu-id="06193-114">For instance, a user can be referred as a user in the identity or membership context, as a customer in a CRM context, as a buyer in an ordering context, and so forth.</span></span>

<span data-ttu-id="06193-115">컨텍스트마다 정확 하 게 식별 하는 방법 수 각 비즈니스 마이크로 서비스 및 관련 된에 대 한 경계에 대해 다른 도메인의 여러 응용 프로그램 컨텍스트 간에 경계를 식별 하는 방법은 도메인 모델 및 데이터입니다.</span><span class="sxs-lookup"><span data-stu-id="06193-115">The way you identify boundaries between multiple application contexts with a different domain for each context is exactly how you can identify the boundaries for each business microservice and its related domain model and data.</span></span> <span data-ttu-id="06193-116">항상 이러한 microservices 간의 결합을 최소화 하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="06193-116">You always attempt to minimize the coupling between those microservices.</span></span> <span data-ttu-id="06193-117">이 가이드의 섹션에서이 식별 및 도메인 모델 디자인에 대 한 자세한 내용으로 이어집니다 [각 마이크로 서비스에 대 한 도메인 모델 경계를 식별](#identifying-domain-model-boundaries-for-each-microservice) 나중입니다.</span><span class="sxs-lookup"><span data-stu-id="06193-117">This guide goes into more detail about this identification and domain model design in the section [Identifying domain-model boundaries for each microservice](#identifying-domain-model-boundaries-for-each-microservice) later.</span></span>

## <a name="challenge-2-how-to-create-queries-that-retrieve-data-from-several-microservices"></a><span data-ttu-id="06193-118">챌린지 \#2: 여러 microservices에서 데이터를 검색 하는 쿼리를 만드는 방법</span><span class="sxs-lookup"><span data-stu-id="06193-118">Challenge \#2: How to create queries that retrieve data from several microservices</span></span>

<span data-ttu-id="06193-119">두 번째 문제는 원격 클라이언트 응용 프로그램에서 통신이 자주는 microservices를 방지 하는 동안 여러 microservices에서 데이터를 검색 하는 쿼리를 구현 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="06193-119">A second challenge is how to implement queries that retrieve data from several microservices, while avoiding chatty communication to the microservices from remote client apps.</span></span> <span data-ttu-id="06193-120">예를 바구니, 카탈로그 및 identity microservices 사용자가 소유 하는 사용자 정보를 표시 하는 모바일 앱에서 단일 화면 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="06193-120">An example could be a single screen from a mobile app that needs to show user information that is owned by the basket, catalog, and user identity microservices.</span></span> <span data-ttu-id="06193-121">또 다른 예로 여러 microservices에 있는 여러 테이블을 포함 하는 복잡 한 보고서는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="06193-121">Another example would be a complex report involving many tables located in multiple microservices.</span></span> <span data-ttu-id="06193-122">적합 한 솔루션은 한 엔터티의 복잡성에 따라 달라 집니다.</span><span class="sxs-lookup"><span data-stu-id="06193-122">The right solution depends on the complexity of the queries.</span></span> <span data-ttu-id="06193-123">하지만 어떤 경우 든, 시스템의 통신에서 효율성을 개선 하려면 정보를 집계 하는 방법을 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="06193-123">But in any case, you will need a way to aggregate information if you want to improve the efficiency in the communications of your system.</span></span> <span data-ttu-id="06193-124">가장 인기 있는 솔루션에는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="06193-124">The most popular solutions are the following.</span></span>

<span data-ttu-id="06193-125">**API 게이트웨이**합니다.</span><span class="sxs-lookup"><span data-stu-id="06193-125">**API Gateway**.</span></span> <span data-ttu-id="06193-126">서로 다른 데이터베이스를 소유 하는 여러 microservices에서 단순 데이터 집계를 위한 API 게이트웨이 라고 하는 집계 마이크로 서비스는 방법이 권장된 합니다.</span><span class="sxs-lookup"><span data-stu-id="06193-126">For simple data aggregation from multiple microservices that own different databases, the recommended approach is an aggregation microservice referred to as an API Gateway.</span></span> <span data-ttu-id="06193-127">그러나 시스템 좁게 지점이 될 수 있습니다 및 마이크로 서비스 자치의 원칙을 위반 하 게 수 때문에이 패턴을 구현 하는 방법에 대 한 주의를 기울여야 할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="06193-127">However, you need to be careful about implementing this pattern, because it can be a choke point in your system, and it can violate the principle of microservice autonomy.</span></span> <span data-ttu-id="06193-128">이러한 가능성을 줄이려면 여러 정교한 API 게이트웨이 "조각 이었습니다" 세로 또는 시스템의 비즈니스 영역에 하나의 집중 각 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="06193-128">To mitigate this possibility, you can have multiple fined-grained API Gateways each one focusing on a vertical “slice” or business area of the system.</span></span> <span data-ttu-id="06193-129">API 게이트웨이 패턴 사용의 섹션에서 자세히 설명 되어 나중에 프로그램 API 게이트웨이 합니다.</span><span class="sxs-lookup"><span data-stu-id="06193-129">The API Gateway pattern is explained in more detail in the section in the Using an API Gateway later.</span></span>

<span data-ttu-id="06193-130">**쿼리/reads 테이블 CQRS**합니다.</span><span class="sxs-lookup"><span data-stu-id="06193-130">**CQRS with query/reads tables**.</span></span> <span data-ttu-id="06193-131">여러 microservices에서 데이터를 집계 하기 위한 다른 방법은 [구체화 된 뷰 패턴](https://docs.microsoft.com/azure/architecture/patterns/materialized-view)합니다.</span><span class="sxs-lookup"><span data-stu-id="06193-131">Another solution for aggregating data from multiple microservices is the [Materialized View pattern](https://docs.microsoft.com/azure/architecture/patterns/materialized-view).</span></span> <span data-ttu-id="06193-132">이 방법에서는 생성 하면 미리 (실제 쿼리의 발생 전에 비 정규화 된 데이터 준비), 여러 microservices가 소유 하는 데이터와 읽기 전용 테이블입니다.</span><span class="sxs-lookup"><span data-stu-id="06193-132">In this approach, you generate, in advance (prepare denormalized data before the actual queries happen), a read-only table with the data that is owned by multiple microservices.</span></span> <span data-ttu-id="06193-133">테이블에는 형식으로 클라이언트 응용 프로그램의 요구에 부합 합니다.</span><span class="sxs-lookup"><span data-stu-id="06193-133">The table has a format suited to the client app’s needs.</span></span>

<span data-ttu-id="06193-134">모바일 앱에 대 한 화면와 같은 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="06193-134">Consider something like the screen for a mobile app.</span></span> <span data-ttu-id="06193-135">단일 데이터베이스를 설정한 경우 있습니다 수 모아 여러 테이블을 포함 하는 복잡 한 조인을 수행 하는 SQL 쿼리를 사용 하 여 해당 화면에 대 한 데이터입니다.</span><span class="sxs-lookup"><span data-stu-id="06193-135">If you have a single database, you might pull together the data for that screen using a SQL query that performs a complex join involving multiple tables.</span></span> <span data-ttu-id="06193-136">그러나 여러 데이터베이스 있고 각 데이터베이스는 다른 마이크로 서비스를 소유한 경우 해당 데이터베이스를 쿼리할 수 없으며 SQL 조인을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="06193-136">However, when you have multiple databases, and each database is owned by a different microservice, you cannot query those databases and create a SQL join.</span></span> <span data-ttu-id="06193-137">복잡 한 쿼리는 것이 어려울 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="06193-137">Your complex query becomes a challenge.</span></span> <span data-ttu-id="06193-138">CQRS 접근 방식을 사용 하는 요구 사항을 해결할 수 있습니다-쿼리에 대해서만 사용 되는 다른 데이터베이스에 정규화 되지 않은 테이블을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="06193-138">You can address the requirement using a CQRS approach—you create a denormalized table in a different database that is used just for queries.</span></span> <span data-ttu-id="06193-139">특히 복잡 한 쿼리를 응용 프로그램의 화면 및 쿼리 테이블의 열에 필요한 필드 간의 한 일 관계에 필요한 데이터에 대 한 테이블을 디자인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="06193-139">The table can be designed specifically for the data you need for the complex query, with a one-to-one relationship between fields needed by your application’s screen and the columns in the query table.</span></span> <span data-ttu-id="06193-140">보고 목적으로 사용 될 수도 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="06193-140">It could also serve for reporting purposes.</span></span>

<span data-ttu-id="06193-141">이 방법은 뿐만 아니라 (쿼리 및 microservices 간에 조인 하는 방법); 원래 문제를 해결 쿼리 테이블에는 응용 프로그램에서 필요로 하는 데이터에 이미 있기 때문에 훨씬 복잡 한 조인와 비교 했을 때 성능이 향상 됩니다.</span><span class="sxs-lookup"><span data-stu-id="06193-141">This approach not only solves the original problem (how to query and join across microservices); it also improves performance considerably when compared with a complex join, because you already have the data that the application needs in the query table.</span></span> <span data-ttu-id="06193-142">물론, 명령 및 쿼리 책임 분리 CQRS ()를 사용 하 여 쿼리/reads 테이블이 포함 된 추가 개발 작업을 의미 하 고 결과적 일관성을 수용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="06193-142">Of course, using Command and Query Responsibility Segregation (CQRS) with query/reads tables means additional development work, and you will need to embrace eventual consistency.</span></span> <span data-ttu-id="06193-143">그럼에도 불구 하 고 성능 및 확장성에 대 한 요구 사항을 [공동 작업 시나리오](http://udidahan.com/2011/10/02/why-you-should-be-using-cqrs-almost-everywhere/) (또는 관점에 따라 경쟁 시나리오)가 있는 여러 데이터베이스가 있는 CQRS를 적용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="06193-143">Nonetheless, requirements on performance and high scalability in [collaborative scenarios](http://udidahan.com/2011/10/02/why-you-should-be-using-cqrs-almost-everywhere/) (or competitive scenarios, depending on the point of view) is where you should apply CQRS with multiple databases.</span></span>

<span data-ttu-id="06193-144">**"콜드" 데이터베이스의에서 데이터를 중앙**합니다.</span><span class="sxs-lookup"><span data-stu-id="06193-144">**“Cold data” in central databases**.</span></span> <span data-ttu-id="06193-145">복잡 한 보고서 및 실시간 데이터는 필요 하지 않을 수도 있는 쿼리를 실행 하는 것에 대 한 일반적인 방법은 내보낼 프로그램 "핫 데이터" (트랜잭션 데이터는 microservices에서) 보고에 사용 되는 대형 데이터베이스에 "콜드 데이터"로 합니다.</span><span class="sxs-lookup"><span data-stu-id="06193-145">For complex reports and queries that might not require real-time data, a common approach is to export your “hot data” (transactional data from the microservices) as “cold data” into large databases that are used only for reporting.</span></span> <span data-ttu-id="06193-146">해당 중앙 데이터베이스 시스템 빅 데이터 기반 시스템에서 Hadoop, Azure SQL 데이터 웨어하우스 또는 심지어 단일 SQL 데이터베이스 (크기 문제가 되지 것입니다) 하는 경우 보고서에 대 한 사용에 따라 같은 데이터 웨어하우스 같이 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="06193-146">That central database system can be a Big Data-based system, like Hadoop, a data warehouse like one based on Azure SQL Data Warehouse, or even a single SQL database used just for reports (if size will not be an issue).</span></span>

<span data-ttu-id="06193-147">쿼리 및 실시간 데이터는 필요 하지 않는 보고서에 대해서만이 중앙 집중식된 데이터베이스를 사용할 수는 염두에서에 둬야 합니다.</span><span class="sxs-lookup"><span data-stu-id="06193-147">Keep in mind that this centralized database would be used only for queries and reports that do not need real-time data.</span></span> <span data-ttu-id="06193-148">원래 업데이트 및 사실의 원본으로 트랜잭션을 microservices 데이터에서 되어야 할입니다.</span><span class="sxs-lookup"><span data-stu-id="06193-148">The original updates and transactions, as your source of truth, have to be in your microservices data.</span></span> <span data-ttu-id="06193-149">데이터를 동기화 하는 방법은 (다음 섹션에 포함 됨) 하는 이벤트 기반 통신을 사용 하거나 다른 데이터베이스 인프라 가져오기/내보내기 도구를 사용 하 여 것입니다.</span><span class="sxs-lookup"><span data-stu-id="06193-149">The way you would synchronize data would be either by using event-driven communication (covered in the next sections) or by using other database infrastructure import/export tools.</span></span> <span data-ttu-id="06193-150">이벤트 기반 통신을 사용 하는 경우 해당 통합 프로세스 CQRS 쿼리 테이블에 대 한 앞에서 설명한 대로 데이터를 전파 하는 방법에 유사 합니다.</span><span class="sxs-lookup"><span data-stu-id="06193-150">If you use event-driven communication, that integration process would be similar to the way you propagate data as described earlier for CQRS query tables.</span></span>

<span data-ttu-id="06193-151">그러나 응용 프로그램 디자인에서 여러 microservices 복잡 한 쿼리에 대 한 정보를 지속적으로 집계 있을 경우 잘못 된 디자인의 증상 수 있습니다-는 마이크로 서비스를 다른 microservices에서 최대한으로 격리 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="06193-151">However, if your application design involves constantly aggregating information from multiple microservices for complex queries, it might be a symptom of a bad design—a microservice should be as isolated as possible from other microservices.</span></span> <span data-ttu-id="06193-152">(보고서/분석 항상 콜드 데이터 중앙 데이터베이스를 사용 해야 하는 제외 합니다.) 이 문제가 자주 발생 microservices 병합 하는 이유를 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="06193-152">(This excludes reports/analytics that always should use cold-data central databases.) Having this problem often might be a reason to merge microservices.</span></span> <span data-ttu-id="06193-153">진화 자율성 및 강력한 종속성, 응집력, 데이터 집계와 각 마이크로 서비스의 배포 균형을 유지 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="06193-153">You need to balance the autonomy of evolution and deployment of each microservice with strong dependencies, cohesion, and data aggregation.</span></span>

## <a name="challenge-3-how-to-achieve-consistency-across-multiple-microservices"></a><span data-ttu-id="06193-154">챌린지 \#3: 여러 microservices 간에 일관성을 위해 하는 방법</span><span class="sxs-lookup"><span data-stu-id="06193-154">Challenge \#3: How to achieve consistency across multiple microservices</span></span>

<span data-ttu-id="06193-155">앞서 설명한 것 처럼 각 마이크로 서비스를 소유한 데이터는 해당 마이크로 서비스에 전용 포트 이며 해당 마이크로 서비스 API를 사용 하 여 액세스할 수만 있습니다.</span><span class="sxs-lookup"><span data-stu-id="06193-155">As stated previously, the data owned by each microservice is private to that microservice and can only be accessed using its microservice API.</span></span> <span data-ttu-id="06193-156">따라서 표시 되는 것이 어려울은 여러 microservices 간에 일관성을 유지 하면서 종단 간 비즈니스 프로세스를 구현 하는 방법.</span><span class="sxs-lookup"><span data-stu-id="06193-156">Therefore, a challenge presented is how to implement end-to-end business processes while keeping consistency across multiple microservices.</span></span>

<span data-ttu-id="06193-157">이 문제를 분석 하려면 살펴보겠습니다의 한 예는 [eShopOnContainers 응용 프로그램 참조](http://aka.ms/eshoponcontainers)합니다.</span><span class="sxs-lookup"><span data-stu-id="06193-157">To analyze this problem, let’s look at an example from the [eShopOnContainers reference application](http://aka.ms/eshoponcontainers).</span></span> <span data-ttu-id="06193-158">카탈로그 마이크로 서비스 스톡 수준별로 포함 하 여 모든 제품에 대 한 정보를 유지 관리 합니다.</span><span class="sxs-lookup"><span data-stu-id="06193-158">The Catalog microservice maintains information about all the products, including their stock level.</span></span> <span data-ttu-id="06193-159">Ordering 마이크로 서비스 주문을 관리 하 고 새 주문을 사용 가능한 카탈로그 제품 재고를 초과 하지 않는 확인 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="06193-159">The Ordering microservice manages orders and must verify that a new order does not exceed the available catalog product stock.</span></span> <span data-ttu-id="06193-160">또는 시나리오 미처리 제품을 처리 하는 논리를 수행할 수 있습니다. 이 응용 프로그램의 가상 모놀리식 버전에서는 정렬 하위 시스템 수을 사용 하 여 트랜잭션의 ACID 트랜잭션의 재고를 확인 순서 Orders 테이블에서 만들고 Products 테이블의 재고를 업데이트 합니다.</span><span class="sxs-lookup"><span data-stu-id="06193-160">(Or the scenario might involve logic that handles backordered products.) In a hypothetical monolithic version of this application, the ordering subsystem could simply use an ACID transaction to check the available stock, create the order in the Orders table, and update the available stock in the Products table.</span></span>

<span data-ttu-id="06193-161">그러나 microservices 기반 응용 프로그램에서는 주문 및 제품 테이블의 각 microservices에 의해 소유 됩니다.</span><span class="sxs-lookup"><span data-stu-id="06193-161">However, in a microservices- based application, the Order and Product tables are owned by their respective microservices.</span></span> <span data-ttu-id="06193-162">적이 없는 마이크로 서비스는 그림 4-9와 같이 데이터베이스의 자체 트랜잭션을 또는 쿼리를 다른 마이크로 서비스를 소유한을 포함 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="06193-162">No microservice should ever include databases owned by another microservice in its own transactions or queries, as shown in Figure 4-9.</span></span>

![](./media/image9.PNG)

<span data-ttu-id="06193-163">**그림 4-9**합니다.</span><span class="sxs-lookup"><span data-stu-id="06193-163">**Figure 4-9**.</span></span> <span data-ttu-id="06193-164">마이크로 서비스는 다른 마이크로 서비스의 테이블에 직접 액세스할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="06193-164">A microservice cannot directly access a table in another microservice</span></span>

<span data-ttu-id="06193-165">Products 테이블 카탈로그 마이크로 서비스에서 소유 있으므로 Ordering 마이크로 서비스 Products 테이블을 직접 업데이트 하지 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="06193-165">The Ordering microservice should not update the Products table directly, because the Products table is owned by the Catalog microservice.</span></span> <span data-ttu-id="06193-166">카탈로그 마이크로 서비스를 업데이트 하려면 Ordering 마이크로 서비스 통합 이벤트 (메시지 및 이벤트 기반 통신)와 같은 비동기 통신을만 사용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="06193-166">To make an update to the Catalog microservice, the Ordering microservice should only ever use asynchronous communication such as integration events (message and event-based communication).</span></span> <span data-ttu-id="06193-167">이것은 방법을 [eShopOnContainers](http://aka.ms/eshoponcontainers) 참조 응용 프로그램이이 유형의 업데이트를 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="06193-167">This is how the [eShopOnContainers](http://aka.ms/eshoponcontainers) reference application performs this type of update.</span></span>

<span data-ttu-id="06193-168">에 명시 된 대로 [CAP 정리](https://en.wikipedia.org/wiki/CAP_theorem), 가용성 및 ACID 강력한 일관성 중 하나를 선택 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="06193-168">As stated by the [CAP theorem](https://en.wikipedia.org/wiki/CAP_theorem), you need to choose between availability and ACID strong consistency.</span></span> <span data-ttu-id="06193-169">마이크로 서비스 기반 시나리오의 대부분에 강력한 일관성 달리 높은 확장성 및 가용성 요구합니다.</span><span class="sxs-lookup"><span data-stu-id="06193-169">Most microservice-based scenarios demand availability and high scalability as opposed to strong consistency.</span></span> <span data-ttu-id="06193-170">중요 응용 프로그램 위로 유지 되 고 실행 중 이며 개발자는 작업 약하거나 최종 일관성을 위한 기술을 사용 하 여 강력한 일관성 하지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="06193-170">Mission-critical applications must remain up and running, and developers can work around strong consistency by using techniques for working with weak or eventual consistency.</span></span> <span data-ttu-id="06193-171">이것이 대부분 마이크로 서비스 기반 아키텍처에서 사용 하는 접근 방식입니다.</span><span class="sxs-lookup"><span data-stu-id="06193-171">This is the approach taken by most microservice-based architectures.</span></span>

<span data-ttu-id="06193-172">또한 ACID 스타일 또는 2 단계 커밋 트랜잭션이 없는 microservices 원칙; 대상으로 한 대부분의 NoSQL 데이터베이스 (예: Azure Cosmos DB, MongoDB, 등)는 2 단계 커밋 트랜잭션을 지원 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="06193-172">Moreover, ACID-style or two-phase commit transactions are not just against microservices principles; most NoSQL databases (like Azure Cosmos DB, MongoDB, etc.) do not support two-phase commit transactions.</span></span> <span data-ttu-id="06193-173">그러나 데이터는 그대로 유지 서비스 및 데이터베이스 간 일관성 반드시 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="06193-173">However, maintaining data consistency across services and databases is essential.</span></span> <span data-ttu-id="06193-174">이러한 문제는 특정 데이터 중복을 해야 할 때 여러 microservices 변경 내용을 전파 하는 방법에 대 한 질문도 관련이-제품의 이름 또는 설명을 카탈로그 마이크로 서비스 및 바구니 해야 경우 예를 들어 마이크로 서비스입니다.</span><span class="sxs-lookup"><span data-stu-id="06193-174">This challenge is also related to the question of how to propagate changes across multiple microservices when certain data needs to be redundant—for example, when you need to have the product’s name or description in the Catalog microservice and the Basket microservice.</span></span>

<span data-ttu-id="06193-175">이 문제에 대 한 적합 한 솔루션 간의 이벤트 기반 통신, 게시 및 구독 시스템을 통해 명시 microservices 결과적 일관성을 사용 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="06193-175">A good solution for this problem is to use eventual consistency between microservices articulated through event-driven communication and a publish-and-subscribe system.</span></span> <span data-ttu-id="06193-176">섹션에서 다루는 이러한 항목은 [이벤트 구동 비동기 통신](#async_event_driven_communication) 이 가이드의 뒷부분에 나오는 합니다.</span><span class="sxs-lookup"><span data-stu-id="06193-176">These topics are covered in the section [Asynchronous event-driven communication](#async_event_driven_communication) later in this guide.</span></span>

## <a name="challenge-4-how-to-design-communication-across-microservice-boundaries"></a><span data-ttu-id="06193-177">챌린지 \#4: 마이크로 서비스 경계 간에 통신을 디자인 하는 방법</span><span class="sxs-lookup"><span data-stu-id="06193-177">Challenge \#4: How to design communication across microservice boundaries</span></span>

<span data-ttu-id="06193-178">마이크로 서비스 간에 통신 경계는 실제 하기가 어렵습니다.</span><span class="sxs-lookup"><span data-stu-id="06193-178">Communicating across microservice boundaries is a real challenge.</span></span> <span data-ttu-id="06193-179">이 컨텍스트에서 통신을 참조 하지 않습니다 (HTTP 및 나머지 부분에서는 AMQP, 메시징 및 등)를 사용 해야 하면 프로토콜입니다.</span><span class="sxs-lookup"><span data-stu-id="06193-179">In this context, communication does not refer to what protocol you should use (HTTP and REST, AMQP, messaging, and so on).</span></span> <span data-ttu-id="06193-180">대신, 어떤 통신 스타일을 사용 해야 하며 특히 결합 된 방식을 프로그램 microservices 해야 해결 합니다.</span><span class="sxs-lookup"><span data-stu-id="06193-180">Instead, it addresses what communication style you should use, and especially how coupled your microservices should be.</span></span> <span data-ttu-id="06193-181">결합 수준에 따라 오류가 발생할 경우 시스템에서 해당 오류의 영향이 달라 집니다 크게.</span><span class="sxs-lookup"><span data-stu-id="06193-181">Depending on the level of coupling, when failure occurs, the impact of that failure on your system will vary significantly.</span></span>

<span data-ttu-id="06193-182">microservices 기반 응용 프로그램을 이동 하는 여러 아티팩트 및 여러 서버 또는 호스트에 걸쳐 분산된 된 서비스와 같은 분산된 시스템에서 구성 요소 결국 실패 합니다.</span><span class="sxs-lookup"><span data-stu-id="06193-182">In a distributed system like a microservices-based application, with so many artifacts moving around and with distributed services across many servers or hosts, components will eventually fail.</span></span> <span data-ttu-id="06193-183">부분 실패 및 이상이 중단 고려 위험 일반적인 이러한 유형의 분산된 시스템 간에 프로그램 microservices와의 통신을 디자인 해야 하므로 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="06193-183">Partial failure and even larger outages will occur, so you need to design your microservices and the communication across them taking into account the risks common in this type of distributed system.</span></span>

<span data-ttu-id="06193-184">HTTP (REST)를 구현 하는 인기 있는 방법입니다-그 단순 함으로 인해 microservices를 기반으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="06193-184">A popular approach is to implement HTTP (REST)- based microservices, due to their simplicity.</span></span> <span data-ttu-id="06193-185">HTTP 기반 접근 방법은; 완벽 하 게 허용 됩니다. 이 경우 문제는 사용 하는 방법을 관련이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="06193-185">An HTTP-based approach is perfectly acceptable; the issue here is related to how you use it.</span></span> <span data-ttu-id="06193-186">API 게이트웨이 또는 클라이언트 응용 프로그램에서 프로그램 microservices와 상호 작용에 HTTP 요청 및 응답을 사용 하는 문제가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="06193-186">If you use HTTP requests and responses just to interact with your microservices from client applications or from API Gateways, that is fine.</span></span> <span data-ttu-id="06193-187">하지만 microservices에서 HTTP에 대 한 동기 호출은 긴 체인을 만들 경우 해당 경계에 걸쳐 통신 하는 microservices 개체 모놀리식 응용 프로그램에서는 마치 처럼 응용 프로그램이 결국 실행 문제를 합니다.</span><span class="sxs-lookup"><span data-stu-id="06193-187">But if you create long chains of synchronous HTTP calls across microservices, communicating across their boundaries as if the microservices were objects in a monolithic application, your application will eventually run into problems.</span></span>

<span data-ttu-id="06193-188">예를 들어, 클라이언트 응용 프로그램가 Ordering 마이크로 서비스와 같은 마이크로 개별 서비스에 대 한 HTTP API 호출 한다고 가정해 보세요.</span><span class="sxs-lookup"><span data-stu-id="06193-188">For instance, imagine that your client application makes an HTTP API call to an individual microservice like the Ordering microservice.</span></span> <span data-ttu-id="06193-189">Ordering 마이크로 서비스 호출 하 여 추가 microservices 동일한 요청/응답 내에서 HTTP를 사용 하 여 순환, HTTP 호출 체인을 만드는 합니다.</span><span class="sxs-lookup"><span data-stu-id="06193-189">If the Ordering microservice in turn calls additional microservices using HTTP within the same request/response cycle, you are creating a chain of HTTP calls.</span></span> <span data-ttu-id="06193-190">수 나요 합리적인 처음 합니다.</span><span class="sxs-lookup"><span data-stu-id="06193-190">It might sound reasonable initially.</span></span> <span data-ttu-id="06193-191">그러나이 경로 중지 될 때 고려해 야 할 중요 한 사항이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="06193-191">However, there are important points to consider when going down this path:</span></span>

-   <span data-ttu-id="06193-192">차단 및 낮은 성능입니다.</span><span class="sxs-lookup"><span data-stu-id="06193-192">Blocking and low performance.</span></span> <span data-ttu-id="06193-193">동기 HTTP 특성상 내부 HTTP 호출을 모두 완료 될 때까지 답변해를 원래 요청이 드립니다.</span><span class="sxs-lookup"><span data-stu-id="06193-193">Due to the synchronous nature of HTTP, the original request will not get a response until all the internal HTTP calls are finished.</span></span> <span data-ttu-id="06193-194">이러한 호출 수가 크게 향상 동시는 마이크로 서비스를 호출 하는 중간 HTTP 중 하나에 차단 된 경우 한다고 가정 합니다.</span><span class="sxs-lookup"><span data-stu-id="06193-194">Imagine if the number of these calls increases significantly and at the same time one of the intermediate HTTP calls to a microservice is blocked.</span></span> <span data-ttu-id="06193-195">결과는 성능이 저하 되어 및 추가 HTTP 요청 증가으로 전반적인 확장성 기하급수적 영향입니다.</span><span class="sxs-lookup"><span data-stu-id="06193-195">The result is that performance is impacted, and the overall scalability will be exponentially affected as additional HTTP requests increase.</span></span>

-   <span data-ttu-id="06193-196">Microservices HTTP 연결입니다.</span><span class="sxs-lookup"><span data-stu-id="06193-196">Coupling microservices with HTTP.</span></span> <span data-ttu-id="06193-197">비즈니스 microservices 다른 비즈니스 microservices와 연결 해서는 안됩니다.</span><span class="sxs-lookup"><span data-stu-id="06193-197">Business microservices should not be coupled with other business microservices.</span></span> <span data-ttu-id="06193-198">이상적으로 이러한 하지 ""에 대해 알아야 다른 microservices 존재 합니다.</span><span class="sxs-lookup"><span data-stu-id="06193-198">Ideally, they should not “know” about the existence of other microservices.</span></span> <span data-ttu-id="06193-199">응용 프로그램 예제와 같이 microservices 결합을 사용 하는 경우 마이크로 서비스 당 자치를 달성 됩니다 하지 거의 불가능 합니다.</span><span class="sxs-lookup"><span data-stu-id="06193-199">If your application relies on coupling microservices as in the example, achieving autonomy per microservice will be almost impossible.</span></span>

-   <span data-ttu-id="06193-200">모든 하나의 마이크로 서비스 오류가 발생 했습니다.</span><span class="sxs-lookup"><span data-stu-id="06193-200">Failure in any one microservice.</span></span> <span data-ttu-id="06193-201">microservices 중 하나라도 (및 실패 결국 합니다) microservices의 전체 체인 때 HTTP 호출에 의해 연결 된 microservices의 체인을 구현 하는 경우 실패 합니다.</span><span class="sxs-lookup"><span data-stu-id="06193-201">If you implemented a chain of microservices linked by HTTP calls, when any of the microservices fails (and eventually they will fail) the whole chain of microservices will fail.</span></span> <span data-ttu-id="06193-202">마이크로 서비스 기반 시스템 부분 실패 하는 동안 가능한 뿐만 아니라 작업을 계속 하려면 설계 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="06193-202">A microservice-based system should be designed to continue to work as well as possible during partial failures.</span></span> <span data-ttu-id="06193-203">지 수 백오프 또는 회로 차단기 메커니즘에 다시 시도 횟수를 사용 하는 클라이언트 논리를 구현 하는 경우에 더 복잡 한 HTTP 호출 체인은 HTTP 기반 오류 전략을 구현 하는 것 보다 복잡 한입니다.</span><span class="sxs-lookup"><span data-stu-id="06193-203">Even if you implement client logic that uses retries with exponential backoff or circuit breaker mechanisms, the more complex the HTTP call chains are, the more complex it is implement a failure strategy based on HTTP.</span></span>

<span data-ttu-id="06193-204">사실, 내부 microservices에 설명 된 대로 체인의 HTTP 요청을 만들어와 통신 하는 경우 주장할 intraprocess 통신 메커니즘 대신 프로세스 간 HTTP 기반 하나만 제외 하 고 모놀리식 응용 프로그램이 있다고 합니다.</span><span class="sxs-lookup"><span data-stu-id="06193-204">In fact, if your internal microservices are communicating by creating chains of HTTP requests as described, it could be argued that you have a monolithic application, but one based on HTTP between processes instead of intraprocess communication mechanisms.</span></span>

<span data-ttu-id="06193-205">따라서 자율성 마이크로 서비스를 강제 적용 하 고 더 나은 복원 력 있는 microservices에서 체인의 요청/응답 통신의 사용을 최소화 해야 있습니다.</span><span class="sxs-lookup"><span data-stu-id="06193-205">Therefore, in order to enforce microservice autonomy and have better resiliency, you should minimize the use of chains of request/response communication across microservices.</span></span> <span data-ttu-id="06193-206">비동기 메시지 및 이벤트 기반 통신을 사용 하 여 나 HTTP 폴링 원래 HTTP 요청/응답 주기와 별도로 사용 하 여 마이크로 서비스 간 통신에 대 한 비동기만 상호 작용을 사용 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="06193-206">It is recommended that you use only asynchronous interaction for inter-microservice communication, either by using asynchronous message- and event-based communication, or by using HTTP polling independently of the original HTTP request/response cycle.</span></span>

<span data-ttu-id="06193-207">비동기 통신을 사용 하는 섹션에이 가이드의 뒷부분에 나오는 추가 세부 정보와 함께 설명 [비동기 마이크로 서비스 마이크로 서비스의 자치 성을 적용](#asynchronous-microservice-integration-enforce-microservices-autonomy) 및 [비동기 메시지 기반 통신](#asynchronous-message-based-communication)합니다.</span><span class="sxs-lookup"><span data-stu-id="06193-207">The use of asynchronous communication is explained with additional details later in this guide in the sections [Asynchronous microservice integration enforces microservice’s autonomy](#asynchronous-microservice-integration-enforce-microservices-autonomy) and [Asynchronous message-based communication](#asynchronous-message-based-communication).</span></span>

## <a name="additional-resources"></a><span data-ttu-id="06193-208">추가 리소스</span><span class="sxs-lookup"><span data-stu-id="06193-208">Additional resources</span></span>

-   <span data-ttu-id="06193-209">**단면 정리**
    [*https://en.wikipedia.org/wiki/CAP\_정리*](https://en.wikipedia.org/wiki/CAP_theorem)</span><span class="sxs-lookup"><span data-stu-id="06193-209">**CAP theorem**
[*https://en.wikipedia.org/wiki/CAP\_theorem*](https://en.wikipedia.org/wiki/CAP_theorem)</span></span>

-   <span data-ttu-id="06193-210">**결과적 일관성**
    [*https://en.wikipedia.org/wiki/Eventual\_일관성*](https://en.wikipedia.org/wiki/Eventual_consistency)</span><span class="sxs-lookup"><span data-stu-id="06193-210">**Eventual consistency**
[*https://en.wikipedia.org/wiki/Eventual\_consistency*](https://en.wikipedia.org/wiki/Eventual_consistency)</span></span>

-   <span data-ttu-id="06193-211">**데이터 일관성 입문**
    [*https://msdn.microsoft.com/library/dn589800.aspx*](https://msdn.microsoft.com/library/dn589800.aspx)</span><span class="sxs-lookup"><span data-stu-id="06193-211">**Data Consistency Primer**
[*https://msdn.microsoft.com/library/dn589800.aspx*](https://msdn.microsoft.com/library/dn589800.aspx)</span></span>

-   <span data-ttu-id="06193-212">**Martin Fowler. CQRS (명령 및 쿼리 책임 분리)**
    [*http://martinfowler.com/bliki/CQRS.html*](http://martinfowler.com/bliki/CQRS.html)</span><span class="sxs-lookup"><span data-stu-id="06193-212">**Martin Fowler. CQRS (Command and Query Responsibility Segregation)**
[*http://martinfowler.com/bliki/CQRS.html*](http://martinfowler.com/bliki/CQRS.html)</span></span>

-   <span data-ttu-id="06193-213">**뷰를 구체화**
    [*https://docs.microsoft.com/azure/architecture/patterns/materialized-view*](https://docs.microsoft.com/azure/architecture/patterns/materialized-view)</span><span class="sxs-lookup"><span data-stu-id="06193-213">**Materialized View**
[*https://docs.microsoft.com/azure/architecture/patterns/materialized-view*](https://docs.microsoft.com/azure/architecture/patterns/materialized-view)</span></span>

-   <span data-ttu-id="06193-214">**Charles 행입니다. ACID vs입니다. 기준: 데이터베이스 트랜잭션 처리의 Shifting pH**
    [*http://www.dataversity.net/acid-vs-base-the-shifting-ph-of-database-transaction-processing/*](http://www.dataversity.net/acid-vs-base-the-shifting-ph-of-database-transaction-processing/)</span><span class="sxs-lookup"><span data-stu-id="06193-214">**Charles Row. ACID vs. BASE: The Shifting pH of Database Transaction Processing**
[*http://www.dataversity.net/acid-vs-base-the-shifting-ph-of-database-transaction-processing/*](http://www.dataversity.net/acid-vs-base-the-shifting-ph-of-database-transaction-processing/)</span></span>

-   <span data-ttu-id="06193-215">**트랜잭션을 보정**
    [*https://docs.microsoft.com/azure/architecture/patterns/compensating-transaction*](https://docs.microsoft.com/azure/architecture/patterns/compensating-transaction)</span><span class="sxs-lookup"><span data-stu-id="06193-215">**Compensating Transaction**
[*https://docs.microsoft.com/azure/architecture/patterns/compensating-transaction*](https://docs.microsoft.com/azure/architecture/patterns/compensating-transaction)</span></span>

-   <span data-ttu-id="06193-216">**Udi Dahan 합니다. 서비스 지향 컴퍼지션**
    [*http://udidahan.com/2014/07/30/service-oriented-composition-with-video/*](http://udidahan.com/2014/07/30/service-oriented-composition-with-video/)</span><span class="sxs-lookup"><span data-stu-id="06193-216">**Udi Dahan. Service Oriented Composition**
[*http://udidahan.com/2014/07/30/service-oriented-composition-with-video/*](http://udidahan.com/2014/07/30/service-oriented-composition-with-video/)</span></span>


>[!div class="step-by-step"]
<span data-ttu-id="06193-217">[이전] (논리적-대-물리적-architecture.md) [다음] (식별-마이크로 서비스-도메인-모델-boundaries.md)</span><span class="sxs-lookup"><span data-stu-id="06193-217">[Previous] (logical-versus-physical-architecture.md) [Next] (identify-microservice-domain-model-boundaries.md)</span></span>

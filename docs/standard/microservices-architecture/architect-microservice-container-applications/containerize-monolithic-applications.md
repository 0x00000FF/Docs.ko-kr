---
title: "Containerizing 모놀리식 응용 프로그램"
description: "컨테이너 화 된.NET 응용 프로그램에 대 한.NET Microservices 아키텍처 | Containerizing 모놀리식 응용 프로그램"
keywords: "Docker, 마이크로 서비스, ASP.NET, 컨테이너"
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 05/26/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.topic: article
ms.openlocfilehash: 11e2c24403b9b61584e424696c844e00e5d34b03
ms.sourcegitcommit: 4f3fef493080a43e70e951223894768d36ce430a
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 11/21/2017
---
# <a name="containerizing-monolithic-applications"></a><span data-ttu-id="97b0b-104">Containerizing 모놀리식 응용 프로그램</span><span class="sxs-lookup"><span data-stu-id="97b0b-104">Containerizing monolithic applications</span></span>

<span data-ttu-id="97b0b-105">단일, monolithically 배포 된 웹 응용 프로그램 또는 서비스를 빌드하고 컨테이너로 배포 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="97b0b-105">You might want to build a single, monolithically deployed web application or service and deploy it as a container.</span></span> <span data-ttu-id="97b0b-106">응용 프로그램 자체는 내부적으로 모놀리식 수 있지만 여러 라이브러리, 구성 요소, 또는 (응용 프로그램 계층, 도메인 계층, 데이터 액세스 계층 등)에 계층 구조입니다.</span><span class="sxs-lookup"><span data-stu-id="97b0b-106">The application itself might not be internally monolithic, but structured as several libraries, components, or even layers (application layer, domain layer, data-access layer, etc.).</span></span> <span data-ttu-id="97b0b-107">그러나 외부적으로는 단일 컨테이너-단일 프로세스는 단일 웹 응용 프로그램 또는 단일 서비스입니다.</span><span class="sxs-lookup"><span data-stu-id="97b0b-107">Externally, however, it is a single container—a single process, a single web application, or a single service.</span></span>

<span data-ttu-id="97b0b-108">이 모델을 관리 하려면 응용 프로그램을 나타내는 단일 컨테이너를 배포 합니다.</span><span class="sxs-lookup"><span data-stu-id="97b0b-108">To manage this model, you deploy a single container to represent the application.</span></span> <span data-ttu-id="97b0b-109">수직, 부하 분산 장치 앞에 복사본을 여러 개 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="97b0b-109">To scale up, you just add more copies with a load balancer in front.</span></span> <span data-ttu-id="97b0b-110">간단 하 게 단일 컨테이너 또는 VM에 단일 배포를 관리에서 제공 됩니다.</span><span class="sxs-lookup"><span data-stu-id="97b0b-110">The simplicity comes from managing a single deployment in a single container or VM.</span></span>

![](./media/image1.png)

<span data-ttu-id="97b0b-111">**그림 4-1**합니다.</span><span class="sxs-lookup"><span data-stu-id="97b0b-111">**Figure 4-1**.</span></span> <span data-ttu-id="97b0b-112">예제는 컨테이너 화 된 모놀리식 응용 프로그램의 아키텍처</span><span class="sxs-lookup"><span data-stu-id="97b0b-112">Example of the architecture of a containerized monolithic application</span></span>

<span data-ttu-id="97b0b-113">그림 4-1을 보여 주는 것 처럼 각 컨테이너에 여러 구성 요소, 라이브러리 또는 내부 레이어를 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="97b0b-113">You can include multiple components, libraries, or internal layers in each container, as illustrated in Figure 4-1.</span></span> <span data-ttu-id="97b0b-114">하지만이 모놀리식 패턴 "컨테이너 한 작업을 수행 하며 하나의 프로세스에 는", 수 있지만 컨테이너 원칙 충돌할 수 있습니다 일부 경우에 대 한 확인 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="97b0b-114">However, this monolithic pattern might conflict with the container principle “a container does one thing, and does it in one process”, but might be ok for some cases.</span></span>

<span data-ttu-id="97b0b-115">이 방법의 단점은 응용 프로그램 증가 크기를 조정 하도록 요구 하는 경우에 분명해 집니다.</span><span class="sxs-lookup"><span data-stu-id="97b0b-115">The downside of this approach becomes evident if the application grows, requiring it to scale.</span></span> <span data-ttu-id="97b0b-116">전체 응용 프로그램 확장할 수 없는 경우 실제로 문제가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="97b0b-116">If the entire application can scale, it is not really a problem.</span></span> <span data-ttu-id="97b0b-117">그러나 대부분의 경우 몇 개의 응용 프로그램 부분 있는 다른 구성 요소는 크기 조정 요구 사용 하는 작은 좁게 지점.</span><span class="sxs-lookup"><span data-stu-id="97b0b-117">However, in most cases, just a few parts of the application are the choke points that requiring scaling, while other components are used less.</span></span>

<span data-ttu-id="97b0b-118">예를 들어 일반적인 전자 상거래 응용 프로그램에서는 가능성이 제품 정보 하위 시스템의 크기를 조정 하 하기 때문에 필요가 구입 하는 것 보다 많은 고객 찾아보기 제품입니다.</span><span class="sxs-lookup"><span data-stu-id="97b0b-118">For example, in a typical e-commerce application, you likely need to scale the product information subsystem, because many more customers browse products than purchase them.</span></span> <span data-ttu-id="97b0b-119">더 많은 고객 결제 파이프라인을 사용 하는 보다 자신의 바구니를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="97b0b-119">More customers use their basket than use the payment pipeline.</span></span> <span data-ttu-id="97b0b-120">더 적은 수의 고객 주석을 추가 하거나 자신의 구매 기록을 봅니다.</span><span class="sxs-lookup"><span data-stu-id="97b0b-120">Fewer customers add comments or view their purchase history.</span></span> <span data-ttu-id="97b0b-121">및 콘텐츠 및 마케팅 캠페인을 관리 해야 하는 직원 중 소수의 쿼리만 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="97b0b-121">And you might have only a handful of employees, that need to manage the content and marketing campaigns.</span></span> <span data-ttu-id="97b0b-122">모놀리식 디자인을 크기를 조정 하는 경우 이러한 다른 작업에 대 한 모든 코드 여러 번 배포 이며 동일한 등급에 배율이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="97b0b-122">If you scale the monolithic design, all the code for these different tasks is deployed multiple times and scaled at the same grade.</span></span>

<span data-ttu-id="97b0b-123">응용 프로그램의 크기를 조정 하는 방법은 여러 가지가-가로 복제, 응용 프로그램 및 분할 비슷한 비즈니스 개념 또는 데이터의 다양 한 영역을 분할 합니다.</span><span class="sxs-lookup"><span data-stu-id="97b0b-123">There are multiple ways to scale an application—horizontal duplication, splitting different areas of the application, and partitioning similar business concepts or data.</span></span> <span data-ttu-id="97b0b-124">하지만 모든 구성 요소를 확장 하는 문제 외에도 단일 구성 요소를 변경 해야 전체 응용 프로그램 및 모든 인스턴스의 전체 배포 시의 전체 다시 테스트 합니다.</span><span class="sxs-lookup"><span data-stu-id="97b0b-124">But, in addition to the problem of scaling all components, changes to a single component require complete retesting of the entire application, and a complete redeployment of all the instances.</span></span>

<span data-ttu-id="97b0b-125">그러나 모놀리식 접근 방식을 일반적으로 응용 프로그램의 개발은 처음 하기가 매우 microservices 접근 방식입니다.</span><span class="sxs-lookup"><span data-stu-id="97b0b-125">However, the monolithic approach is common, because the development of the application is initially easier than for microservices approaches.</span></span> <span data-ttu-id="97b0b-126">따라서 대부분의 조직에서는이 아키텍처 접근 방법을 사용 하 여 개발 합니다.</span><span class="sxs-lookup"><span data-stu-id="97b0b-126">Thus, many organizations develop using this architectural approach.</span></span> <span data-ttu-id="97b0b-127">일부 조직에서는 충분 한 결과 양호 했을 때 한계 도달 다른 합니다.</span><span class="sxs-lookup"><span data-stu-id="97b0b-127">While some organizations have had good enough results, others are hitting limits.</span></span> <span data-ttu-id="97b0b-128">대부분의 조직에서는 디자인 도구 및 인프라 설정 했다고에 빌드 서비스 지향 아키텍처 (SOA) 년 전 및 필요성을 표시 되지 않은 것은 어려울 때문에이 모델을 사용 하 여 응용 프로그램-응용 프로그램 증가 될 때까지 합니다.</span><span class="sxs-lookup"><span data-stu-id="97b0b-128">Many organizations designed their applications using this model because tools and infrastructure made it too difficult to build service oriented architectures (SOA) years ago, and they did not see the need—until the application grew.</span></span>

<span data-ttu-id="97b0b-129">인프라 측면에서 볼 때 각 서버 동일한 호스트 내에서 많은 응용 프로그램을 실행 하 고 그림 4-2와 같이 리소스 사용량에서 효율성의 허용 되는 비율을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="97b0b-129">From an infrastructure perspective, each server can run many applications within the same host and have an acceptable ratio of efficiency in resources usage, as shown in Figure 4-2.</span></span>

![](./media/image2.png)

<span data-ttu-id="97b0b-130">**그림 4-2**합니다.</span><span class="sxs-lookup"><span data-stu-id="97b0b-130">**Figure 4-2**.</span></span> <span data-ttu-id="97b0b-131">모놀리식 방법: 컨테이너를 실행 하는 각 응용 프로그램을 실행 중인 여러 응용 프로그램 호스트</span><span class="sxs-lookup"><span data-stu-id="97b0b-131">Monolithic approach: Host running multiple apps, each app running as a container</span></span>

<span data-ttu-id="97b0b-132">각 인스턴스에 대 한 전용된 Vm을 사용 하 여 Microsoft Azure에서 단일 응용 프로그램을 배포할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="97b0b-132">Monolithic applications in Microsoft Azure can be deployed using dedicated VMs for each instance.</span></span> <span data-ttu-id="97b0b-133">또한를 사용 하 여 [Azure VM 크기 집합이](https://docs.microsoft.com/azure/virtual-machine-scale-sets/), Vm을 쉽게 확장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="97b0b-133">Additionally, using [Azure VM Scale Sets](https://docs.microsoft.com/azure/virtual-machine-scale-sets/), you can easily scale the VMs.</span></span> <span data-ttu-id="97b0b-134">[Azure 앱 서비스](https://azure.microsoft.com/services/app-service/) 도 모놀리식 응용 프로그램을 실행 하 고 Vm 관리 하지 않고도 인스턴스를 쉽게 확장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="97b0b-134">[Azure App Service](https://azure.microsoft.com/services/app-service/) can also run monolithic applications and easily scale instances without requiring you to manage the VMs.</span></span> <span data-ttu-id="97b0b-135">2016 년부터 Azure 앱 서비스 인스턴스를 실행할 수 단일 뿐, Docker 컨테이너의 배포를 단순화 합니다.</span><span class="sxs-lookup"><span data-stu-id="97b0b-135">Since 2016, Azure App Services can run single instances of Docker containers as well, simplifying deployment.</span></span>

<span data-ttu-id="97b0b-136">QA 환경 또는 제한 된 프로덕션 환경으로 여러 Docker 호스트 Vm을 배포할 수 있으며 그림 4-3에 표시 된 것 처럼 Azure 분산 장치를 사용 하 여 균형을 조정 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="97b0b-136">As a QA environment or a limited production environment, you can deploy multiple Docker host VMs and balance them using the Azure balancer, as shown in Figure 4-3.</span></span> <span data-ttu-id="97b0b-137">이렇게 하면는 성긴 접근 방식으로 배율을 관리 하므로 하나의 컨테이너에서 거주 하는 전체 응용 프로그램.</span><span class="sxs-lookup"><span data-stu-id="97b0b-137">This lets you manage scaling with a coarse-grain approach, because the whole application lives within a single container.</span></span>

![](./media/image3.png)

<span data-ttu-id="97b0b-138">**그림 4-3**합니다.</span><span class="sxs-lookup"><span data-stu-id="97b0b-138">**Figure 4-3**.</span></span> <span data-ttu-id="97b0b-139">단일 컨테이너 응용 프로그램을 확장 하는 여러 호스트의 예</span><span class="sxs-lookup"><span data-stu-id="97b0b-139">Example of multiple hosts scaling up a single container application</span></span>

<span data-ttu-id="97b0b-140">일반적인 배포 방법으로 다양 한 호스트에 배포를 관리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="97b0b-140">Deployment to the various hosts can be managed with traditional deployment techniques.</span></span> <span data-ttu-id="97b0b-141">와 같은 명령을 사용 하 여 docker 호스트를 관리 `docker run` 또는 `docker-compose` 수동으로 또는 지속적인 업데이트 (CD) 파이프라인 같은 자동화를 통해 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="97b0b-141">Docker hosts can be managed with commands like `docker run` or `docker-compose` performed manually, or through automation such as continuous delivery (CD) pipelines.</span></span>

## <a name="deploying-a-monolithic-application-as-a-container"></a><span data-ttu-id="97b0b-142">컨테이너는 모놀리식 응용 프로그램 배포</span><span class="sxs-lookup"><span data-stu-id="97b0b-142">Deploying a monolithic application as a container</span></span>

<span data-ttu-id="97b0b-143">컨테이너를 사용 하 여 단일 응용 프로그램 배포를 관리 하는 이점이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="97b0b-143">There are benefits to using containers to manage monolithic application deployments.</span></span> <span data-ttu-id="97b0b-144">컨테이너 인스턴스를 확장 하는 것은 훨씬 보다 쉽고 빠르게 추가 Vm을 배포 합니다.</span><span class="sxs-lookup"><span data-stu-id="97b0b-144">Scaling container instances is far faster and easier than deploying additional VMs.</span></span> <span data-ttu-id="97b0b-145">VM 크기 집합을 사용 하는 경우에 Vm 시작 시간을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="97b0b-145">Even if you use VM Scale Sets, VMs take time to start.</span></span> <span data-ttu-id="97b0b-146">서버 인스턴스 컨테이너 대신 기존 응용 프로그램 인스턴스를 배포할 때 VM의 일부로 응용 프로그램의 구성 관리 되는 적절 하지 합니다.</span><span class="sxs-lookup"><span data-stu-id="97b0b-146">When deployed as traditional application instances instead of containers, the configuration of the application is managed as part of the VM, which is not ideal.</span></span>

<span data-ttu-id="97b0b-147">Docker 이미지는 훨씬 더 빠른 업데이트를 배포 하 고 효율적인 네트워크입니다.</span><span class="sxs-lookup"><span data-stu-id="97b0b-147">Deploying updates as Docker images is far faster and network efficient.</span></span> <span data-ttu-id="97b0b-148">Docker 이미지 일반적으로 시작 합니다 (초)을 롤아웃 속도가 향상.</span><span class="sxs-lookup"><span data-stu-id="97b0b-148">Docker images typically start in seconds, which speeds rollouts.</span></span> <span data-ttu-id="97b0b-149">실행 하는 것 만큼 쉽게는 Docker 이미지 인스턴스를 중지 한 `docker stop` 명령을 실행 하 고 몇 초 내에 완료 일반적으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="97b0b-149">Tearing down a Docker image instance is as easy as issuing a `docker stop` command, and typically completes in less than a second.</span></span>

<span data-ttu-id="97b0b-150">컨테이너를 디자인 하 여 변경할 수 없기 때문에 손상 된 Vm에 걱정할 필요가 하는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="97b0b-150">Because containers are immutable by design, you never need to worry about corrupted VMs.</span></span> <span data-ttu-id="97b0b-151">반면, 업데이트 스크립트는 VM에 대 한 몇 가지 특정 구성 또는 디스크에 남아 있는 파일을 설명 하기 위해 잊지 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="97b0b-151">In contrast, update scripts for a VM might forget to account for some specific configuration or file left on disk.</span></span>

<span data-ttu-id="97b0b-152">모놀리식 응용 프로그램은 Docker에서 이점을 얻을 수, 하는 동안에 이점에 대해서만 터치 하 했습니다.</span><span class="sxs-lookup"><span data-stu-id="97b0b-152">While monolithic applications can benefit from Docker, we are touching only on the benefits.</span></span> <span data-ttu-id="97b0b-153">컨테이너 관리의 추가 이점은 컨테이너 orchestrators 다양 한 인스턴스 및 각 컨테이너 인스턴스의 수명 주기 관리를 사용 하 여 배포에서 제공 됩니다.</span><span class="sxs-lookup"><span data-stu-id="97b0b-153">Additional benefits of managing containers come from deploying with container orchestrators, which manage the various instances and lifecycle of each container instance.</span></span> <span data-ttu-id="97b0b-154">모놀리식 응용 프로그램 확장, 개발 하 고 개별적으로 배포할 수 있는 하위 시스템을 손상 시 키 지 microservices의 영역에 프로그램 진입점입니다.</span><span class="sxs-lookup"><span data-stu-id="97b0b-154">Breaking up the monolithic application into subsystems that can be scaled, developed, and deployed individually is your entry point into the realm of microservices.</span></span>

## <a name="publishing-a-single-container-based-application-to-azure-app-service"></a><span data-ttu-id="97b0b-155">Azure 앱 서비스를 단일 컨테이너 기반 응용 프로그램 게시</span><span class="sxs-lookup"><span data-stu-id="97b0b-155">Publishing a single-container-based application to Azure App Service</span></span>

<span data-ttu-id="97b0b-156">Azure에 배포 하는 컨테이너의 유효성 검사 수행 하려는 여부 또는 응용 프로그램이 단일 컨테이너 응용 프로그램을 단순히이 Azure 앱 서비스는 단일 컨테이너 기반 서비스의 확장성을 제공 하는 좋은 방법을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="97b0b-156">Whether you want to get validation of a container deployed to Azure or when an application is simply a single-container application, Azure App Service provides a great way to provide scalable single-container-based services.</span></span> <span data-ttu-id="97b0b-157">Azure 앱 서비스를 사용 하는 것은 간단 합니다.</span><span class="sxs-lookup"><span data-stu-id="97b0b-157">Using Azure App Service is simple.</span></span> <span data-ttu-id="97b0b-158">쉽게 프로그램 코드, Visual Studio에서 빌드 및 Azure에 직접 배포할 수 있도록 Git가 포함 된 좋은 통합을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="97b0b-158">It provides great integration with Git to make it easy to take your code, build it in Visual Studio, and deploy it directly to Azure.</span></span>

![](./media/image4.png)

<span data-ttu-id="97b0b-159">**그림 4-4**합니다.</span><span class="sxs-lookup"><span data-stu-id="97b0b-159">**Figure 4-4**.</span></span> <span data-ttu-id="97b0b-160">Visual Studio에서 Azure 앱 서비스를 단일 컨테이너 응용 프로그램 게시</span><span class="sxs-lookup"><span data-stu-id="97b0b-160">Publishing a single-container application to Azure App Service from Visual Studio</span></span>

<span data-ttu-id="97b0b-161">Docker, 없이 다른 기능, 프레임 워크 또는 Azure 앱 서비스에서 지원 되지 않는 종속성 필요한 경우 해야 했습니다 Azure 팀에서는 이러한 종속성 앱 서비스에서 업데이트 될 때까지 기다립니다.</span><span class="sxs-lookup"><span data-stu-id="97b0b-161">Without Docker, if you needed other capabilities, frameworks, or dependencies that are not supported in Azure App Service, you had to wait until the Azure team updated those dependencies in App Service.</span></span> <span data-ttu-id="97b0b-162">또는 Azure Service Fabric, Azure 클라우드 서비스 또는 Vm의 경우 여기서 컨트롤에 추가 하 고 응용 프로그램에 대 한 필수 구성 요소 또는 프레임 워크를 설치할 수와 같은 다른 서비스도 전환 해야 했습니다.</span><span class="sxs-lookup"><span data-stu-id="97b0b-162">Or you had to switch to other services like Azure Service Fabric, Azure Cloud Services, or even VMs, where you had further control and you could install a required component or framework for your application.</span></span>

<span data-ttu-id="97b0b-163">Visual Studio 2017에 컨테이너 지원 그림 4-4에 나와 있는 것 처럼 응용 프로그램 환경에서 원하는 작업이 무엇이 든 포함할 수가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="97b0b-163">Container support in Visual Studio 2017 gives you the ability to include whatever you want in your application environment, as shown in Figure 4-4.</span></span> <span data-ttu-id="97b0b-164">를 실행 하는 것을 컨테이너에서 응용 프로그램에 종속성을 추가 하는 경우 이후 Dockerfile 또는 Docker 이미지의 종속성을 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="97b0b-164">Since you are running it in a container, if you add a dependency to your application, you can include the dependency in your Dockerfile or Docker image.</span></span>

<span data-ttu-id="97b0b-165">또한 표시 된 것 처럼 그림 4-4, 게시 흐름 컨테이너 레지스트리를 통해 이미지를 푸시합니다.</span><span class="sxs-lookup"><span data-stu-id="97b0b-165">As also shown in Figure 4-4, the publish flow pushes an image through a container registry.</span></span> <span data-ttu-id="97b0b-166">Azure 컨테이너 레지스트리 (레지스트리 가깝게 위치 해 Azure에서 배포 하 고 Azure Active Directory 그룹 및 계정에 의해 보안) 또는 Docker 허브 또는 온-프레미스 레지스트리 등의 다른 Docker 레지스트리 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="97b0b-166">This can be the Azure Container Registry (a registry close to your deployments in Azure and secured by Azure Active Directory groups and accounts), or any other Docker registry, like Docker Hub or an on-premises registry.</span></span>


>[!div class="step-by-step"]
<span data-ttu-id="97b0b-167">[이전] [다음] (docker-응용 프로그램-상태-data.md) (index.md)</span><span class="sxs-lookup"><span data-stu-id="97b0b-167">[Previous] (index.md) [Next] (docker-application-state-data.md)</span></span>

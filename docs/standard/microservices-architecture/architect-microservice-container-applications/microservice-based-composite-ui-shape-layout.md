---
title: "시각적 UI 셰이프 및 여러 microservices에 의해 생성 된 레이아웃을 포함 하 여 microservices에 따라 복합 UI 만들기"
description: "컨테이너 화 된.NET 응용 프로그램에 대 한.NET Microservices 아키텍처 | 시각적 UI 셰이프 및 여러 microservices에 의해 생성 된 레이아웃을 포함 하 여 microservices에 따라 복합 UI 만들기"
keywords: "Docker, 마이크로 서비스, ASP.NET, 컨테이너"
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 05/26/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.topic: article
ms.openlocfilehash: 4b32fed5eb0de02b01665efa4368eb83e3fda08d
ms.sourcegitcommit: e99dfadbca1992c187179b6a3b42bef44534ebb6
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 11/01/2017
---
# <a name="creating-composite-ui-based-on-microservices-including-visual-ui-shape-and-layout-generated-by-multiple-microservices"></a><span data-ttu-id="ca5a4-104">시각적 UI 셰이프 및 여러 microservices에 의해 생성 된 레이아웃을 포함 하 여 microservices에 따라 복합 UI 만들기</span><span class="sxs-lookup"><span data-stu-id="ca5a4-104">Creating composite UI based on microservices, including visual UI shape and layout generated by multiple microservices</span></span>

<span data-ttu-id="ca5a4-105">데이터 및 논리를 처리 하는 서버 쪽 Microservices 아키텍처 자주 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="ca5a4-105">Microservices architecture often starts with the server side handling data and logic.</span></span> <span data-ttu-id="ca5a4-106">그러나 UI microservices도에 따라 응용 프로그램을 디자인 하는 고급 방법이입니다.</span><span class="sxs-lookup"><span data-stu-id="ca5a4-106">However, a more advanced approach is to design your application UI based on microservices as well.</span></span> <span data-ttu-id="ca5a4-107">즉, 서버와는 microservices 소비는 모놀리식 클라이언트 앱에서 microservices 필요 없이 microservices에서 생성 되는 복합 UI 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="ca5a4-107">That means having a composite UI produced by the microservices, instead of having microservices on the server and just a monolithic client app consuming the microservices.</span></span> <span data-ttu-id="ca5a4-108">이 방법에서는 빌드할 microservices 논리 및 시각적 표현 모두 완료 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ca5a4-108">With this approach, the microservices you build can be complete with both logic and visual representation.</span></span>

<span data-ttu-id="ca5a4-109">그림 4-20 방금 microservices 모놀리식 클라이언트 응용 프로그램에서을 사용 하는 간단한 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="ca5a4-109">Figure 4-20 shows the simpler approach of just consuming microservices from a monolithic client application.</span></span> <span data-ttu-id="ca5a4-110">물론, HTML 및 JavaScript를 생성 하는 사이는 ASP.NET MVC 서비스가 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ca5a4-110">Of course, you could have an ASP.NET MVC service in between producing the HTML and JavaScript.</span></span> <span data-ttu-id="ca5a4-111">그림에는 단일 (모놀리식) 클라이언트 UI 사용 (HTML 및 JavaScript) UI 셰이프 아니라 논리와 데이터에만 집중는 microservices 있는지를 강조 하는 단순화 된 버전입니다.</span><span class="sxs-lookup"><span data-stu-id="ca5a4-111">The figure is a simplification that highlights that you have a single (monolithic) client UI consuming the microservices, which just focus on logic and data and not on the UI shape (HTML and JavaScript).</span></span>

![](./media/image20.png)

<span data-ttu-id="ca5a4-112">**그림 4-20**합니다.</span><span class="sxs-lookup"><span data-stu-id="ca5a4-112">**Figure 4-20**.</span></span> <span data-ttu-id="ca5a4-113">백 엔드 microservices 소비 모놀리식 UI 응용 프로그램</span><span class="sxs-lookup"><span data-stu-id="ca5a4-113">A monolithic UI application consuming back-end microservices</span></span>

<span data-ttu-id="ca5a4-114">반면, 복합 UI는 정확 하 게 생성 및 microservices 자체에 의해 구성 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="ca5a4-114">In contrast, a composite UI is precisely generated and composed by the microservices themselves.</span></span> <span data-ttu-id="ca5a4-115">일부는 microservices UI의 특정 영역의 시각적 모양을 구동합니다.</span><span class="sxs-lookup"><span data-stu-id="ca5a4-115">Some of the microservices drive the visual shape of specific areas of the UI.</span></span> <span data-ttu-id="ca5a4-116">주요 차이가 클라이언트 UI 구성 요소 (예: TS 클래스) 템플릿에 기반 있으며 해당 템플릿에 대 한 데이터 셰이핑 UI ViewModel는 각 마이크로 서비스에서 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="ca5a4-116">The key difference is that you have client UI components (TS classes, for example) based on templates, and the data-shaping-UI ViewModel for those templates comes from each microservice.</span></span>

<span data-ttu-id="ca5a4-117">클라이언트 응용 프로그램 시작 시 각 클라이언트 UI 구성 요소 (예: TypeScript 클래스)에 자동으로 등록는 인프라 마이크로 서비스를 지정된 된 시나리오에 대 한 Viewmodel를 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ca5a4-117">At client application start-up time, each of the client UI components (TypeScript classes, for example) registers itself with an infrastructure microservice capable of providing ViewModels for a given scenario.</span></span> <span data-ttu-id="ca5a4-118">마이크로 서비스의 모양을 변경 되 면 UI도 변경 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ca5a4-118">If the microservice changes the shape, the UI changes also.</span></span>

<span data-ttu-id="ca5a4-119">그림 4-21이 복합 UI 접근 방법의 버전을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="ca5a4-119">Figure 4-21 shows a version of this composite UI approach.</span></span> <span data-ttu-id="ca5a4-120">이 단순 하 여, 다양 한 기술을 기반으로 하는 세분화 된 파트를 집계 하는 다른 microservices 해야할-을 개발 하는 일반적인 웹 접근 방식 (ASP.NET MVC) 또는 SPA (단일 페이지 응용 프로그램)에 따라 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="ca5a4-120">This is simplified, because you might have other microservices that are aggregating granular parts based on different techniques—it depends on whether you are building a traditional web approach (ASP.NET MVC) or an SPA (Single Page Application).</span></span>

![](./media/image21.png)

<span data-ttu-id="ca5a4-121">**그림 4-21**합니다.</span><span class="sxs-lookup"><span data-stu-id="ca5a4-121">**Figure 4-21**.</span></span> <span data-ttu-id="ca5a4-122">백 엔드 microservices 모양이 지정 복합 UI 응용 프로그램의 예</span><span class="sxs-lookup"><span data-stu-id="ca5a4-122">Example of a composite UI application shaped by back-end microservices</span></span>

<span data-ttu-id="ca5a4-123">각 해당 UI 컴퍼지션 microservices 작은 API 게이트웨이 유사 합니다.</span><span class="sxs-lookup"><span data-stu-id="ca5a4-123">Each of those UI composition microservices would be similar to a small API Gateway.</span></span> <span data-ttu-id="ca5a4-124">그러나이 경우 각은 작은 UI 영역에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="ca5a4-124">But in this case each is responsible for a small UI area.</span></span>

<span data-ttu-id="ca5a4-125">따라서 덜 UI 기술, 사용 중인 또는 microservices에 의해 발생 하는 복합 UI 접근 방식을 좀 더 어렵습니다 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ca5a4-125">A composite UI approach that is driven by microservices can be more challenging or less so, depending on what UI technologies you are using.</span></span> <span data-ttu-id="ca5a4-126">예를 들어, 동일한 기술을 SPA를 구축 하기 위한 또는 네이티브 모바일 앱을 사용 하는 기존 웹 응용 프로그램을 구축 하기 위한 사용 하지 것입니다 (마찬가지로이 방법은 좀 더 어렵습니다 될 수 있는 Xamarin 앱을 개발 하는 경우).</span><span class="sxs-lookup"><span data-stu-id="ca5a4-126">For instance, you will not use the same techniques for building a traditional web application that you use for building an SPA or for native mobile app (as when developing Xamarin apps, which can be more challenging for this approach).</span></span>

<span data-ttu-id="ca5a4-127">[eShopOnContainers](http://aka.ms/MicroservicesArchitecture) 예제 응용 프로그램 여러 가지 이유로 모놀리식 UI 접근 방식을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="ca5a4-127">The [eShopOnContainers](http://aka.ms/MicroservicesArchitecture) sample application uses the monolithic UI approach for multiple reasons.</span></span> <span data-ttu-id="ca5a4-128">첫째, 것은 microservices 및 컨테이너에 대해 소개 합니다.</span><span class="sxs-lookup"><span data-stu-id="ca5a4-128">First, it is an introduction to microservices and containers.</span></span> <span data-ttu-id="ca5a4-129">복합 UI 더 높은 수준의 있지만 복잡성 디자인 하 고 UI를 개발 하는 경우 더 이상 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="ca5a4-129">A composite UI is more advanced but also requires further complexity when designing and developing the UI.</span></span> <span data-ttu-id="ca5a4-130">둘째, eShopOnContainers 제공 기본 모바일 앱에 Xamarin을 만들 때와 더 복잡 한 C 클라이언트에 따라\# 쪽입니다.</span><span class="sxs-lookup"><span data-stu-id="ca5a4-130">Second, eShopOnContainers also provides a native mobile app based on Xamarin, which would make it more complex on the client C\# side.</span></span>

<span data-ttu-id="ca5a4-131">그러나 좋습니다 복합 microservices를 기반으로 UI에 대 한 자세한 내용을 보려면 다음 참조를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ca5a4-131">However, we encourage you to use the following references to learn more about composite UI based on microservices.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="ca5a4-132">추가 리소스</span><span class="sxs-lookup"><span data-stu-id="ca5a4-132">Additional resources</span></span>

-   <span data-ttu-id="ca5a4-133">**ASP.NET (특정의 Workshop)를 사용 하 여 복합 UI**
    [*http://go.particular.net/workshop-composite-ui-demo*](http://go.particular.net/workshop-composite-ui-demo)</span><span class="sxs-lookup"><span data-stu-id="ca5a4-133">**Composite UI using ASP.NET (Particular’s Workshop)**
[*http://go.particular.net/workshop-composite-ui-demo*](http://go.particular.net/workshop-composite-ui-demo)</span></span>

-   <span data-ttu-id="ca5a4-134">**Ruben Oostinga 합니다. Microservices 아키텍처에서 모놀리식 프런트 엔드**
    [*http://blog.xebia.com/the-monolithic-frontend-in-the-microservices-architecture/*](http://blog.xebia.com/the-monolithic-frontend-in-the-microservices-architecture/)</span><span class="sxs-lookup"><span data-stu-id="ca5a4-134">**Ruben Oostinga. The Monolithic Frontend in the Microservices Architecture**
[*http://blog.xebia.com/the-monolithic-frontend-in-the-microservices-architecture/*](http://blog.xebia.com/the-monolithic-frontend-in-the-microservices-architecture/)</span></span>

-   <span data-ttu-id="ca5a4-135">**Mauro Servienti 합니다. 더 나은 UI 배치 비밀**
    [*https://particular.net/blog/secret-of-better-ui-composition*](https://particular.net/blog/secret-of-better-ui-composition)</span><span class="sxs-lookup"><span data-stu-id="ca5a4-135">**Mauro Servienti. The secret of better UI composition**
[*https://particular.net/blog/secret-of-better-ui-composition*](https://particular.net/blog/secret-of-better-ui-composition)</span></span>

-   <span data-ttu-id="ca5a4-136">**Viktor Farcic 합니다. 웹 프런트 엔드 구성 요소를 포함 하 여 Microservices에**
    [*https://technologyconversations.com/2015/08/09/including-front-end-web-components-into-microservices/*](https://technologyconversations.com/2015/08/09/including-front-end-web-components-into-microservices/)</span><span class="sxs-lookup"><span data-stu-id="ca5a4-136">**Viktor Farcic. Including Front-End Web Components Into Microservices**
[*https://technologyconversations.com/2015/08/09/including-front-end-web-components-into-microservices/*](https://technologyconversations.com/2015/08/09/including-front-end-web-components-into-microservices/)</span></span>

-   <span data-ttu-id="ca5a4-137">**Microservices 아키텍처에 대 한 프런트 엔드를 관리합니다.**\\</span><span class="sxs-lookup"><span data-stu-id="ca5a4-137">**Managing Frontend in the Microservices Architecture**\\</span></span>
    [<span data-ttu-id="ca5a4-138">*http://allegro.tech/2016/03/Managing-Frontend-in-the-microservices-architecture.html*</span><span class="sxs-lookup"><span data-stu-id="ca5a4-138">*http://allegro.tech/2016/03/Managing-Frontend-in-the-microservices-architecture.html*</span></span>](http://allegro.tech/2016/03/Managing-Frontend-in-the-microservices-architecture.html)


>[!div class="step-by-step"]
<span data-ttu-id="ca5a4-139">[이전] (microservices-주소 지정 기능-service-registry.md) [다음] (복원 력 있는-높은-가용성-microservices.md)</span><span class="sxs-lookup"><span data-stu-id="ca5a4-139">[Previous] (microservices-addressability-service-registry.md) [Next] (resilient-high-availability-microservices.md)</span></span>

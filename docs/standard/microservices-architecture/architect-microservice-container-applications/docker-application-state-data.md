---
title: "상태 및 Docker는 응용 프로그램에서 데이터"
description: "컨테이너 화 된.NET 응용 프로그램에 대 한.NET Microservices 아키텍처 | 상태 및 Docker는 응용 프로그램에서 데이터"
keywords: "Docker, Microservices, ASP.NET, 컨테이너, SQL, CosmosDB, Docker"
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 10/18/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.topic: article
ms.openlocfilehash: 36d0fb9f27ef56b36c380e2fc972c79cff77003e
ms.sourcegitcommit: c2e216692ef7576a213ae16af2377cd98d1a67fa
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 10/22/2017
---
# <a name="state-and-data-in-docker-applications"></a><span data-ttu-id="29ba0-104">상태 및 Docker는 응용 프로그램에서 데이터</span><span class="sxs-lookup"><span data-stu-id="29ba0-104">State and data in Docker applications</span></span>

<span data-ttu-id="29ba0-105">대부분의 경우에서 프로세스의 인스턴스로 서 컨테이너의 생각할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="29ba0-105">In most cases, you can think of a container as an instance of a process.</span></span> <span data-ttu-id="29ba0-106">프로세스는 영구 상태를 유지 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="29ba0-106">A process does not maintain persistent state.</span></span> <span data-ttu-id="29ba0-107">를 로컬 저장소에 컨테이너를 작성할 수 인스턴스 주위 무기한 될 됩니다 가정 것과 같습니다 메모리 내의 단일 위치 내구성 된다는 것으로 가정 합니다.</span><span class="sxs-lookup"><span data-stu-id="29ba0-107">While a container can write to its local storage, assuming that an instance will be around indefinitely would be like assuming that a single location in memory will be durable.</span></span> <span data-ttu-id="29ba0-108">여러 개의 인스턴스가 있는 프로세스와 같은 컨테이너 이미지 간주 또는 이러한 종료 결국 됩니다. 컨테이너 orchestrator와 관리 하는 경우 것을 가정해는 get 이동 수 노드 또는 VM 간에 합니다.</span><span class="sxs-lookup"><span data-stu-id="29ba0-108">Container images, like processes, should be assumed to have multiple instances or that they will eventually be killed; if they’re managed with a container orchestrator, it should be assumed that they might get moved from one node or VM to another.</span></span>

<span data-ttu-id="29ba0-109">라는 기능을 제공 하는 docker는 *오버레이 파일 시스템*합니다.</span><span class="sxs-lookup"><span data-stu-id="29ba0-109">Docker provides a feature named the *overlay file system*.</span></span> <span data-ttu-id="29ba0-110">저장소 컨테이너의 루트 파일 시스템에 정보를 업데이트 하는 쓰기 시 복사 작업을 구현 합니다.</span><span class="sxs-lookup"><span data-stu-id="29ba0-110">This implements a copy-on-write task that stores updated information to the root file system of the container.</span></span> <span data-ttu-id="29ba0-111">해당 정보는 또한에 원본 이미지는 컨테이너의 기반으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="29ba0-111">That information is in addition to the original image on which the container is based.</span></span> <span data-ttu-id="29ba0-112">시스템에서 컨테이너를 삭제 하는 경우 해당 변경 내용이 손실 됩니다.</span><span class="sxs-lookup"><span data-stu-id="29ba0-112">If the container is deleted from the system, those changes are lost.</span></span> <span data-ttu-id="29ba0-113">따라서 로컬 저장소 내의 컨테이너의 상태를 저장 하는 가능 하지만 기본적으로는 상태 비저장 컨테이너 디자인의 전제 충돌이 시스템을 디자인 합니다.</span><span class="sxs-lookup"><span data-stu-id="29ba0-113">Therefore, while it is possible to save the state of a container within its local storage, designing a system around this would conflict with the premise of container design, which by default is stateless.</span></span>

<span data-ttu-id="29ba0-114">다음 솔루션은 Docker는 응용 프로그램에서 영구 데이터를 관리 하는 데 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="29ba0-114">The following solutions are used to manage persistent data in Docker applications:</span></span>

-   <span data-ttu-id="29ba0-115">[데이터 볼륨](https://docs.docker.com/engine/tutorials/dockervolumes/) 하는 호스트에 탑재 합니다.</span><span class="sxs-lookup"><span data-stu-id="29ba0-115">[Data volumes](https://docs.docker.com/engine/tutorials/dockervolumes/) that mount to the host.</span></span>

-   <span data-ttu-id="29ba0-116">[데이터 볼륨 컨테이너](https://docs.docker.com/engine/tutorials/dockervolumes/#creating-and-mounting-a-data-volume-container) 외부 컨테이너를 사용 하 여 컨테이너에서 공유 저장소를 제공 하는 합니다.</span><span class="sxs-lookup"><span data-stu-id="29ba0-116">[Data volume containers](https://docs.docker.com/engine/tutorials/dockervolumes/#creating-and-mounting-a-data-volume-container) that provide shared storage across containers using an external container.</span></span>

-   <span data-ttu-id="29ba0-117">[볼륨 플러그 인](https://docs.docker.com/engine/tutorials/dockervolumes/) 장기 지 속성을 제공 하는 원격 서비스에 볼륨을 탑재 하 합니다.</span><span class="sxs-lookup"><span data-stu-id="29ba0-117">[Volume plugins](https://docs.docker.com/engine/tutorials/dockervolumes/) that mount volumes to remote services, providing long-term persistence.</span></span>

-   <span data-ttu-id="29ba0-118">[Azure 저장소](https://docs.microsoft.com/azure/storage/), 컨테이너에 대 한 좋은 장기 지 속성 솔루션을 제공 하 지역 배포 가능한 저장소를 제공 하는 합니다.</span><span class="sxs-lookup"><span data-stu-id="29ba0-118">[Azure Storage](https://docs.microsoft.com/azure/storage/), which provides geo-distributable storage, providing a good long-term persistence solution for containers.</span></span>

-   <span data-ttu-id="29ba0-119">원격 관계형 데이터베이스와 같은 [Azure SQL 데이터베이스](https://azure.microsoft.com/services/sql-database/) NoSQL 데이터베이스 같은 [Azure Cosmos DB](https://docs.microsoft.com/azure/cosmos-db/introduction), 또는 같은 서비스 캐시 [Redis](https://redis.io/)합니다.</span><span class="sxs-lookup"><span data-stu-id="29ba0-119">Remote relational databases like [Azure SQL Database](https://azure.microsoft.com/services/sql-database/) or NoSQL databases like [Azure Cosmos DB](https://docs.microsoft.com/azure/cosmos-db/introduction), or cache services like [Redis](https://redis.io/).</span></span>

<span data-ttu-id="29ba0-120">다음은 이러한 옵션에 대 한 자세한 내용을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="29ba0-120">The following provides more detail about these options.</span></span>

<span data-ttu-id="29ba0-121">**데이터 볼륨** 는 호스트 OS에서에서 컨테이너에 있는 디렉터리에 매핑된 디렉터리입니다.</span><span class="sxs-lookup"><span data-stu-id="29ba0-121">**Data volumes** are directories mapped from the host OS to directories in containers.</span></span> <span data-ttu-id="29ba0-122">때 컨테이너의 코드에 액세스가 실제로 호스트 OS에서 디렉터리에 있는 디렉터리에 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="29ba0-122">When code in the container has access to the directory, that access is actually to a directory on the host OS.</span></span> <span data-ttu-id="29ba0-123">이 디렉터리 자체에 컨테이너의 수명에 연결 되지 않은 및 호스트 운영 체제에서 직접 실행 되는 코드에서 디렉터리를 액세스할 수 있습니다 또는 동일한 호스트 디렉터리 자체에 매핑되는 다른 컨테이너에 의해 합니다.</span><span class="sxs-lookup"><span data-stu-id="29ba0-123">This directory is not tied to the lifetime of the container itself, and the directory can be accessed from code running directly on the host OS or by another container that maps the same host directory to itself.</span></span> <span data-ttu-id="29ba0-124">따라서 데이터 볼륨 컨테이너의 수명 독립적으로 데이터를 유지 하도록 설계 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="29ba0-124">Thus, data volumes are designed to persist data independently of the life of the container.</span></span> <span data-ttu-id="29ba0-125">컨테이너를 삭제 하거나 이미지 Docker 호스트에서 데이터에 유지 하는 경우에 데이터 볼륨 삭제 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="29ba0-125">If you delete a container or an image from the Docker host, the data persisted in the data volume is not deleted.</span></span> <span data-ttu-id="29ba0-126">호스트 OS도에서 볼륨의 데이터를 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="29ba0-126">The data in a volume can be accessed from the host OS as well.</span></span>

<span data-ttu-id="29ba0-127">**데이터 볼륨 컨테이너** 일반 데이터 볼륨의 진화 됩니다.</span><span class="sxs-lookup"><span data-stu-id="29ba0-127">**Data volume containers** are an evolution of regular data volumes.</span></span> <span data-ttu-id="29ba0-128">데이터 볼륨 컨테이너는 간단한 컨테이너 내에서 하나 이상의 데이터 볼륨에입니다.</span><span class="sxs-lookup"><span data-stu-id="29ba0-128">A data volume container is a simple container that has one or more data volumes within it.</span></span> <span data-ttu-id="29ba0-129">데이터 볼륨 컨테이너 중앙 탑재 지점에서 컨테이너에 대 한 액세스를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="29ba0-129">The data volume container provides access to containers from a central mount point.</span></span> <span data-ttu-id="29ba0-130">이 데이터 액세스 방법은 편리 하 게 때문에 원래 데이터의 위치를 분리 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="29ba0-130">This method of data access is convenient because it abstracts the location of the original data.</span></span> <span data-ttu-id="29ba0-131">외에 원하는 동작 이므로 일반 데이터 볼륨의 기능과 유사 데이터 응용 프로그램의 컨테이너의 수명 주기에 독립적으로 전용된이 컨테이너에 보관 됩니다.</span><span class="sxs-lookup"><span data-stu-id="29ba0-131">Other than that, its behavior is similar to that of a regular data volume, so data is persisted in this dedicated container independently of the lifecycle of the application’s containers.</span></span>

<span data-ttu-id="29ba0-132">그림 4-5와 같이, 일반의 Docker 볼륨 컨테이너 자체 속하지 않지만 호스트 서버 또는 VM의 물리적 장벽을 저장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="29ba0-132">As shown in Figure 4-5, regular Docker volumes can be stored outside of the containers themselves but within the physical boundaries of the host server or VM.</span></span> <span data-ttu-id="29ba0-133">그러나 Docker 컨테이너를 다른 호스트 서버 또는 VM에서 볼륨을 액세스할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="29ba0-133">However, Docker containers cannot access a volume from one host server or VM to another.</span></span> <span data-ttu-id="29ba0-134">즉, 이러한 볼륨 수 없으면 다른 Docker 호스트에서 실행 되는 컨테이너 간에 공유할 데이터 관리</span><span class="sxs-lookup"><span data-stu-id="29ba0-134">In other words, with these volumes, it is not possible to manage data shared between containers that run on different Docker hosts</span></span>

![](./media/image5.png)

<span data-ttu-id="29ba0-135">**그림 4-5**합니다.</span><span class="sxs-lookup"><span data-stu-id="29ba0-135">**Figure 4-5**.</span></span> <span data-ttu-id="29ba0-136">데이터 볼륨 및 컨테이너 기반 응용 프로그램에 대 한 외부 데이터 원본</span><span class="sxs-lookup"><span data-stu-id="29ba0-136">Data volumes and external data sources for container-based applications</span></span>

<span data-ttu-id="29ba0-137">또한 Docker 컨테이너 관리는 orchestrator 때 컨테이너 수 "이동" 호스트 클러스터에서 수행한 최적화에 따라 사이의 합니다.</span><span class="sxs-lookup"><span data-stu-id="29ba0-137">In addition, when Docker containers are managed by an orchestrator, containers might “move” between hosts, depending on the optimizations performed by the cluster.</span></span> <span data-ttu-id="29ba0-138">따라서으로 비즈니스 데이터에 대 한 데이터 볼륨을 사용 하는 것이 좋습니다 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="29ba0-138">Therefore, it is not recommended that you use data volumes for business data.</span></span> <span data-ttu-id="29ba0-139">그러나 적합 한 메커니즘 추적 파일을 임시 파일을 사용 하는 또는 유사한는 영향을 주지 않을 비즈니스 데이터 일관성.</span><span class="sxs-lookup"><span data-stu-id="29ba0-139">But they are a good mechanism to work with trace files, temporal files, or similar that will not impact business data consistency.</span></span>

<span data-ttu-id="29ba0-140">**볼륨 플러그 인** 같은 [Flocker](https://clusterhq.com/flocker/) 클러스터의 모든 호스트에 걸쳐 데이터 액세스를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="29ba0-140">**Volume plugins** like [Flocker](https://clusterhq.com/flocker/) provide data access across all hosts in a cluster.</span></span> <span data-ttu-id="29ba0-141">일부 볼륨 플러그 인 동일 하 게 생성 되는 동안 볼륨 플러그 인은 일반적으로 변경할 수 없는 컨테이너에서 영구 표면화 된 신뢰할 수 있는 저장소를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="29ba0-141">While not all volume plugins are created equally, volume plugins typically provide externalized persistent reliable storage from immutable containers.</span></span>

<span data-ttu-id="29ba0-142">**원격 데이터 원본과 캐시** Azure SQL 데이터베이스, Azure Cosmos DB 또는 Redis에 사용할 수와 같은 원격 캐시와 같은 도구 컨테이너 화 가능한 응용 프로그램 컨테이너 없이 개발할 때 사용 되는 동일한 방식으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="29ba0-142">**Remote data sources and cache** tools like Azure SQL Database, Azure Cosmos DB, or a remote cache like Redis can be used in containerized applications the same way they are used when developing without containers.</span></span> <span data-ttu-id="29ba0-143">이 방법은 비즈니스 응용 프로그램 데이터를 저장 하는 검증 합니다.</span><span class="sxs-lookup"><span data-stu-id="29ba0-143">This is a proven way to store business application data.</span></span>

<span data-ttu-id="29ba0-144">**메트릭을 제공 합니다.**</span><span class="sxs-lookup"><span data-stu-id="29ba0-144">**Azure Storage.**</span></span> <span data-ttu-id="29ba0-145">일반적으로 비즈니스 데이터 외부 리소스 또는 Azure 저장소와 같은 데이터베이스에 배치 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="29ba0-145">Business data usually will need to be placed in external resources or databases, like Azure Storage.</span></span> <span data-ttu-id="29ba0-146">콘크리트의 azure 저장소에서는 클라우드에서 다음 서비스를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="29ba0-146">Azure Storage, in concrete, provides the following services in the cloud:</span></span>

-   <span data-ttu-id="29ba0-147">Blob 저장소는 구조화 되지 않은 개체 데이터를 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="29ba0-147">Blob storage stores unstructured object data.</span></span> <span data-ttu-id="29ba0-148">Blob에는 문서 또는 미디어 파일 (이미지, 오디오 및 비디오 파일)와 같은 텍스트 또는 이진 데이터 형식일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="29ba0-148">A blob can be any type of text or binary data, such as document or media files (images, audio, and video files).</span></span> <span data-ttu-id="29ba0-149">Blob 저장소 개체 저장소 라고도 합니다.</span><span class="sxs-lookup"><span data-stu-id="29ba0-149">Blob storage is also referred to as Object storage.</span></span>

-   <span data-ttu-id="29ba0-150">파일 저장소 표준 SMB 프로토콜을 사용 하 여 레거시 응용 프로그램에 대 한 공유 저장소를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="29ba0-150">File storage offers shared storage for legacy applications using standard SMB protocol.</span></span> <span data-ttu-id="29ba0-151">Azure 가상 컴퓨터 및 클라우드 서비스 탑재 된 공유를 통해 응용 프로그램 구성 요소 간에 파일 데이터를 공유할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="29ba0-151">Azure virtual machines and cloud services can share file data across application components via mounted shares.</span></span> <span data-ttu-id="29ba0-152">온-프레미스 응용 프로그램은 파일 서비스 REST API를 통해 공유에 파일 데이터에 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="29ba0-152">On-premises applications can access file data in a share via the File service REST API.</span></span>

-   <span data-ttu-id="29ba0-153">테이블 저장소는 구조화 된 데이터 집합을 저장 합니다.</span><span class="sxs-lookup"><span data-stu-id="29ba0-153">Table storage stores structured datasets.</span></span> <span data-ttu-id="29ba0-154">테이블 저장소는 신속 하 게 개발 및 많은 양의 데이터에 빠르게 액세스할 수 있도록 하는 NoSQL 키-특성 데이터 저장소.</span><span class="sxs-lookup"><span data-stu-id="29ba0-154">Table storage is a NoSQL key-attribute data store, which allows rapid development and fast access to large quantities of data.</span></span>

<span data-ttu-id="29ba0-155">**관계형 데이터베이스 및 NoSQL 데이터베이스입니다.**</span><span class="sxs-lookup"><span data-stu-id="29ba0-155">**Relational databases and NoSQL databases.**</span></span> <span data-ttu-id="29ba0-156">Azure Cosmos DB, MongoDB 등과 같은 SQL Server, PostgreSQL, Oracle 또는 NoSQL 데이터베이스와 같은 관계형 데이터베이스에서 외부 데이터베이스에 대 한 여러 가지 있습니다. 이러한 데이터베이스는 완전히 다른 주체에 있으므로이 가이드의 일부로 설명 하지 것입니다.</span><span class="sxs-lookup"><span data-stu-id="29ba0-156">There are many choices for external databases, from relational databases like SQL Server, PostgreSQL, Oracle, or NoSQL databases like Azure Cosmos DB, MongoDB, etc. These databases are not going to be explained as part of this guide since they are in a completely different subject.</span></span>


>[!div class="step-by-step"]
<span data-ttu-id="29ba0-157">[이전] (컨테이너 화할-모놀리식-applications.md) [다음] (서비스-지향-architecture.md)</span><span class="sxs-lookup"><span data-stu-id="29ba0-157">[Previous] (containerize-monolithic-applications.md) [Next] (service-oriented-architecture.md)</span></span>

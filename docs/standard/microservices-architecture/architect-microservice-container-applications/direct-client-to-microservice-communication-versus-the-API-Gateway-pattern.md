---
title: 클라이언트-마이크로 서비스 간 직접 통신과 API 게이트웨이 패턴 비교
description: 컨테이너화된 .NET 응용 프로그램에 대한 .NET 마이크로 서비스 아키텍처 | 클라이언트-마이크로 서비스 간 통신과 API 게이트웨이 패턴 비교
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 10/18/2017
ms.openlocfilehash: 40accd8e881c9667f69a61c98da1d013d28e7da6
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 05/04/2018
---
# <a name="direct-client-to-microservice-communication-versus-the-api-gateway-pattern"></a>클라이언트-마이크로 서비스 간 직접 통신과 API 게이트웨이 패턴 비교

마이크로 서비스 아키텍처에서 각 마이크로 서비스는 일반적으로 미세 엔드포인트의 집합을 노출합니다. 이 사실은 이 섹션에 설명된 대로 클라이언트-마이크로 서비스 간 통신에 영향을 줄 수 있습니다.

## <a name="direct-client-to-microservice-communication"></a>클라이언트-마이크로 서비스 간 직접 통신

가능한 방법은 클라이언트-마이크로 서비스 간 직접 통신 아키텍처를 사용하는 것입니다. 이 방법에서 클라이언트 앱은 그림 4-12에 나와 있는 것처럼 일부 마이크로 서비스에 직접 요청을 만듭니다.

![](./media/image12.png)

**그림 4-12**. 클라이언트-마이크로 서비스 간 직접 통신 아키텍처 사용

이 방법에서 각 마이크로 서비스에 공용 엔드포인트가 있으며 경우에 따라 각 마이크로 서비스에 대해 다른 TCP 포트가 있을 수 있습니다. 특정 서비스에 대한 URL의 예는 Azure에서 다음 URL을 참조하세요.

<http://eshoponcontainers.westus.cloudapp.azure.com:88/>

클러스터에 기반한 프로덕션 환경에서는 해당 URL이 클러스터에서 사용되는 부하 분산 장치에 매핑하고, 이어서 요청을 마이크로 서비스에 분산하게 됩니다. 프로덕션 환경에서는 마이크로 서비스와 인터넷 사이에 [Azure Application Gateway](https://docs.microsoft.com/azure/application-gateway/application-gateway-introduction)와 같은 ADC(응용 프로그램 배달 컨트롤러)를 사용할 수 있습니다. 이는 부하 분산을 수행할 뿐 아니라 SSL 종료를 제공하여 서비스를 보호하는 투명한 계층으로 작동합니다. 이는 CPU 집중적 SSL 종료 및 Azure Application Gateway로의 라우팅 듀티를 오프로딩하여 호스트의 로드를 증가시킵니다. 어떤 경우든 부하 분산 장치 및 ADC는 논리적 응용 프로그램 아키텍처 관점에서 투명합니다.

클라이언트-마이크로 서비스 간 직접 통신 아키텍처는 소규모 마이크로 서비스 기반 응용 프로그램에, 특히 클라이언트 앱이 ASP.NET MVC 앱과 같은 서버 쪽 웹 응용 프로그램인 경우에 적합합니다. 그러나 대규모 또는 복잡한 마이크로 서비스 기반 응용 프로그램을 빌드할 때(예: 마이크로 서비스 형식을 수십 번 처리하는 경우), 그리고 특히 클라이언트 앱이 원격 모바일 앱 또는 SPA 웹 응용 프로그램인 경우에는 해당 방식에 몇 가지 문제가 있습니다.

마이크로 서비스 기반의 대규모 응용 프로그램을 개발할 때 다음과 같은 질문을 고려합니다.

-   *클라이언트 앱이 백 엔드에 대한 요청 수를 최소화하고 여러 마이크로 서비스에 대한 번거로운 통신을 줄이려면 어떻게 해야 할까요?*

여러 마이크로 서비스와 상호 작용하여 단일 UI 화면을 빌드하면 인터넷에서 왕복 수가 증가합니다. 그러면 대기 시간 및 UI 쪽 복잡성이 증가합니다. 이상적으로 응답은 서버 쪽에서 효율적으로 집계됩니다. 이렇게 하면 여러 데이터 조각이 동시에 돌아오고, 일부 UI는 준비되는 즉시 데이터를 표시하기 때문에 대기 시간이 줄어듭니다.

-   *권한 부여, 데이터 변환 및 동적 요청 디스패치와 같은 교차 편집 문제를 처리하려면 어떻게 해야 할까요?*

모든 마이크로 서비스의 보안 및 권한 부여와 같은 보안 및 교차 편집 문제를 구현하려면 상당한 개발 노력이 필요할 수 있습니다. 가능한 방법은 외부에서 직접 액세스하지 못하도록 제한하고 그러한 교차 편집 문제를 API 게이트웨이와 같은 중앙 집중식으로 구현하도록 그러한 서비스를 Docker 호스트 또는 내부 클러스터 내에 두는 것입니다.

-   *클라이언트 앱이 인터넷 친화적이 아닌 프로토콜을 사용하는 서비스와 통신하려면 어떻게 해야 할까요?*

서버 쪽에서 사용되는 프로토콜(예: AMQP 또는 이진 프로토콜)은 일반적으로 클라이언트 앱에서 지원되지 않습니다. 따라서 요청은 HTTP/HTTPS와 같은 프로토콜을 통해 수행되고 나중에 다른 프로토콜로 변환해야 합니다. *메시지 가로채기(man-in-the-middle)* 방식은 이 경우 도움이 될 수 있습니다.

-   *모바일 앱에 대해 특별히 제작한 외관을 만들려면 어떻게 해야 할까요?*

여러 마이크로 서비스의 API는 다른 클라이언트 응용 프로그램의 요구 사항에 적합하지 않게 디자인되었을 수 있습니다. 예를 들어 모바일 앱의 요구는 웹앱의 요구와 다를 수 있습니다. 모바일 앱의 경우 데이터 응답이 더 효율적일 수 있도록 더욱 최적화해야 할 수 있습니다. 이는 여러 마이크로 서비스에서 데이터를 집계하고, 단일 데이터 집합을 반환하며, 경우에 따라 모바일 앱에 필요하지 않은 응답의 모든 데이터를 제거하여 수행할 수 있습니다. 또한 물론 해당 데이터를 압축할 수도 있습니다. 다시, 모바일 앱과 마이크로 서비스 간 외관 또는 API는 이 시나리오에 편리할 수 있습니다.

## <a name="using-an-api-gateway"></a>API 게이트웨이 사용

여러 클라이언트 앱이 있는 대규모 또는 복잡한 마이크로 서비스 기반 응용 프로그램을 디자인하고 빌드하는 경우 [API 게이트웨이](https://microservices.io/patterns/apigateway.html)가 고려할 좋은 방법일 수 있습니다. 이는 마이크로 서비스의 특정 그룹에 단일 진입점을 제공하는 서비스입니다. 개체 지향 디자인의 [외관 패턴](https://en.wikipedia.org/wiki/Facade_pattern)과 유사하지만, 이 경우 분산된 시스템의 일부입니다. 또한 클라이언트 앱의 요구 사항을 고려하면서 빌드하였기 때문에 API 게이트웨이 패턴을 “[BFF](https://samnewman.io/patterns/architectural/bff/)(프런트 엔드를 위한 백 엔드)”라고도 합니다.

그림 4-13에 사용자 지정 API 게이트웨이가 어떻게 마이크로 서비스 기반 아키텍처에 적합한지가 나와 있습니다.
해당 다이어그램에서 여러 다른 클라이언트 앱에 직면하는 단일 사용자 지정 API 게이트웨이 서비스를 사용한다는 점을 강조하는 게 중요합니다. 사용자의 API 게이트웨이 서비스는 클라이언트 앱의 다양하고 많은 요구 사항을 기반으로 늘어나고 진화하므로 그러한 사실은 중요한 위험입니다. 결국 이러한 다른 요구 사항으로 인해 너무 커지면 사실상 모놀리식 응용 프로그램 또는 모놀리식 서비스와 상당히 비슷할 수 있습니다. 그래서 예를 들어 폼 팩터 형식당 하나와 같이 API 게이트웨이를 여러 서비스 또는 더 작은 여러 API 게이트웨이로 분할하는 것이 강력히 권장됩니다.

![](./media/image13.png)

**그림 4-13**. 사용자 지정 Web API 서비스로 구현된 API 게이트웨이 사용

이 예제에서는 API 게이트웨이가 컨테이너로 실행 중인 사용자 지정 Web API 서비스로 구현됩니다.

앞에서 설명한 것처럼 각 클라이언트 앱의 요구 사항에 대한 다른 외관을 가질 수 있도록 여러 API 게이트웨이를 구현해야 합니다. 각 API 게이트웨이는 여러 내부 마이크로 서비스의 호출 아래에 있는 특정 어댑터 코드를 구현하여 가능한 클라이언트 폼 팩터에 기반한 각 클라이언트 앱에 맞춰진 다른 API를 제공할 수 있습니다.

사용자 지정 API 게이트웨이는 일반적으로 데이터 집계이므로 주의를 기울여야 합니다. 일반적으로 단일 API 게이트웨이가 응용 프로그램의 모든 내부 마이크로 서비스를 집계하도록 하지 않는 것이 좋습니다. 그렇지 않으면 모놀리식 집계 또는 오케스트레이터로 동작하며 모든 마이크로 서비스를 연결하여 마이크로 서비스 자치를 위반합니다. 따라서 API 게이트웨이는 비즈니스 경계를 기준으로 분리되어야 하며, 전체 응용 프로그램에서 집계로 작동하지 않아야 합니다.

경우에 따라 세부적인 API 게이트웨이는 자체적으로 마이크로 서비스가 될 수도 있고, 도메인이나 회사 이름 및 관련된 데이터를 가질 수도 있습니다. API 게이트웨이의 경계가 비즈니스 또는 도메인에 의해 결정되면 더 나은 디자인을 얻는 데 도움이 됩니다.

세분화된 API 게이트웨이의 개념은 UI 컴퍼지션 서비스와 유사하므로 세분화된 API 게이트웨이 계층은 마이크로 서비스 기반의 더 향상된 복합 UI 응용 프로그램에 특히 유용할 수 있습니다. 이러한 작업은 [마이크로 서비스 기반 복합 UI 만들기](#creating-composite-ui-based-on-microservices-including-visual-ui-shape-and-layout-generated-by-multiple-microservices)에서 나중에 논의합니다.

따라서 대부분의 중간 규모 및 대규모 응용 프로그램의 경우 일반적으로 사용자가 빌드한 API 게이트웨이를 사용하는 것이 좋은 방법이지만, 단일 모놀리식 집계 또는 고유한 중앙 사용자 지정 API 게이트웨이만큼은 아닙니다.

또 다른 방법은 그림 4-14에서와 같이 [Azure API Management](https://azure.microsoft.com/services/api-management/)와 같은 제품을 사용하는 것입니다. 이 방법은 API 게이트웨이 요구 사항을 해결할 뿐 아니라 API에서 정보를 수집하는 것과 같은 기능도 제공합니다. API 관리 솔루션을 사용하는 경우 API 게이트웨이는 해당 전체 API 관리 솔루션 내 구성 요소입니다.

![](./media/image14.png)

**그림 4-14**. API 게이트웨이에 Azure API Management 사용

이 경우 Azure API Management와 같은 제품을 사용할 때, 단일 API 게이트웨이가 있을 수도 있다는 사실은 그리 위험하지 않습니다. 이러한 API 게이트웨이 유형은 “더 가볍기” 때문에, 즉 모놀리식 구성 요소로 진화할 수도 있는 사용자 지정 C# 코드를 구현하지 않기 때문입니다. 

이 제품 유형은 통신 진입을 위한 역방향 프록시와 더 비슷하게 동작합니다. 또한 여기서는 내부 마이크로 서비스에서 API를 필터링하고, 이 단일 계층에 게시된 API에 권한을 적용할 수 있습니다.

API Management 시스템에서 사용할 수 있는 정보는 API가 사용되는 방식과 수행되는 방식을 이해하는 데 유용합니다. 유사한 실시간 분석 보고서를 볼 수 있으며 비즈니스에 영향을 줄 수 있는 추세를 식별하여 이를 수행합니다. 또한 요청 및 응답 작업에 관한 로그를 향후 온라인 및 오프라인 분석을 위해 보유할 수 있습니다.

Azure API Management를 통해 키, 토큰 및 IP 필터링을 사용하여 API를 보호할 수 있습니다. 이러한 기능을 사용하면 유연하고 세분화된 할당량 및 속도 제한이 가능하며, 정책을 사용하여 API의 모양과 동작을 수정하고, 응답 캐싱을 통해 성능을 향상시킬 수 있습니다.

이 가이드 및 참조 샘플 응용 프로그램(eShopOnContainers)에서 Azure API Management와 같은 PaaS 제품을 사용하지 않고 일반 컨테이너에 집중할 수 있도록 아키텍처를 더 간단하고 사용자 지정한 컨테이너화된 아키텍처로 제한했습니다. 하지만 Microsoft Azure에 배포되는 더 큰 규모의 마이크로 서비스 기반 응용 프로그램의 경우 API 게이트웨이를 위한 기준으로 Azure API Management를 검토하고 도입하는 것이 좋습니다.

## <a name="drawbacks-of-the-api-gateway-pattern"></a>API 게이트웨이 패턴의 단점

-   가장 중요한 단점은 API 게이트웨이를 구현할 때 사용자가 내부 마이크로 서비스를 사용하여 해당 계층에 결합된다는 점입니다. 이와 같은 결합으로 인해 응용 프로그램에 심각한 문제가 발생할 수 있습니다. Azure Service Bus 팀의 아키텍트인 Clemens Vaster는 GOTO 2016에서 자신의 “[메시징 및 마이크로 서비스](https://www.youtube.com/watch?v=rXi5CLjIQ9k)” 세션 중 이 잠재적 문제점을 “새로운 ESB”라고 언급합니다.

-   마이크로 서비스 API 게이트웨이를 사용하면 가능한 추가 단일 실패 지점이 만들어집니다.

-   API 게이트웨이는 추가 네트워크 호출로 인해 응답 시간 증가로 이어질 수 있습니다. 그러나 이 추가 호출은 일반적으로 내부 마이크로 서비스를 너무 빈번하게 직접 호출하는 클라이언트 인터페이스를 갖는 것보다는 적은 영향을 미칩니다.

-   제대로 스케일 아웃하지 않으면 API 게이트웨이는 병목 상태가 될 수 있습니다.

-   사용자 지정 논리 및 데이터 집계를 포함하는 경우 API 게이트웨이는 추가 개발 비용 및 향후 유지 관리가 필요합니다. 개발자는 각 마이크로 서비스의 엔드포인트를 노출하기 위해 API 게이트웨이를 업데이트해야 합니다. 또한 내부 마이크로 서비스의 구현 변경은 API 게이트웨이 수준의 코드 변경으로 이어질 수 있습니다. 그러나 API 게이트웨이가 보안, 로깅 및 버전 관리에만 적용하는 경우(Azure API Management를 사용할 때) 이 추가 개발 비용은 적용되지 않을 수 있습니다.

-   API 게이트웨이가 단일 팀에서 개발된 경우 개발 병목 상태가 있을 수 있습니다. 이것이 다양한 클라이언트 요구 사항에 응답하는 세분화된 API 게이트웨이가 여러 개인 것이 더 나은 방법인 또 다른 이유입니다. 또한 내부 마이크로 서비스에서 작업 중인 다른 팀에서 소유하는 여러 영역 또는 레이어로 API 게이트웨이를 내부적으로 구분할 수도 있습니다.

## <a name="additional-resources"></a>추가 자료

-   **Charles Richardson. 패턴: 프런트 엔드용 API 게이트웨이/백 엔드**
    [*https://microservices.io/patterns/apigateway.html*](https://microservices.io/patterns/apigateway.html)

-   **Azure API Management**
    [*https://azure.microsoft.com/services/api-management/*](https://azure.microsoft.com/services/api-management/)

-   **Udi Dahan. 서비스 지향 컴퍼지션**\
    [*http://udidahan.com/2014/07/30/service-oriented-composition-with-video/*](http://udidahan.com/2014/07/30/service-oriented-composition-with-video/)

-   **Clemens Vasters. GOTO 2016의 메시징 및 마이크로 서비스**(비디오) [*https://www.youtube.com/watch?v=rXi5CLjIQ9k*](https://www.youtube.com/watch?v=rXi5CLjIQ9k)


>[!div class="step-by-step"]
[이전] (identify-microservice-domain-model-boundaries.md) [다음] (communication-in-microservice-architecture.md)

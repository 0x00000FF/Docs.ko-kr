---
title: "클라이언트-마이크로 서비스 간 직접 통신과 API 게이트웨이 패턴 비교"
description: "컨테이너화된 .NET 응용 프로그램에 대한 .NET 마이크로 서비스 아키텍처 | 클라이언트-마이크로 서비스 간 통신과 API 게이트웨이 패턴 비교"
keywords: "Docker, 마이크로 서비스, ASP.NET, 컨테이너, API 게이트웨이"
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 10/18/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.topic: article
ms.workload:
- dotnet
- dotnetcore
ms.openlocfilehash: 96a02958ef5750aec7a92ff0dd145edc15a5953a
ms.sourcegitcommit: e7f04439d78909229506b56935a1105a4149ff3d
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 12/23/2017
---
# <a name="direct-client-to-microservice-communication-versus-the-api-gateway-pattern"></a><span data-ttu-id="ba0c4-104">클라이언트-마이크로 서비스 간 직접 통신과 API 게이트웨이 패턴 비교</span><span class="sxs-lookup"><span data-stu-id="ba0c4-104">Direct client-to-microservice communication versus the API Gateway pattern</span></span>

<span data-ttu-id="ba0c4-105">마이크로 서비스 아키텍처에서 각 마이크로 서비스는 일반적으로 미세 엔드포인트의 집합을 노출합니다.</span><span class="sxs-lookup"><span data-stu-id="ba0c4-105">In a microservices architecture, each microservice exposes a set of (typically) fine‑grained endpoints.</span></span> <span data-ttu-id="ba0c4-106">이 사실은 이 섹션에 설명된 대로 클라이언트-마이크로 서비스 간 통신에 영향을 줄 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ba0c4-106">This fact can impact the client‑to‑microservice communication, as explained in this section.</span></span>

## <a name="direct-client-to-microservice-communication"></a><span data-ttu-id="ba0c4-107">클라이언트-마이크로 서비스 간 직접 통신</span><span class="sxs-lookup"><span data-stu-id="ba0c4-107">Direct client-to-microservice communication</span></span>

<span data-ttu-id="ba0c4-108">가능한 방법은 클라이언트-마이크로 서비스 간 직접 통신 아키텍처를 사용하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="ba0c4-108">A possible approach is to use a direct client-to-microservice communication architecture.</span></span> <span data-ttu-id="ba0c4-109">이 방법에서 클라이언트 앱은 그림 4-12에 나와 있는 것처럼 일부 마이크로 서비스에 직접 요청을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="ba0c4-109">In this approach, a client app can make requests directly to some of the microservices, as shown in Figure 4-12.</span></span>

![](./media/image12.png)

<span data-ttu-id="ba0c4-110">**그림 4-12**.</span><span class="sxs-lookup"><span data-stu-id="ba0c4-110">**Figure 4-12**.</span></span> <span data-ttu-id="ba0c4-111">클라이언트-마이크로 서비스 간 직접 통신 아키텍처 사용</span><span class="sxs-lookup"><span data-stu-id="ba0c4-111">Using a direct client-to-microservice communication architecture</span></span>

<span data-ttu-id="ba0c4-112">이 방법에서</span><span class="sxs-lookup"><span data-stu-id="ba0c4-112">In this approach.</span></span> <span data-ttu-id="ba0c4-113">각 마이크로 서비스에 공용 엔드포인트가 있으며 경우에 따라 각 마이크로 서비스에 대해 다른 TCP 포트가 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ba0c4-113">each microservice has a public endpoint, sometimes with a different TCP port for each microservice.</span></span> <span data-ttu-id="ba0c4-114">특정 서비스에 대한 URL의 예는 Azure에서 다음 URL을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ba0c4-114">An example of a URL for a particular service could be the following URL in Azure:</span></span>

<span data-ttu-id="ba0c4-115"><http://eshoponcontainers.westus.cloudapp.azure.com:88/></span><span class="sxs-lookup"><span data-stu-id="ba0c4-115"><http://eshoponcontainers.westus.cloudapp.azure.com:88/></span></span>

<span data-ttu-id="ba0c4-116">클러스터에 기반한 프로덕션 환경에서는 해당 URL이 클러스터에서 사용되는 부하 분산 장치에 매핑하고, 이어서 요청을 마이크로 서비스에 분산하게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ba0c4-116">In a production environment based on a cluster, that URL would map to the load balancer used in the cluster, which in turn distributes the requests across the microservices.</span></span> <span data-ttu-id="ba0c4-117">프로덕션 환경에서는 마이크로 서비스와 인터넷 사이에 [Azure Application Gateway](https://docs.microsoft.com/azure/application-gateway/application-gateway-introduction)와 같은 ADC(응용 프로그램 배달 컨트롤러)를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ba0c4-117">In production environments, you could have an Application Delivery Controller (ADC) like [Azure Application Gateway](https://docs.microsoft.com/azure/application-gateway/application-gateway-introduction) between your microservices and the Internet.</span></span> <span data-ttu-id="ba0c4-118">이는 부하 분산을 수행할 뿐 아니라 SSL 종료를 제공하여 서비스를 보호하는 투명한 계층으로 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="ba0c4-118">This acts as a transparent tier that not only performs load balancing, but secures your services by offering SSL termination.</span></span> <span data-ttu-id="ba0c4-119">이는 CPU 집중적 SSL 종료 및 Azure Application Gateway로의 라우팅 듀티를 오프로딩하여 호스트의 로드를 증가시킵니다.</span><span class="sxs-lookup"><span data-stu-id="ba0c4-119">This improves the load of your hosts by offloading CPU-intensive SSL termination and other routing duties to the Azure Application Gateway.</span></span> <span data-ttu-id="ba0c4-120">어떤 경우든 부하 분산 장치 및 ADC는 논리적 응용 프로그램 아키텍처 관점에서 투명합니다.</span><span class="sxs-lookup"><span data-stu-id="ba0c4-120">In any case, a load balancer and ADC are transparent from a logical application architecture point of view.</span></span>

<span data-ttu-id="ba0c4-121">클라이언트-마이크로 서비스 간 직접 통신 아키텍처는 소규모 마이크로 서비스 기반 응용 프로그램에, 특히 클라이언트 앱이 ASP.NET MVC 앱과 같은 서버 쪽 웹 응용 프로그램인 경우에 적합합니다.</span><span class="sxs-lookup"><span data-stu-id="ba0c4-121">A direct client-to-microservice communication architecture could be good enough for a small microservice-based application, especially if the client app is a server-side web application like an ASP.NET MVC app.</span></span> <span data-ttu-id="ba0c4-122">그러나 대규모 또는 복잡한 마이크로 서비스 기반 응용 프로그램을 빌드할 때(예: 마이크로 서비스 형식을 수십 번 처리하는 경우), 그리고 특히 클라이언트 앱이 원격 모바일 앱 또는 SPA 웹 응용 프로그램인 경우에는 해당 방식에 몇 가지 문제가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ba0c4-122">However, when you build large and complex microservice-based applications (for example, when handling dozens of microservice types), and especially when the client apps are remote mobile apps or SPA web applications, that approach faces a few issues.</span></span>

<span data-ttu-id="ba0c4-123">마이크로 서비스 기반의 대규모 응용 프로그램을 개발할 때 다음과 같은 질문을 고려합니다.</span><span class="sxs-lookup"><span data-stu-id="ba0c4-123">Consider the following questions when developing a large application based on microservices:</span></span>

-   <span data-ttu-id="ba0c4-124">*클라이언트 앱이 백 엔드에 대한 요청 수를 최소화하고 여러 마이크로 서비스에 대한 번거로운 통신을 줄이려면 어떻게 해야 할까요?*</span><span class="sxs-lookup"><span data-stu-id="ba0c4-124">*How can client apps minimize the number of requests to the backend and reduce chatty communication to multiple microservices?*</span></span>

<span data-ttu-id="ba0c4-125">여러 마이크로 서비스와 상호 작용하여 단일 UI 화면을 빌드하면 인터넷에서 왕복 수가 증가합니다.</span><span class="sxs-lookup"><span data-stu-id="ba0c4-125">Interacting with multiple microservices to build a single UI screen increases the number of roundtrips across the Internet.</span></span> <span data-ttu-id="ba0c4-126">그러면 대기 시간 및 UI 쪽 복잡성이 증가합니다.</span><span class="sxs-lookup"><span data-stu-id="ba0c4-126">This increases latency and complexity on the UI side.</span></span> <span data-ttu-id="ba0c4-127">이상적으로 응답은 서버 쪽에서 효율적으로 집계됩니다. 이렇게 하면 여러 데이터 조각이 동시에 돌아오고, 일부 UI는 준비되는 즉시 데이터를 표시하기 때문에 대기 시간이 줄어듭니다.</span><span class="sxs-lookup"><span data-stu-id="ba0c4-127">Ideally, responses should be efficiently aggregated in the server side—this reduces latency, since multiple pieces of data come back in parallel and some UI can show data as soon as it is ready.</span></span>

-   <span data-ttu-id="ba0c4-128">*권한 부여, 데이터 변환 및 동적 요청 디스패치와 같은 교차 편집 문제를 처리하려면 어떻게 해야 할까요?*</span><span class="sxs-lookup"><span data-stu-id="ba0c4-128">*How can you handle cross-cutting concerns such as authorization, data transformations, and dynamic request dispatching?*</span></span>

<span data-ttu-id="ba0c4-129">모든 마이크로 서비스의 보안 및 권한 부여와 같은 보안 및 교차 편집 문제를 구현하려면 상당한 개발 노력이 필요할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ba0c4-129">Implementing security and cross-cutting concerns like security and authorization on every microservice can require significant development effort.</span></span> <span data-ttu-id="ba0c4-130">가능한 방법은 외부에서 직접 액세스하지 못하도록 제한하고 그러한 교차 편집 문제를 API 게이트웨이와 같은 중앙 집중식으로 구현하도록 그러한 서비스를 Docker 호스트 또는 내부 클러스터 내에 두는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="ba0c4-130">A possible approach is to have those services within the Docker host or internal cluster, in order to restrict direct access to them from the outside, and to implement those cross-cutting concerns in a centralized place, like an API Gateway.</span></span>

-   <span data-ttu-id="ba0c4-131">*클라이언트 앱이 인터넷 친화적이 아닌 프로토콜을 사용하는 서비스와 통신하려면 어떻게 해야 할까요?*</span><span class="sxs-lookup"><span data-stu-id="ba0c4-131">*How can client apps communicate with services that use non-Internet-friendly protocols?*</span></span>

<span data-ttu-id="ba0c4-132">서버 쪽에서 사용되는 프로토콜(예: AMQP 또는 이진 프로토콜)은 일반적으로 클라이언트 앱에서 지원되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ba0c4-132">Protocols used on the server side (like AMQP or binary protocols) are usually not supported in client apps.</span></span> <span data-ttu-id="ba0c4-133">따라서 요청은 HTTP/HTTPS와 같은 프로토콜을 통해 수행되고 나중에 다른 프로토콜로 변환해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ba0c4-133">Therefore, requests must be performed through protocols like HTTP/HTTPS and translated to the other protocols afterwards.</span></span> <span data-ttu-id="ba0c4-134">*메시지 가로채기(man-in-the-middle)* 방식은 이 경우 도움이 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ba0c4-134">A *man-in-the-middle* approach can help in this situation.</span></span>

-   <span data-ttu-id="ba0c4-135">*모바일 앱에 대해 특별히 제작한 외관을 만들려면 어떻게 해야 할까요?*</span><span class="sxs-lookup"><span data-stu-id="ba0c4-135">*How can you shape a façade especially made for mobile apps?*</span></span>

<span data-ttu-id="ba0c4-136">여러 마이크로 서비스의 API는 다른 클라이언트 응용 프로그램의 요구 사항에 적합하지 않게 디자인되었을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ba0c4-136">The API of multiple microservices might not be well designed for the needs of different client applications.</span></span> <span data-ttu-id="ba0c4-137">예를 들어 모바일 앱의 요구는 웹앱의 요구와 다를 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ba0c4-137">For instance, the needs of a mobile app might be different than the needs of a web app.</span></span> <span data-ttu-id="ba0c4-138">모바일 앱의 경우 데이터 응답이 더 효율적일 수 있도록 더욱 최적화해야 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ba0c4-138">For mobile apps, you might need to optimize even further so that data responses can be more efficient.</span></span> <span data-ttu-id="ba0c4-139">이는 여러 마이크로 서비스에서 데이터를 집계하고, 단일 데이터 집합을 반환하며, 경우에 따라 모바일 앱에 필요하지 않은 응답의 모든 데이터를 제거하여 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ba0c4-139">You might do this by aggregating data from multiple microservices and returning a single set of data, and sometimes eliminating any data in the response that is not needed by the mobile app.</span></span> <span data-ttu-id="ba0c4-140">또한 물론 해당 데이터를 압축할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ba0c4-140">And, of course, you might compress that data.</span></span> <span data-ttu-id="ba0c4-141">다시, 모바일 앱과 마이크로 서비스 간 외관 또는 API는 이 시나리오에 편리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ba0c4-141">Again, a façade or API in between the mobile app and the microservices can be convenient for this scenario.</span></span>

## <a name="using-an-api-gateway"></a><span data-ttu-id="ba0c4-142">API 게이트웨이 사용</span><span class="sxs-lookup"><span data-stu-id="ba0c4-142">Using an API Gateway</span></span>

<span data-ttu-id="ba0c4-143">여러 클라이언트 앱이 있는 대규모 또는 복잡한 마이크로 서비스 기반 응용 프로그램을 디자인하고 빌드하는 경우 [API 게이트웨이](http://microservices.io/patterns/apigateway.html)가 고려할 좋은 방법일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ba0c4-143">When you design and build large or complex microservice-based applications with multiple client apps, a good approach to consider can be an [API Gateway](http://microservices.io/patterns/apigateway.html).</span></span> <span data-ttu-id="ba0c4-144">이는 마이크로 서비스의 특정 그룹에 단일 진입점을 제공하는 서비스입니다.</span><span class="sxs-lookup"><span data-stu-id="ba0c4-144">This is a service that provides a single entry point for certain groups of microservices.</span></span> <span data-ttu-id="ba0c4-145">개체 지향 디자인의 [외관 패턴](https://en.wikipedia.org/wiki/Facade_pattern)과 유사하지만, 이 경우 분산된 시스템의 일부입니다.</span><span class="sxs-lookup"><span data-stu-id="ba0c4-145">It is similar to the [Facade pattern](https://en.wikipedia.org/wiki/Facade_pattern) from object‑oriented design, but in this case, it is part of a distributed system.</span></span> <span data-ttu-id="ba0c4-146">또한 클라이언트 앱의 요구 사항을 고려하면서 빌드하였기 때문에 API 게이트웨이 패턴을 “[BFF](http://samnewman.io/patterns/architectural/bff/)(프런트 엔드를 위한 백 엔드)”라고도 합니다.</span><span class="sxs-lookup"><span data-stu-id="ba0c4-146">The API Gateway pattern is also sometimes known as the “backend for frontend” [(BFF)](http://samnewman.io/patterns/architectural/bff/) because you build it while thinking about the needs of the client app.</span></span>

<span data-ttu-id="ba0c4-147">그림 4-13에 사용자 지정 API 게이트웨이가 어떻게 마이크로 서비스 기반 아키텍처에 적합한지가 나와 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ba0c4-147">Figure 4-13 shows how a custom API Gateway can fit into a microservice-based architecture.</span></span>
<span data-ttu-id="ba0c4-148">해당 다이어그램에서 여러 다른 클라이언트 앱에 직면하는 단일 사용자 지정 API 게이트웨이 서비스를 사용한다는 점을 강조하는 게 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="ba0c4-148">It is important to highlight that in that diagram, you would be using a single custom API Gateway service facing multiple and different client apps.</span></span> <span data-ttu-id="ba0c4-149">사용자의 API 게이트웨이 서비스는 클라이언트 앱의 다양하고 많은 요구 사항을 기반으로 늘어나고 진화하므로 그러한 사실은 중요한 위험입니다.</span><span class="sxs-lookup"><span data-stu-id="ba0c4-149">That fact can be an important risk because your API Gateway service will be growing and evolving based on many different requirements from the client apps.</span></span> <span data-ttu-id="ba0c4-150">결국 이러한 다른 요구 사항으로 인해 너무 커지면 사실상 모놀리식 응용 프로그램 또는 모놀리식 서비스와 상당히 비슷할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ba0c4-150">Eventually, it will be bloated because of those different needs and effectively it could be pretty similar to a monolithic application or monolithic service.</span></span> <span data-ttu-id="ba0c4-151">그래서 예를 들어 폼 팩터 형식당 하나와 같이 API 게이트웨이를 여러 서비스 또는 더 작은 여러 API 게이트웨이로 분할하는 것이 강력히 권장됩니다.</span><span class="sxs-lookup"><span data-stu-id="ba0c4-151">That is why it is very much recommended to split the API Gateway in multiple services or multiple smaller API Gateways, one per form-factor type, for instance.</span></span>

![](./media/image13.png)

<span data-ttu-id="ba0c4-152">**그림 4-13**.</span><span class="sxs-lookup"><span data-stu-id="ba0c4-152">**Figure 4-13**.</span></span> <span data-ttu-id="ba0c4-153">사용자 지정 Web API 서비스로 구현된 API 게이트웨이 사용</span><span class="sxs-lookup"><span data-stu-id="ba0c4-153">Using an API Gateway implemented as a custom Web API service</span></span>

<span data-ttu-id="ba0c4-154">이 예제에서는 API 게이트웨이가 컨테이너로 실행 중인 사용자 지정 Web API 서비스로 구현됩니다.</span><span class="sxs-lookup"><span data-stu-id="ba0c4-154">In this example, the API Gateway would be implemented as a custom Web API service running as a container.</span></span>

<span data-ttu-id="ba0c4-155">앞에서 설명한 것처럼 각 클라이언트 앱의 요구 사항에 대한 다른 외관을 가질 수 있도록 여러 API 게이트웨이를 구현해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ba0c4-155">As mentioned, you should implement several API Gateways so that you can have a different façade for the needs of each client app.</span></span> <span data-ttu-id="ba0c4-156">각 API 게이트웨이는 여러 내부 마이크로 서비스의 호출 아래에 있는 특정 어댑터 코드를 구현하여 가능한 클라이언트 폼 팩터에 기반한 각 클라이언트 앱에 맞춰진 다른 API를 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ba0c4-156">Each API Gateway can provide a different API tailored for each client app, possibly even based on the client form factor by implementing specific adapter code which underneath calls multiple internal microservices.</span></span>

<span data-ttu-id="ba0c4-157">사용자 지정 API 게이트웨이는 일반적으로 데이터 집계이므로 주의를 기울여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ba0c4-157">Since a custom API Gateway is usually a data aggregator, you need to be careful with it.</span></span> <span data-ttu-id="ba0c4-158">일반적으로 단일 API 게이트웨이가 응용 프로그램의 모든 내부 마이크로 서비스를 집계하도록 하지 않는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="ba0c4-158">Usually it isn't a good idea to have a single API Gateway aggregating all the internal microservices of your application.</span></span> <span data-ttu-id="ba0c4-159">그렇지 않으면 모놀리식 집계 또는 오케스트레이터로 동작하며 모든 마이크로 서비스를 연결하여 마이크로 서비스 자치를 위반합니다.</span><span class="sxs-lookup"><span data-stu-id="ba0c4-159">If it does, it acts as a monolithic aggregator or orchestrator and violates microservice autonomy by coupling all the microservices.</span></span> <span data-ttu-id="ba0c4-160">따라서 API 게이트웨이는 비즈니스 경계를 기준으로 분리되어야 하며, 전체 응용 프로그램에서 집계로 작동하지 않아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ba0c4-160">Therefore, the API Gateways should be segregated based on business boundaries and not act as an aggregator for the whole application.</span></span>

<span data-ttu-id="ba0c4-161">경우에 따라 세부적인 API 게이트웨이는 자체적으로 마이크로 서비스가 될 수도 있고, 도메인이나 회사 이름 및 관련된 데이터를 가질 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ba0c4-161">Sometimes a granular API Gateway can also be a microservice by itself, and even have a domain or business name and related data.</span></span> <span data-ttu-id="ba0c4-162">API 게이트웨이의 경계가 비즈니스 또는 도메인에 의해 결정되면 더 나은 디자인을 얻는 데 도움이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ba0c4-162">Having the API Gateway’s boundaries dictated by the business or domain will help you to get a better design.</span></span>

<span data-ttu-id="ba0c4-163">세분화된 API 게이트웨이의 개념은 UI 컴퍼지션 서비스와 유사하므로 세분화된 API 게이트웨이 계층은 마이크로 서비스 기반의 더 향상된 복합 UI 응용 프로그램에 특히 유용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ba0c4-163">Granularity in the API Gateway tier can be especially useful for more advanced composite UI applications based on microservices, because the concept of a fine-grained API Gateway is similar to a UI composition service.</span></span> <span data-ttu-id="ba0c4-164">이러한 작업은 [마이크로 서비스 기반 복합 UI 만들기](#creating-composite-ui-based-on-microservices-including-visual-ui-shape-and-layout-generated-by-multiple-microservices)에서 나중에 논의합니다.</span><span class="sxs-lookup"><span data-stu-id="ba0c4-164">We discuss this later in the [Creating composite UI based on microservices](#creating-composite-ui-based-on-microservices-including-visual-ui-shape-and-layout-generated-by-multiple-microservices).</span></span>

<span data-ttu-id="ba0c4-165">따라서 대부분의 중간 규모 및 대규모 응용 프로그램의 경우 일반적으로 사용자가 빌드한 API 게이트웨이를 사용하는 것이 좋은 방법이지만, 단일 모놀리식 집계 또는 고유한 중앙 사용자 지정 API 게이트웨이만큼은 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="ba0c4-165">Therefore, for many medium- and large-size applications, using a custom-built API Gateway is usually a good approach, but not as a single monolithic aggregator or unique central custom API Gateway.</span></span>

<span data-ttu-id="ba0c4-166">또 다른 방법은 그림 4-14에서와 같이 [Azure API Management](https://azure.microsoft.com/services/api-management/)와 같은 제품을 사용하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="ba0c4-166">Another approach is to use a product like [Azure API Management](https://azure.microsoft.com/services/api-management/) as shown in Figure 4-14.</span></span> <span data-ttu-id="ba0c4-167">이 방법은 API 게이트웨이 요구 사항을 해결할 뿐 아니라 API에서 정보를 수집하는 것과 같은 기능도 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="ba0c4-167">This approach not only solves your API Gateway needs, but provides features like gathering insights from your APIs.</span></span> <span data-ttu-id="ba0c4-168">API 관리 솔루션을 사용하는 경우 API 게이트웨이는 해당 전체 API 관리 솔루션 내 구성 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="ba0c4-168">If you are using an API management solution, an API Gateway is only a component within that full API management solution.</span></span>

![](./media/image14.png)

<span data-ttu-id="ba0c4-169">**그림 4-14**.</span><span class="sxs-lookup"><span data-stu-id="ba0c4-169">**Figure 4-14**.</span></span> <span data-ttu-id="ba0c4-170">API 게이트웨이에 Azure API Management 사용</span><span class="sxs-lookup"><span data-stu-id="ba0c4-170">Using Azure API Management for your API Gateway</span></span>

<span data-ttu-id="ba0c4-171">이 경우 Azure API Management와 같은 제품을 사용할 때, 단일 API 게이트웨이가 있을 수도 있다는 사실은 그리 위험하지 않습니다. 이러한 API 게이트웨이 유형은 “더 가볍기” 때문에, 즉 모놀리식 구성 요소로 진화할 수도 있는 사용자 지정 C# 코드를 구현하지 않기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="ba0c4-171">In this case, when using a product like Azure API Management, the fact that you might have a single API Gateway is not so risky because these kinds of API Gateways are "thinner", meaning that you don't implement custom C# code that could evolve towards a monolithic component.</span></span> 

<span data-ttu-id="ba0c4-172">이 제품 유형은 통신 진입을 위한 역방향 프록시와 더 비슷하게 동작합니다. 또한 여기서는 내부 마이크로 서비스에서 API를 필터링하고, 이 단일 계층에 게시된 API에 권한을 적용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ba0c4-172">This type of product acts more like a reverse proxy for ingress communication, where you can also filter the APIs from the internal microservices plus apply authorization to the published APIs in this single tier.</span></span>

<span data-ttu-id="ba0c4-173">API Management 시스템에서 사용할 수 있는 정보는 API가 사용되는 방식과 수행되는 방식을 이해하는 데 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="ba0c4-173">The insights available from an API Management system help you get an understanding of how your APIs are being used and how they are performing.</span></span> <span data-ttu-id="ba0c4-174">유사한 실시간 분석 보고서를 볼 수 있으며 비즈니스에 영향을 줄 수 있는 추세를 식별하여 이를 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="ba0c4-174">They do this by letting you view near real-time analytics reports and identifying trends that might impact your business.</span></span> <span data-ttu-id="ba0c4-175">또한 요청 및 응답 작업에 관한 로그를 향후 온라인 및 오프라인 분석을 위해 보유할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ba0c4-175">Plus, you can have logs about request and response activity for further online and offline analysis.</span></span>

<span data-ttu-id="ba0c4-176">Azure API Management를 통해 키, 토큰 및 IP 필터링을 사용하여 API를 보호할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ba0c4-176">With Azure API Management, you can secure your APIs using a key, a token, and IP filtering.</span></span> <span data-ttu-id="ba0c4-177">이러한 기능을 사용하면 유연하고 세분화된 할당량 및 속도 제한이 가능하며, 정책을 사용하여 API의 모양과 동작을 수정하고, 응답 캐싱을 통해 성능을 향상시킬 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ba0c4-177">These features let you enforce flexible and fine-grained quotas and rate limits, modify the shape and behavior of your APIs using policies, and improve performance with response caching.</span></span>

<span data-ttu-id="ba0c4-178">이 가이드 및 참조 샘플 응용 프로그램(eShopOnContainers)에서 Azure API Management와 같은 PaaS 제품을 사용하지 않고 일반 컨테이너에 집중할 수 있도록 아키텍처를 더 간단하고 사용자 지정한 컨테이너화된 아키텍처로 제한했습니다.</span><span class="sxs-lookup"><span data-stu-id="ba0c4-178">In this guide and the reference sample application (eShopOnContainers), we are limiting the architecture to a simpler and custom-made containerized architecture in order to focus on plain containers without using PaaS products like Azure API Management.</span></span> <span data-ttu-id="ba0c4-179">하지만 Microsoft Azure에 배포되는 더 큰 규모의 마이크로 서비스 기반 응용 프로그램의 경우 API 게이트웨이를 위한 기준으로 Azure API Management를 검토하고 도입하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="ba0c4-179">But for large microservice-based applications that are deployed into Microsoft Azure, we encourage you to review and adopt Azure API Management as the base for your API Gateways.</span></span>

## <a name="drawbacks-of-the-api-gateway-pattern"></a><span data-ttu-id="ba0c4-180">API 게이트웨이 패턴의 단점</span><span class="sxs-lookup"><span data-stu-id="ba0c4-180">Drawbacks of the API Gateway pattern</span></span>

-   <span data-ttu-id="ba0c4-181">가장 중요한 단점은 API 게이트웨이를 구현할 때 사용자가 내부 마이크로 서비스를 사용하여 해당 계층에 결합된다는 점입니다.</span><span class="sxs-lookup"><span data-stu-id="ba0c4-181">The most important drawback is that when you implement an API Gateway, you are coupling that tier with the internal microservices.</span></span> <span data-ttu-id="ba0c4-182">이와 같은 결합으로 인해 응용 프로그램에 심각한 문제가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ba0c4-182">Coupling like this might introduce serious difficulties for your application.</span></span> <span data-ttu-id="ba0c4-183">Azure Service Bus 팀의 아키텍트인 Clemens Vaster는 GOTO 2016에서 자신의 “[메시징 및 마이크로 서비스](https://www.youtube.com/watch?v=rXi5CLjIQ9k)” 세션 중 이 잠재적 문제점을 “새로운 ESB”라고 언급합니다.</span><span class="sxs-lookup"><span data-stu-id="ba0c4-183">Clemens Vaster, architect at the Azure Service Bus team, refers to this potential difficulty as “the new ESB” in his "[Messaging and Microservices](https://www.youtube.com/watch?v=rXi5CLjIQ9k)" session at GOTO 2016.</span></span>

-   <span data-ttu-id="ba0c4-184">마이크로 서비스 API 게이트웨이를 사용하면 가능한 추가 단일 실패 지점이 만들어집니다.</span><span class="sxs-lookup"><span data-stu-id="ba0c4-184">Using a microservices API Gateway creates an additional possible single point of failure.</span></span>

-   <span data-ttu-id="ba0c4-185">API 게이트웨이는 추가 네트워크 호출로 인해 응답 시간 증가로 이어질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ba0c4-185">An API Gateway can introduce increased response time due to the additional network call.</span></span> <span data-ttu-id="ba0c4-186">그러나 이 추가 호출은 일반적으로 내부 마이크로 서비스를 너무 빈번하게 직접 호출하는 클라이언트 인터페이스를 갖는 것보다는 적은 영향을 미칩니다.</span><span class="sxs-lookup"><span data-stu-id="ba0c4-186">However, this extra call usually has less impact than having a client interface that is too chatty directly calling the internal microservices.</span></span>

-   <span data-ttu-id="ba0c4-187">제대로 스케일 아웃하지 않으면 API 게이트웨이는 병목 상태가 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ba0c4-187">If not scaled out properly, the API Gateway can become a bottleneck.</span></span>

-   <span data-ttu-id="ba0c4-188">사용자 지정 논리 및 데이터 집계를 포함하는 경우 API 게이트웨이는 추가 개발 비용 및 향후 유지 관리가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="ba0c4-188">An API Gateway requires additional development cost and future maintenance if it includes custom logic and data aggregation.</span></span> <span data-ttu-id="ba0c4-189">개발자는 각 마이크로 서비스의 엔드포인트를 노출하기 위해 API 게이트웨이를 업데이트해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ba0c4-189">Developers must update the API Gateway in order to expose each microservice’s endpoints.</span></span> <span data-ttu-id="ba0c4-190">또한 내부 마이크로 서비스의 구현 변경은 API 게이트웨이 수준의 코드 변경으로 이어질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ba0c4-190">Moreover, implementation changes in the internal microservices might cause code changes at the API Gateway level.</span></span> <span data-ttu-id="ba0c4-191">그러나 API 게이트웨이가 보안, 로깅 및 버전 관리에만 적용하는 경우(Azure API Management를 사용할 때) 이 추가 개발 비용은 적용되지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ba0c4-191">However, if the API Gateway is just applying security, logging, and versioning (as when using Azure API Management), this additional development cost might not apply.</span></span>

-   <span data-ttu-id="ba0c4-192">API 게이트웨이가 단일 팀에서 개발된 경우 개발 병목 상태가 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ba0c4-192">If the API Gateway is developed by a single team, there can be a development bottleneck.</span></span> <span data-ttu-id="ba0c4-193">이것이 다양한 클라이언트 요구 사항에 응답하는 세분화된 API 게이트웨이가 여러 개인 것이 더 나은 방법인 또 다른 이유입니다.</span><span class="sxs-lookup"><span data-stu-id="ba0c4-193">This is another reason why a better approach is to have several fined-grained API Gateways that respond to different client needs.</span></span> <span data-ttu-id="ba0c4-194">또한 내부 마이크로 서비스에서 작업 중인 다른 팀에서 소유하는 여러 영역 또는 레이어로 API 게이트웨이를 내부적으로 구분할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ba0c4-194">You could also segregate the API Gateway internally into multiple areas or layers that are owned by the different teams working on the internal microservices.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="ba0c4-195">추가 리소스</span><span class="sxs-lookup"><span data-stu-id="ba0c4-195">Additional resources</span></span>

-   <span data-ttu-id="ba0c4-196">**Charles Richardson. 패턴: API 게이트웨이 / 프런트 엔드를 위한 백 엔드**
    [*http://microservices.io/patterns/apigateway.html*](http://microservices.io/patterns/apigateway.html)</span><span class="sxs-lookup"><span data-stu-id="ba0c4-196">**Charles Richardson. Pattern: API Gateway / Backend for Front-End**
[*http://microservices.io/patterns/apigateway.html*](http://microservices.io/patterns/apigateway.html)</span></span>

-   <span data-ttu-id="ba0c4-197">**Azure API Management**
    [*https://azure.microsoft.com/services/api-management/*](https://azure.microsoft.com/services/api-management/)</span><span class="sxs-lookup"><span data-stu-id="ba0c4-197">**Azure API Management**
[*https://azure.microsoft.com/services/api-management/*](https://azure.microsoft.com/services/api-management/)</span></span>

-   <span data-ttu-id="ba0c4-198">**Udi Dahan. 서비스 지향 컴퍼지션**\\</span><span class="sxs-lookup"><span data-stu-id="ba0c4-198">**Udi Dahan. Service Oriented Composition**\\</span></span>
    [<span data-ttu-id="ba0c4-199">*http://udidahan.com/2014/07/30/service-oriented-composition-with-video/*</span><span class="sxs-lookup"><span data-stu-id="ba0c4-199">*http://udidahan.com/2014/07/30/service-oriented-composition-with-video/*</span></span>](http://udidahan.com/2014/07/30/service-oriented-composition-with-video/)

-   <span data-ttu-id="ba0c4-200">**Clemens Vasters. GOTO 2016에서의 메시징 및 마이크로 서비스**(비디오) [*https://www.youtube.com/watch?v=rXi5CLjIQ9k*](https://www.youtube.com/watch?v=rXi5CLjIQ9k)</span><span class="sxs-lookup"><span data-stu-id="ba0c4-200">**Clemens Vasters. Messaging and Microservices at GOTO 2016** (video) [*https://www.youtube.com/watch?v=rXi5CLjIQ9k*](https://www.youtube.com/watch?v=rXi5CLjIQ9k)</span></span>


>[!div class="step-by-step"]
<span data-ttu-id="ba0c4-201">[이전] (identify-microservice-domain-model-boundaries.md) [다음] (communication-in-microservice-architecture.md)</span><span class="sxs-lookup"><span data-stu-id="ba0c4-201">[Previous] (identify-microservice-domain-model-boundaries.md) [Next] (communication-in-microservice-architecture.md)</span></span>

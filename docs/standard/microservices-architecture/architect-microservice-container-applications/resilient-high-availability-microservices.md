---
title: 마이크로 서비스의 복원력 및 고가용성
description: 컨테이너화된 .NET 응용 프로그램을 위한 .NET 마이크로 서비스 아키텍처 | 마이크로 서비스의 복원력 및 고가용성
keywords: Docker, 마이크로 서비스, ASP.NET, 컨테이너
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 05/26/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.topic: article
ms.workload:
- dotnet
- dotnetcore
ms.openlocfilehash: 3ad3fc88a3e857f49283ff596e0385d0daad64b6
ms.sourcegitcommit: 2e8acae16ae802f2d6d04e3ce0a6dbf04e476513
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 04/18/2018
---
# <a name="resiliency-and-high-availability-in-microservices"></a><span data-ttu-id="8eabd-104">마이크로 서비스의 복원력 및 고가용성</span><span class="sxs-lookup"><span data-stu-id="8eabd-104">Resiliency and high availability in microservices</span></span>

<span data-ttu-id="8eabd-105">예기치 않은 오류를 처리하는 것은 특히 분산 시스템에서 해결하기 가장 어려운 문제 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="8eabd-105">Dealing with unexpected failures is one of the hardest problems to solve, especially in a distributed system.</span></span> <span data-ttu-id="8eabd-106">개발자가 작성하는 대부분의 코드에는 예외 처리가 포함되어 있으며 테스트하는 데 가장 많은 시간이 소요되는 부분이기도 합니다.</span><span class="sxs-lookup"><span data-stu-id="8eabd-106">Much of the code that developers write involves handling exceptions, and this is also where the most time is spent in testing.</span></span> <span data-ttu-id="8eabd-107">코드를 작성하여 오류를 처리하는 것보다 문제가 더 복잡합니다.</span><span class="sxs-lookup"><span data-stu-id="8eabd-107">The problem is more involved than writing code to handle failures.</span></span> <span data-ttu-id="8eabd-108">마이크로 서비스를 실행 중인 컴퓨터에 오류가 발생하면 어떻게 되나요?</span><span class="sxs-lookup"><span data-stu-id="8eabd-108">What happens when the machine where the microservice is running fails?</span></span> <span data-ttu-id="8eabd-109">이 마이크로 서비스 오류를 감지해야 할 뿐만 아니라(자체적으로 어려운 문제) 마이크로 서비스를 다시 시작해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8eabd-109">Not only do you need to detect this microservice failure (a hard problem on its own), but you also need something to restart your microservice.</span></span>

<span data-ttu-id="8eabd-110">마이크로 서비스는 오류에 대해 복원력이 있어야 하고 가용성을 위해 다른 컴퓨터에서 자주 다시 시작할 수 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8eabd-110">A microservice needs to be resilient to failures and to be able to restart often on another machine for availability.</span></span> <span data-ttu-id="8eabd-111">이 복원력은 또한 마이크로 서비스가 이 상태를 복구할 수 있도록 마이크로 서비스를 대신하여 미리 저장된 상태와 마이크로 서비스를 성공적으로 다시 시작할 수 있는지 여부에 달려 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8eabd-111">This resiliency also comes down to the state that was saved on behalf of the microservice, where the microservice can recover this state from, and whether the microservice can restart successfully.</span></span> <span data-ttu-id="8eabd-112">즉, 상태 또는 데이터의 복원력(데이터 손실 없음, 데이터 일관성 유지)뿐만 아니라 계산 기능(프로세스가 언제든지 다시 시작할 수 있음)에도 복원력이 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8eabd-112">In other words, there needs to be resiliency in the compute capability (the process can restart at any time) as well as resilience in the state or data (no data loss, and the data remains consistent).</span></span>

<span data-ttu-id="8eabd-113">복원력 문제는 응용 프로그램 업그레이드 중에 오류가 발생하는 경우와 같이 다른 시나리오 중에 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="8eabd-113">The problems of resiliency are compounded during other scenarios, such as when failures occur during an application upgrade.</span></span> <span data-ttu-id="8eabd-114">배포 시스템을 사용하는 마이크로 서비스는 최신 버전으로 계속 전환할지 또는 일관된 상태를 유지하기 위해 이전 버전으로 롤백할지를 결정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8eabd-114">The microservice, working with the deployment system, needs to determine whether it can continue to move forward to the newer version or instead roll back to a previous version to maintain a consistent state.</span></span> <span data-ttu-id="8eabd-115">계속 전환할 수 있을 만큼 충분한 컴퓨터가 있는지 여부, 이전 버전의 마이크로 서비스를 복구하는 방법에 대한 질문을 고려해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8eabd-115">Questions such as whether enough machines are available to keep moving forward and how to recover previous versions of the microservice need to be considered.</span></span> <span data-ttu-id="8eabd-116">전체 응용 프로그램 및 오케스트레이터에서 이러한 결정을 내릴 수 있도록 마이크로 서비스에서 상태 정보를 내보내야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8eabd-116">This requires the microservice to emit health information so that the overall application and orchestrator can make these decisions.</span></span>

<span data-ttu-id="8eabd-117">또한 복원력은 클라우드 기반 시스템의 작동 방식과 관련이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8eabd-117">In addition, resiliency is related to how cloud-based systems must behave.</span></span> <span data-ttu-id="8eabd-118">앞서 언급했듯이 클라우드 기반 시스템은 오류에 대응하여 자동으로 복구를 시도해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8eabd-118">As mentioned, a cloud-based system must embrace failures and must try to automatically recover from them.</span></span> <span data-ttu-id="8eabd-119">예를 들어, 네트워크 또는 컨테이너 오류가 발생하는 경우 많은 경우 클라우드의 오류가 부분적이기 때문에 클라이언트 앱 또는 클라이언트 서비스는 메시지 전송을 재시도하거나 요청을 재시도하는 전략을 포함해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8eabd-119">For instance, in case of network or container failures, client apps or client services must have a strategy to retry sending messages or to retry requests, since in many cases failures in the cloud are partial.</span></span> <span data-ttu-id="8eabd-120">이 가이드의 [복원력 있는 응용 프로그램 구현](#implementing_resilient_apps) 섹션에서는 부분적인 오류를 처리하는 방법에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="8eabd-120">The [Implementing Resilient Applications](#implementing_resilient_apps) section in this guide addresses how to handle partial failure.</span></span> <span data-ttu-id="8eabd-121">이 주제를 다룰 다양한 정책을 제공하는 [Polly](https://github.com/App-vNext/Polly)와 같은 라이브러리를 사용하여 .NET Core의 회로 차단기 패턴이나 지수 백오프를 통한 재시도 같은 기술을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="8eabd-121">It describes techniques like retries with exponential backoff or the Circuit Breaker pattern in .NET Core by using libraries like [Polly](https://github.com/App-vNext/Polly), which offers a large variety of policies to handle this subject.</span></span>

## <a name="health-management-and-diagnostics-in-microservices"></a><span data-ttu-id="8eabd-122">마이크로 서비스의 상태 관리 및 진단</span><span class="sxs-lookup"><span data-stu-id="8eabd-122">Health management and diagnostics in microservices</span></span>

<span data-ttu-id="8eabd-123">명백한 것 같으면서도 지나치기 쉽지만 마이크로 서비스는 해당 상태와 진단을 보고해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8eabd-123">It may seem obvious, and it is often overlooked, but a microservice must report its health and diagnostics.</span></span> <span data-ttu-id="8eabd-124">그렇지 않으면 작업 측면에서 거의 정보를 얻을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="8eabd-124">Otherwise, there is little insight from an operations perspective.</span></span> <span data-ttu-id="8eabd-125">일련의 독립된 서비스의 진단 이벤트를 상호 연결하고 이벤트 순서를 파악하기 위해 시스템 클록 불일치를 다루는 것은 어려운 문제입니다.</span><span class="sxs-lookup"><span data-stu-id="8eabd-125">Correlating diagnostic events across a set of independent services and dealing with machine clock skews to make sense of the event order is challenging.</span></span> <span data-ttu-id="8eabd-126">합의된 프로토콜 및 데이터 형식을 통해 마이크로 서비스와 상호 작용하는 것과 같은 방식으로, 궁극적으로 쿼리 및 보기를 위해 이벤트 저장소에 저장되는 상태 및 진단 이벤트를 로깅하는 방법에 대한 표준화가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="8eabd-126">In the same way that you interact with a microservice over agreed-upon protocols and data formats, there is a need for standardization in how to log health and diagnostic events that ultimately end up in an event store for querying and viewing.</span></span> <span data-ttu-id="8eabd-127">마이크로 서비스 접근 방식에서는 서로 다른 팀이 단일 로깅 형식에 동의하는 것이 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="8eabd-127">In a microservices approach, it is key that different teams agree on a single logging format.</span></span> <span data-ttu-id="8eabd-128">응용 프로그램에서는 진단 이벤트를 보는 일관된 접근 방식이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="8eabd-128">There needs to be a consistent approach to viewing diagnostic events in the application.</span></span>

### <a name="health-checks"></a><span data-ttu-id="8eabd-129">상태 확인</span><span class="sxs-lookup"><span data-stu-id="8eabd-129">Health checks</span></span>

<span data-ttu-id="8eabd-130">상태는 진단과 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="8eabd-130">Health is different from diagnostics.</span></span> <span data-ttu-id="8eabd-131">상태란 적절한 조치를 취하기 위해 현재 상태를 보고하는 마이크로 서비스에 관한 것입니다.</span><span class="sxs-lookup"><span data-stu-id="8eabd-131">Health is about the microservice reporting its current state to take appropriate actions.</span></span> <span data-ttu-id="8eabd-132">좋은 예로는 가용성을 유지하기 위해 업그레이드 및 배포 메커니즘을 사용하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="8eabd-132">A good example is working with upgrade and deployment mechanisms to maintain availability.</span></span> <span data-ttu-id="8eabd-133">서비스가 프로세스 충돌이나 컴퓨터 재부팅으로 인해 현재 상태가 좋지 않을 수도 있지만 서비스는 여전히 작동 중일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8eabd-133">Although a service might currently be unhealthy due to a process crash or machine reboot, the service might still be operational.</span></span> <span data-ttu-id="8eabd-134">마지막으로 필요한 것은 업그레이드를 수행하여 이 문제를 악화시키는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="8eabd-134">The last thing you need is to make this worse by performing an upgrade.</span></span> <span data-ttu-id="8eabd-135">가장 좋은 방법은 조사를 먼저 하거나 마이크로 서비스가 복구되는 시간을 허용하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="8eabd-135">The best approach is to do an investigation first or allow time for the microservice to recover.</span></span> <span data-ttu-id="8eabd-136">마이크로 서비스의 상태 이벤트를 통해 합리적인 의사 결정을 수행할 수 있고 실제로 자체 복구 서비스를 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8eabd-136">Health events from a microservice help us make informed decisions and, in effect, help create self-healing services.</span></span>

<span data-ttu-id="8eabd-137">이 가이드의 ASP.NET Core 서비스의 상태 확인 구현 섹션에서는 마이크로 서비스에서 새 ASP.NET HealthChecks 라이브러리를 사용하여 모니터링 서비스에 상태를 보고하고 적절한 조치를 취할 수 있는 방법을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="8eabd-137">In the Implementing health checks in ASP.NET Core services section of this guide, we explain how to use a new ASP.NET HealthChecks library in your microservices so they can report their state to a monitoring service to take appropriate actions.</span></span>

### <a name="using-diagnostics-and-logs-event-streams"></a><span data-ttu-id="8eabd-138">진단 및 로그 이벤트 스트림 사용</span><span class="sxs-lookup"><span data-stu-id="8eabd-138">Using diagnostics and logs event streams</span></span>

<span data-ttu-id="8eabd-139">로그는 예외, 경고 및 간단한 정보 메시지를 포함하여 응용 프로그램이나 서비스의 실행 방법에 대한 정보를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="8eabd-139">Logs provide information about how an application or service is running, including exceptions, warnings, and simple informational messages.</span></span> <span data-ttu-id="8eabd-140">일반적으로 각 로그는 이벤트당 하나의 줄이 있는 텍스트 형식이지만 종종 여러 줄에 걸쳐 스택 추적을 표시하는 경우도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8eabd-140">Usually, each log is in a text format with one line per event, although exceptions also often show the stack trace across multiple lines.</span></span>

<span data-ttu-id="8eabd-141">모놀리식 서버 기반 응용 프로그램에서는 로그를 디스크의 파일(로그 파일)에 기록한 다음, 모든 도구로 분석할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8eabd-141">In monolithic server-based applications, you can simply write logs to a file on disk (a logfile) and then analyze it with any tool.</span></span> <span data-ttu-id="8eabd-142">응용 프로그램 실행은 고정된 서버 또는 VM으로 제한되므로 일반적으로 이벤트 흐름을 분석하기에는 그다지 복잡하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="8eabd-142">Since application execution is limited to a fixed server or VM, it generally is not too complex to analyze the flow of events.</span></span> <span data-ttu-id="8eabd-143">그러나 오케스트레이터 클러스터의 여러 노드에서 여러 서비스가 실행되는 분산 응용 프로그램에서는 분산된 이벤트를 상호 연결할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8eabd-143">However, in a distributed application where multiple services are executed across many nodes in an orchestrator cluster, being able to correlate distributed events is a challenge.</span></span>

<span data-ttu-id="8eabd-144">마이크로 서비스 기반 응용 프로그램은 이벤트나 로그 파일의 출력 스트림을 자체적으로 저장하려고 시도해서는 안되며 이벤트 라우팅을 중앙 위치로 관리하려고 시도하지 않아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8eabd-144">A microservice-based application should not try to store the output stream of events or logfiles by itself, and not even try to manage the routing of the events to a central place.</span></span> <span data-ttu-id="8eabd-145">이 모든 과정은 투명해야 합니다. 즉, 각 프로세스는 해당 이벤트 스트림을 실행 중인 실행 환경 인프라에서 수집하는 표준 출력에 기록해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8eabd-145">It should be transparent, meaning that each process should just write its event stream to a standard output that underneath will be collected by the execution environment infrastructure where it is running.</span></span> <span data-ttu-id="8eabd-146">이러한 이벤트 스트림 라우터의 예로는 [Microsoft.Diagnostic.EventFlow](https://github.com/Azure/diagnostics-eventflow)가 있으며, 여러 소스에서 이벤트 스트림을 수집하여 출력 시스템에 게시합니다.</span><span class="sxs-lookup"><span data-stu-id="8eabd-146">An example of these event stream routers is [Microsoft.Diagnostic.EventFlow](https://github.com/Azure/diagnostics-eventflow), which collects event streams from multiple sources and publishes it to output systems.</span></span> <span data-ttu-id="8eabd-147">여기에는 [Application Insights](https://azure.microsoft.com/services/application-insights/), [OMS](https://github.com/Azure/diagnostics-eventflow#oms-operations-management-suite)(온-프레미스 응용 프로그램용) 및 [Azure Diagnostics](https://docs.microsoft.com/azure/monitoring-and-diagnostics/azure-diagnostics)와 같은 개발 환경 또는 클라우드 시스템을 위한 간단한 표준 출력이 포함될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8eabd-147">These can include simple standard output for a development environment or cloud systems like [Application Insights](https://azure.microsoft.com/services/application-insights/), [OMS](https://github.com/Azure/diagnostics-eventflow#oms-operations-management-suite) (for on-premises applications), and [Azure Diagnostics](https://docs.microsoft.com/azure/monitoring-and-diagnostics/azure-diagnostics).</span></span> <span data-ttu-id="8eabd-148">[Splunk](https://www.splunk.com/goto/Splunk_Log_Management?ac=ga_usa_log_analysis_phrase_Mar17&_kk=logs%20analysis&gclid=CNzkzIrex9MCFYGHfgodW5YOtA)와 같이 실시간으로도 로그를 검색, 경고, 보고 및 모니터링할 수 있는 타사 로그 분석 플랫폼 및 도구도 제공됩니다.</span><span class="sxs-lookup"><span data-stu-id="8eabd-148">There are also good third-party log analysis platforms and tools that can search, alert, report, and monitor logs, even in real time, like [Splunk](https://www.splunk.com/goto/Splunk_Log_Management?ac=ga_usa_log_analysis_phrase_Mar17&_kk=logs%20analysis&gclid=CNzkzIrex9MCFYGHfgodW5YOtA).</span></span>

### <a name="orchestrators-managing-health-and-diagnostics-information"></a><span data-ttu-id="8eabd-149">상태 및 진단 정보를 관리하는 오케스트레이터</span><span class="sxs-lookup"><span data-stu-id="8eabd-149">Orchestrators managing health and diagnostics information</span></span>

<span data-ttu-id="8eabd-150">마이크로 서비스 기반 응용 프로그램을 만들 때는 복잡성을 처리해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8eabd-150">When you create a microservice-based application, you need to deal with complexity.</span></span> <span data-ttu-id="8eabd-151">물론 단일 마이크로 서비스는 다루기가 쉽지만 유형이나 수십 수백 가지 유형의 마이크로 서비스 인스턴스는 복잡한 문제입니다.</span><span class="sxs-lookup"><span data-stu-id="8eabd-151">Of course, a single microservice is simple to deal with, but dozens or hundreds of types and thousands of instances of microservices is a complex problem.</span></span> <span data-ttu-id="8eabd-152">안정적이고 응집성 있는 시스템을 갖추기 위해서는 마이크로 서비스 아키텍처를 빌드하는 것뿐만 아니라 고가용성, 주소 지정 기능, 복원력, 상태 및 진단도 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="8eabd-152">It is not just about building your microservice architecture—you also need high availability, addressability, resiliency, health, and diagnostics if you intend to have a stable and cohesive system.</span></span>

![](./media/image22.png)

<span data-ttu-id="8eabd-153">**그림 4-22**.</span><span class="sxs-lookup"><span data-stu-id="8eabd-153">**Figure 4-22**.</span></span> <span data-ttu-id="8eabd-154">마이크로 서비스 플랫폼은 응용 프로그램의 상태 관리를 위한 기본 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="8eabd-154">A Microservice Platform is fundamental for an application’s health management</span></span>

<span data-ttu-id="8eabd-155">그림 4-22의 복잡한 문제는 직접 해결하기가 어렵습니다.</span><span class="sxs-lookup"><span data-stu-id="8eabd-155">The complex problems shown in Figure 4-22 are very hard to solve by yourself.</span></span> <span data-ttu-id="8eabd-156">개발 팀은 마이크로 서비스 기반 접근 방식을 사용하여 비즈니스 문제를 해결하고 사용자 지정 응용 프로그램을 빌드하는 데 집중해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8eabd-156">Development teams should focus on solving business problems and building custom applications with microservice-based approaches.</span></span> <span data-ttu-id="8eabd-157">복잡한 인프라 문제를 해결하는 데 집중해서는 안됩니다. 마이크로 서비스 기반 응용 프로그램의 비용이 엄청나게 늘어나기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="8eabd-157">They should not focus on solving complex infrastructure problems; if they did, the cost of any microservice-based application would be huge.</span></span> <span data-ttu-id="8eabd-158">따라서 오케스트레이터 또는 마이크로 서비스 클러스터라고 하는 마이크로 서비스 지향 플랫폼이 있어 서비스 구축 및 실행과 인프라 리소스를 효율적으로 사용하는 어려운 문제를 해결하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="8eabd-158">Therefore, there are microservice-oriented platforms, referred to as orchestrators or microservice clusters, that try to solve the hard problems of building and running a service and using infrastructure resources efficiently.</span></span> <span data-ttu-id="8eabd-159">이를 통해 마이크로 서비스 접근 방식을 사용하는 응용 프로그램 빌드의 복잡성을 줄일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8eabd-159">This reduces the complexities of building applications that use a microservices approach.</span></span>

<span data-ttu-id="8eabd-160">서로 다른 오케스트레이터가 비슷한 것처럼 보일 수도 있지만, 다음 섹션에서 설명하는 것처럼 각각 제공되는 진단 및 상태 확인은 OS 플랫폼에 따라 기능 및 성숙도가 다를 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8eabd-160">Different orchestrators might sound similar, but the diagnostics and health checks offered by each of them differ in features and state of maturity, sometimes depending on the OS platform, as explained in the next section.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="8eabd-161">추가 자료</span><span class="sxs-lookup"><span data-stu-id="8eabd-161">Additional resources</span></span>

-   <span data-ttu-id="8eabd-162">**The Twelve-Factor App. XI. 로그: 로그를 이벤트 스트림처럼 처리**
    [*https://12factor.net/logs*](https://12factor.net/logs)</span><span class="sxs-lookup"><span data-stu-id="8eabd-162">**The Twelve-Factor App. XI. Logs: Treat logs as event streams**
[*https://12factor.net/logs*](https://12factor.net/logs)</span></span>

-   <span data-ttu-id="8eabd-163">**Microsoft 진단 EventFlow 라이브러리.**</span><span class="sxs-lookup"><span data-stu-id="8eabd-163">**Microsoft Diagnostic EventFlow Library.**</span></span> <span data-ttu-id="8eabd-164">GitHub 리포지토리</span><span class="sxs-lookup"><span data-stu-id="8eabd-164">GitHub repo.</span></span>

    [*https://github.com/Azure/diagnostics-eventflow*](https://github.com/Azure/diagnostics-eventflow)

-   <span data-ttu-id="8eabd-165">**Azure 진단이란?**
    [*https://docs.microsoft.com/azure/azure-diagnostics*](https://docs.microsoft.com/azure/azure-diagnostics)</span><span class="sxs-lookup"><span data-stu-id="8eabd-165">**What is Azure Diagnostics**
[*https://docs.microsoft.com/azure/azure-diagnostics*](https://docs.microsoft.com/azure/azure-diagnostics)</span></span>

-   <span data-ttu-id="8eabd-166">**Azure에서 Windows 컴퓨터를 Log Analytics 서비스에 연결**
    [*https://docs.microsoft.com/azure/log-analytics/log-analytics-windows-agents*](https://docs.microsoft.com/azure/log-analytics/log-analytics-windows-agents)</span><span class="sxs-lookup"><span data-stu-id="8eabd-166">**Connect Windows computers to the Log Analytics service in Azure**
[*https://docs.microsoft.com/azure/log-analytics/log-analytics-windows-agents*](https://docs.microsoft.com/azure/log-analytics/log-analytics-windows-agents)</span></span>

-   <span data-ttu-id="8eabd-167">**Logging What You Mean: Using the Semantic Logging Application Block(의도한 내용 로깅: 의미 체계 로깅 응용 프로그램 블록 사용)**
    [*https://msdn.microsoft.com/library/dn440729(v=pandp.60).aspx*](https://msdn.microsoft.com/library/dn440729(v=pandp.60).aspx)</span><span class="sxs-lookup"><span data-stu-id="8eabd-167">**Logging What You Mean: Using the Semantic Logging Application Block**
[*https://msdn.microsoft.com/library/dn440729(v=pandp.60).aspx*](https://msdn.microsoft.com/library/dn440729(v=pandp.60).aspx)</span></span>

-   <span data-ttu-id="8eabd-168">**Splunk.**</span><span class="sxs-lookup"><span data-stu-id="8eabd-168">**Splunk.**</span></span> <span data-ttu-id="8eabd-169">공식 사이트입니다.</span><span class="sxs-lookup"><span data-stu-id="8eabd-169">Official site.</span></span>
    [*https://www.splunk.com/*](https://www.splunk.com/)

-   <span data-ttu-id="8eabd-170">**EventSource 클래스**.</span><span class="sxs-lookup"><span data-stu-id="8eabd-170">**EventSource Class**.</span></span> <span data-ttu-id="8eabd-171">Windows용 이벤트 추적 API(ETW)[*https://docs.microsoft.com/dotnet/api/system.diagnostics.tracing.eventsource*](xref:System.Diagnostics.Tracing.EventSource)</span><span class="sxs-lookup"><span data-stu-id="8eabd-171">API for events tracing for Windows (ETW) [*https://docs.microsoft.com/dotnet/api/system.diagnostics.tracing.eventsource*](xref:System.Diagnostics.Tracing.EventSource)</span></span>




>[!div class="step-by-step"]
<span data-ttu-id="8eabd-172">[이전] (microservice-based-composite-ui-shape-layout.md) [다음] (scalable-available-multi-container-microservice-applications.md)</span><span class="sxs-lookup"><span data-stu-id="8eabd-172">[Previous] (microservice-based-composite-ui-shape-layout.md) [Next] (scalable-available-multi-container-microservice-applications.md)</span></span>

---
title: "각 마이크로 서비스에 대 한 도메인 모델 경계를 식별합니다."
description: "컨테이너 화 된.NET 응용 프로그램에 대 한.NET Microservices 아키텍처 | 각 마이크로 서비스에 대 한 도메인 모델 경계를 식별합니다."
keywords: "Docker, 마이크로 서비스, ASP.NET, 컨테이너"
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 05/26/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.topic: article
ms.openlocfilehash: 6fef11e5718706701abb29149c4c4a23ba39bde0
ms.sourcegitcommit: c2e216692ef7576a213ae16af2377cd98d1a67fa
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 10/22/2017
---
# <a name="identify-domain-model-boundaries-for-each-microservice"></a><span data-ttu-id="fa0ea-104">각 마이크로 서비스에 대 한 경계를 도메인 모델 식별</span><span class="sxs-lookup"><span data-stu-id="fa0ea-104">Identify domain-model boundaries for each microservice</span></span>

<span data-ttu-id="fa0ea-105">가능 하면 microservices 작은 쪽으로 경향이 해야 하지만를 가능한 가장 세분화 된 분리를 받지 않도록 모델 경계와 각 마이크로 서비스에 대 한 크기를 식별할 때 목표가입니다.</span><span class="sxs-lookup"><span data-stu-id="fa0ea-105">The goal when identifying model boundaries and size for each microservice is not to get to the most granular separation possible, although you should tend toward small microservices if possible.</span></span> <span data-ttu-id="fa0ea-106">대신, 목표 기반 도메인 지식을 여 가장 적합 한 분리를 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="fa0ea-106">Instead, your goal should be to get to the most meaningful separation guided by your domain knowledge.</span></span> <span data-ttu-id="fa0ea-107">강조에 없는 경우는 크기에 그 대신 비즈니스 기능</span><span class="sxs-lookup"><span data-stu-id="fa0ea-107">The emphasis is not on the size, but instead on business capabilities.</span></span> <span data-ttu-id="fa0ea-108">또한 없을 경우 많은 수의 종속성을 기준으로 응용 프로그램의 특정 부분에 필요한 응집력 지우기, 나타내는 단일 마이크로 서비스에 대 한 필요성 너무입니다.</span><span class="sxs-lookup"><span data-stu-id="fa0ea-108">In addition, if there is clear cohesion needed for a certain area of the application based on a high number of dependencies, that indicates the need for a single microservice, too.</span></span> <span data-ttu-id="fa0ea-109">응집력은 그룹 함께 microservices 또는 분리 하는 방법을 식별 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="fa0ea-109">Cohesion is a way to identify how to break apart or group together microservices.</span></span> <span data-ttu-id="fa0ea-110">궁극적으로, 도메인에 대 한 더 많은 지식의 확보 하는 동안에 프로그램 마이크로 서비스의 크기 반복적으로 활용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="fa0ea-110">Ultimately, while you gain more knowledge about the domain, you should adapt the size of your microservice, iteratively.</span></span> <span data-ttu-id="fa0ea-111">원 샷 프로세스가 아닙니다 찾기 크기가 적절 합니다.</span><span class="sxs-lookup"><span data-stu-id="fa0ea-111">Finding the right size is not a one-shot process.</span></span>

<span data-ttu-id="fa0ea-112">[Sam Newman](http://samnewman.io/), microservices 및 책 저자 인식된 프로모터 [건물 Microservices](http://samnewman.io/books/building_microservices/), (의 일부 경계가 지정 된 컨텍스트 (BC) 패턴에 따라 프로그램 microservices 디자인 해야에 하이라이트 도메인 기반 디자인)를 앞서 도입 합니다.</span><span class="sxs-lookup"><span data-stu-id="fa0ea-112">[Sam Newman](http://samnewman.io/), a recognized promoter of microservices and author of the book [Building Microservices](http://samnewman.io/books/building_microservices/), highlights that you should design your microservices based on the Bounded Context (BC) pattern (part of domain-driven design), as introduced earlier.</span></span> <span data-ttu-id="fa0ea-113">경우에 따라 몇 가지 물리적 서비스 있지만 그 반대의 경우는 가능 하지는 BC 구성 될 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="fa0ea-113">Sometimes, a BC could be composed of several physical services, but not vice versa.</span></span>

<span data-ttu-id="fa0ea-114">구체적인 BC 내에서 적용 되는 도메인 모델 특정 도메인 엔터티와 또는 마이크로 서비스입니다.</span><span class="sxs-lookup"><span data-stu-id="fa0ea-114">A domain model with specific domain entities applies within a concrete BC or microservice.</span></span> <span data-ttu-id="fa0ea-115">A BC 구분 도메인 모델에 적용할 수 있는지 및 제공 개발자 팀 멤버를 명확 하 고 공유 이해 화합 해야 할 기능 수 개발할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fa0ea-115">A BC delimits the applicability of a domain model and gives developer team members a clear and shared understanding of what must be cohesive and what can be developed independently.</span></span> <span data-ttu-id="fa0ea-116">이들은 microservices에 대 한 동일한 목표입니다.</span><span class="sxs-lookup"><span data-stu-id="fa0ea-116">These are the same goals for microservices.</span></span>

<span data-ttu-id="fa0ea-117">디자인 선택에 알려 주는 또 다른 도구는 [Conway 법칙](https://en.wikipedia.org/wiki/Conway%27s_law), 가능한 상태는 응용 프로그램 생성 한 조직의 소셜 경계를 반영 됩니다.</span><span class="sxs-lookup"><span data-stu-id="fa0ea-117">Another tool that informs your design choice is [Conway’s law](https://en.wikipedia.org/wiki/Conway%27s_law), which states that an application will reflect the social boundaries of the organization that produced it.</span></span> <span data-ttu-id="fa0ea-118">그러나 반대가 true 경우가-회사의 소프트웨어에 의해 구성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="fa0ea-118">But sometimes the opposite is true—the company’s organization is formed by the software.</span></span> <span data-ttu-id="fa0ea-119">비즈니스 프로세스 컨설팅 향해 기울 Conway 법칙 역방향을 구성할 수는 회사를 원하는 방식으로 경계를 생성 하 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fa0ea-119">You might need to reverse Conway’s law and build the boundaries the way you want the company to be organized, leaning toward business process consulting.</span></span>

<span data-ttu-id="fa0ea-120">이 사용할 수 있는 DDD 패턴은 제한 된 컨텍스트를 식별 하기 위해는 [컨텍스트 매핑 패턴](https://www.infoq.com/articles/ddd-contextmapping)합니다.</span><span class="sxs-lookup"><span data-stu-id="fa0ea-120">In order to identify bounded contexts, a DDD pattern that can be used for this is the [Context Mapping pattern](https://www.infoq.com/articles/ddd-contextmapping).</span></span> <span data-ttu-id="fa0ea-121">상황에 맞는 매핑 응용 프로그램 및 사이트 경계에 다양 한 컨텍스트를 식별합니다.</span><span class="sxs-lookup"><span data-stu-id="fa0ea-121">With Context Mapping, you identify the various contexts in the application and their boundaries.</span></span> <span data-ttu-id="fa0ea-122">일반적으로 예를 들어 다른 컨텍스트 및 각 작은 하위 시스템에 대 한 경계는 됩니다.</span><span class="sxs-lookup"><span data-stu-id="fa0ea-122">It is common to have a different context and boundary for each small subsystem, for instance.</span></span> <span data-ttu-id="fa0ea-123">상황에 맞는 지도 정의 하 고 명시적 해당 경계 간에 만들 도메인 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="fa0ea-123">The Context Map is a way to define and make explicit those boundaries between domains.</span></span> <span data-ttu-id="fa0ea-124">A BC 자치 이며 단일 도메인의 세부 정보가 포함 됩니다.-같은 도메인 엔터티 세부 정보-다른 BCs와 통합 계약을 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="fa0ea-124">A BC is autonomous and includes the details of a single domain—details like the domain entities—and defines integration contracts with other BCs.</span></span> <span data-ttu-id="fa0ea-125">이것은 한 마이크로 서비스 정의 비슷합니다: 자치 인 특정 도메인 기능을 구현 하 고 인터페이스를 제공 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="fa0ea-125">This is similar to the definition of a microservice: it is autonomous, it implements certain domain capability, and it must provide interfaces.</span></span> <span data-ttu-id="fa0ea-126">이 때문에 상황에 맞는 매핑을 나타내며 경계가 지정 된 컨텍스트 패턴은 프로그램 microservices의 도메인 모델 경계를 식별 하기 위한 좋은 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="fa0ea-126">This is why Context Mapping and the Bounded Context pattern are good approaches for identifying the domain model boundaries of your microservices.</span></span>

<span data-ttu-id="fa0ea-127">대형 응용 프로그램을 디자인할 때 표시 됩니다는 도메인 모델을 조각화 할 방법을 — 카탈로그 도메인의 도메인 전문가의 이름을 엔터티 다르게 배송 도메인 전문가, 보다 카탈로그 및 인벤토리 도메인의 예를 들어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fa0ea-127">When designing a large application, you will see how its domain model can be fragmented — a domain expert from the catalog domain will name entities differently in the catalog and inventory domains than a shipping domain expert, for instance.</span></span> <span data-ttu-id="fa0ea-128">또는 고객에 대 한 불완전 한 데이터가 필요 하 게 정렬 도메인 전문가 대 한 보다 고객에 대 한 모든 정보를 저장 하려는 CRM 전문가 처리할 때 사용자 도메인 엔터티 특성의 크기와 수에 다를 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fa0ea-128">Or the user domain entity might be different in size and number of attributes when dealing with a CRM expert who wants to store every detail about the customer than for an ordering domain expert who just needs partial data about the customer.</span></span> <span data-ttu-id="fa0ea-129">매우 큰 응용 프로그램과 관련 된 모든 도메인에서 모든 도메인 용어를 명확히 구분 하는 것이 어렵습니다.</span><span class="sxs-lookup"><span data-stu-id="fa0ea-129">It is very hard to disambiguate all domain terms across all the domains related to a large application.</span></span> <span data-ttu-id="fa0ea-130">가장 중요 한 점은; 용어를 통합 하려고 하지 해야 하지만 대신, 차이점과 각 도메인에서 제공 하는 다양 한 동의.</span><span class="sxs-lookup"><span data-stu-id="fa0ea-130">But the most important thing is that you should not try to unify the terms; instead, accept the differences and richness provided by each domain.</span></span> <span data-ttu-id="fa0ea-131">전체 응용 프로그램에 대 한 통합 데이터베이스 하려고 하면 통합된 어휘 시도 이상 하 게 되 고 여러 도메인 전문가 권한을 소리 됩니다.</span><span class="sxs-lookup"><span data-stu-id="fa0ea-131">If you try to have a unified database for the whole application, attempts at a unified vocabulary will be awkward and will not sound right to any of the multiple domain experts.</span></span> <span data-ttu-id="fa0ea-132">따라서 BCs (microservices로 구현) 수는 분명 하 게 특정 도메인 용어를 사용할 수 있는 위치를 시스템 나누고 서로 다른 도메인을 사용 하 여 추가 BCs 만들기 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="fa0ea-132">Therefore, BCs (implemented as microservices) will help you to clarify where you can use certain domain terms and where you will need to split the system and create additional BCs with different domains.</span></span>

<span data-ttu-id="fa0ea-133">오른쪽 경계와 각 BC의 크기를가지고 및 일반적인 응용 프로그램을 수행할 때 여러 도메인 모델에서 정보를 병합 해야 할 도메인 모델 간의 몇 가지 강력한 관계가 존재 하 고 일반적으로 사용 하지 않을 경우 도메인 모델을 알 수 있습니다. 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="fa0ea-133">You will know that you got the right boundaries and sizes of each BC and domain model if you have few strong relationships between domain models, and you do not usually need to merge information from multiple domain models when performing typical application operations.</span></span>

<span data-ttu-id="fa0ea-134">아마도으로 최상의 답변을 얼마나 큰 각 마이크로 서비스에 대 한 도메인 모델 해야의 질문에는 다음:는 자치 BC 있어야 가능한 지속적으로 (기타 다른 컨텍스트를 전환 하지 않고도 작업할 수 있는 격리 된 마이크로 서비스의 모델)입니다.</span><span class="sxs-lookup"><span data-stu-id="fa0ea-134">Perhaps the best answer to the question of how big a domain model for each microservice should be is the following: it should have an autonomous BC, as isolated as possible, that enables you to work without having to constantly switch to other contexts (other microservice’s models).</span></span> <span data-ttu-id="fa0ea-135">그림 4-10 나타나면 자신의 모델 및 해당 엔터티 정의할 수 있는 방법을, 각각의 응용 프로그램에서 확인 된 도메인에 대 한 특정 요구 사항에 따라 각 여러 microservices (여러 BCs) 있어야 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="fa0ea-135">In Figure 4-10 you can see how multiple microservices (multiple BCs) each have their own model and how their entities can be defined, depending on the specific requirements for each of the identified domains in your application.</span></span>

![](./media/image10.png)

<span data-ttu-id="fa0ea-136">**그림 4-10**합니다.</span><span class="sxs-lookup"><span data-stu-id="fa0ea-136">**Figure 4-10**.</span></span> <span data-ttu-id="fa0ea-137">엔터티 및 마이크로 서비스 모델 경계를 식별합니다.</span><span class="sxs-lookup"><span data-stu-id="fa0ea-137">Identifying entities and microservice model boundaries</span></span>

<span data-ttu-id="fa0ea-138">그림 4-10 온라인 회의 관리 시스템과 관련 된 예제 시나리오를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="fa0ea-138">Figure 4-10 illustrates a sample scenario related to an online conference management system.</span></span> <span data-ttu-id="fa0ea-139">도메인 전문가으로 정의 하는 도메인에 따라 microservices로 구현할 수 있는 몇 가지 BCs 사실을 파악 했습니다.</span><span class="sxs-lookup"><span data-stu-id="fa0ea-139">You have identified several BCs that could be implemented as microservices, based on domains that domain experts defined for you.</span></span> <span data-ttu-id="fa0ea-140">볼 수 있듯이는 지불을 결제 마이크로 서비스와 같은 단일 마이크로 서비스 모델에만 있는 엔터티입니다.</span><span class="sxs-lookup"><span data-stu-id="fa0ea-140">As you can see, there are entities that are present just in a single microservice model, like Payments in the Payment microservice.</span></span> <span data-ttu-id="fa0ea-141">이러한 구현 하기 쉬운 됩니다.</span><span class="sxs-lookup"><span data-stu-id="fa0ea-141">Those will be easy to implement.</span></span>

<span data-ttu-id="fa0ea-142">그러나 다른 모양의 들에 게 여러 microservices에서 여러 도메인 모델에서 동일한 id를 공유 하는 엔터티를 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fa0ea-142">However, you might also have entities that have a different shape but share the same identity across the multiple domain models from the multiple microservices.</span></span> <span data-ttu-id="fa0ea-143">예를 들어 사용자 엔터티는 회의 관리 마이크로 서비스에서 식별 됩니다.</span><span class="sxs-lookup"><span data-stu-id="fa0ea-143">For example, the User entity is identified in the Conferences Management microservice.</span></span> <span data-ttu-id="fa0ea-144">동일한 id와 같은 사용자, 하나는 구매자 Ordering 마이크로 서비스에 명명 된 또는 한 지불 마이크로 서비스 및 고객 서비스 마이크로 서비스에서 명명된 한 고객도에 지불자 명명 된 경우</span><span class="sxs-lookup"><span data-stu-id="fa0ea-144">That same user, with the same identity, is the one named Buyers in the Ordering microservice, or the one named Payer in the Payment microservice, and even the one named Customer in the Customer Service microservice.</span></span> <span data-ttu-id="fa0ea-145">에 따라 때문에 이것이 [유비쿼터스 언어](https://martinfowler.com/bliki/UbiquitousLanguage.html) 각 도메인 전문가 사용 하 여, 사용자는 서로 다른 특성으로도 다른 관점 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fa0ea-145">This is because, depending on the [ubiquitous language](https://martinfowler.com/bliki/UbiquitousLanguage.html) that each domain expert is using, a user might have a different perspective even with different attributes.</span></span> <span data-ttu-id="fa0ea-146">회의 관리 라는 마이크로 서비스 모델의 사용자 엔터티는 대부분의 개인 데이터 특성의 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fa0ea-146">The user entity in the microservice model named Conferences Management might have most of its personal data attributes.</span></span> <span data-ttu-id="fa0ea-147">그러나 같은 사용자 지불 마이크로 서비스 이나 마이크로 서비스 고객 서비스에에서 고객의 모양에서 지불자 모양에 동일한 특성 목록이 필요는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="fa0ea-147">However, that same user in the shape of Payer in the microservice Payment or in the shape of Customer in the microservice Customer Service might not need the same list of attributes.</span></span>

<span data-ttu-id="fa0ea-148">그림 4-11 유사한 방법을 나와 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fa0ea-148">A similar approach is illustrated in Figure 4-11.</span></span>

![](./media/image11.png)

<span data-ttu-id="fa0ea-149">**그림 4-11**합니다.</span><span class="sxs-lookup"><span data-stu-id="fa0ea-149">**Figure 4-11**.</span></span> <span data-ttu-id="fa0ea-150">일반적인 데이터 모델을 여러 도메인 모델 분해</span><span class="sxs-lookup"><span data-stu-id="fa0ea-150">Decomposing traditional data models into multiple domain models</span></span>

<span data-ttu-id="fa0ea-151">사용자가 사용자 엔터티로 회의 관리 마이크로 서비스 모델에 존재 하 고 가격 책정 마이크로 서비스 대체 특성 또는 구매자 실제로 되었을 때 사용자에 대 한 세부 정보에서에서 구매자 엔터티 형식에도 제공 됩니다 하는 방법을 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fa0ea-151">You can see how the user is present in the Conferences Management microservice model as the User entity and is also present in the form of the Buyer entity in the Pricing microservice, with alternate attributes or details about the user when it is actually a buyer.</span></span> <span data-ttu-id="fa0ea-152">각 마이크로 서비스 또는 BC에의 한 부분일 뿐, 문제를 해결 또는 상황에 따라 사용자 엔터티와 관련 된 모든 데이터를 필요 하지 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fa0ea-152">Each microservice or BC might not need all the data related to a User entity, just part of it, depending on the problem to solve or the context.</span></span> <span data-ttu-id="fa0ea-153">예를 들어, 가격 책정 마이크로 서비스 모델에서 불필요 주소나 ID (id)로 때 구매자 각 좌석을 가격 할인에 영향을 미치게 됩니다 하는 상태에만 사용자의 ID입니다.</span><span class="sxs-lookup"><span data-stu-id="fa0ea-153">For instance, in the Pricing microservice model, you do not need the address or the ID of the user, just ID (as identity) and Status, which will have an impact on discounts when pricing the seats per buyer.</span></span>

<span data-ttu-id="fa0ea-154">동일한 사용자 엔터티에 포함 된 각 도메인 모델에 있지만 다른 특성 이름을 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="fa0ea-154">The Seat entity has the same name but different attributes in each domain model.</span></span> <span data-ttu-id="fa0ea-155">사용자 단위는 동일한 ID를 기반으로 id를 공유 하는 반면 사용자와 구매자가 발생 하면 합니다.</span><span class="sxs-lookup"><span data-stu-id="fa0ea-155">However, Seat shares identity based on the same ID, as happens with User and Buyer.</span></span>

<span data-ttu-id="fa0ea-156">기본적으로, 모든 해당 사용자의 id를 공유 하는 여러 서비스 (도메인)에 있는 사용자의 공유 개념이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fa0ea-156">Basically, there is a shared concept of a user that exists in multiple services (domains), which all share the identity of that user.</span></span> <span data-ttu-id="fa0ea-157">하지만 각각의 도메인 모델에는 사용자 엔터티에 대 한 세부 정보를 추가 또는 다른 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fa0ea-157">But in each domain model there might be additional or different details about the user entity.</span></span> <span data-ttu-id="fa0ea-158">따라서 필요에 다른 한 도메인 (마이크로 서비스)에서 사용자 엔터티를 매핑할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fa0ea-158">Therefore, there needs to be a way to map a user entity from one domain (microservice) to another.</span></span>

<span data-ttu-id="fa0ea-159">도메인 간에 동일한 특성 수와 같은 사용자 엔터티를 공유 하지에 다양 한 이점이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fa0ea-159">There are several benefits to not sharing the same user entity with the same number of attributes across domains.</span></span> <span data-ttu-id="fa0ea-160">이점 중 하나는, 중복을 줄이기 위해 되므로 마이크로 서비스 모델 필요 하지 않은 모든 데이터는 요소가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="fa0ea-160">One benefit is to reduce duplication, so that microservice models do not have any data that they do not need.</span></span> <span data-ttu-id="fa0ea-161">또 다른 이점은 업데이트 및 해당 유형의 데이터에 대 한 쿼리는 해당 마이크로 서비스에 의해서만 발생 하는 특정 형식의 엔터티별로 데이터를 소유 하는 마스터 마이크로 서비스 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="fa0ea-161">Another benefit is having a master microservice that owns a certain type of data per entity so that updates and queries for that type of data are driven only by that microservice.</span></span>


>[!div class="step-by-step"]
<span data-ttu-id="fa0ea-162">[이전] (분산-데이터-management.md) [다음] (direct-client-to-microservice-communication-versus-the-api-gateway-pattern.md)</span><span class="sxs-lookup"><span data-stu-id="fa0ea-162">[Previous] (distributed-data-management.md) [Next] (direct-client-to-microservice-communication-versus-the-api-gateway-pattern.md)</span></span>

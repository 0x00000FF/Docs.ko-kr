---
title: 서버 리스 아키텍처 고려 사항-서버 리스 앱
description: 로깅, 추적 및 진단 상태 관리 및 크기를 조정 하려면 영구 저장소에서 서버 리스 응용 프로그램을 설계 하는 문제를 이해 합니다.
author: JEREMYLIKNESS
ms.author: jeliknes
ms.date: 06/26/2018
ms.openlocfilehash: b12a09c0fcef7e7ff954a3f959fb9e3080a6e859
ms.sourcegitcommit: ccd8c36b0d74d99291d41aceb14cf98d74dc9d2b
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 12/10/2018
ms.locfileid: "53155066"
---
# <a name="serverless-architecture-considerations"></a>서버 리스 아키텍처 고려 사항

서버 리스 아키텍처를 채택 하는 몇 가지 문제 함께 제공 됩니다. 이 섹션에서는 알아야 할 일반적인 고려 사항 중 일부를 살펴봅니다. 솔루션 경우 이러한 모든 문제 모든 아키텍처 선택와 마찬가지로 서버 리스 환경으로 결정을 신중 하 게 장점 및 단점을 고려한 후에 이루어져야 합니다. 응용 프로그램의 요구에 따라 서버 리스 구현 되지 특정 구성 요소에 적합 한 솔루션을 결정할 수 있습니다.

## <a name="managing-state"></a>상태 관리

서버 리스 함수, 일반적으로 마이크로 서비스와 마찬가지로 기본적으로 상태 비저장입니다. 방지 상태를 확장 하는 데 중심점 실패 하지 않고 복원 력을 제공 임시 서버 리스를 수 있습니다. 경우에 따라 비즈니스 프로세스 상태를 필요합니다. 프로세스 상태에 필요한 경우 두 가지 옵션이 있습니다. 서버 리스 보다 다른 모델을 채택 수도 있고 상태를 제공 하는 별도 서비스와 상호 작용할 수 있습니다. 추가 상태 수 솔루션 복잡 해질를 어렵게 조정 및 잠재적으로 단일 실패 지점을 만듭니다. 함수에서 상태를 반드시 필요한 지 여부를 신중 하 게 고려 합니다. 대답이 "예" 인 경우 서버를 사용 하 여이 구현 하는 것이 여전히는 지 여부를 결정 합니다.

서버 리스의 이점을 그대로 유지 하면서 상태를 채택 하는 방법은 여러 시나리오도 있습니다. 많이 솔루션 중 일부는 다음과 같습니다.

* 임시 데이터 저장소 또는 Redis와 같은 분산된 캐시 사용
* SQL 또는 CosmosDB와 같은 데이터베이스의 상태를 저장 합니다.
* 지 속성 함수 처럼 워크플로 엔진을 통해 상태를 처리 합니다.

결론은의 서버 리스를 사용 하 여 구현 하려고 합니다. 프로세스 내에서 상태 관리에 대 한 필요성을 인식 해야 있습니다.

## <a name="long-running-processes"></a>장기 실행 프로세스

서버 리스의 다양 한 이점을 사용 후 삭제 되 고 프로세스에 의존 합니다. 짧은 실행된 시간 함수의 끝과 공유 functions 호스트 하는 대로 리소스를 확보 하려면 서버 리스 공급자 쉽게 있습니다. 대부분의 클라우드 공급자는 총 시간을 약 10 분으로 함수 실행 수를 제한 합니다. 프로세스는 오래 걸릴 수 있습니다, 대체 구현을 수도 있습니다.

예외 및 솔루션을 몇 가지 있습니다. 한 가지 해결 프로세스를 개별적으로 실행 시간을 사용 하는 더 작은 구성 요소로 분해 수 있습니다. 프로세스를 종속성으로 인해 장기 실행 지 속성 함수 같은 솔루션을 사용 하 여 비동기 워크플로 수도 있습니다. 지 속성 함수는 일시 중지 하 고 완료 하는 외부 프로세스를 기다리는 동안 프로세스의 상태를 유지 합니다. 비동기 처리에는 실제 프로세스는 실행 시간이 줄어듭니다.

## <a name="startup-time"></a>시작 시간

서버 리스 구현 사용 하 여 잠재적인 문제 하나는 시작 시간입니다. 자원을 절약 하려면 많은 서버 리스 공급자는 "주문형." 인프라 만들기 서버 리스 함수 시간이 지나면 트리거되면 함수 호스트 리소스를 만들거나 다시 시작 해야 합니다. 상황에 따라 콜드 몇 초의 지연이 발생할 수 있습니다. 시작 시간 공급자 및 서비스 수준에 따라 다릅니다. 앱의 성공에 최소화 해야 하는 경우 주소 시작 시간을 몇 가지 방법이 있습니다.

* 일부 공급자는 인프라는 "무중단"을 보장 하는 서비스 수준에 대해 사용자를 허용 합니다.
* 연결 유지 메커니즘 (ping에 끝점을 "절전 모드 해제" 유지)를 구현 합니다.
* Kubernetes 같은 오케스트레이션 (호스트 이미 실행 되어 새 인스턴스를 스핀업 매우 빠릅니다.)는 컨테이너 화 된 함수 접근 방식을 사용 합니다.

## <a name="database-updates-and-migrations"></a>데이터베이스 업데이트 및 마이그레이션

서버 리스 코드의 장점은 전체 응용 프로그램을 재배포 하지 않고도 새 함수를 릴리스할 수 있습니다. 이러한 이점은 관계형 데이터베이스와 관련 된 경우 단점이 될 수 있습니다. 데이터베이스 스키마를 변경 하는 것은 서버 리스 업데이트와 동기화 하기가 어렵습니다. 무엇 인가 잘못 하 고 변경 내용을 롤백해야 하는 경우 추가 문제 야기 됩니다. 데이터 무결성은 마이크로 서비스 및 서버 리스 functions에 대 한 모범 사례는 자신의 데이터 소유 하는 이유 중 하나입니다. 변경 내용을 계산 및 데이터의 단일 단위로 배포 하는 것이 가능 합니다. 사실 대부분의 레거시 시스템 큰 백 엔드 데이터베이스 서버 리스 아키텍처를 사용 하 여 문제를 해결 해야 하는 기능을 합니다.

스키마 버전 관리를 해결 하는 인기 있는 방법은 기존 속성 및 열을 수정 하지 마십시오 있지만 대신 새 정보를 추가 하는 것입니다. 예를 들어 부울에서 이동할 변경 "완료"를 "완료 된 날짜입니다."는 todo 목록에 대 한 플래그 기존 필드를 제거 하는 대신 데이터베이스 변경이 됩니다.

1. 새 "완료 된 날짜" 필드를 추가 합니다.
1. 현재 날짜 후 완료 된 날짜 인지 여부를 평가 하는 계산된 함수를 "완료 됨된" 부울 필드를 변환 합니다.
1. 완료 된 부울 값이 설정 된 경우 현재 날짜가 완료 된 날짜를 설정 하는 트리거를 추가 합니다. true로 합니다.

변경 내용 시퀀스로 레거시 코드를 계속 최신 서버 리스 functions 활용할 수 있습니다 새 필드를 "있는 그대로" 실행 하는 것을 확인 합니다.

서버 리스 아키텍처에서 데이터에 대 한 자세한 내용은 참조 하세요. [분산 데이터 관리의 문제 및 솔루션](../microservices-architecture/architect-microservice-container-applications/distributed-data-management.md)합니다.

## <a name="scaling"></a>배율 조정

것은 일반적인 오해는 서버 리스 의미 "서버가 없습니다." 사실 "서버가." 사실 있습니다은 백업 인프라를 크기 조정에 나올 때 이해 해야 합니다. 대부분의 서버 리스 플랫폼 이벤트 밀도 증가 하면 인프라를 확장 해야 하는 방법을 처리 하는 컨트롤 집합을 제공 합니다. 다양 한 옵션을 선택할 수 있지만 전략 함수에 따라 달라질 수 있습니다. 또한 동일한 호스트에는 함수가 동일한 크기 조정 옵션을 갖도록 함수는 일반적으로 관련된 호스트에서 실행 됩니다. 따라서 구성 및 전략을 수립할 함수 호스팅되는 크기 조정 요구 사항에 따라 함께 하는 데 필요한 것입니다.

규칙에는 종종 강화 하는 방법을 지정 (호스트 리소스를 늘리는) 및 스케일 아웃 (호스트 인스턴스 수 늘리기) 다양 한 매개 변수를 기반 합니다. 눈금에 대 한 트리거 일정, 요청 속도, CPU 사용률 및 메모리 사용량에 포함 될 수 있습니다. 더 높은 성능을 자주 큰 비용이 듭니다. 신속 하 게 요청 속도가 갑자기 증가 하는 경우 저렴, 사용량 기반 접근 방식을 확장 하지 않을 수 있습니다. 특성은 상호 타협 든 "보험 비용" 지불 및 지불 간에 엄격 하 게 "으로 이동" 하 고 갑작스러운 수요 증가에 인해 느린 응답의 위험 합니다.

## <a name="monitoring-tracing-and-logging"></a>모니터링, 추적 및 로깅

DevOps 측면 흔히 간과 되는 응용 프로그램을 배포한 후 모니터링 합니다. 서버 리스 functions를 모니터링 하기 위한 전략을 두는 것이 반드시 합니다. 가장 큰 난관은 종종 상관 관계 또는 사용자는 같은 상호 작용의 일부로 여러 함수를 호출 하는 경우를 인식 합니다. 대부분의 서버 리스 플랫폼 허용 타사 도구에 콘솔 로그를 가져올 수 있습니다. 원격 분석의 컬렉션을 자동화, 생성 및 상관 관계 Id를 추적 및 세부 정보를 제공 하기 위한 특정 작업을 모니터링 하는 옵션도 있습니다. Azure에서 고급 제공 [Application Insights 플랫폼](https://docs.microsoft.com/azure/azure-functions/functions-monitoring) 모니터링 및 분석 합니다.

## <a name="inter-service-dependencies"></a>서비스 간 종속성

서버 리스 아키텍처를 다른 함수를 사용 하는 함수를 포함할 수 있습니다. 사실, 일반적이 지 않은에 없는 여러 서비스 호출을 상호 작용 또는 분산된 트랜잭션의 일부로 서로 다른 서버 리스 아키텍처를 합니다. 강력한 결합을 방지 하려면 것이 좋습니다는 services 서로 직접 참조 하지 않습니다. 서비스에 대 한 끝점을 변경 해야 하는 경우 주요 리팩터링에 대 한 직접 참조 될 수 있습니다. 제안 된 솔루션을 요청 형식에 대 한 적절 한 끝점을 제공 하는 레지스트리와 같은 서비스 검색 메커니즘을 제공 하는 것입니다. 다른 방법은 서비스 간의 통신에 대 한 큐 또는 항목과 같은 메시징 서비스를 활용 하는 것입니다.

## <a name="managing-failure-and-providing-resiliency"></a>오류 관리 및 복원 력 제공

것도 고려해 야 할 중요 합니다 *회로 차단기 패턴*: 어떤 이유로 서비스를 계속 실패 하는 경우 해당 서비스를 반복적으로 호출 하는 것이 좋습니다는 없습니다. 대신, 대체 서비스를 호출 하거나 종속 서비스의 상태를 다시 설정 될 때까지 메시지를 반환 합니다. 서버 리스 아키텍처를 해결 하 고 서비스 간 종속성을 관리 하기 위한 전략을 고려해 야 할 필요 합니다.

회로 차단기 패턴을 계속 하려면 서비스를 허용 하 고 복원 력 있는 오류 수 해야 합니다. 발생 하는 잘못 된 상태 또는 내결함성 예기치 않은 예외 후에 계속 실행 하려면 응용 프로그램의 기능을 참조 합니다. 내결함성은 일반적으로 자체 코드의 함수 및 예외 처리를 기록 하는 방법입니다. 복원 력 앱에서 오류 로부터 복구 하는 능력를 참조 합니다. 복원 력은 종종 서버 리스 플랫폼에서 관리 됩니다. 플랫폼 기존 실패 한 경우 새 서버 리스 함수 인스턴스를 스핀업 하 수 있어야 합니다. 플랫폼을 모든 새 인스턴스가 실패 하는 경우 새 인스턴스를 스핀업을 중지 해야 합니다.

자세한 내용은 [회로 차단기 패턴 구현](../microservices-architecture/implement-resilient-applications/implement-circuit-breaker-pattern.md)합니다.

## <a name="versioning-and-greenblue-deployments"></a>버전 관리 및 녹색/파랑 배포

서버 리스의 주요 혜택은 전체 응용 프로그램을 재배포 하지 않고도 특정 기능을 업그레이드 하는 기능. 성공적인 업그레이드에 대 한 함수 호출 하는 서비스 코드의 올바른 버전으로 라우팅되도록 버전이 관리 되어야 합니다. 새 버전을 배포 하기 위한 전략을 역시 중요 합니다. 일반적인 방법은 "녹색/파랑 배포 합니다."를 사용 하는 것 녹색 배포는 현재 함수입니다. "Blue" 새 버전은 프로덕션 환경에 배포 하 고 테스트. 패스를 테스트할 때 새 버전에는 라이브 제공 되므로 녹색 및 파랑 버전 교환 됩니다. 문제가 발생 하는 경우 다시 교환할 수 있습니다. 버전 관리 및 녹색/파랑 배포를 지 원하는 버전 변경 내용을 수용할 수 있는 함수를 작성 및 배포를 처리 하는 서버 리스 플랫폼을 사용 하 여 작업의 조합이 필요 합니다. 한 가지 방법을 설명 하는 프록시를 사용 하는 것은 [Azure 서버 리스 플랫폼](azure-functions.md#proxies) 장입니다.

>[!div class="step-by-step"]
>[이전](serverless-architecture.md)
>[다음](serverless-design-examples.md)
---
title: DevOps 공동 작업을 위한 기반으로 컨테이너
description: Microsoft 플랫폼 및 도구를 사용하여 컨테이너화된 Docker 응용 프로그램 수명 주기
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 09/22/2017
ms.openlocfilehash: 0fa43263e789bba5b720792e7e8dc5321af795b7
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 05/04/2018
ms.locfileid: "33576222"
---
# <a name="containers-as-the-foundation-for-devops-collaboration"></a><span data-ttu-id="0b945-103">DevOps 공동 작업을 위한 기반으로 컨테이너</span><span class="sxs-lookup"><span data-stu-id="0b945-103">Containers as the foundation for DevOps collaboration</span></span>

<span data-ttu-id="0b945-104">컨테이너 및 Docker 기술 특성상 개발자와 공유할 수 소프트웨어와 종속성에 쉽게 IT 운영 팀 및 프로덕션 환경 이와 동시에 일반적인 "내 컴퓨터에서 작동" 변명.</span><span class="sxs-lookup"><span data-stu-id="0b945-104">By the very nature of the containers and Docker technology, developers can share their software and dependencies easily with IT operations and production environments while eliminating the typical "it works on my machine" excuse.</span></span> <span data-ttu-id="0b945-105">여러 환경 간에 응용 프로그램 충돌을 해결 하는 컨테이너입니다.</span><span class="sxs-lookup"><span data-stu-id="0b945-105">Containers solve application conflicts between different environments.</span></span> <span data-ttu-id="0b945-106">를 직접 컨테이너 및 Docker 상태로 전환 하지 개발자와 IT 운영에 가깝게 함께 효율적으로 공동 작업을 더욱 쉽게 합니다.</span><span class="sxs-lookup"><span data-stu-id="0b945-106">Indirectly, containers and Docker bring developers and IT operations closer together, making it easier for them to collaborate effectively.</span></span> <span data-ttu-id="0b945-107">컨테이너 워크플로 채택 하는 고객이 많은 DevOps 연속성 검색 했으므로 되지만 이전 릴리스에 대 한 보다 복잡 한 구성을 통해 구현 하 여 파이프라인에 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="0b945-107">Adopting the container workflow provides many customers with the DevOps continuity they've sought but previously had to implement via more complex configuration for release and build pipelines.</span></span> <span data-ttu-id="0b945-108">컨테이너는 DevOps의 파이프라인을 빌드/테스트/배포를 단순화합니다.</span><span class="sxs-lookup"><span data-stu-id="0b945-108">Containers simplify the build/test/deploy pipelines in DevOps.</span></span>

![](./media/image1.png)

<span data-ttu-id="0b945-109">Docker의 컨테이너 화 된 응용 프로그램에 대 한 수명 주기에서 "사용자" 당 그림 2-1: 기본 작업</span><span class="sxs-lookup"><span data-stu-id="0b945-109">Figure 2-1: Main workloads per "personas" in the life cycle for containerized Docker applications</span></span>

<span data-ttu-id="0b945-110">Docker 컨테이너를 개발자가 직접 (응용 프로그램 및 서비스에 프레임 워크 및 구성 요소에 대 한 종속성) 컨테이너와 컨테이너와 서비스는 서비스의 컬렉션으로 구성 된 응용 프로그램으로 함께 작동 하는 내 이란 합니다.</span><span class="sxs-lookup"><span data-stu-id="0b945-110">With Docker containers, developers own what's within the container (application and service, and dependencies to frameworks and components) and how the containers and services behave together as an application composed by a collection of services.</span></span> <span data-ttu-id="0b945-111">여러 컨테이너의 상호 종속성 docker compose.yml 파일 또는 호출 될 수 있는에 정의 된 *배포 매니페스트*합니다.</span><span class="sxs-lookup"><span data-stu-id="0b945-111">The interdependencies of the multiple containers are defined in a docker-compose.yml file, or what could be called a *deployment manifest*.</span></span> <span data-ttu-id="0b945-112">IT 운영 팀 (IT 전문가 및 관리); 프로덕션 환경의 관리에 집중할 수는 한편, 인프라; 확장성입니다. 모니터링; 및 궁극적으로 응용 프로그램은 배달 하는 제대로 최종 사용자에 대 한 다양 한 컨테이너의 내용을 알 필요 없이 되었는지 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="0b945-112">Meanwhile, IT operations teams (IT professionals and management) can focus on the management of production environments; infrastructure; scalability; monitoring; and, ultimately, ensuring that the applications are delivering properly for the end users, without having to know the contents of the various containers.</span></span> <span data-ttu-id="0b945-113">따라서 이름 "컨테이너" 실제 배송 컨테이너에 비유를 다시 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="0b945-113">Hence, the name "container," recalling the analogy to real-world shipping containers.</span></span> <span data-ttu-id="0b945-114">따라서 컨테이너의 콘텐츠 소유자 필요 하지 관련이 자체적으로 어떻게 컨테이너를 전달할 및 운송 회사 전송의 발생 시점에서 컨테이너를 대상으로 파악 하거나 내용에 대해 고려 하지 않고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0b945-114">Thus, the owners of a container's content need not concern themselves with how the container will be shipped, and the shipping company transports a container from its point of origin to its destination without knowing or caring about the contents.</span></span> <span data-ttu-id="0b945-115">비슷한 방식으로, 개발자가 만들고 "전송" 메커니즘을 염려 하지 않고도 Docker 컨테이너 내에서 콘텐츠를 소유할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0b945-115">In a similar manner, developers can create and own the contents within a Docker container without the need to concern themselves with the "transport" mechanisms.</span></span>

<span data-ttu-id="0b945-116">그림 2-1의 왼쪽에 pillar, 개발자가 작성 한 Windows 용 Docker 또는 Mac. 사용 하 여 Docker 컨테이너 로컬로 코드를 실행</span><span class="sxs-lookup"><span data-stu-id="0b945-116">In the pillar on the left side of Figure 2-1, developers write and run code locally in Docker containers by using Docker for Windows or Mac.</span></span> <span data-ttu-id="0b945-117">Docker 이미지에 해당 코드를 작성 하기 위한 빌드 단계 뿐만 아니라 실행 하려면 기본 운영 체제를 지정 하는 Dockerfile을 사용 하 여 코드에 대 한 운영 환경을 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="0b945-117">They define the operating environment for the code by using a Dockerfile that specifies the base operating system to run as well as the build steps for building their code into a Docker image.</span></span> <span data-ttu-id="0b945-118">개발자 정의 방법을 사용 하 여 앞서 언급 한 하나 이상의 이미지를 운용 됩니다 *docker compose.yml* 배포 매니페스트 파일.</span><span class="sxs-lookup"><span data-stu-id="0b945-118">The developers define how the one or more images will interoperate using the aforementioned *docker-compose.yml* file deployment manifest.</span></span> <span data-ttu-id="0b945-119">자신의 로컬 개발을 완료은 응용 프로그램 코드와 Docker 구성 파일의 코드 리포지토리에 푸시가 선택한 (즉, Git 리포지토리).</span><span class="sxs-lookup"><span data-stu-id="0b945-119">As they complete their local development, they push their application code plus the Docker configuration files to the code repository of their choice (that is, Git repository).</span></span>

<span data-ttu-id="0b945-120">DevOps pillar 코드 리포지토리에 제공 Dockerfile을 사용 하 여 빌드-Continuous Integration (CI) 파이프라인을 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="0b945-120">The DevOps pillar defines the build–Continuous Integration (CI) pipelines using the Dockerfile provided in the code repository.</span></span> <span data-ttu-id="0b945-121">CI 시스템에서 선택한 Docker 레지스트리 기본 컨테이너 이미지를 끌어온 하 고 응용 프로그램에 대 한 사용자 지정 Docker 이미지를 빌드합니다.</span><span class="sxs-lookup"><span data-stu-id="0b945-121">The CI system pulls the base container images from the selected Docker registry and builds the custom Docker images for the application.</span></span> <span data-ttu-id="0b945-122">다음 이미지 유효성 검사와 여러 환경에 배포 하기 위해 사용 되는 Docker 레지스트리 밀어넣습니다.</span><span class="sxs-lookup"><span data-stu-id="0b945-122">The images then are validated and pushed to the Docker registry used for the deployments to multiple environments.</span></span>

<span data-ttu-id="0b945-123">오른쪽에 pillar, 운영 팀은 관리할 배포 응용 프로그램과 인프라를 피드백과 개발 팀에 대 한 방법을 응용 프로그램 정보를 제공 하는 환경 및 응용 프로그램을 모니터링 하는 동안 프로덕션 환경에서 향상 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="0b945-123">In the pillar on the right, operations teams manage deployed applications and infrastructure in production while monitoring the environment and applications so that they can provide feedback and insights to the development team about how the application might be improved.</span></span> <span data-ttu-id="0b945-124">컨테이너 앱은 일반적으로 컨테이너 orchestrators를 사용 하 여 프로덕션에서 실행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0b945-124">Container apps are typically run in production using container orchestrators.</span></span>

<span data-ttu-id="0b945-125">두 팀을 분리 하는 계약으로 두 팀의 공동 작업을 응용 프로그램 수명 주기를 크게 향상을 제공 하는 기본 플랫폼 (Docker 컨테이너)를 통해 공동 작업 하는 합니다.</span><span class="sxs-lookup"><span data-stu-id="0b945-125">The two teams are collaborating through a foundational platform (Docker containers) that provides a separation of concerns as a contract, while greatly improving the two teams' collaboration in the application life cycle.</span></span> <span data-ttu-id="0b945-126">개발자는 컨테이너 내용을, 환경, 및 컨테이너 상호 종속성을 소유할 반면 운영 팀 매니페스트 함께 빌드된 이미지를 사용 하 고 오케스트레이션 시스템에서이 실행 합니다.</span><span class="sxs-lookup"><span data-stu-id="0b945-126">The developers own the container contents, its operating environment, and the container interdependencies, whereas the operations teams take the built images along with the manifest and runs them in their orchestration system.</span></span>

## <a name="introduction-to-a-generic-end-to-end-docker-application-life-cycle-workflow"></a><span data-ttu-id="0b945-127">종단 간 Docker 응용 프로그램 수명 주기 워크플로 제네릭 소개</span><span class="sxs-lookup"><span data-stu-id="0b945-127">Introduction to a generic end-to-end Docker application life cycle workflow</span></span>

<span data-ttu-id="0b945-128">그림 2-2 표시 하는 특정 DevOps 활동 및 자산에이 인스턴스에서 중점을 두기 Docker 응용 프로그램 수명 주기에 대 한 더 자세한 워크플로 합니다.</span><span class="sxs-lookup"><span data-stu-id="0b945-128">Figure 2-2 presents a more detailed workflow for a Docker application life cycle, focusing in this instance on specific DevOps activities and assets.</span></span>

![](./media/image2.png)

<span data-ttu-id="0b945-129">Docker 컨테이너 화 된 응용 프로그램 수명 주기에 대 한 높은 수준의 워크플로 그림 2-2:</span><span class="sxs-lookup"><span data-stu-id="0b945-129">Figure 2-2: High-level workflow for the Docker containerized application life cycle</span></span>

<span data-ttu-id="0b945-130">모든 개발자 내부 루프 워크플로에서 코드 작성을 시작으로 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="0b945-130">Everything begins with the developer, who starts writing code in the inner-loop workflow.</span></span> <span data-ttu-id="0b945-131">내부 루프 단계 코드 (예를 들어 소스 제어 시스템 Git와 같은) 코드 리포지토리로 푸시하기 전에 발생 하는 모든 개발자 정의입니다.</span><span class="sxs-lookup"><span data-stu-id="0b945-131">The inner-loop stage is where developers define everything that happens before pushing code into the code repository (for example, a source control system such as Git).</span></span> <span data-ttu-id="0b945-132">커밋된 후 연속 통합 (CI) 및 워크플로의 나머지 저장소를 트리거합니다.</span><span class="sxs-lookup"><span data-stu-id="0b945-132">After it is committed, the repository triggers Continuous Integration (CI) and the rest of the workflow.</span></span>

<span data-ttu-id="0b945-133">내부 루프 "코드" "실행", "test" 및 "debug" + 추가 단계 응용 프로그램을 로컬로 실행 하기 전에 직접 같은 일반적인 단계 기본적으로 구성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0b945-133">The inner loop basically consists of typical steps like "code," "run," "test," and "debug," plus additional steps directly before running the app locally.</span></span> <span data-ttu-id="0b945-134">이 개발자가 실행 되 고 Docker 컨테이너 응용 프로그램을 테스트 합니다.</span><span class="sxs-lookup"><span data-stu-id="0b945-134">This is when the developer runs and tests the app as a Docker container.</span></span> <span data-ttu-id="0b945-135">내부 루프 워크플로 다음 섹션에 설명 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0b945-135">The inner-loop workflow will be explained in the sections that follow.</span></span>

<span data-ttu-id="0b945-136">에 대 한 최종 워크플로 살펴볼 수는 단계를 다시 수행, DevOps 워크플로 기술 또는 도구 집합 보다 많은:는 문화적 변화를 필요로 하는 태도 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="0b945-136">Taking a step back to look at the end-to end workflow, the DevOps workflow is more than a technology or a tool set: it's a mindset that requires cultural evolution.</span></span> <span data-ttu-id="0b945-137">것, 사람, 프로세스 및 적절 한 도구를 빠르고 보다 예측 가능한 응용 프로그램 수명 주기를 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="0b945-137">It is people, processes, and the appropriate tools to make your application life cycle faster and more predictable.</span></span> <span data-ttu-id="0b945-138">컨테이너 화 된 워크플로 일반적으로 채택 하 고 기업의 사람 및 컨테이너 화 된 워크플로 일치 하는 프로세스를 나타내기 위해 자신의 조직 재구성 합니다.</span><span class="sxs-lookup"><span data-stu-id="0b945-138">Enterprises that adopt a containerized workflow typically restructure their organizations to represent people and processes that match the containerized workflow.</span></span>

<span data-ttu-id="0b945-139">DevOps 연습 신속 하 게 응답할 함께 경쟁 부족 한지에 오류가 발생 하기 쉬운 수동 프로세스 자동화에 향상 된 추적 가능성 및 반복 워크플로를 대체 하 여 팀 시킬 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0b945-139">Practicing DevOps can help teams respond faster together to competitive pressures by replacing error-prone manual processes with automation, which results in improved traceability and repeatable workflows.</span></span> <span data-ttu-id="0b945-140">조직에서는 환경을 보다 효율적으로 관리 하 고 수도 온-프레미스와 클라우드 리소스의 조합 사용 하 여 비용 절감와 통합 된 도구를 실현 합니다.</span><span class="sxs-lookup"><span data-stu-id="0b945-140">Organizations also can manage environments more efficiently and realize cost savings with a combination of on-premises and cloud resources as well as tightly integrated tooling.</span></span>

<span data-ttu-id="0b945-141">Docker의 기술을 개발 상자 안쪽 루프 (실행 되는 코드, 디버그)에서 빌드-테스트-CI 단계를 작업 하는 동안 워크플로 거의 모든 단계에 존재 하는지 참조 Docker 응용 프로그램에 대 한 DevOps 워크플로 구현할 때는 하 고, 물론, 프로덕션 및 스테이징 환경 및 사용자 컨테이너 환경에 배포 하는 경우.</span><span class="sxs-lookup"><span data-stu-id="0b945-141">When implementing your DevOps workflow for Docker applications, you'll see that Docker's technologies are present in almost every stage of the workflow, from your development box while working in the inner loop (code, run, debug), to the build-test-CI phase, and, of course, at the production and staging environments and when deploying your containers to those environments.</span></span>

<span data-ttu-id="0b945-142">품질 사례 향상 률 값 수정의 비용을 줄일 수 있는 개발 주기의 초기 단계에서 오류를 식별할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0b945-142">Improvement of quality practices helps to identify defects early in the development cycle, which reduces the cost of fixing them.</span></span> <span data-ttu-id="0b945-143">이미지에는 환경 및 종속성을 포함 하 여 여러 환경에 걸쳐 같은 이미지 배포의 원칙을 채택 하 환경 관련 구성 배포를 안정적으로 만드는 추출 하는 규칙을 수준을 올립니다.</span><span class="sxs-lookup"><span data-stu-id="0b945-143">By including the environment and dependencies in the image and adopting a philosophy of deploying the same image across multiple environments, you promote a discipline of extracting the environment-specific configurations making deployments more reliable.</span></span>

<span data-ttu-id="0b945-144">다양 한 데이터 (모니터링 및 진단) 효과적인 계측을 통해 얻은 성능 문제와 향후 우선 순위 및 투자를 안내 하는 사용자 동작에 대 한 정보를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="0b945-144">Rich data obtained through effective instrumentation (monitoring and diagnostics) provides insight into performance issues and user behavior to guide future priorities and investments.</span></span>

<span data-ttu-id="0b945-145">DevOps는 목적지는 여행을 고려 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="0b945-145">DevOps should be considered a journey, not a destination.</span></span> <span data-ttu-id="0b945-146">수 성공을 보여에 자세한 하 고 있는 발전 적절 하 게 범위가 지정 된 프로젝트를 통해 증분 방식으로 구현 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="0b945-146">It should be implemented incrementally through appropriately scoped projects from which you can demonstrate success, learn, and evolve.</span></span>

## <a name="benefits-of-devops-for-containerized-applications"></a><span data-ttu-id="0b945-147">컨테이너 화 된 응용 프로그램에 대 한 DevOps의 이점</span><span class="sxs-lookup"><span data-stu-id="0b945-147">Benefits of DevOps for containerized applications</span></span>

<span data-ttu-id="0b945-148">다음은 단색 DevOps 워크플로에서 제공 하는 가장 중요 한 이점입니다.</span><span class="sxs-lookup"><span data-stu-id="0b945-148">Here are some of the most important benefits provided by a solid DevOps workflow:</span></span>

-   <span data-ttu-id="0b945-149">빠르고 더 나은 준수 더 나은 품질의 소프트웨어를 제공합니다</span><span class="sxs-lookup"><span data-stu-id="0b945-149">Deliver better-quality software, faster and with better compliance</span></span>

-   <span data-ttu-id="0b945-150">이전 버전, 그리고 보다 경제적으로 드라이브 지속적인 향상 및 조정</span><span class="sxs-lookup"><span data-stu-id="0b945-150">Drive continuous improvement and adjustments earlier and more economically</span></span>

-   <span data-ttu-id="0b945-151">투명도 작업 효율성과 관련자에 게 제공 하 고 소프트웨어 운영에 관련 된 간 공동 작업</span><span class="sxs-lookup"><span data-stu-id="0b945-151">Increase transparency and collaboration among stakeholders involved in delivering and operating software</span></span>

-   <span data-ttu-id="0b945-152">비용을 제어 하 고 보안 위험을 최소화 하면서 프로 비전 된 리소스를 보다 효과적으로 활용</span><span class="sxs-lookup"><span data-stu-id="0b945-152">Control costs and utilize provisioned resources more effectively while minimizing security risks</span></span>

-   <span data-ttu-id="0b945-153">대부분의 오픈 소스에 대 한 투자를 포함 하 여 기존 DevOps 투자와 잘 플러그 앤 플레이</span><span class="sxs-lookup"><span data-stu-id="0b945-153">Plug and play well with many of your existing DevOps investments, including investments in open source</span></span>

>[!div class="step-by-step"]
<span data-ttu-id="0b945-154">[이전] [다음]을 (index.md) (... /Microsoft-platform-tools-containerized-apps/index.md)</span><span class="sxs-lookup"><span data-stu-id="0b945-154">[Previous] (index.md) [Next] (../Microsoft-platform-tools-containerized-apps/index.md)</span></span>

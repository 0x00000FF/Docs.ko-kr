---
title: DevOps 공동 작업을 위한 기초로 컨테이너
description: DevOps를 간소화 하는 컨테이너의 키 역할을 이해 합니다.
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 11/23/2018
ms.openlocfilehash: d0339199092304dd6c91707d8cf4da213f110b58
ms.sourcegitcommit: 30e2fe5cc4165aa6dde7218ec80a13def3255e98
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 02/13/2019
ms.locfileid: "56219292"
---
# <a name="containers-as-the-foundation-for-devops-collaboration"></a><span data-ttu-id="e7eaa-103">DevOps 공동 작업을 위한 기초로 컨테이너</span><span class="sxs-lookup"><span data-stu-id="e7eaa-103">Containers as the foundation for DevOps collaboration</span></span>

<span data-ttu-id="e7eaa-104">컨테이너 및 Docker 기술을 매우 기본적으로 개발자와 공유할 수는 소프트웨어 및 종속성 쉽게 IT 운영 및 프로덕션 환경 일반적인 "작동 내 컴퓨터에서" 변명을 제거 하는 동안.</span><span class="sxs-lookup"><span data-stu-id="e7eaa-104">By the very nature of the containers and Docker technology, developers can share their software and dependencies easily with IT operations and production environments while eliminating the typical "it works on my machine" excuse.</span></span> <span data-ttu-id="e7eaa-105">컨테이너는 서로 다른 환경 간에 응용 프로그램 충돌을 해결 합니다.</span><span class="sxs-lookup"><span data-stu-id="e7eaa-105">Containers solve application conflicts between different environments.</span></span> <span data-ttu-id="e7eaa-106">직접 컨테이너 및 Docker 하지 개발자와 IT 운영에 더 가깝게를 모을 쉽게 효율적으로 공동 작업할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e7eaa-106">Indirectly, containers and Docker bring developers and IT operations closer together, making it easier for them to collaborate effectively.</span></span> <span data-ttu-id="e7eaa-107">컨테이너 워크플로 채택 하 고 많은 고객이 검색 했으므로 있지만 이전 릴리스에 대 한 더 복잡 한 구성을 통해 구현 하 고 파이프라인을 구축 해야 했습니다 DevOps 연속성을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="e7eaa-107">Adopting the container workflow provides many customers with the DevOps continuity they've sought but previously had to implement via more complex configuration for release and build pipelines.</span></span> <span data-ttu-id="e7eaa-108">컨테이너는 DevOps의 빌드/테스트/배포 파이프라인을 간소화합니다.</span><span class="sxs-lookup"><span data-stu-id="e7eaa-108">Containers simplify the build/test/deploy pipelines in DevOps.</span></span>

![](./media/image1.png)

<span data-ttu-id="e7eaa-109">그림 2-1: 컨테이너 화 된 Docker 응용 프로그램에 대 한 수명 주기에서 "가상"사용자 당 기본 워크 로드</span><span class="sxs-lookup"><span data-stu-id="e7eaa-109">Figure 2-1: Main workloads per "personas" in the life cycle for containerized Docker applications</span></span>

<span data-ttu-id="e7eaa-110">Docker 컨테이너를 개발자 고유의 (응용 프로그램 및 서비스에 프레임 워크 및 구성 요소에 대 한 종속성)는 컨테이너와 컨테이너 및 서비스를 함께 서비스의 컬렉션으로 구성 된 응용 프로그램으로 동작 내에서 새로운 기능입니다.</span><span class="sxs-lookup"><span data-stu-id="e7eaa-110">With Docker containers, developers own what's within the container (application and service, and dependencies to frameworks and components) and how the containers and services behave together as an application composed by a collection of services.</span></span> <span data-ttu-id="e7eaa-111">여러 컨테이너의 상호 종속성 호출할 수 있습니다 하거나 docker compose.yml 파일에 정의 된 한 *배포 매니페스트*합니다.</span><span class="sxs-lookup"><span data-stu-id="e7eaa-111">The interdependencies of the multiple containers are defined in a docker-compose.yml file, or what could be called a *deployment manifest*.</span></span> <span data-ttu-id="e7eaa-112">IT 운영 팀 (IT 전문가 및 관리) 프로덕션 환경의; 관리에 집중할 수는 한편, 인프라 확장성입니다. 모니터링, 고 궁극적으로 응용 프로그램 제공 하는 제대로 최종 사용자에 대 한 다양 한 컨테이너의 내용을 알 필요 없이 보장 합니다.</span><span class="sxs-lookup"><span data-stu-id="e7eaa-112">Meanwhile, IT operations teams (IT professionals and management) can focus on the management of production environments; infrastructure; scalability; monitoring; and, ultimately, ensuring that the applications are delivering properly for the end users, without having to know the contents of the various containers.</span></span> <span data-ttu-id="e7eaa-113">따라서 이름 "컨테이너" 실제 배송 컨테이너에 비유를 회수 합니다.</span><span class="sxs-lookup"><span data-stu-id="e7eaa-113">Hence, the name "container," recalling the analogy to real-world shipping containers.</span></span> <span data-ttu-id="e7eaa-114">따라서 컨테이너의 콘텐츠 소유자 필요 하지 관련이 어떻게 컨테이너 제공 될를 사용 하 여 자체 및 배송 회사 전송 대상 원본 지점에서 컨테이너를 파악 하거나 콘텐츠에 대 한 고려 없이 합니다.</span><span class="sxs-lookup"><span data-stu-id="e7eaa-114">Thus, the owners of a container's content need not concern themselves with how the container will be shipped, and the shipping company transports a container from its point of origin to its destination without knowing or caring about the contents.</span></span> <span data-ttu-id="e7eaa-115">유사한 방식으로 개발자가 만들고 "전송" 메커니즘을 염려 하지 않아도 Docker 컨테이너 내에서 콘텐츠를 소유할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e7eaa-115">In a similar manner, developers can create and own the contents within a Docker container without the need to concern themselves with the "transport" mechanisms.</span></span>

<span data-ttu-id="e7eaa-116">그림 2-1의 좌 변에 있는 pillar, 개발자가 작성 한 Docker에 대 한 Windows 또는 Mac. 사용 하 여 로컬로 Docker 컨테이너에서 코드 실행</span><span class="sxs-lookup"><span data-stu-id="e7eaa-116">In the pillar on the left side of Figure 2-1, developers write and run code locally in Docker containers by using Docker for Windows or Mac.</span></span> <span data-ttu-id="e7eaa-117">Docker 이미지에 해당 코드를 빌드하는 빌드 단계 및 실행 하려면 기본 운영 체제를 지정 하는 Dockerfile을 사용 하 여 코드에 대 한 운영 환경을 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="e7eaa-117">They define the operating environment for the code by using a Dockerfile that specifies the base operating system to run as well as the build steps for building their code into a Docker image.</span></span> <span data-ttu-id="e7eaa-118">개발자가 정의 하는 방법을 사용 하 여 앞서 언급 한 하나 이상의 이미지를 운용 됩니다 *docker compose.yml* 배포 매니페스트 파일.</span><span class="sxs-lookup"><span data-stu-id="e7eaa-118">The developers define how the one or more images will interoperate using the aforementioned *docker-compose.yml* file deployment manifest.</span></span> <span data-ttu-id="e7eaa-119">로컬 개발을 완료 될 때마다 이러한 응용 프로그램 코드와 Docker 구성 파일이 코드 리포지토리에 푸시합니다 (즉, Git 리포지토리) 선택한 합니다.</span><span class="sxs-lookup"><span data-stu-id="e7eaa-119">As they complete their local development, they push their application code plus the Docker configuration files to the code repository of their choice (that is, Git repository).</span></span>

<span data-ttu-id="e7eaa-120">DevOps 기본 제공 코드 리포지토리에 Dockerfile을 사용 하 여 빌드 – 연속 통합 (CI) 파이프라인을 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="e7eaa-120">The DevOps pillar defines the build–Continuous Integration (CI) pipelines using the Dockerfile provided in the code repository.</span></span> <span data-ttu-id="e7eaa-121">CI 시스템 선택한 Docker 레지스트리에서 기본 컨테이너 이미지를 가져옵니다 하 고 응용 프로그램에 대 한 사용자 지정 Docker 이미지를 빌드합니다.</span><span class="sxs-lookup"><span data-stu-id="e7eaa-121">The CI system pulls the base container images from the selected Docker registry and builds the custom Docker images for the application.</span></span> <span data-ttu-id="e7eaa-122">이미지 다음 유효성이 검사 되며 여러 환경에 배포에 사용 되는 Docker 레지스트리로 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="e7eaa-122">The images then are validated and pushed to the Docker registry used for the deployments to multiple environments.</span></span>

<span data-ttu-id="e7eaa-123">응용 프로그램 및 사용자 의견 및 응용 프로그램 수 하는 방법에 대 한 개발 팀에 대 한 정보를 제공할 수 있습니다 이러한 환경 및 응용 프로그램을 모니터링 하는 동안 프로덕션 환경에서 인프라에 오른쪽 pillar, 팀 관리 작업을 배포 향상 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="e7eaa-123">In the pillar on the right, operations teams manage deployed applications and infrastructure in production while monitoring the environment and applications so that they can provide feedback and insights to the development team about how the application might be improved.</span></span> <span data-ttu-id="e7eaa-124">컨테이너 앱은 일반적으로 컨테이너 오 케 스트레이 터를 사용 하 여 프로덕션에서 실행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="e7eaa-124">Container apps are typically run in production using container orchestrators.</span></span>

<span data-ttu-id="e7eaa-125">두 팀을 분리를 계약으로 응용 프로그램 수명 주기에서 두 팀의 공동 작업을 크게 개선 하는 동안 제공 하는 기본 플랫폼 (Docker 컨테이너)를 통해 공동 작업 합니다.</span><span class="sxs-lookup"><span data-stu-id="e7eaa-125">The two teams are collaborating through a foundational platform (Docker containers) that provides a separation of concerns as a contract, while greatly improving the two teams' collaboration in the application life cycle.</span></span> <span data-ttu-id="e7eaa-126">개발자가 컨테이너 내용을, 운영 환경 및 컨테이너 상호 종속성을 소유할 반면 운영 팀을 매니페스트 함께 빌드된 이미지를 가져오고 해당 오케스트레이션 시스템에서 실행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="e7eaa-126">The developers own the container contents, its operating environment, and the container interdependencies, whereas the operations teams take the built images along with the manifest and runs them in their orchestration system.</span></span>

## <a name="introduction-to-a-generic-end-to-end-docker-application-life-cycle-workflow"></a><span data-ttu-id="e7eaa-127">제네릭 엔드-투-엔드 Docker 응용 프로그램 수명 주기 워크플로 소개</span><span class="sxs-lookup"><span data-stu-id="e7eaa-127">Introduction to a generic end-to-end Docker application life cycle workflow</span></span>

<span data-ttu-id="e7eaa-128">그림 2-2은 특정 DevOps 작업 및 자산에이 인스턴스에서 집중 Docker 응용 프로그램 수명 주기를 위한 자세한 워크플로.</span><span class="sxs-lookup"><span data-stu-id="e7eaa-128">Figure 2-2 presents a more detailed workflow for a Docker application life cycle, focusing in this instance on specific DevOps activities and assets.</span></span>

![](./media/image2.png)

<span data-ttu-id="e7eaa-129">그림 2-2: Docker 컨테이너 화 된 응용 프로그램 수명 주기에 대 한 개략적인 워크플로</span><span class="sxs-lookup"><span data-stu-id="e7eaa-129">Figure 2-2: High-level workflow for the Docker containerized application life cycle</span></span>

<span data-ttu-id="e7eaa-130">모든 내부 루프 워크플로의 코드 작성을 시작 하는 개발자가 사용 하 여 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="e7eaa-130">Everything begins with the developer, who starts writing code in the inner-loop workflow.</span></span> <span data-ttu-id="e7eaa-131">내부 루프 단계 코드 (예를 들어, 소스 제어 시스템을 Git과 같은) 코드 리포지토리로 푸시하기 전에 발생 하는 모든 개발자가 정의 됩니다.</span><span class="sxs-lookup"><span data-stu-id="e7eaa-131">The inner-loop stage is where developers define everything that happens before pushing code into the code repository (for example, a source control system such as Git).</span></span> <span data-ttu-id="e7eaa-132">커밋된 후 리포지토리에 CI (지속적인 통합) 및 워크플로의 나머지 부분을 트리거합니다.</span><span class="sxs-lookup"><span data-stu-id="e7eaa-132">After it is committed, the repository triggers Continuous Integration (CI) and the rest of the workflow.</span></span>

<span data-ttu-id="e7eaa-133">기본적으로 내부 루프 "코드," 실행"," "test" 및 "debug" + 추가 단계 앱을 로컬로 실행 하기 전에 직접 같은 일반적인 단계로 구성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="e7eaa-133">The inner loop basically consists of typical steps like "code," "run," "test," and "debug," plus additional steps directly before running the app locally.</span></span> <span data-ttu-id="e7eaa-134">개발자는 실행 하 고 Docker 컨테이너 앱을 테스트 하는 경우입니다.</span><span class="sxs-lookup"><span data-stu-id="e7eaa-134">This is when the developer runs and tests the app as a Docker container.</span></span> <span data-ttu-id="e7eaa-135">내부 루프 워크플로 다음 섹션에 설명 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e7eaa-135">The inner-loop workflow will be explained in the sections that follow.</span></span>

<span data-ttu-id="e7eaa-136">단계를 다시 간 최종 워크플로 런타임에 검색할, DevOps 워크플로 수행 하는 기술 또는 도구 집합 보다: 문화적 발전 해야 하는 하나의 사고방식입니다.</span><span class="sxs-lookup"><span data-stu-id="e7eaa-136">Taking a step back to look at the end-to end workflow, the DevOps workflow is more than a technology or a tool set: it's a mindset that requires cultural evolution.</span></span> <span data-ttu-id="e7eaa-137">인력, 프로세스 및 적절 한 도구 빠르고 예측 가능성이 더욱 뛰어난 응용 프로그램 수명 주기를 확인 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="e7eaa-137">It is people, processes, and the appropriate tools to make your application life cycle faster and more predictable.</span></span> <span data-ttu-id="e7eaa-138">기업은 일반적으로 컨테이너 화 된 워크플로 채택 하는 사람 및 컨테이너 화 된 워크플로 일치 하는 프로세스를 나타내는 조직 재구성 합니다.</span><span class="sxs-lookup"><span data-stu-id="e7eaa-138">Enterprises that adopt a containerized workflow typically restructure their organizations to represent people and processes that match the containerized workflow.</span></span>

<span data-ttu-id="e7eaa-139">DevOps를 캡처하므로 더 빠르게 응답 함께 경쟁 정리가 향상 된 추적 가능성 및 반복 가능한 워크플로 자동화를 사용 하 여 오류가 발생 하기 쉬운 수동 프로세스를 대체 하 여 팀 도움이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="e7eaa-139">Practicing DevOps can help teams respond faster together to competitive pressures by replacing error-prone manual processes with automation, which results in improved traceability and repeatable workflows.</span></span> <span data-ttu-id="e7eaa-140">조직은 환경을 보다 효율적으로 관리 하 고 수도 긴밀 하 게 통합 된 도구와 온-프레미스 및 클라우드 리소스를 조합 하 여 비용 절감을 실현 합니다.</span><span class="sxs-lookup"><span data-stu-id="e7eaa-140">Organizations also can manage environments more efficiently and realize cost savings with a combination of on-premises and cloud resources as well as tightly integrated tooling.</span></span>

<span data-ttu-id="e7eaa-141">Docker 응용 프로그램에 대 한 DevOps 워크플로 구현할 때 Docker의 기술은 CI-빌드-테스트 단계로 (코드, 실행, 디버그), 내부 루프에서 작업 하는 동안 개발 상자에 있는 워크플로의 거의 모든 단계에서 볼 수 있습니다 하 고, 물론 프로덕션 및 스테이징 환경 및 해당 환경에 컨테이너를 배포 합니다.</span><span class="sxs-lookup"><span data-stu-id="e7eaa-141">When implementing your DevOps workflow for Docker applications, you'll see that Docker's technologies are present in almost every stage of the workflow, from your development box while working in the inner loop (code, run, debug), to the build-test-CI phase, and, of course, at the production and staging environments and when deploying your containers to those environments.</span></span>

<span data-ttu-id="e7eaa-142">품질 사례 향상 수정 비용을 줄일 수 있는 개발 주기의 초기에 결함을 식별할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e7eaa-142">Improvement of quality practices helps to identify defects early in the development cycle, which reduces the cost of fixing them.</span></span> <span data-ttu-id="e7eaa-143">환경 및 종속성을 포함 하 여 이미지에서 및 다양 한 환경에서 동일한 이미지를 배포 하는 원칙을 채택 하 고, 안정적으로 배포할 수 있어 환경별 구성을 추출 하는 분야를 승격할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e7eaa-143">By including the environment and dependencies in the image and adopting a philosophy of deploying the same image across multiple environments, you promote a discipline of extracting the environment-specific configurations making deployments more reliable.</span></span>

<span data-ttu-id="e7eaa-144">효과적인 계측 (모니터링 및 진단)을 통해 가져온 데이터를 다양 한 성능 문제와 향후 우선 순위 및 투자를 안내할 사용자 동작에 대 한 정보를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="e7eaa-144">Rich data obtained through effective instrumentation (monitoring and diagnostics) provides insight into performance issues and user behavior to guide future priorities and investments.</span></span>

<span data-ttu-id="e7eaa-145">DevOps는 목적지 경험을 고려해 야 합니다.</span><span class="sxs-lookup"><span data-stu-id="e7eaa-145">DevOps should be considered a journey, not a destination.</span></span> <span data-ttu-id="e7eaa-146">적절 하 게 범위가 지정 된 프로젝트는 성공을 보여, 자세한를 발전을 통해 증분 방식으로 구현 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="e7eaa-146">It should be implemented incrementally through appropriately scoped projects from which you can demonstrate success, learn, and evolve.</span></span>

## <a name="benefits-of-devops-for-containerized-applications"></a><span data-ttu-id="e7eaa-147">컨테이너 화 된 응용 프로그램에 대 한 DevOps의 이점</span><span class="sxs-lookup"><span data-stu-id="e7eaa-147">Benefits of DevOps for containerized applications</span></span>

<span data-ttu-id="e7eaa-148">다음은 일부 solid DevOps 워크플로에 의해 제공 되는 가장 중요 한 혜택입니다.</span><span class="sxs-lookup"><span data-stu-id="e7eaa-148">Here are some of the most important benefits provided by a solid DevOps workflow:</span></span>

-   <span data-ttu-id="e7eaa-149">빠르고 효율적인 준수를 사용 하 여 더 나은 품질의 소프트웨어를 제공</span><span class="sxs-lookup"><span data-stu-id="e7eaa-149">Deliver better-quality software, faster and with better compliance</span></span>

-   <span data-ttu-id="e7eaa-150">조기에 더 경제적으로 지속적인 향상과 조정 드라이브</span><span class="sxs-lookup"><span data-stu-id="e7eaa-150">Drive continuous improvement and adjustments earlier and more economically</span></span>

-   <span data-ttu-id="e7eaa-151">투명도 증가 및 제공 하 고 소프트웨어를 운영 하는 데 참여할된 관련자 간의 공동 작업</span><span class="sxs-lookup"><span data-stu-id="e7eaa-151">Increase transparency and collaboration among stakeholders involved in delivering and operating software</span></span>

-   <span data-ttu-id="e7eaa-152">비용을 제어 하 고 보안 위험을 최소화 하면서 프로 비전 된 리소스를 보다 효과적으로 활용</span><span class="sxs-lookup"><span data-stu-id="e7eaa-152">Control costs and utilize provisioned resources more effectively while minimizing security risks</span></span>

-   <span data-ttu-id="e7eaa-153">다양 한 오픈 소스에 대 한 투자를 포함 하 여 기존 DevOps 투자 잘 플러그 앤 플레이</span><span class="sxs-lookup"><span data-stu-id="e7eaa-153">Plug and play well with many of your existing DevOps investments, including investments in open source</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="e7eaa-154">[이전](index.md)
>[다음](../Microsoft-platform-tools-containerized-apps/index.md)</span><span class="sxs-lookup"><span data-stu-id="e7eaa-154">[Previous](index.md)
[Next](../Microsoft-platform-tools-containerized-apps/index.md)</span></span>
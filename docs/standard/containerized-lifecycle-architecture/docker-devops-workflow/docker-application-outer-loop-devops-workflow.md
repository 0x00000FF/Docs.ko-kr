---
title: Docker 응용 프로그램에 대 한 외부 루프 DevOps 워크플로의 단계
description: Microsoft 플랫폼 및 도구를 사용하여 컨테이너화된 Docker 응용 프로그램 수명 주기
ms.prod: .net
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 09/22/2017
ms.topic: article
ms.workload:
- dotnet
- dotnetcore
ms.openlocfilehash: 7a85f42969a3bc1476367203415eb6898641e33a
ms.sourcegitcommit: 2e8acae16ae802f2d6d04e3ce0a6dbf04e476513
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 04/18/2018
---
# <a name="steps-in-the-outer-loop-devops-workflow-for-a-docker-application"></a><span data-ttu-id="aa55d-103">Docker 응용 프로그램에 대 한 외부 루프 DevOps 워크플로의 단계</span><span class="sxs-lookup"><span data-stu-id="aa55d-103">Steps in the outer-loop DevOps workflow for a Docker application</span></span>

<span data-ttu-id="aa55d-104">그림 5-1 DevOps 외부 반복 워크플로 구성 하는 단계는 종단 간 솔루션 내의 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa55d-104">Figure 5-1 presents an end-to-end depiction of the steps comprising the DevOps outer-loop workflow.</span></span>

![](./media/image1.png)

<span data-ttu-id="aa55d-105">Microsoft 도구와 함께 Docker 응용 프로그램에 대 한 그림 5-1: DevOps 외부 루프 워크플로</span><span class="sxs-lookup"><span data-stu-id="aa55d-105">Figure 5-1: DevOps outer-loop workflow for Docker applications with Microsoft tools</span></span>

<span data-ttu-id="aa55d-106">이제 이러한 각 단계를 더 자세히 살펴보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="aa55d-106">Now, let's examine each of these steps in greater detail.</span></span>

## <a name="step-1-inner-loop-development-workflow"></a><span data-ttu-id="aa55d-107">1 단계: 내부 루프 개발 워크플로</span><span class="sxs-lookup"><span data-stu-id="aa55d-107">Step 1: Inner-loop development workflow</span></span>

<span data-ttu-id="aa55d-108">이 단계 4 장에에서 자세히 설명 되어 있지만 재생을 위해 다음은 여기서 외부 루프 시작 되는 순간을 개발자 푸시 CI 파이프라인 동작 시작 코드를 소스 제어 관리 시스템 (예: Git).</span><span class="sxs-lookup"><span data-stu-id="aa55d-108">This step is explained in detail in Chapter 4, but, to recap, here is where the outer-loop begins, the moment at which a developer pushes code to the source control management system (like Git) initiating CI pipeline actions.</span></span>

## <a name="step-2-source-code-control-integration-and-management-with-visual-studio-team-services-and-git"></a><span data-ttu-id="aa55d-109">2 단계: 소스 코드 제어 통합 및 Visual Studio Team Services 및 Git를 사용 하 여 관리</span><span class="sxs-lookup"><span data-stu-id="aa55d-109">Step 2: Source-Code Control integration and management with Visual Studio Team Services and Git</span></span>

<span data-ttu-id="aa55d-110">이 단계에서 통합 된 버전의 팀에서 다른 개발자 로부터 들어오는 모든 코드를 수집 하기 위해 버전 제어 시스템을 지정 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa55d-110">At this step, you need to have a version-control system to gather a consolidated version of all the code coming from the different developers in the team.</span></span>

<span data-ttu-id="aa55d-111">소스 코드 제어 (SCC) 및 소스 코드 관리에 대부분의 개발자는 DevOps 수명에서 Docker 응용 프로그램을 만들 때 주기 많습니다 것 처럼 보일 수, 하는 경우에이 응용 프로그램을 사용 하 여 Docker 이미지를 제출 하지 해야 강조 하기 위해 중요 레지스트리를 직접 전역 Docker (예: Azure 컨테이너 레지스트리 또는 Docker 허브)에서 개발자의 컴퓨터.</span><span class="sxs-lookup"><span data-stu-id="aa55d-111">Even though source-code control (SCC) and source-code management might seem second-nature to most developers, when creating Docker applications in a DevOps life cycle, it is critical to emphasize that you must not submit the Docker images with the application directly to the global Docker Registry (like Azure Container Registry or Docker Hub) from the developer's machine.</span></span> <span data-ttu-id="aa55d-112">반대로 Docker 이미지를 해제 하 고 프로덕션 환경에 배포 글로벌 빌드 또는 소스 코드 리포지토리에 (예: Git)에 따라 CI 파이프라인에 통합 되는 소스 코드에만 전적으로 만들 수 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa55d-112">On the contrary, the Docker images to be released and deployed to production environments must be created solely on the source code that is being integrated in your global build or CI pipeline based on your source-code repository (like Git).</span></span>

<span data-ttu-id="aa55d-113">자체는 개발자가 생성 되는 로컬 이미지 자신의 컴퓨터 내에서 테스트할 때 개발자가 여는 것 같습니다.</span><span class="sxs-lookup"><span data-stu-id="aa55d-113">The local images generated by the developers themselves should be used just by the developers when testing within their own machines.</span></span> <span data-ttu-id="aa55d-114">이 때문에를 SCC 코드에서 활성화 DevOps 파이프라인에 있는 것이 중요 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa55d-114">This is why it is critical to have the DevOps pipeline activated from the SCC code.</span></span>

<span data-ttu-id="aa55d-115">Visual Studio Team Services 및 Team Foundation Server Git 및 Team Foundation 버전 제어를 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="aa55d-115">Visual Studio Team Services and Team Foundation Server support Git and Team Foundation Version Control.</span></span> <span data-ttu-id="aa55d-116">서로 선택할 수 있으며 Microsoft 종단 간 환경을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa55d-116">You can choose between them and use it for an end-to-end Microsoft experience.</span></span> <span data-ttu-id="aa55d-117">그러나도 관리할 수 있습니다 (예: GitHub, 온-프레미스 Git 리포지토리 또는 Subversion) 외부 저장소에서 코드 고에 연결 하 고 DevOps CI 파이프라인에 대 한 시작 점으로 코드를 가져올 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aa55d-117">However, you also can manage your code in external repositories (like GitHub, on-premises Git repositories, or Subversion) and still be able to connect to it and get the code as the starting point for your DevOps CI pipeline.</span></span>

## <a name="step-3-build-ci-integrate-and-test-with-visual-studio-team-services-and-docker"></a><span data-ttu-id="aa55d-118">3 단계: 빌드, CI를 통합 하 고 Visual Studio Team Services 및 Docker와 테스트</span><span class="sxs-lookup"><span data-stu-id="aa55d-118">Step 3: Build, CI, Integrate, and Test with Visual Studio Team Services and Docker</span></span>

<span data-ttu-id="aa55d-119">CI 최신 소프트웨어 테스트 및 배달에 대 한 표준으로 나타났습니다.</span><span class="sxs-lookup"><span data-stu-id="aa55d-119">CI has emerged as a standard for modern software testing and delivery.</span></span> <span data-ttu-id="aa55d-120">Docker 솔루션 개발 및 운영 팀 간의 문제를 명확 하 게 분리 유지 관리합니다.</span><span class="sxs-lookup"><span data-stu-id="aa55d-120">The Docker solution maintains a clear separation of concerns between the development and operations teams.</span></span> <span data-ttu-id="aa55d-121">Docker 이미지의 불변성 개발, CI를 통해 테스트 및 프로덕션 환경에서 실행에 어떤 간의 반복 가능한 배포가 보장 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa55d-121">The immutability of Docker images ensures a repeatable deployment between what's developed, tested through CI, and run in production.</span></span> <span data-ttu-id="aa55d-122">Docker 엔진 개발자 랩톱에서 배포 하 고 테스트 인프라 컨테이너 이식 가능한 환경에 걸쳐.</span><span class="sxs-lookup"><span data-stu-id="aa55d-122">Docker Engine deployed across the developer laptops and test infrastructure makes the containers portable across environments.</span></span>

<span data-ttu-id="aa55d-123">이 시점에서 제출 올바른 코드 버전 제어 시스템을 설정한 후 필요한는 *빌드 서비스* 에 코드를 선택 하 고 글로벌 빌드 및 테스트를 실행 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa55d-123">At this point, after you have a version-control system with the correct code submitted, you need a *build service* to pick up the code and run the global build and tests.</span></span>

<span data-ttu-id="aa55d-124">이 단계 (CI 빌드, 테스트)에 대 한 내부 워크플로 빌드 (Visual Studio Team Services) 서버에, Docker 엔진 및 Docker 레지스트리 코드 리포지토리에 (Git, 등)로 구성 된 CI 파이프라인의 구성에 관한는입니다.</span><span class="sxs-lookup"><span data-stu-id="aa55d-124">The internal workflow for this step (CI, build, test) is about the construction of a CI pipeline consisting of your code repository (Git, etc.), your build server (Visual Studio Team Services), Docker Engine, and a Docker Registry.</span></span>

<span data-ttu-id="aa55d-125">사용할 수 있습니다 Visual Studio Team Services의 기반으로 하 고 작성 된 "아티팩트"를 게시 하기 위한 응용 프로그램을 빌드하고 CI 파이프라인을 설정 하기 위한 "아티팩트 저장소에," 다음 단계에 설명 된.</span><span class="sxs-lookup"><span data-stu-id="aa55d-125">You can use Visual Studio Team Services as the foundation for building your applications and setting your CI pipeline, and for publishing the built "artifacts" to an "artifacts repository," which is explained in the next step.</span></span>

<span data-ttu-id="aa55d-126">"최종 아티팩트" 배포에 대 한 Docker를 사용 하는 경우 배포할 응용 프로그램 또는 서비스를 사용 하 여 Docker 이미지에 포함 된 해당 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa55d-126">When using Docker for the deployment, the "final artifacts" to be deployed are Docker images with your application or services embedded within them.</span></span> <span data-ttu-id="aa55d-127">이러한 이미지는 푸시하거나에 게시 한 *Docker 레지스트리* (공식 기본 이미지에 일반적으로 사용 되는 Docker 허브 레지스트리 같은 공용 하나 또는 Azure 컨테이너 레지스트리에 있는 수와 같은 개인 리포지토리에).</span><span class="sxs-lookup"><span data-stu-id="aa55d-127">Those images are pushed or published to a *Docker Registry* (a private repository like the ones you can have in Azure Container Registry, or a public one like Docker Hub Registry, which is commonly used for official base images).</span></span>

<span data-ttu-id="aa55d-128">여기에 기본적으로 개념: CI 파이프라인 시작-으로 해제 Git 같은 SCC 저장소에 커밋 됩니다.</span><span class="sxs-lookup"><span data-stu-id="aa55d-128">Here is the basic concept: The CI pipeline will be kicked-off by a commit to an SCC repository like Git.</span></span> <span data-ttu-id="aa55d-129">그림 5-2를 보여 주는 것 처럼 커밋 Docker 컨테이너 내에서 빌드 작업을 실행 하 고 해당 작업을 성공적으로 완료 되 면 Docker 이미지를 Docker 레지스트리를 강제 하려면 Visual Studio Team Services를 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa55d-129">The commit will cause Visual Studio Team Services to run a build job within a Docker container and, upon successful completion of that job, push a Docker image to the Docker Registry, as illustrated in Figure 5-2.</span></span>

![](./media/image2.png)

<span data-ttu-id="aa55d-130">그림 5-2: 관련 된 단계 CI</span><span class="sxs-lookup"><span data-stu-id="aa55d-130">Figure 5-2: The steps involved in CI</span></span>

<span data-ttu-id="aa55d-131">Docker 및 Visual Studio Team Services를 사용 하 여 기본 CI 워크플로 단계는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="aa55d-131">Here are the basic CI workflow steps with Docker and Visual Studio Team Services:</span></span>

1.  <span data-ttu-id="aa55d-132">개발자는 커밋 SCC 저장소 (Git/Visual Studio Team Services, GitHub, 등)에 푸시합니다.</span><span class="sxs-lookup"><span data-stu-id="aa55d-132">The developer pushes a commit to an SCC repository (Git/Visual Studio Team Services, GitHub, etc.).</span></span>

2.  <span data-ttu-id="aa55d-133">Visual Studio Team Services 또는 Git을 사용 하는 경우 CI 내장 되어 하기만 하면 Visual Studio Team Services에서 확인란을 선택 하는 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa55d-133">If you're using Visual Studio Team Services or Git, CI is built in, which means that it is as simple as selecting a check box in Visual Studio Team Services.</span></span> <span data-ttu-id="aa55d-134">외부 SCC (예: GitHub에서)를 사용 하 여 한 *webhook* 업데이트의 Visual Studio Team Services 또는 Git/GitHub를 강제 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa55d-134">If you're using an external SCC (like GitHub), a *webhook* will notify Visual Studio Team Services of the update or push to Git/GitHub.</span></span>

3.  <span data-ttu-id="aa55d-135">Visual Studio Team Services에는 이미지 뿐만 아니라 응용 프로그램 및 테스트 코드를 설명 하는 DockerFile을 포함 하 여 SCC 저장소를 끌어옵니다.</span><span class="sxs-lookup"><span data-stu-id="aa55d-135">Visual Studio Team Services pulls the SCC repository, including the DockerFile describing the image as well as the application and test code.</span></span>

4.  <span data-ttu-id="aa55d-136">Visual Studio Team Services에는 Docker 이미지를 빌드하고 빌드 번호 레이블 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa55d-136">Visual Studio Team Services builds a Docker image and labels it with a build number.</span></span>

5.  <span data-ttu-id="aa55d-137">Visual Studio Team Services를 프로 비전 된 Docker 호스트 내에서 Docker 컨테이너 인스턴스화하고 적절 한 테스트를 실행 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa55d-137">Visual Studio Team Services instantiates the Docker container within the provisioned Docker Host, and runs the appropriate tests.</span></span>

6.  <span data-ttu-id="aa55d-138">테스트가 성공 하면 이미지는 먼저 레이블 재지정 된 의미 있는 이름에는 "축복 받은 빌드" 알 수 있도록 (같은 "/ 1.0.0" 또는 다른 레이블), 다음 푸시됩니다. Docker 레지스트리 (Docker 허브, Azure 컨테이너 레지스트리, DTR 등) 하 고</span><span class="sxs-lookup"><span data-stu-id="aa55d-138">If the tests are successful, the image is first relabeled to a meaningful name so that you know it is a "blessed build" (like "/1.0.0" or any other label), and then pushed up to your Docker Registry (Docker Hub, Azure Container Registry, DTR, etc.)</span></span>

### <a name="implementing-the-ci-pipeline-with-visual-studio-team-services-and-the-docker-extension-for-visual-studio-team-services"></a><span data-ttu-id="aa55d-139">Visual Studio Team Services에 대 한 Visual Studio Team Services와 Docker 확장이 포함 된 CI 파이프라인 구현</span><span class="sxs-lookup"><span data-stu-id="aa55d-139">Implementing the CI pipeline with Visual Studio Team Services and the Docker extension for Visual Studio Team Services</span></span>

<span data-ttu-id="aa55d-140">[Visual Studio Team Services Docker 확장](https://aka.ms/vstsdockerextension) CI 파이프라인은 Docker 이미지를 작성, 인증 된 Docker 레지스트리에 Docker 이미지를 푸시, Docker 이미지를 실행 하거나 실행할 수 있습니다 제공 하는 다른 작업에 작업을 추가 Docker CLI 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa55d-140">The [Visual Studio Team Services Docker extension](https://aka.ms/vstsdockerextension) adds a task to your CI pipeline with which you can build Docker images, push Docker images to an authenticated Docker registry, run Docker images, or run other operations offered by the Docker CLI.</span></span> <span data-ttu-id="aa55d-141">또한 Docker Compose를 빌드, 푸시 및 multicontainer Docker 응용 프로그램을 실행 또는 그림 5-3에 나와 있는 것 처럼 Docker 작성 CLI 제공 하는 다른 작업을 실행 하는 데 사용할 수 있는 작업을 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa55d-141">It also adds a Docker Compose task that you can use to build, push, and run multicontainer Docker applications, or run other operations offered by the Docker Compose CLI, as shown in Figure 5-3.</span></span>

![](./media/image3.png)

<span data-ttu-id="aa55d-142">그림 5-3: Visual Studio Team Services에서 Docker CI 파이프라인</span><span class="sxs-lookup"><span data-stu-id="aa55d-142">Figure 5-3: The Docker CI pipeline in Visual Studio Team Services</span></span>

<span data-ttu-id="aa55d-143">Docker 확장 서비스 끝점을 사용 하 여 Docker 호스트에 대 한 컨테이너 또는 이미지 레지스트리 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aa55d-143">The Docker extension can use service endpoints for Docker hosts and for container or image registries.</span></span> <span data-ttu-id="aa55d-144">작업 기본적으로 (이 현재는 사용자 지정 Visual Studio Team Services 에이전트 필요); 사용 가능한 경우 로컬 Docker 호스트를 사용 합니다. 그렇지 Docker 호스트 연결을 제공 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa55d-144">The tasks default to using a local Docker host if available (this currently requires a custom Visual Studio Team Services agent); otherwise, they require that you provide a Docker host connection.</span></span> <span data-ttu-id="aa55d-145">같은 이미지를 푸시하는 Docker 레지스트리로 인증 하 고에 종속 된 작업을 제공 하는 Docker 레지스트리 연결 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa55d-145">Actions that depend on being authenticated with a Docker registry, such as pushing an image, require that you provide a Docker registry connection.</span></span>

<span data-ttu-id="aa55d-146">Visual Studio Team Services 계정에 다음 구성 요소를 설치 하는 Visual Studio Team Services Docker 확장 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa55d-146">The Visual Studio Team Services Docker extension installs the following components in your Visual Studio Team Services account:</span></span>

-   <span data-ttu-id="aa55d-147">Docker 레지스트리에 연결에 대 한 서비스 끝점</span><span class="sxs-lookup"><span data-stu-id="aa55d-147">A service endpoint for connecting to a Docker registry</span></span>

-   <span data-ttu-id="aa55d-148">Docker 컨테이너 호스트에 연결 하기 위한 서비스 끝점</span><span class="sxs-lookup"><span data-stu-id="aa55d-148">A service endpoint for connecting to a Docker Container Host</span></span>

-   <span data-ttu-id="aa55d-149">다음을 수행 하는 Docker 작업:</span><span class="sxs-lookup"><span data-stu-id="aa55d-149">A Docker task to do the following:</span></span>

-   <span data-ttu-id="aa55d-150">이미지 만들기</span><span class="sxs-lookup"><span data-stu-id="aa55d-150">Build an image</span></span>

-   <span data-ttu-id="aa55d-151">레지스트리에 이미지 또는 리포지토리 푸시</span><span class="sxs-lookup"><span data-stu-id="aa55d-151">Push an image or a repository to a registry</span></span>

-   <span data-ttu-id="aa55d-152">이미지는 컨테이너에서 실행</span><span class="sxs-lookup"><span data-stu-id="aa55d-152">Run an image in a container</span></span>

-   <span data-ttu-id="aa55d-153">Docker 명령 실행</span><span class="sxs-lookup"><span data-stu-id="aa55d-153">Run a Docker command</span></span>

-   <span data-ttu-id="aa55d-154">Docker Compose 명령을 실행 하는 Docker Compose 작업</span><span class="sxs-lookup"><span data-stu-id="aa55d-154">A Docker Compose task to run a Docker Compose command</span></span>

<span data-ttu-id="aa55d-155">이러한 Visual Studio Team Services 작업 빌드 Linux Docker 호스트/v M Azure에서 프로 비전 및 기본 Docker 레지스트리 (Azure 컨테이너 레지스트리, Docker 허브, 개인 Docker DTR 또는 다른 Docker 레지스트리) Docker CI 파이프라인을 어셈블할 수 있습니다는 매우 일관 된 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="aa55d-155">With these Visual Studio Team Services tasks, a build Linux-Docker Host/VM provisioned in Azure and your preferred Docker registry (Azure Container Registry, Docker Hub, private Docker DTR, or any other Docker registry) you can assemble your Docker CI pipeline in a very consistent way.</span></span>

<span data-ttu-id="aa55d-156">***요구 사항:***</span><span class="sxs-lookup"><span data-stu-id="aa55d-156">***Requirements:***</span></span>

-   <span data-ttu-id="aa55d-157">Visual Studio Team Services 또는 Team Foundation Server 2015 업데이트 3 이상을 온-프레미스 설치 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa55d-157">Visual Studio Team Services, or for on-premises installations, Team Foundation Server 2015 Update 3 or later.</span></span>

-   <span data-ttu-id="aa55d-158">Docker 이진 파일에 있는 Visual Studio Team Services 에이전트입니다.</span><span class="sxs-lookup"><span data-stu-id="aa55d-158">A Visual Studio Team Services agent that has the Docker binaries.</span></span>

<span data-ttu-id="aa55d-159">다음 중 하나를 만드는 쉽게 Visual Studio Team Services 에이전트 Docker 이미지를 기반으로 컨테이너를 실행 하려면 Docker를 사용 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="aa55d-159">An easy way to create one of these is to use Docker to run a container based on the Visual Studio Team Services agent Docker image.</span></span>

<span data-ttu-id="aa55d-160">**자세한 내용은** 파이프라인와 연습을 보려면 다음 사이트를 방문 하십시오. Visual Studio Team Services Docker CI 어셈블하는 방법에 대 한 자세한를 읽으려면:</span><span class="sxs-lookup"><span data-stu-id="aa55d-160">**More info** To read more about assembling a Visual Studio Team Services Docker CI pipeline and to view walkthroughs, visit the following sites:</span></span>

<span data-ttu-id="aa55d-161">Docker 컨테이너와 Visual Studio Team Services 에이전트를 실행: [ https://hub.docker.com/r/\ 에이전트에서 microsoft/vsts /](https://hub.docker.com/r/microsoft/vsts-agent/)</span><span class="sxs-lookup"><span data-stu-id="aa55d-161">Running a Visual Studio Team Services agent as a Docker container: [https://hub.docker.com/r/\ microsoft/vsts-agent/](https://hub.docker.com/r/microsoft/vsts-agent/)</span></span>

<span data-ttu-id="aa55d-162">VSTS Docker 확장: <https://aka.ms/vstsdockerextension></span><span class="sxs-lookup"><span data-stu-id="aa55d-162">VSTS Docker extension: <https://aka.ms/vstsdockerextension></span></span>

<span data-ttu-id="aa55d-163">Visual Studio Team Services를 사용 하 여.NET Core Linux Docker 이미지를 구축: <https://blogs.msdn.microsoft.com/stevelasker/2016/06/13/building-net-core-linux-docker-images-with-visual-studio-team-services/></span><span class="sxs-lookup"><span data-stu-id="aa55d-163">Building .NET Core Linux Docker images with Visual Studio Team Services: <https://blogs.msdn.microsoft.com/stevelasker/2016/06/13/building-net-core-linux-docker-images-with-visual-studio-team-services/></span></span>

<span data-ttu-id="aa55d-164">Docker 지 원하는 Visual Studio 팀 서비스 Linux 기반 빌드 컴퓨터 구축: <http://donovanbrown.com/post/2016/06/03/Building-a-Linux-Based-Visual-Studio-Team-Service-Build-Machine-with-Docker-Support></span><span class="sxs-lookup"><span data-stu-id="aa55d-164">Building a Linux-based Visual Studio Team Service build machine with Docker support: <http://donovanbrown.com/post/2016/06/03/Building-a-Linux-Based-Visual-Studio-Team-Service-Build-Machine-with-Docker-Support></span></span>

### <a name="integrate-test-and-validate-multicontainer-docker-applications"></a><span data-ttu-id="aa55d-165">통합, 테스트 및 multicontainer Docker 응용 프로그램의 유효성을 검사합니다</span><span class="sxs-lookup"><span data-stu-id="aa55d-165">Integrate, test, and validate multicontainer Docker applications</span></span>

<span data-ttu-id="aa55d-166">일반적으로 대부분의 Docker 응용 프로그램은 단일 컨테이너 대신 여러 컨테이너도 구성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="aa55d-166">Typically, most Docker applications are composed of multiple containers rather than a single container.</span></span> <span data-ttu-id="aa55d-167">좋은 예 해야 마이크로 서비스 당 하나의 컨테이너 microservices 지향 응용 프로그램입니다.</span><span class="sxs-lookup"><span data-stu-id="aa55d-167">A good example is a microservices-oriented application for which you would have one container per microservice.</span></span> <span data-ttu-id="aa55d-168">그러나 microservices 접근 방식을 패턴을 엄격 하 게 수행 하지 않고도 매우 예상 Docker 응용 프로그램이 여러 컨테이너 또는 서비스의 구성 된 것입니다.</span><span class="sxs-lookup"><span data-stu-id="aa55d-168">But, even without strictly following the microservices approach patterns, it is very probable that your Docker application would be composed of multiple containers or services.</span></span>

<span data-ttu-id="aa55d-169">따라서 CI 파이프라인에서 응용 프로그램 컨테이너를 빌드한 후도 해야 배포, 통합 및 모든 해당 컨테이너 통합 Docker 호스트 내에서 나 사용자 컨테이너에는 테스트 클러스터에도 전체 응용 프로그램 테스트 배포 됩니다.</span><span class="sxs-lookup"><span data-stu-id="aa55d-169">Therefore, after building the application containers in the CI pipeline, you also need to deploy, integrate, and test the application as a whole with all of its containers within an integration Docker host or even into a test cluster to which your containers are distributed.</span></span>

<span data-ttu-id="aa55d-170">단일 호스트를 사용 하 여 docker 같은 Docker 명령을 사용할 수 있습니다-을 빌드 및 배포는 단일 VM에서 Docker 환경 ֲ 관련된 컨테이너를 구성 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa55d-170">If you're using a single host, you can use Docker commands such as docker-compose to build and deploy related containers to test and validate the Docker environment in a single VM.</span></span> <span data-ttu-id="aa55d-171">하지만 orchestrator 클러스터 DC/OS, Kubernetes, docker는 Docker Swarm 등을 사용 하는 경우 orchestrator 선택한 클러스터/스케줄러에 따라 또는 다른 메커니즘을 통해 프로그램 컨테이너를 배포 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa55d-171">But, if you are working with an orchestrator cluster like DC/OS, Kubernetes, or Docker Swarm, you need to deploy your containers through a different mechanism or orchestrator, depending on your selected cluster/scheduler.</span></span>

<span data-ttu-id="aa55d-172">다음은 몇 가지 종류의 Docker 컨테이너에 대해 실행할 수 있는 테스트.</span><span class="sxs-lookup"><span data-stu-id="aa55d-172">Following are several types of tests that you can run against Docker containers:</span></span>

-   <span data-ttu-id="aa55d-173">Docker 컨테이너에 대 한 단위 테스트</span><span class="sxs-lookup"><span data-stu-id="aa55d-173">Unit tests for Docker containers</span></span>

-   <span data-ttu-id="aa55d-174">서로 관련 된 응용 프로그램 또는 microservices 테스트 그룹</span><span class="sxs-lookup"><span data-stu-id="aa55d-174">Testing groups of interrelated applications or microservices</span></span>

-   <span data-ttu-id="aa55d-175">프로덕션 서버와 "카나리아" 릴리스에서 테스트</span><span class="sxs-lookup"><span data-stu-id="aa55d-175">Test in production and "canary" releases</span></span>

<span data-ttu-id="aa55d-176">중요 한 점은 통합 및 기능 테스트를 실행할 때 컨테이너의 외부에서 이러한 테스트 실행 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa55d-176">The important point is that when running integration and functional tests, you must run those tests from outside of the containers.</span></span> <span data-ttu-id="aa55d-177">테스트를 정의 고 컨테이너는 프로덕션 환경에 배포 하는 동일 해야 하는 정적 이미지를 기반으로 하므로, 배포 하는 컨테이너 안에서 실행 될 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa55d-177">Tests must not be defined and run within the containers that you are deploying, because the containers are based on static images that should be exactly like those that you will be deploying into production.</span></span>

<span data-ttu-id="aa55d-178">여러 클러스터 (클러스터, 클러스터 준비 및 프로덕션 클러스터 테스트)를 테스트와 같은 더 고급 시나리오를 테스트할 때 매우 사용할 수 없는 옵션인 다양 한 클러스터에서 테스트 하는 레지스트리를 이미지를 게시 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="aa55d-178">A very feasible option when testing more advanced scenarios like testing several clusters (test cluster, staging cluster, and production cluster) is to publish the images to a registry to test in various clusters.</span></span>

### <a name="push-the-custom-application-docker-image-into-your-global-docker-registry"></a><span data-ttu-id="aa55d-179">사용자 지정 응용 프로그램 Docker 이미지 글로벌 Docker 레지스트리 푸시</span><span class="sxs-lookup"><span data-stu-id="aa55d-179">Push the custom application Docker image into your global Docker Registry</span></span>

<span data-ttu-id="aa55d-180">Docker 이미지를 테스트 하 고 유효성을 검사 한 후에 태그 및 Docker 레지스트리에 게시을 하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa55d-180">After the Docker images have been tested and validated, you'll want to tag and publish them to your Docker registry.</span></span> <span data-ttu-id="aa55d-181">Docker 레지스트리 QA 및 프로덕션 환경에 배포 하 여 사용자 지정 테스트 (즉, "축복 받은 이미지")을 저장 하는 중심적인 곳 이므로 Docker 응용 프로그램 수명 주기에서 중요 한 부분을는.</span><span class="sxs-lookup"><span data-stu-id="aa55d-181">The Docker registry is a critical piece in the Docker application life cycle because it is the central place where you store your custom test (aka "blessed images") to be deployed into QA and production environments.</span></span>

<span data-ttu-id="aa55d-182">Docker 레지스트리는 프로그램 "source of truth" QA 또는 프로덕션 환경에 배포할 응용 프로그램 이진 또는 비트에 대 한 방법을 SCC 리포지토리에 (Git, 등)에 저장 된 응용 프로그램 코드는 "소스 of truth" 비슷합니다.</span><span class="sxs-lookup"><span data-stu-id="aa55d-182">Similar to how the application code stored in your SCC repository (Git, etc.) is your "source of truth," the Docker registry is your "source of truth" for your binary application or bits to be deployed to the QA or production environments.</span></span>

<span data-ttu-id="aa55d-183">일반적으로 있습니다 (예: 제한 된 액세스로 공용 클라우드 레지스트리 또는 Azure 컨테이너 레지스트리 또는 Docker Trusted Registry와 같은 온-프레미스 레지스트리는 사용자 지정 이미지에 대 한 개인 저장소에 개인 저장소에서 해야 할 수 있습니다. Docker 허브) 오픈 소스 코드가 경우 마지막 액세스 위반은 하지만에 공급 업체의 보안을 신뢰 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa55d-183">Typically, you might want to have your private repositories for your custom images either in a private repository in Azure Container Registry or in an on-premises registry like Docker Trusted Registry, or in a public-cloud registry with restricted access (like Docker Hub), although in this last case if your code is not open source, you must trust the vendor's security.</span></span> <span data-ttu-id="aa55d-184">어떤 방법을 사용 하는 기준인이 작업을 수행 방법은 매우 유사 하 고 궁극적으로 docker push 명령에 따라 그림 5-4에 표시 된 것 처럼 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa55d-184">Either way, the method by which you do this is pretty similar and ultimately based on the docker push command, as depicted in Figure 5-4.</span></span>

![](./media/image4.png)

<span data-ttu-id="aa55d-185">그림 5-4: 사용자 지정 이미지를 Docker 레지스트리에 게시</span><span class="sxs-lookup"><span data-stu-id="aa55d-185">Figure 5-4: Publishing custom images to Docker Registry</span></span>

<span data-ttu-id="aa55d-186">Azure 컨테이너 레지스트리, Amazon 웹 서비스 컨테이너 레지스트리, Google 컨테이너 레지스트리, Quay 레지스트리 등 클라우드 공급 업체에서 Docker 레지스트리의의 여러 제공 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aa55d-186">There are multiple offerings of Docker registries from cloud vendors like Azure Container Registry, Amazon Web Services Container Registry, Google Container Registry, Quay Registry, and so on.</span></span>

<span data-ttu-id="aa55d-187">Visual Studio Team Services Docker 확장을 사용 하 여 그림 5-5와 같이 이미지는 인증 된 Docker 레지스트리 (예: Azure 컨테이너 레지스트리)에 여러 태그와 docker compose.yml 파일에 정의 된 서비스의 집합을 푸시할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aa55d-187">Using the Visual Studio Team Services Docker extension, you can push a set of service images defined by a docker-compose.yml file, with multiple tags, to an authenticated Docker registry (like Azure Container Registry), as shown in Figure 5-5.</span></span>

![](./media/image5.png)

<span data-ttu-id="aa55d-188">그림 5-5: Visual Studio Team Services Docker 레지스트리에 게시 사용자 지정 이미지를 사용 하 여</span><span class="sxs-lookup"><span data-stu-id="aa55d-188">Figure 5-5: Using Visual Studio Team Services to publishing custom images to a Docker Registry</span></span>

<span data-ttu-id="aa55d-189">**자세한 내용은** 자세한 내용을 알아보려면 Visual Studio Team Services에 대 한 Docker 확장 프로그램에 대 한 <https://aka.ms/vstsdockerextension>합니다.</span><span class="sxs-lookup"><span data-stu-id="aa55d-189">**More info** To read more about the Docker extension for Visual Studio Team Services, go to <https://aka.ms/vstsdockerextension>.</span></span> <span data-ttu-id="aa55d-190">Azure 컨테이너 레지스트리에 대 한 자세한 내용은로 이동 <https://aka.ms/azurecontainerregistry>합니다.</span><span class="sxs-lookup"><span data-stu-id="aa55d-190">To learn more about Azure Container Registry, go to <https://aka.ms/azurecontainerregistry>.</span></span>

## <a name="step-4-cd-deploy"></a><span data-ttu-id="aa55d-191">4 단계: CD, 배포</span><span class="sxs-lookup"><span data-stu-id="aa55d-191">Step 4: CD, Deploy</span></span>

<span data-ttu-id="aa55d-192">Docker 이미지의 불변성 개발, CI를 통해 테스트 및 프로덕션 환경에서 실행에 어떤 반복 가능한 배포가 보장 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa55d-192">The immutability of Docker images ensures a repeatable deployment with what's developed, tested through CI, and run in production.</span></span> <span data-ttu-id="aa55d-193">응용 프로그램 Docker 이미지를 Docker 레지스트리 (개인 또는 공용)에서 게시를 설정한 후 발생할 수 있는 여러 환경에 배포할 수 있습니다 (프로덕션, QA, 스테이징 등)에서 Visual Studio Team Services를 사용 하 여 CD 파이프라인 파이프라인 작업이 나 Visual Studio Team Services 릴리스 관리 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa55d-193">After you have the application Docker images published in your Docker registry (either private or public), you can deploy them to the several environments that you might have (production, QA, staging, etc.) from your CD pipeline by using Visual Studio Team Services pipeline tasks or Visual Studio Team Services Release Management.</span></span>

<span data-ttu-id="aa55d-194">그러나이 시점에서 종속 배포 Docker 응용 프로그램의 종류에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aa55d-194">However, at this point it depends on what kind of Docker application you are deploying.</span></span> <span data-ttu-id="aa55d-195">간단한 응용 프로그램에 배포 (구성 및 배포의 관점에서)는 모놀리식 같은 몇 가지 컨테이너 또는 서비스를 구성 하는 응용 프로그램 및 배포 된 몇 가지 서버 또는 Vm 간에 차이가 있는 매우와 같은 보다 복잡 한 응용 프로그램 배포는 microservices 지향 응용 프로그램 대규모 기능을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa55d-195">Deploying a simple application (from a composition and deployment point of view) like a monolithic application comprising a few containers or services and deployed to a few servers or VMs is very different from deploying a more complex application like a microservices-oriented application with hyperscale capabilities.</span></span> <span data-ttu-id="aa55d-196">이러한 두 가지 시나리오는 다음 섹션에 설명 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aa55d-196">These two scenarios are explained in the following sections.</span></span>

### <a name="deploying-composed-docker-applications-to-multiple-docker-environments"></a><span data-ttu-id="aa55d-197">구성 된 여러 Docker 환경에 Docker 응용 프로그램 배포</span><span class="sxs-lookup"><span data-stu-id="aa55d-197">Deploying composed Docker applications to multiple Docker environments</span></span>

<span data-ttu-id="aa55d-198">덜 복잡 한 시나리오에서 첫 번째 하는지 살펴보겠습니다: 단일 환경 또는 여러 환경에서 간단한 Docker 호스트 (Vm 또는 서버)를 배포 (QA, 스테이징 및 프로덕션).</span><span class="sxs-lookup"><span data-stu-id="aa55d-198">Let's look first at the less-complex scenario: deploying to simple Docker hosts (VMs or servers) in a single environment or multiple environments (QA, staging, and production).</span></span> <span data-ttu-id="aa55d-199">이 시나리오에서는 내부적으로 CD 파이프라인 צ ְ ײ docker-그림 5-6에 설명 된 대로 컨테이너 또는 서비스의 관련된 집합으로 Docker 응용 프로그램을 배포 (Visual Studio Team Services 배포 작업)에서 작성 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa55d-199">In this scenario, internally your CD pipeline can use docker-compose (from your Visual Studio Team Services deployment tasks) to deploy the Docker applications with its related set of containers or services, as illustrated in Figure 5-6.</span></span>

![](./media/image6.png)

<span data-ttu-id="aa55d-200">그림 5-6: 간단 하 게 Docker 호스트 환경 레지스트리를 응용 프로그램 컨테이너 배포</span><span class="sxs-lookup"><span data-stu-id="aa55d-200">Figure 5-6: Deploying application containers to simple Docker host environments registry</span></span>

<span data-ttu-id="aa55d-201">그림 5-7 작업 추가 대화 상자에서 Docker Compose를 클릭 하 여 Visual Studio Team Services를 통해 QA/테스트 환경에 빌드 CI를 연결할 수는 어떻게 강조 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa55d-201">Figure 5-7 highlights how you can connect your build CI to QA/test environments via Visual Studio Team Services by clicking Docker Compose in the Add Task dialog box.</span></span> <span data-ttu-id="aa55d-202">그러나,을 스테이징 또는 프로덕션 환경에 배포할 때는 일반적으로 사용 환경이 여러 개를 처리 하는 릴리스 관리 기능 (같은 QA, 스테이징 및 프로덕션).</span><span class="sxs-lookup"><span data-stu-id="aa55d-202">However, when deploying to staging or production environments, you would usually use Release Management features handling multiple environments (like QA, staging, and production).</span></span> <span data-ttu-id="aa55d-203">Visual Studio Team Services를 사용 하는 단일 Docker 호스트에 배포할 경우 작업 "Docker Compose" (docker를 호출 하는 것입니다-내부에서 명령을 작성).</span><span class="sxs-lookup"><span data-stu-id="aa55d-203">If you're deploying to single Docker hosts, it is using the Visual Studio Team Services "Docker Compose" task (which is invoking the docker-compose up command under the hood).</span></span> <span data-ttu-id="aa55d-204">Azure 컨테이너 서비스를 배포 하는 경우 다음 섹션에 설명 된 대로 Docker 배포 태스크를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa55d-204">If you're deploying to Azure Container Service, it uses the Docker Deployment task, as explained in the section that follows.</span></span>

![](./media/image7.png)

<span data-ttu-id="aa55d-205">그림 5-7: Visual Studio Team Services 파이프라인에서 Docker Compose 태스크 추가</span><span class="sxs-lookup"><span data-stu-id="aa55d-205">Figure 5-7: Adding a Docker Compose task in a Visual Studio Team Services pipeline</span></span>

<span data-ttu-id="aa55d-206">Visual Studio Team Services에서 릴리스를 만들 때에 입력된 아티팩트는 집합을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa55d-206">When you create a release in Visual Studio Team Services, it takes a set of input artifacts.</span></span> <span data-ttu-id="aa55d-207">이러한 작업은 여러 환경에 걸쳐 릴리스의 수명 주기 동안 변경할 수 없어야 하는 데 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="aa55d-207">These are intended to be immutable throughout the lifetime of the release across multiple environments.</span></span> <span data-ttu-id="aa55d-208">컨테이너를 사용할 때 입력된 아티팩트를 배포 하는 레지스트리에서 이미지를 식별 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa55d-208">When you introduce containers, the input artifacts identify images in a registry to deploy.</span></span> <span data-ttu-id="aa55d-209">를 확인 방법에 따라 docker-compose 파일에서 "myimage:latest"를 참조 하는 경우 되 고 가장 뚜렷한 사례는 릴리스 기간 동안 동일 하 게 보장 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="aa55d-209">Depending on how these are identified, they are not guaranteed to remain the same throughout the duration of the release, the most obvious case being when you reference "myimage:latest" from a docker-compose file.</span></span>

<span data-ttu-id="aa55d-210">Visual Studio Team Services에 대 한 Docker 확장을 제공 특정 레지스트리 이미지를 포함 하는 빌드 아티팩트를 생성 하는 기능 다이제스트 고유 하 게 식별 하는 이미지를 이진 보장 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa55d-210">The Docker extension for Visual Studio Team Services gives you the ability to generate build artifacts that contain specific registry image digests that are guaranteed to uniquely identify the same image binary.</span></span> <span data-ttu-id="aa55d-211">실제로 필요한 것 릴리스에 대 한 입력으로 사용 하는 것이 이들은입니다.</span><span class="sxs-lookup"><span data-stu-id="aa55d-211">These are what you really want to use as input to a release.</span></span>

### <a name="managing-releases-to-docker-environments-by-using-visual-studio-team-services-release-management"></a><span data-ttu-id="aa55d-212">Visual Studio Team Services Release Management를 사용 하 여 Docker 환경에는 릴리스 관리</span><span class="sxs-lookup"><span data-stu-id="aa55d-212">Managing releases to Docker environments by using Visual Studio Team Services Release Management</span></span>

<span data-ttu-id="aa55d-213">Visual Studio Team Services 확장 프로그램을 통해 있습니다 수 새 이미지를 작성, Docker 레지스트리에 게시, Linux 또는 Windows 호스트에서 실행 및 docker와 같은 명령을 사용 하 여-시각적 개체를 통해 전체 응용 프로그램으로 여러 컨테이너를 배포 하도록 구성 Studio Team Services 릴리스 관리 기능을 그림 5-8에 나와 있는 것 처럼 여러 환경을 위한 것입니다.</span><span class="sxs-lookup"><span data-stu-id="aa55d-213">Through the Visual Studio Team Services extensions, you can build a new image, publish it to a Docker registry, run it on Linux or Windows hosts, and use commands such as docker-compose to deploy multiple containers as an entire application, all through the Visual Studio Team Services Release Management capabilities intended for multiple environments, as shown in Figure 5-8.</span></span>

![](./media/image8.png)

<span data-ttu-id="aa55d-214">그림 5-8: Visual Studio Team Services Release Management에서 Visual Studio Team Services Docker Compose 작업 구성</span><span class="sxs-lookup"><span data-stu-id="aa55d-214">Figure 5-8: Configuring Visual Studio Team Services Docker Compose tasks from Visual Studio Team Services Release Management</span></span>

<span data-ttu-id="aa55d-215">하지만 그림 5-6을 표시 하 고 그림 5-8을 구현 하는 시나리오 (단순 Docker 호스트 및 Vm을 배포 하는 및 단일 컨테이너 또는 이미지 당 인스턴스 됩니다) 상당히 기본적 이며 아마도 sc 개발 또는 테스트에 대해서만 사용할 수 해야 염두에서에 둬야 enarios 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa55d-215">However, keep in mind that the scenario shown in Figure 5-6 and implemented in Figure 5-8 is pretty basic (it is deploying to simple Docker hosts and VMs, and there will be a single container or instance per image) and probably should be used only for development or test scenarios.</span></span> <span data-ttu-id="aa55d-216">대부분의 엔터프라이즈 프로덕션 시나리오에서는 HA (고가용성)를 포함 하려고는 및에 걸쳐 부하 분산 여러 노드, 서버 및 Vm의 경우와 "지능형 장애 조치" 하므로 하는 경우 서버 또는 노드도 관리 하기 쉬운 확장성에 실패 하면 해당 서비스 및 컨테이너를 다른 호스트 서버 또는 VM으로 이동 됩니다.</span><span class="sxs-lookup"><span data-stu-id="aa55d-216">In most enterprise production scenarios, you would want to have High Availability (HA) and easy-to-manage scalability by load balancing across multiple nodes, servers, and VMs, plus "intelligent failovers" so that if a server or node fails, its services and containers will be moved to another host server or VM.</span></span> <span data-ttu-id="aa55d-217">이 경우 컨테이너 클러스터, orchestrators, 및 스케줄러와 같은 고급 기술이 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa55d-217">In that case, you need more advanced technologies like container clusters, orchestrators, and schedulers.</span></span> <span data-ttu-id="aa55d-218">따라서 해당 클러스터에 배포 하는 방법은 다음 섹션에서 설명 하는 고급 시나리오를 통해 정확 하 게는 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa55d-218">Thus, the way to deploy to those clusters is precisely through the advanced scenarios explained in the next section.</span></span>

### <a name="deploying-complex-docker-applications-to-docker-clusters-dcos-kubernetes-and-docker-swarm"></a><span data-ttu-id="aa55d-219">Docker 클러스터 (DC/OS, Kubernetes, 및 docker는 Docker Swarm)에 복잡 한 Docker 응용 프로그램 배포</span><span class="sxs-lookup"><span data-stu-id="aa55d-219">Deploying complex Docker applications to Docker clusters (DC/OS, Kubernetes, and Docker Swarm)</span></span>

<span data-ttu-id="aa55d-220">분산된 응용 프로그램의 특성에는 또한 배포 되는 계산 리소스가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa55d-220">The nature of distributed applications requires compute resources that are also distributed.</span></span> <span data-ttu-id="aa55d-221">풀링된 리소스를 기준으로 한 HA 및 프로덕션 규모 기능이 하려면 클러스터링 높은 확장성을 제공 하는 기능을 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa55d-221">To have production-scale capabilities, you need to have clustering capabilities that provide high scalability and HA based on pooled resources.</span></span>

<span data-ttu-id="aa55d-222">Docker는 Docker Swarm 같은 CLI 도구에서 위에 해당 클러스터에 컨테이너를 수동으로 배포할 수 있습니다 (사용과 같은 [docker 서비스를 만들](https://docs.docker.com/engine/swarm/swarm-tutorial/deploy-service/)) 또는 웹 UI와 같은 [Mesosphere 마라톤](https://mesosphere.github.io/marathon/docs/marathon-ui.html) DC/OS 용 클러스터에 있지만 해야 확장 또는 모니터링을 위해 관리 목적으로 또는 punctual 배포 테스트에 있는 예약 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa55d-222">You could deploy containers manually to those clusters from a CLI tool such as Docker Swarm (like using [docker service create](https://docs.docker.com/engine/swarm/swarm-tutorial/deploy-service/)) or a web UI such as [Mesosphere Marathon](https://mesosphere.github.io/marathon/docs/marathon-ui.html) for DC/OS clusters, but you should reserve that only for punctual deployment testing or for management purposes like scaling-out or monitoring purposes.</span></span>

<span data-ttu-id="aa55d-223">CD의 관점 및 Visual Studio Team Services에서 특히에서 실행할 수 있습니다 특수 처리 된 배포 작업 분산 클러스터에 컨테이너 화 된 응용 프로그램 배포는 Visual Studio Team Services 릴리스 관리 환경 그림 5-9와 같이 컨테이너 서비스입니다.</span><span class="sxs-lookup"><span data-stu-id="aa55d-223">From a CD point of view, and Visual Studio Team Services specifically, you can run specially made deployment tasks from your Visual Studio Team Services Release Management environments which will deploy your containerized applications to distributed clusters in Container Service, as illustrated in Figure 5-9.</span></span>

![](./media/image9.png)

<span data-ttu-id="aa55d-224">그림 5-9: 컨테이너 서비스에 분산된 된 응용 프로그램 배포</span><span class="sxs-lookup"><span data-stu-id="aa55d-224">Figure 5-9: Deploying distributed applications to Container Service</span></span>

<span data-ttu-id="aa55d-225">처음에 특정 클러스터 또는 orchestrators을 배포할 때는 일반적으로 사용 합니다 (즉, Mesosphere DC/OS 또는 Docker 및 Docker 보다 다양 한 배포 메커니즘이 Kubernetes 각 orchestrator 당 메커니즘과 특정 배포 스크립트 대신 swarm)는 간단 하 고 사용 하기 쉬운 docker-작성 도구 docker compose.yml 정의 파일에 기반 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa55d-225">Initially, when deploying to certain clusters or orchestrators, you would traditionally use specific deployment scripts and mechanisms per each orchestrator (that is, Mesosphere DC/OS or Kubernetes have different deployment mechanisms than Docker and Docker Swarm) instead of the simpler and easy-to-use docker-compose tool based on the docker-compose.yml definition file.</span></span> <span data-ttu-id="aa55d-226">그러나 Microsoft Visual Studio Team Services Docker를 배포 하는 작업을 그림 5-10에서 표시 된 덕분에 하면 이제도를 배포할 수 DC/OS Microsoft 드립니다 "변환"을 수행 하기 때문에 친숙 한 docker compose.yml 파일 사용 하 여 (에서 프로그램 docker compose.yml 파일 DC/OS에 필요한 다른 형식으로).</span><span class="sxs-lookup"><span data-stu-id="aa55d-226">However, thanks to the Microsoft Visual Studio Team Services Docker Deploy task, shown in Figure 5-10, you now also can deploy to DC/OS by just using your familiar docker-compose.yml file because Microsoft performs that "translation" for you (from your docker-compose.yml file to other formats needed by DC/OS).</span></span>

![](./media/image10.png)

<span data-ttu-id="aa55d-227">그림 5-10: 환경 RM에 Docker 배포 태스크 추가</span><span class="sxs-lookup"><span data-stu-id="aa55d-227">Figure 5-10: Adding the Docker Deploy task to your Environment RM</span></span>

<span data-ttu-id="aa55d-228">그림 5-11 편집 Docker 배포 작업 대상 유형 (Azure 컨테이너 서비스 DC/OS,이 경우), Docker 구성 파일 및 Docker 레지스트리 연결 (예: Azure 컨테이너 레지스트리 또는 Docker 허브)를 지정 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="aa55d-228">Figure 5-11 demonstrates how you can edit the Docker Deploy task and specify the Target Type (Azure Container Service DC/OS, in this case), your Docker Compose File, and the Docker Registry connection (like Azure Container Registry or Docker Hub).</span></span> <span data-ttu-id="aa55d-229">이 작업 DC/OS 클러스터의 컨테이너 형태로 배포할 수를 즉시 사용할 사용자 지정 Docker 이미지를 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa55d-229">This is where the task will retrieve your ready-to-use custom Docker images to be deployed as containers in the DC/OS cluster.</span></span>

![](./media/image11.png)

<span data-ttu-id="aa55d-230">그림 5-11: Docker 배포 작업 정의 배포 하려면 Azure 컨테이너 서비스 DC/OS</span><span class="sxs-lookup"><span data-stu-id="aa55d-230">Figure 5-11: Docker Deploy task definition deploying to Azure Container Service DC/OS</span></span>

<span data-ttu-id="aa55d-231">**자세한 내용은** 자세한 내용은 Visual Studio Team Services 및 Docker와 CD 파이프라인에 대 한 다음 사이트를 방문 하십시오.:</span><span class="sxs-lookup"><span data-stu-id="aa55d-231">**More info** To read more about the CD pipeline with Visual Studio Team Services and Docker, visit the following sites:</span></span>

<span data-ttu-id="aa55d-232">Docker 및 Azure 컨테이너 서비스에 대 한 visual Studio Team Services 확장: [ https://aka.ms/\ vstsdockerextension](https://aka.ms/vstsdockerextension)</span><span class="sxs-lookup"><span data-stu-id="aa55d-232">Visual Studio Team Services extension for Docker and Azure Container Service: [https://aka.ms/\ vstsdockerextension](https://aka.ms/vstsdockerextension)</span></span>

<span data-ttu-id="aa55d-233">Azure 컨테이너 서비스: <https://aka.ms/azurecontainerservice></span><span class="sxs-lookup"><span data-stu-id="aa55d-233">Azure Container Service: <https://aka.ms/azurecontainerservice></span></span>

<span data-ttu-id="aa55d-234">Mesosphere DC/OS: <https://mesosphere.com/product/></span><span class="sxs-lookup"><span data-stu-id="aa55d-234">Mesosphere DC/OS: <https://mesosphere.com/product/></span></span>

## <a name="step-5-run-and-manage"></a><span data-ttu-id="aa55d-235">5 단계: 실행 및 관리</span><span class="sxs-lookup"><span data-stu-id="aa55d-235">Step 5: Run and manage</span></span>

<span data-ttu-id="aa55d-236">실행 및 응용 프로그램을 관리 하기 때문에 엔터프라이즈 프로덕션에서 수준이 고 언어에서는 자체의 형식 작업으로 인해 주요 대상은 고이 영역의 큰 범위 뿐만 아니라 해당 수준 (IT 작업)에서 작업 하는 사람들 우리는 할당 되어 전체 다음 장 것에 대해 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa55d-236">Because running and managing applications at enterprise-production level is a major subject in and of itself, and due to the type of operations and people working at that level (IT operations) as well as the large scope of this area, we have devoted the entire next chapter to explaining it.</span></span>

## <a name="step-6-monitor-and-diagnose"></a><span data-ttu-id="aa55d-237">6 단계: 모니터링 및 진단</span><span class="sxs-lookup"><span data-stu-id="aa55d-237">Step 6: Monitor and diagnose</span></span>

<span data-ttu-id="aa55d-238">이 항목 또한에 대해서는 다음 장에서 IT 운영; 프로덕션 시스템에서 수행 하는 작업의 일부로 그러나는이 단계에서 얻은 insights 응용 프로그램은 지속적으로 개선 하는 개발 팀에 다시 피드 해야 강조 표시 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa55d-238">This topic also is covered in the next chapter as part of the tasks that IT operations performs in production systems; however, is important to highlight that the insights obtained in this step must feed back to the development team so that the application is constantly improved.</span></span> <span data-ttu-id="aa55d-239">그의 관점에서 일부 이기도 하므로 DevOps의 작업 및 작업에서 일반적으로 수행 되지만 IT 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa55d-239">From that point of view, it is also part of DevOps, although the tasks and operations are usually performed by IT.</span></span>

<span data-ttu-id="aa55d-240">모니터링 및 진단이 100 %DevOps 영역 내에서 경우에 모니터링 하는 프로세스와 테스트 또는 베타 환경에 대 한 개발 팀에서 수행 하는 분석 됩니다.</span><span class="sxs-lookup"><span data-stu-id="aa55d-240">Only when monitoring and diagnostics are 100 percent within the realm of DevOps are the monitoring processes and analytics performed by the development team against testing or beta environments.</span></span> <span data-ttu-id="aa55d-241">이 부하 테스트를 수행 하 여 또는 베타 또는 QA 환경에 베타 테스터에서 새 버전을 시도 하는 위치를 모니터링 하 여 수행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="aa55d-241">This is done either by performing load testing or simply by monitoring beta or QA environments, where beta testers are trying the new versions.</span></span>

>[!div class="step-by-step"]
<span data-ttu-id="aa55d-242">[이전] [다음]을 (index.md) (... /run-manage-monitor-docker-environments/index.md)</span><span class="sxs-lookup"><span data-stu-id="aa55d-242">[Previous] (index.md) [Next] (../run-manage-monitor-docker-environments/index.md)</span></span>

---
title: Docker 응용 프로그램의 상태 및 데이터
description: Microsoft 플랫폼 및 도구를 사용하여 컨테이너화된 Docker 응용 프로그램 수명 주기
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 09/22/2017
ms.openlocfilehash: 78db191bdec4c25c11728d819d89eaaaff4bd7da
ms.sourcegitcommit: 2350a091ef6459f0fcfd894301242400374d8558
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 09/21/2018
ms.locfileid: "46532469"
---
# <a name="state-and-data-in-docker-applications"></a><span data-ttu-id="551f6-103">Docker 응용 프로그램의 상태 및 데이터</span><span class="sxs-lookup"><span data-stu-id="551f6-103">State and data in Docker applications</span></span>

<span data-ttu-id="551f6-104">컨테이너의 기본 형식은 불변성입니다.</span><span class="sxs-lookup"><span data-stu-id="551f6-104">A primitive of containers is immutability.</span></span> <span data-ttu-id="551f6-105">VM에 비해, 주로으로 컨테이너 사라지지 않도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="551f6-105">When compared to a VM, containers don't disappear as a common occurrence.</span></span> <span data-ttu-id="551f6-106">소멸 프로세스, 오버 로드 된 CPU 또는 전체 또는 실패 한 디스크에서 다양 한 형태로 VM 실패할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="551f6-106">A VM might fail in various forms from dead processes, overloaded CPU, or a full or failed disk.</span></span> <span data-ttu-id="551f6-107">아직 VM을 사용할 수 있는 것으로 예상 하 고 RAID 드라이브는 드라이브 오류 데이터를 유지 관리를 수행 하기 위해 일반화 합니다.</span><span class="sxs-lookup"><span data-stu-id="551f6-107">Yet, we expect the VM to be available and RAID drives are commonplace to assure drive failures maintain data.</span></span>

<span data-ttu-id="551f6-108">그러나 컨테이너 프로세스 인스턴스의 간주 됩니다.</span><span class="sxs-lookup"><span data-stu-id="551f6-108">However, containers are thought to be instances of processes.</span></span> <span data-ttu-id="551f6-109">프로세스는 영구 상태를 유지 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="551f6-109">A process doesn't maintain durable state.</span></span> <span data-ttu-id="551f6-110">컨테이너를 로컬 저장소에 쓸 수 있지만 해당 인스턴스에 되도록 주위 무기한 가정 하 고 동일 단일 복사본 메모리는 지속적 이어야 하는 것으로 가정 합니다.</span><span class="sxs-lookup"><span data-stu-id="551f6-110">Even though a container can write to its local storage, assuming that that instance will be around indefinitely would be equivalent to assuming a single-copy memory will be durable.</span></span> <span data-ttu-id="551f6-111">종료 프로세스와 같은 컨테이너는 중복 또는 컨테이너 오 케 스트레이 터를 사용 하 여 관리 되는 경우 이러한 이동 될 수 가정해 야 합니다.</span><span class="sxs-lookup"><span data-stu-id="551f6-111">You should assume that containers, like processes, are duplicated, killed, or, when managed with a container orchestrator, they might be moved.</span></span>

<span data-ttu-id="551f6-112">Docker 이라고 하는 기능을 사용 하는 *오버레이 파일 시스템* 기반이 되는 원본 이미지에 비해 컨테이너의 루트 파일 시스템에 업데이트 된 정보를 저장 하는 모든 쓰기 시 복사 프로세스를 구현 합니다.</span><span class="sxs-lookup"><span data-stu-id="551f6-112">Docker uses a feature known as an *overlay file system* to implement a copy-on-write process that stores any updated information to the root file system of a container, compared to the original image on which it is based.</span></span> <span data-ttu-id="551f6-113">컨테이너 시스템에서 이후에 삭제 되 면 이러한 변경 내용은 손실 됩니다.</span><span class="sxs-lookup"><span data-stu-id="551f6-113">These changes are lost if the container is subsequently deleted from the system.</span></span> <span data-ttu-id="551f6-114">컨테이너를 따라서 없는 영구 저장소 기본적으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="551f6-114">A container, therefore, does not have persistent storage by default.</span></span> <span data-ttu-id="551f6-115">컨테이너의 상태를 저장 하는 가능한 경우에이 문제를 해결 하는 시스템 디자인 것 컨테이너 아키텍처의 원칙 충돌입니다.</span><span class="sxs-lookup"><span data-stu-id="551f6-115">Although it's possible to save the state of a container, designing a system around this would be in conflict with the principle of container architecture.</span></span>

<span data-ttu-id="551f6-116">Docker 응용 프로그램의 영구 데이터를 관리 하려면 일반적인 시나리오도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="551f6-116">To manage persistent data in Docker applications, there are common solutions:</span></span>

-   <span data-ttu-id="551f6-117">[**데이터 볼륨이**](https://docs.docker.com/engine/tutorials/dockervolumes/) 이러한 방금 설명한 것 처럼 호스트에 탑재 합니다.</span><span class="sxs-lookup"><span data-stu-id="551f6-117">[**Data volumes**](https://docs.docker.com/engine/tutorials/dockervolumes/) These mount to the host, as just noted.</span></span>

-   <span data-ttu-id="551f6-118">[**데이터 볼륨 컨테이너**](https://docs.docker.com/engine/tutorials/dockervolumes/#/creating-and-mounting-a-data-volume-container) 이러한 주기 수는 외부 컨테이너를 사용 하 여 컨테이너에서 공유 저장소를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="551f6-118">[**Data volume containers**](https://docs.docker.com/engine/tutorials/dockervolumes/#/creating-and-mounting-a-data-volume-container) These provide shared storage across containers, using an external container that can cycle.</span></span>

-   <span data-ttu-id="551f6-119">[**볼륨 플러그 인**](https://docs.docker.com/engine/tutorials/dockervolumes/#/mount-a-shared-storage-volume-as-a-data-volume) 이러한 장기 지 속성을 제공 하는 원격 위치에 볼륨을 탑재 합니다.</span><span class="sxs-lookup"><span data-stu-id="551f6-119">[**Volume Plugins**](https://docs.docker.com/engine/tutorials/dockervolumes/#/mount-a-shared-storage-volume-as-a-data-volume) These mount volumes to remote locations, providing long-term persistence.</span></span>

-   <span data-ttu-id="551f6-120">**원격 데이터 원본을** 예제 SQL 및 비 SQL 데이터베이스를 포함 하거나 Redis와 같은 캐시 서비스입니다.</span><span class="sxs-lookup"><span data-stu-id="551f6-120">**Remote data sources** Examples include SQL and NO-SQL databases or cache services like Redis.</span></span>

-   <span data-ttu-id="551f6-121">[**Azure Storage**](https://docs.microsoft.com/azure/storage/) 컨테이너의 가장으로 장기 지 속성을 제공 하는 서비스 (PaaS) 저장소로 지역 배포 가능 플랫폼 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="551f6-121">[**Azure Storage**](https://docs.microsoft.com/azure/storage/) This provides geo distributable platform as a service (PaaS) storage, providing the best of containers as long-term persistence.</span></span>

<span data-ttu-id="551f6-122">데이터 볼륨은 무시 하는 하나 이상의 컨테이너 내의 디렉터리 지정 된 특수 합니다 [Union 파일 시스템](https://docs.docker.com/glossary/?term=Union%20file%20system)입니다.</span><span class="sxs-lookup"><span data-stu-id="551f6-122">Data volumes are specially designated directories within one or more containers that bypass the [Union File System](https://docs.docker.com/glossary/?term=Union%20file%20system).</span></span> <span data-ttu-id="551f6-123">데이터 볼륨 컨테이너의 수명 주기에 독립적으로 데이터를 유지 하도록 설계 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="551f6-123">Data volumes are designed to maintain data, independent of the container's life cycle.</span></span> <span data-ttu-id="551f6-124">Docker 따라서 자동으로 삭제 볼륨 컨테이너를 제거 하거나 컨테이너에서 더 이상 참조 하는 "가비지 수집" 볼륨을가 하는 경우.</span><span class="sxs-lookup"><span data-stu-id="551f6-124">Docker therefore never automatically deletes volumes when you remove a container, nor will it "garbage collect" volumes that are no longer referenced by a container.</span></span> <span data-ttu-id="551f6-125">호스트 운영 체제를 찾아 모든 볼륨의 데이터를 데이터 볼륨을 꼭 필요할 때만 사용 하는 또 다른 이유는 자유롭게 편집할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="551f6-125">The host operating system can browse and edit the data in any volume freely, which is just another reason to use data volumes sparingly.</span></span>

<span data-ttu-id="551f6-126">A [데이터 볼륨 컨테이너](https://docs.docker.com/glossary/?term=volume) 일반 데이터 볼륨은 향상 된 기능입니다.</span><span class="sxs-lookup"><span data-stu-id="551f6-126">A [data volume container](https://docs.docker.com/glossary/?term=volume) is an improvement over regular data volumes.</span></span> <span data-ttu-id="551f6-127">기본적으로 유휴 포함 된 컨테이너를 하나 이상의 데이터 볼륨 (앞에서 설명한) 내에 만들어진 경우</span><span class="sxs-lookup"><span data-stu-id="551f6-127">It is essentially a dormant container that has one or more data volumes created within it (as described earlier).</span></span> <span data-ttu-id="551f6-128">데이터 볼륨 컨테이너는 중앙 탑재 지점에서 컨테이너에 대한 액세스를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="551f6-128">The data volume container provides access to containers from a central mount point.</span></span> <span data-ttu-id="551f6-129">이 메서드의 액세스의 장점은 데이터 컨테이너를 논리 탑재 지점을 수행, 원래 데이터의 위치를 추출 하기.</span><span class="sxs-lookup"><span data-stu-id="551f6-129">The benefit of this method of access is that it abstracts the location of the original data, making the data container a logical mount point.</span></span> <span data-ttu-id="551f6-130">"Application" 컨테이너 만들어지고 소멸 전용된 컨테이너에 영구 데이터를 유지 하면서 컨테이너 데이터 볼륨에 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="551f6-130">It also allows "application" containers accessing the data container volumes to be created and destroyed while keeping the data persistent in a dedicated container.</span></span>

<span data-ttu-id="551f6-131">그림 4-5 일반 Docker 볼륨 저장소 컨테이너 자체가 되었지만 호스트 서버/v M 물리적 경계 내에 배치할 수 있는지 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="551f6-131">Figure 4-5 shows that regular Docker volumes can be placed on storage out of the containers themselves but within the host server/VM physical boundaries.</span></span> <span data-ttu-id="551f6-132">*Docker 볼륨을 다른 호스트 서버/v M에서 볼륨을 사용할 수 없는*합니다.</span><span class="sxs-lookup"><span data-stu-id="551f6-132">*Docker volumes don't have the ability to use a volume from one host server/VM to another*.</span></span>

![](./media/image5.png)

<span data-ttu-id="551f6-133">그림 4-5: 데이터 볼륨 및 컨테이너 앱/컨테이너에 대 한 외부 데이터 원본</span><span class="sxs-lookup"><span data-stu-id="551f6-133">Figure 4-5: Data volumes and external data sources for containers apps/containers</span></span>

<span data-ttu-id="551f6-134">별도 물리적 호스트에서 실행 되는 컨테이너 간에 공유 된 데이터를 관리 하려면 않다는 것이 좋습니다는 사용 하면 볼륨 비즈니스 데이터에 대 한 Docker 호스트에 고정된 호스트/v M 아닌 때문에 오 케 스트레이 터에서 Docker 컨테이너를 사용 하는 경우 컨테이너는 클러스터에서 수행 하는 최적화에 따라 다른 호스트 간에 이동 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="551f6-134">Due to the inability to manage data shared between containers that run on separate physical hosts, it is recommended that you not use volumes for business data unless the Docker host is a fixed host/VM, because when using Docker containers in an orchestrator, containers are expected to be moved from one to another host, depending on the optimizations to be performed by the cluster.</span></span>

<span data-ttu-id="551f6-135">따라서 일반 데이터 볼륨은 추적 파일, 임시 파일 또는 컨테이너를 여러 호스트 간에 이동할 때 아니면 비즈니스 데이터 일관성에 영향을 주지는 비슷한 개념이 작업할 수 있는 유용한 메커니즘입니다.</span><span class="sxs-lookup"><span data-stu-id="551f6-135">Therefore, regular data volumes are a good mechanism to work with trace files, temporal files, or any similar concept that won't affect the business data consistency if or when your containers are moved across multiple hosts.</span></span>

<span data-ttu-id="551f6-136">[볼륨 플러그 인](https://docs.docker.com/engine/extend/plugins_volume/) 클러스터의 모든 호스트 간에 데이터를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="551f6-136">[Volume plug-ins](https://docs.docker.com/engine/extend/plugins_volume/) provide data across all hosts in a cluster.</span></span> <span data-ttu-id="551f6-137">일부 볼륨 플러그 인을 동일 하 게 생성 되더라도 볼륨 플러그 인는 일반적으로 변경할 수 없는 컨테이너에서 표면화 된 영구적 신뢰할 수 있는 저장소를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="551f6-137">Although not all volume plug-ins are created equally, volume plug-ins typically provide externalized persistent reliable storage from the immutable containers.</span></span>

<span data-ttu-id="551f6-138">원격 데이터 원본 및 SQL Database, DocumentDB 또는 Redis와 같은 원격 캐시와 같은 캐시 컨테이너 없이 개발할 같을 수는 있습니다.</span><span class="sxs-lookup"><span data-stu-id="551f6-138">Remote data sources and caches like SQL Database, DocumentDB, or a remote cache like Redis would be the same as developing without containers.</span></span> <span data-ttu-id="551f6-139">비즈니스 응용 프로그램 데이터를 저장 하는 기본 및 검증 방법 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="551f6-139">This is one of the preferred, and proven, ways to store business application data.</span></span>


>[!div class="step-by-step"]
<span data-ttu-id="551f6-140">[이전](monolithic-applications.md)
[다음](soa-applications.md)</span><span class="sxs-lookup"><span data-stu-id="551f6-140">[Previous](monolithic-applications.md)
[Next](soa-applications.md)</span></span>

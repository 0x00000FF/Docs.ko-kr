---
title: 단일 응용 프로그램
description: Microsoft 플랫폼 및 도구를 사용하여 컨테이너화된 Docker 응용 프로그램 수명 주기
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 09/22/2017
ms.openlocfilehash: 4d25ef131cf149eb869fa2acd40eddff5ee0b55d
ms.sourcegitcommit: 979597cd8055534b63d2c6ee8322938a27d0c87b
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 06/29/2018
ms.locfileid: "37106621"
---
# <a name="monolithic-applications"></a><span data-ttu-id="9aa17-103">단일 응용 프로그램</span><span class="sxs-lookup"><span data-stu-id="9aa17-103">Monolithic applications</span></span>

<span data-ttu-id="9aa17-104">이 시나리오에서는 단일 및 모놀리식 웹 응용 프로그램 또는 서비스를 만들 하는 컨테이너로 배포 합니다.</span><span class="sxs-lookup"><span data-stu-id="9aa17-104">In this scenario, you are building a single and monolithic web application or service and deploying it as a container.</span></span> <span data-ttu-id="9aa17-105">응용 프로그램 내에서 구조 하지 못할 모놀리식; 여러 라이브러리, 구성 요소, 또는 심지어 계층 (응용 프로그램 계층, 도메인 계층, 데이터 액세스 계층 등)를 구성 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9aa17-105">Within the application, the structure might not be monolithic; it might comprise several libraries, components, or even layers (application layer, domain layer, data access layer, etc.).</span></span> <span data-ttu-id="9aa17-106">외부적으로 것은 단일 프로세스, 단일 웹 응용 프로그램 또는 단일 서비스와 같은 단일 컨테이너입니다.</span><span class="sxs-lookup"><span data-stu-id="9aa17-106">Externally, it is a single container, like a single process, single web application, or single service.</span></span>

<span data-ttu-id="9aa17-107">이 모델을 관리하려면 응용 프로그램을 나타내는 단일 컨테이너를 배포합니다.</span><span class="sxs-lookup"><span data-stu-id="9aa17-107">To manage this model, you deploy a single container to represent the application.</span></span> <span data-ttu-id="9aa17-108">크기를 조정, 부하 분산 장치 앞에 몇 가지 더 많은 복사본 추가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="9aa17-108">To scale it, just add a few more copies with a load balancer in front.</span></span> <span data-ttu-id="9aa17-109">간단 하 게 단일 컨테이너 또는 가상 컴퓨터 (VM)의 단일 배포를 관리에서 제공 됩니다.</span><span class="sxs-lookup"><span data-stu-id="9aa17-109">The simplicity comes from managing a single deployment in a single container or virtual machine (VM).</span></span>

<span data-ttu-id="9aa17-110">주 서버 컨테이너만, 한 작업을 수행 하며 하나의 프로세스에는 다음 모놀리식 패턴 충돌은입니다.</span><span class="sxs-lookup"><span data-stu-id="9aa17-110">Following the principal that a container does one thing only, and does it in one process, the monolithic pattern is in conflict.</span></span> <span data-ttu-id="9aa17-111">그림 4-1을 보여 주는 것 처럼 여러 구성 요소/라이브러리 또는 각 컨테이너 내에서 내부 레이어를 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9aa17-111">You can include multiple components/libraries or internal layers within each container, as illustrated in Figure 4-1.</span></span>

![](./media/image1.png)

<span data-ttu-id="9aa17-112">그림 4-1: 모놀리식 응용 프로그램 아키텍처의 예</span><span class="sxs-lookup"><span data-stu-id="9aa17-112">Figure 4-1: An example of monolithic application architecture</span></span>

<span data-ttu-id="9aa17-113">이 방법의 단점은 이거나 응용 프로그램 증가 크기를 조정 하도록 요구 하는 경우에 제공 됩니다.</span><span class="sxs-lookup"><span data-stu-id="9aa17-113">The downside to this approach comes if or when the application grows, requiring it to scale.</span></span> <span data-ttu-id="9aa17-114">전체 응용 프로그램의 크기를 조정하는 것은 문제가 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9aa17-114">If the entire application scaled, it's not really a problem.</span></span> <span data-ttu-id="9aa17-115">그러나 대부분의 경우에서 응용 프로그램의 몇 가지 부분이 있는 좁게 지점을 확장 해야 하는 반면 다른 구성 요소에 덜 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="9aa17-115">However, in most cases, a few parts of the application are the choke points that require scaling, whereas other components are used less.</span></span>

<span data-ttu-id="9aa17-116">제품 정보 구성 요소 크기를 조정 하는 가능성이 필요한 일반적인 전자 상거래 예제를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="9aa17-116">Using the typical e-commerce example, what you likely need is to scale the product information component.</span></span> <span data-ttu-id="9aa17-117">제품을 구매하는 고객보다 제품을 살펴보는 고객이 훨씬 많습니다.</span><span class="sxs-lookup"><span data-stu-id="9aa17-117">Many more customers browse products than purchase them.</span></span> <span data-ttu-id="9aa17-118">많은 고객이 결제 파이프라인을 사용하지 않고 자신의 바구니를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="9aa17-118">More customers use their basket than use the payment pipeline.</span></span> <span data-ttu-id="9aa17-119">적은 수의 고객이 주석을 추가하거나 자신의 구매 기록을 봅니다.</span><span class="sxs-lookup"><span data-stu-id="9aa17-119">Fewer customers add comments or view their purchase history.</span></span> <span data-ttu-id="9aa17-120">및 콘텐츠 및 마케팅 캠페인을 관리 해야 하는 단일 지역에서 직원의 일부만 있을 가능성이 높습니다.</span><span class="sxs-lookup"><span data-stu-id="9aa17-120">And you likely have only a handful of employees, in a single region, that need to manage the content and marketing campaigns.</span></span> <span data-ttu-id="9aa17-121">모놀리식 디자인을 조정 하 여 여러 번 배포의 모든 코드입니다.</span><span class="sxs-lookup"><span data-stu-id="9aa17-121">By scaling the monolithic design, all of the code is deployed multiple times.</span></span>

<span data-ttu-id="9aa17-122">이외에 "배율-모든 항목" 모든 인스턴스의 전체 재배포 뿐만 아니라 전체 응용 프로그램의 전체 다시 테스트 문제, 단일 구성 요소를 변경 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9aa17-122">In addition to the "scale-everything" problem, changes to a single component require complete retesting of the entire application as well as a complete redeployment of all the instances.</span></span>

<span data-ttu-id="9aa17-123">일반적으로 모놀리식 접근 방식 및 대부분의 조직에서는이 아키텍처 메서드를 사용 하 여 개발 합니다.</span><span class="sxs-lookup"><span data-stu-id="9aa17-123">The monolithic approach is common, and many organizations are developing with this architectural method.</span></span> <span data-ttu-id="9aa17-124">다른 발생할 제한 하는 반면 많은 즐길 충분 한 결과 양호 합니다.</span><span class="sxs-lookup"><span data-stu-id="9aa17-124">Many enjoy good enough results, whereas others encounter limits.</span></span> <span data-ttu-id="9aa17-125">도구 및 인프라, Soa 빌드 너무 문제가 발생 하지 않은 대체할 필요는 하기 때문에이 모델에서 응용 프로그램의 설계 된 많은-응용 프로그램 증가 될 때까지 합니다.</span><span class="sxs-lookup"><span data-stu-id="9aa17-125">Many designed their applications in this model because the tools and infrastructure were too difficult to build SOAs, and they didn't see the need—until the app grew.</span></span>

<span data-ttu-id="9aa17-126">인프라 측면에서 볼 때 각 서버 수 많은 응용 프로그램을 동일한 호스트 내에서 한 효율성의 허용 되는 비율의 리소스 사용량에 그림 4-2에 나와 있는 것 처럼 합니다.</span><span class="sxs-lookup"><span data-stu-id="9aa17-126">From an infrastructure perspective, each server can run many applications within the same host and have an acceptable ratio of efficiency in your resources usage, as shown in Figure 4-2.</span></span>

![](./media/image2.png)

<span data-ttu-id="9aa17-127">그림 4-2: 실행 하는 호스트 여러 응용 프로그램/컨테이너</span><span class="sxs-lookup"><span data-stu-id="9aa17-127">Figure 4-2: A host running multiple apps/containers</span></span>

<span data-ttu-id="9aa17-128">각 인스턴스에 대 한 전용된 Vm을 사용 하 여 Azure에서 단일 응용 프로그램을 배포할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9aa17-128">You can deploy monolithic applications in Azure by using dedicated VMs for each instance.</span></span> <span data-ttu-id="9aa17-129">사용 하 여 [Azure VM 크기 집합이](https://docs.microsoft.com/azure/virtual-machine-scale-sets/), Vm을 쉽게 확장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9aa17-129">Using [Azure VM Scale Sets](https://docs.microsoft.com/azure/virtual-machine-scale-sets/), you can scale the VMs easily.</span></span> <span data-ttu-id="9aa17-130">[Azure App Services](https://azure.microsoft.com/en-us/services/app-service/)는 VM을 관리하지 않고 모놀리식 응용 프로그램을 실행하고 인스턴스 크기를 쉽게 조정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9aa17-130">[Azure App Services](https://azure.microsoft.com/en-us/services/app-service/) can run monolithic applications and easily scale instances without having to manage the VMs.</span></span> <span data-ttu-id="9aa17-131">2016의 경우 이후의 Azure 앱 서비스 인스턴스를 실행할 수 단일 뿐, Docker 컨테이너의 배포를 단순화 합니다.</span><span class="sxs-lookup"><span data-stu-id="9aa17-131">Since 2016, Azure App Services can run single instances of Docker containers, as well, simplifying the deployment.</span></span> <span data-ttu-id="9aa17-132">및 Docker를 사용 하는 Docker 호스트에 단일 VM을 배포 하 고 실행할 수 여러 인스턴스.</span><span class="sxs-lookup"><span data-stu-id="9aa17-132">And, using Docker, you can deploy a single VM as a Docker host and run multiple instances.</span></span> <span data-ttu-id="9aa17-133">그림 4-3에 표시 된 것 처럼 Azure 분산 장치를 사용 하 여, 크기 조정을 관리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9aa17-133">Using the Azure balancer, as illustrated in the Figure 4-3, you can manage scaling.</span></span>

![](./media/image3.png)

<span data-ttu-id="9aa17-134">그림 4-3: 다중 호스트는 단일 Docker 응용 앱/컨테이너 확장</span><span class="sxs-lookup"><span data-stu-id="9aa17-134">Figure 4-3: Multiple hosts scaling-out a single Docker application apps/containers</span></span>

<span data-ttu-id="9aa17-135">기존의 배포 기술을 통해 다양 한 호스트에 배포를 관리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9aa17-135">You can manage the deployment to the various hosts via traditional deployment techniques.</span></span> <span data-ttu-id="9aa17-136">과 같은 명령을 사용 하 여 Docker 호스트를 관리할 수 있습니다 `docker run` 이 전자책 (영문)의 뒷부분에 나오는 설명 하는 지속적인 배달 (CD) 파이프라인 같은 자동화를 통해 수동으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="9aa17-136">You can manage Docker hosts by using commands like `docker run` manually, through automation such as Continuous Delivery (CD) pipelines, which we explain later in this e-book.</span></span>

## <a name="monolithic-application-deployed-as-a-container"></a><span data-ttu-id="9aa17-137">컨테이너로 배포된 모놀리식 응용 프로그램</span><span class="sxs-lookup"><span data-stu-id="9aa17-137">Monolithic application deployed as a container</span></span>

<span data-ttu-id="9aa17-138">컨테이너를 사용 하 여 모놀리식 배포를 관리할 수 있는 이점이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9aa17-138">There are benefits to using containers to manage monolithic deployments.</span></span> <span data-ttu-id="9aa17-139">컨테이너 인스턴스의 크기를 확장하는 것은 추가 VM을 배포하는 것보다 훨씬 쉽고 빠릅니다.</span><span class="sxs-lookup"><span data-stu-id="9aa17-139">Scaling the instances of containers is far faster and easier than deploying additional VMs.</span></span> <span data-ttu-id="9aa17-140">VM 크기 집합이 있는 유용한 기능 Docker 컨테이너를 호스트 하는 데 필요한 Vm 크기를 조정 하는 설정 시간이 걸리기 합니다.</span><span class="sxs-lookup"><span data-stu-id="9aa17-140">Although VM Scale Sets are a great feature to scale VMs, which are required to host your Docker containers, they take time to set up.</span></span> <span data-ttu-id="9aa17-141">앱 인스턴스로 배포되는 경우 앱 구성은 VM의 일부로 관리됩니다.</span><span class="sxs-lookup"><span data-stu-id="9aa17-141">When deployed as app instances, the configuration of the app is managed as part of the VM.</span></span>

<span data-ttu-id="9aa17-142">Docker 이미지로 업데이트를 배포하는 것이 훨씬 더 빠르고 네트워크 효율적입니다.</span><span class="sxs-lookup"><span data-stu-id="9aa17-142">Deploying updates as Docker images is far faster and network efficient.</span></span> <span data-ttu-id="9aa17-143">Vn 인스턴스 추가 Vm에서 발생 하는 추가 비용 제거 Vn 1 인스턴스로 동일한 호스트에 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9aa17-143">The Vn instances can be set up on the same hosts as your Vn-1 instances, eliminating added costs resulting from additional VMs.</span></span> <span data-ttu-id="9aa17-144">Docker 이미지 롤아웃 속도 (초) 일반적으로 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="9aa17-144">Docker images typically start in seconds, speeding rollouts.</span></span> <span data-ttu-id="9aa17-145">Docker 인스턴스를 중지 하는 것은 호출 하는 것 만큼 쉽게는 `docker stop` 명령, 일반적으로 몇 초에서 완료 합니다.</span><span class="sxs-lookup"><span data-stu-id="9aa17-145">Tearing down a Docker instance is as easy as invoking the `docker stop` command, typically completing in less than a second.</span></span>

<span data-ttu-id="9aa17-146">컨테이너를 디자인 하 여 본질적으로 변경할 수 없기 때문에 일부 특정 구성 또는 디스크에 남아 있는 파일을 설명 하기 위해 업데이트 스크립트를 찾기 때문에 손상 된 Vm에 대해서는 걱정 필요가 하는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9aa17-146">Because containers are inherently immutable, by design, you never need to worry about corrupted VMs because an update script forgot to account for some specific configuration or file left on disk.</span></span>

<span data-ttu-id="9aa17-147">구식 응용 프로그램은 Docker에서 이익을 얻을 수, 혜택 팁만에 터치 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="9aa17-147">Although monolithic apps can benefit from Docker, we're touching on only the tips of the benefits.</span></span> <span data-ttu-id="9aa17-148">컨테이너 관리의 더 큰 이점 다양 한 인스턴스 및 각 컨테이너 인스턴스의 수명 주기를 관리 하는 컨테이너 orchestrators 사용 하 여 배포에서 제공 됩니다.</span><span class="sxs-lookup"><span data-stu-id="9aa17-148">The larger benefits of managing containers comes from deploying with container orchestrators that manage the various instances and life cycle of each container instance.</span></span> <span data-ttu-id="9aa17-149">개별적으로 크기를 조정하고, 개발하고, 배포할 수 있는 하위 시스템으로 모놀리식 응용 프로그램을 나누는 작업은 마이크로 서비스 영역의 진입점입니다.</span><span class="sxs-lookup"><span data-stu-id="9aa17-149">Breaking up the monolithic application into subsystems that can be scaled, developed, and deployed individually is your entry point into the realm of microservices.</span></span>

## <a name="publishing-a-single-docker-container-app-to-azure-app-service"></a><span data-ttu-id="9aa17-150">Azure 앱 서비스에 단일 Docker 컨테이너 응용 프로그램 게시</span><span class="sxs-lookup"><span data-stu-id="9aa17-150">Publishing a single Docker container app to Azure App Service</span></span>

<span data-ttu-id="9aa17-151">하거나 없거나 앱은 Azure에 배포 하는 컨테이너의 빠른 유효성 검사 하려고 하기 때문에 단순히 Azure 앱 서비스 하는 단일 컨테이너 앱 확장 가능한 단일 컨테이너 서비스를 제공 하는 좋은 방법이 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="9aa17-151">Either because you want to get a quick validation of a container deployed to Azure or because the app is simply a single-container app, Azure App Services provides a great way to provide scalable single-container services.</span></span>

<span data-ttu-id="9aa17-152">Azure 앱 서비스를 사용 하 여의 직관적인 얻을 수 있습니다 및 훌륭한 Git를 제공 하기 때문에 신속 하 게 실행 통합 코드를 적용 하려면 Microsoft Visual Studio에서 빌드 및 직접 Azure에 배포 합니다.</span><span class="sxs-lookup"><span data-stu-id="9aa17-152">Using Azure App Service is intuitive and you can get up and running quickly because it provides great Git integration to take your code, build it in Microsoft Visual Studio, and directly deploy it to Azure.</span></span> <span data-ttu-id="9aa17-153">하지만, 일반적으로 (Docker가 있는 없음), 다른 기능, 프레임 워크 또는 앱 서비스에서 지원 되지 않는 종속성 필요한 경우 Azure 팀 앱 서비스에서 해당 종속성을 업데이트할 때까지 대기 하는 데 필요한 하거나 다른 서비스를 전환 서비스 패브릭, 클라우드 서비스 또는 일반도 Vm의 경우 추가로 제어할를 응용 프로그램에 대 한 필수 구성 요소 또는 프레임 워크를 설치할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9aa17-153">But, traditionally (with no Docker), if you needed other capabilities, frameworks, or dependencies that aren't supported in App Services, you needed to wait for it until the Azure team updates those dependencies in App Service or switched to other services like Service Fabric, Cloud Services, or even plain VMs, for which you have further control and can install a required component or framework for your application.</span></span>

<span data-ttu-id="9aa17-154">그러나 이제, (2016 년 11 월에에서 Microsoft Connect 2016에서 발표 된) 제공 하 고, 그림 4‑4 Visual Studio 2017을 사용 하는 경우와 같이 Azure 앱 서비스의 컨테이너 지원 응용 프로그램 환경에서 원하는 작업이 무엇이 든 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9aa17-154">Now, however, (announced at Microsoft Connect 2016 in November 2016) and as shown in Figure 4‑4, when using Visual Studio 2017, container support in Azure App Service gives you the ability to include whatever you want in your app environment.</span></span> <span data-ttu-id="9aa17-155">컨테이너에서 실행 되므로 응용 프로그램에 종속성 추가 Dockerfile 또는 Docker 이미지에 해당 종속성을 포함 하는 기능을 얻을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9aa17-155">If you added a dependency to your app, because you are running it in a container, you get the capability of including those dependencies in your Dockerfile or Docker image.</span></span>

![](./media/image4.png)

<span data-ttu-id="9aa17-156">그림 4-4: Visual Studio 응용 프로그램/컨테이너에서 컨테이너를 Azure 앱 서비스에 게시</span><span class="sxs-lookup"><span data-stu-id="9aa17-156">Figure 4-4: Publishing a container to Azure App Service from Visual Studio apps/containers</span></span>

<span data-ttu-id="9aa17-157">게시 흐름 Azure 컨테이너 레지스트리 (레지스트리 근처 Azure에 배포 하 고 Azure Active Directory 그룹 및 계정을 보호) 될 수 있는 컨테이너 레지스트리 또는 다른 Docker 레지스트리를 통해 이미지를 푸시합니다 그림 4-4도 표시 Docker 허브 또는 온-프레미스 레지스트리 같은.</span><span class="sxs-lookup"><span data-stu-id="9aa17-157">Figure 4-4 also shows that the publish flow pushes an image through a Container Registry, which can be the Azure Container Registry (a registry near to your deployments in Azure and secured by Azure Active Directory groups and accounts) or any other Docker Registry like Docker Hub or on-premises registries.</span></span>


>[!div class="step-by-step"]
<span data-ttu-id="9aa17-158">[이전](common-container-design-principles.md)
[다음](state-and-data-in-docker-applications.md)</span><span class="sxs-lookup"><span data-stu-id="9aa17-158">[Previous](common-container-design-principles.md)
[Next](state-and-data-in-docker-applications.md)</span></span>

---
title: "PLINQ의 속도 향상 이해"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-standard
ms.tgt_pltfrm: 
ms.topic: article
dev_langs:
- csharp
- vb
helpviewer_keywords: PLINQ queries, performance tuning
ms.assetid: 53706c7e-397d-467a-98cd-c0d1fd63ba5e
caps.latest.revision: "14"
author: rpetrusha
ms.author: ronpet
manager: wpickett
ms.openlocfilehash: c3373cb6a2c535bd7d42eb062e1f9727952f7cfb
ms.sourcegitcommit: bd1ef61f4bb794b25383d3d72e71041a5ced172e
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 10/18/2017
---
# <a name="understanding-speedup-in-plinq"></a><span data-ttu-id="e7212-102">PLINQ의 속도 향상 이해</span><span class="sxs-lookup"><span data-stu-id="e7212-102">Understanding Speedup in PLINQ</span></span>
<span data-ttu-id="e7212-103">PLINQ의 주 목적은 다중 코어 컴퓨터에서 병렬로 쿼리 대리자를 실행 하 여 개체 쿼리는 LINQ의 실행을 가속화 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="e7212-103">The primary purpose of PLINQ is to speed up the execution of LINQ to Objects queries by executing the query delegates in parallel on multi-core computers.</span></span> <span data-ttu-id="e7212-104">PLINQ는 소스 컬렉션에 있는 각 요소의 처리는 독립적 이며 사용할 수 있는 공유 상태 간에 개별 대리자 때 가장 잘 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="e7212-104">PLINQ performs best when the processing of each element in a source collection is independent, with no shared state involved among the individual delegates.</span></span> <span data-ttu-id="e7212-105">이러한 작업은 LINQ to Objects 및 PLINQ에서에서 일반적으로 되 고 통칭 되 "*이러한 병렬*" 것에 중점을 두 쉽게 여러 스레드를 예약 하기 때문에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e7212-105">Such operations are common in LINQ to Objects and PLINQ, and are often called "*delightfully parallel*" because they lend themselves easily to scheduling on multiple threads.</span></span> <span data-ttu-id="e7212-106">그러나 모든 쿼리에 이러한 병렬 작업 대부분의 경우 쿼리 하나 평행 화할 수 없는, 또는 병렬 실행 속도가 저하 하는 몇 가지 연산자를 통해 합니다.</span><span class="sxs-lookup"><span data-stu-id="e7212-106">However, not all queries consist entirely of delightfully parallel operations; in most cases, a query involves some operators that either cannot be parallelized, or that slow down parallel execution.</span></span> <span data-ttu-id="e7212-107">와 완전히 병렬화 되어 있는 쿼리를 PLINQ 해야 데이터 소스를 분할 하 고 작업을 스레드를 예약 하며 쿼리가 완료 되 면 결과 병합 합니다.</span><span class="sxs-lookup"><span data-stu-id="e7212-107">And even with queries that are entirely delightfully parallel, PLINQ must still partition the data source and schedule the work on the threads, and usually merge the results when the query completes.</span></span> <span data-ttu-id="e7212-108">이 작업은 모두 병렬화;의 계산 비용에 추가 병렬 처리 기능을 추가 하는 이러한 비용 라고 *오버 헤드*합니다.</span><span class="sxs-lookup"><span data-stu-id="e7212-108">All these operations add to the computational cost of parallelization; these costs of adding parallelization are called *overhead*.</span></span> <span data-ttu-id="e7212-109">PLINQ 쿼리의 성능을 최적화 하려면, 목표 병렬화 되어 있는 파트를 최대화 하 고 오버 헤드를 필요로 하는 파트를 최소화 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="e7212-109">To achieve optimum performance in a PLINQ query, the goal is to maximize the parts that are delightfully parallel and minimize the parts that require overhead.</span></span> <span data-ttu-id="e7212-110">이 문서는 올바른 결과 산출 하는 동안 최대한 효율적으로 PLINQ 쿼리를 작성 하는 데 도움이 되는 정보를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="e7212-110">This article provides information that will help you write PLINQ queries that are as efficient as possible while still yielding correct results.</span></span>  
  
## <a name="factors-that-impact-plinq-query-performance"></a><span data-ttu-id="e7212-111">PLINQ 쿼리 성능에 영향을 주는 요소</span><span class="sxs-lookup"><span data-stu-id="e7212-111">Factors that Impact PLINQ Query Performance</span></span>  
 <span data-ttu-id="e7212-112">다음 섹션에서는 병렬 쿼리 성능에 영향을 해당 가장 중요 한 요소 중 일부를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="e7212-112">The following sections lists some of the most important factors that impact parallel query performance.</span></span> <span data-ttu-id="e7212-113">이 일반 문 자체 만으로는 부족 한 모든 경우에에서 쿼리 성능을 예측할 수입니다.</span><span class="sxs-lookup"><span data-stu-id="e7212-113">These are general statements that by themselves are not sufficient to predict query performance in all cases.</span></span> <span data-ttu-id="e7212-114">늘 그렇듯이 대표 구성 및 부하의 범위를 컴퓨터에 대 한 특정 쿼리의 실제 성능을 측정을 고려해 야 합니다.</span><span class="sxs-lookup"><span data-stu-id="e7212-114">As always, it is important to measure actual performance of specific queries on computers with a range of representative configurations and loads.</span></span>  
  
1.  <span data-ttu-id="e7212-115">전체 작업의 계산 비용입니다.</span><span class="sxs-lookup"><span data-stu-id="e7212-115">Computational cost of the overall work.</span></span>  
  
     <span data-ttu-id="e7212-116">PLINQ 쿼리 속도 향상 시키려면 오버 헤드를 충분 한 이러한 병렬 작업이 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="e7212-116">To achieve speedup, a PLINQ query must have enough delightfully parallel work to offset the overhead.</span></span> <span data-ttu-id="e7212-117">작업의 소스 컬렉션의 요소 수를 곱한 각 대리자의 계산 비용으로 표현할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e7212-117">The work can be expressed as the computational cost of each delegate multiplied by the number of elements in the source collection.</span></span> <span data-ttu-id="e7212-118">가정 하는 작업 병렬화 될 수 있으면 계산 비용이 많이 드는 인 큼 속도 대 한 기회입니다.</span><span class="sxs-lookup"><span data-stu-id="e7212-118">Assuming that an operation can be parallelized, the more computationally expensive it is, the greater the opportunity for speedup.</span></span> <span data-ttu-id="e7212-119">예를 들어, 함수가 실행에 1 밀리초를 사용 하는 경우 1000 요소 걸립니다 해당 작업을 수행 하려면 1 초 4 개의 코어를 사용 하는 컴퓨터에서 병렬 쿼리 하는 반면 순차적 쿼리 초가 걸릴 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e7212-119">For example, if a function takes one millisecond to execute, a sequential query over 1000 elements will take one second to perform that operation, whereas a parallel query on a computer with four cores might take only 250 milliseconds.</span></span> <span data-ttu-id="e7212-120">750 밀리초의 속도 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="e7212-120">This yields a speedup of 750 milliseconds.</span></span> <span data-ttu-id="e7212-121">함수가 각 요소에 대해 실행할 수는 1 초, 필요한 경우 지금까지 750 초 것 다음입니다.</span><span class="sxs-lookup"><span data-stu-id="e7212-121">If the function required one second to execute for each element, then the speedup would be 750 seconds.</span></span> <span data-ttu-id="e7212-122">대리자가 부담이, PLINQ 소스 컬렉션의 항목 수가 적은와 중요 한 속도 향상을 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e7212-122">If the delegate is very expensive, then PLINQ might offer significant speedup with only a few items in the source collection.</span></span> <span data-ttu-id="e7212-123">반대로 크기가 작은 소스 trivial 대리자 컬렉션은 일반적으로 적합 하지 않습니다 PLINQ에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="e7212-123">Conversely, small source collections with trivial delegates are generally not good candidates for PLINQ.</span></span>  
  
     <span data-ttu-id="e7212-124">다음 예에서 queryA 때문일에 적합 한 많은 작업 함수는 선택 과정이 포함 되어 있음을 가정 PLINQ 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e7212-124">In the following example, queryA is probably a good candidate for PLINQ, assuming that its Select function involves a lot of work.</span></span> <span data-ttu-id="e7212-125">queryB Select 문에서 충분 한 작업이 없기 때문에는 병렬화 오버 헤드 대부분 또는 지금까지 모두 만큼 오프셋 됩니다 적합 없는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="e7212-125">queryB is probably not a good candidate because there is not enough work in the Select statement, and the overhead of parallelization will offset most or all of the speedup.</span></span>  
  
    ```vb  
    Dim queryA = From num In numberList.AsParallel()  
                 Select ExpensiveFunction(num); 'good for PLINQ  
  
    Dim queryB = From num In numberList.AsParallel()  
                 Where num Mod 2 > 0  
                 Select num; 'not as good for PLINQ  
    ```  
  
    ```csharp  
    var queryA = from num in numberList.AsParallel()  
                 select ExpensiveFunction(num); //good for PLINQ  
  
    var queryB = from num in numberList.AsParallel()  
                 where num % 2 > 0  
                 select num; //not as good for PLINQ  
    ```  
  
2.  <span data-ttu-id="e7212-126">시스템 (병렬 처리 수준)의 논리 코어 수입니다.</span><span class="sxs-lookup"><span data-stu-id="e7212-126">The number of logical cores on the system (degree of parallelism).</span></span>  
  
     <span data-ttu-id="e7212-127">이 점은 이전 섹션에는 확실 한 단독, 병렬화 되어 있는 쿼리 실행 속도가 컴퓨터에서 더 많은 코어와 더 많은 동시 스레드 간에 작업을 구분할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e7212-127">This point is an obvious corollary to the previous section, queries that are delightfully parallel run faster on machines with more cores because the work can be divided among more concurrent threads.</span></span> <span data-ttu-id="e7212-128">전반적인 속도의 양이 병렬화 된 쿼리의 전체 작업의 비율에 따라 달라 집니다.</span><span class="sxs-lookup"><span data-stu-id="e7212-128">The overall amount of speedup depends on what percentage of the overall work of the query is parallelizable.</span></span> <span data-ttu-id="e7212-129">그러나 가정 하지 마십시오 모든 쿼리도 두 번 실행 됩니다 4 코어 컴퓨터와는 8 개 코어 컴퓨터에서 빠른 합니다.</span><span class="sxs-lookup"><span data-stu-id="e7212-129">However, do not assume that all queries will run twice as fast on an eight core computer as a four core computer.</span></span> <span data-ttu-id="e7212-130">최적의 성능을 위해 쿼리를 튜닝 하는 경우에 다양 한 수의 코어 시스템에 실제 결과 측정 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="e7212-130">When tuning queries for optimal performance, it is important to measure actual results on computers with various numbers of cores.</span></span> <span data-ttu-id="e7212-131">이 지점 관련 되어 #1: 더 큰 컴퓨팅 리소스를 활용 하는 데 필요한 데이터 집합이 큰 경우.</span><span class="sxs-lookup"><span data-stu-id="e7212-131">This point is related to point #1: larger datasets are required to take advantage of greater computing resources.</span></span>  
  
3.  <span data-ttu-id="e7212-132">작업의 종류와 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e7212-132">The number and kind of operations.</span></span>  
  
     <span data-ttu-id="e7212-133">PLINQ는 소스 시퀀스에서 요소의 순서를 유지 해야 하는 상황을 위한 AsOrdered 연산자를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="e7212-133">PLINQ provides the AsOrdered operator for situations in which it is necessary to maintain the order of elements in the source sequence.</span></span> <span data-ttu-id="e7212-134">순서와 관련 된 비용이 발생 하지만이 비용은 속도가 일반적으로 빠릅니다.</span><span class="sxs-lookup"><span data-stu-id="e7212-134">There is a cost associated with ordering, but this cost is usually modest.</span></span> <span data-ttu-id="e7212-135">마찬가지로 GroupBy 및 조인 작업 해야 오버 헤드가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="e7212-135">GroupBy and Join operations likewise incur overhead.</span></span> <span data-ttu-id="e7212-136">PLINQ를 순서에 관계 없이 소스 컬렉션의 요소를 처리 하 고 다음 운영자에 게 전달 하는 업데이트가 준비 되는 즉시 허용 될 때 최적으로 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="e7212-136">PLINQ performs best when it is allowed to process elements in the source collection in any order, and pass them to the next operator as soon as they are ready.</span></span> <span data-ttu-id="e7212-137">자세한 내용은 [PLINQ에서 순서 유지](../../../docs/standard/parallel-programming/order-preservation-in-plinq.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="e7212-137">For more information, see [Order Preservation in PLINQ](../../../docs/standard/parallel-programming/order-preservation-in-plinq.md).</span></span>  
  
4.  <span data-ttu-id="e7212-138">쿼리 실행의 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="e7212-138">The form of query execution.</span></span>  
  
     <span data-ttu-id="e7212-139">ToArray 또는 ToList 호출 하 여 쿼리의 결과 저장 하는 경우 단일 데이터 구조에는 모든 병렬 스레드의 결과를 병합 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="e7212-139">If you are storing the results of a query by calling ToArray or ToList, then the results from all parallel threads must be merged into the single data structure.</span></span> <span data-ttu-id="e7212-140">이 불가피 한 계산 비용을 해야합니다.</span><span class="sxs-lookup"><span data-stu-id="e7212-140">This involves an unavoidable computational cost.</span></span> <span data-ttu-id="e7212-141">마찬가지로, (각각에 대해 Visual basic에서) foreach 루프를 사용 하 여 결과 반복 하는 경우 작업자 스레드의 결과를 열거자 스레드 serialize 할 수 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="e7212-141">Likewise, if you iterate the results by using a foreach (For Each in Visual Basic) loop, the results from the worker threads need to be serialized onto the enumerator thread.</span></span> <span data-ttu-id="e7212-142">하지만 각 스레드에서 결과에 따라 일부 작업을 수행 하려면 여러 스레드에서이 작업을 수행 하는 ForAll 메서드를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e7212-142">But if you just want to perform some action based on the result from each thread, you can use the ForAll method to perform this work on multiple threads.</span></span>  
  
5.  <span data-ttu-id="e7212-143">병합 옵션의 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="e7212-143">The type of merge options.</span></span>  
  
     <span data-ttu-id="e7212-144">PLINQ 하거나 해당 출력을 버퍼링 하 고 전체 결과 집합이 생성 되 또는 else 스트림 개별 결과를 생성 된 후 또는 한 번에 청크에서 생성 하도록 구성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e7212-144">PLINQ can be configured to either buffer its output, and produce it in chunks or all at once after the entire result set is produced, or else to stream individual results as they are produced.</span></span> <span data-ttu-id="e7212-145">이전 결과는 구성된 요소 간의 지연이 감소 후자 결과 및 전반적인 실행 시간이입니다.</span><span class="sxs-lookup"><span data-stu-id="e7212-145">The former result is decreased overall execution time and the latter results in decreased latency between yielded elements.</span></span>  <span data-ttu-id="e7212-146">병합 옵션 항상 없는 반면 큰 영향을 전체 쿼리 성능에,은 영향을 줄 수 인식된 성능을 기간 사용자를 제어 하기 때문에 결과를 볼 때까지 대기 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="e7212-146">While the merge options do not always have a major impact on overall query performance, they can impact perceived performance because they control how long a user must wait to see results.</span></span> <span data-ttu-id="e7212-147">자세한 내용은 [PLINQ의 병합 옵션](../../../docs/standard/parallel-programming/merge-options-in-plinq.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="e7212-147">For more information, see [Merge Options in PLINQ](../../../docs/standard/parallel-programming/merge-options-in-plinq.md).</span></span>  
  
6.  <span data-ttu-id="e7212-148">분할의 종류입니다.</span><span class="sxs-lookup"><span data-stu-id="e7212-148">The kind of partitioning.</span></span>  
  
     <span data-ttu-id="e7212-149">일부 경우에 인덱싱 가능한 소스 컬렉션에 대해 PLINQ 쿼리 불균형된 작업 로드 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e7212-149">In some cases, a PLINQ query over an indexable source collection may result in an unbalanced work load.</span></span> <span data-ttu-id="e7212-150">이 경우 사용자 지정 파티 셔 너를 만들어 쿼리 성능을 향상 시킬 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e7212-150">When this occurs, you might be able to increase the query performance by creating a custom partitioner.</span></span> <span data-ttu-id="e7212-151">자세한 내용은 [PLINQ 및 TPL에 대한 사용자 지정 파티셔너](../../../docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="e7212-151">For more information, see [Custom Partitioners for PLINQ and TPL](../../../docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md).</span></span>  
  
## <a name="when-plinq-chooses-sequential-mode"></a><span data-ttu-id="e7212-152">PLINQ 순차 모드를 선택 하는 경우</span><span class="sxs-lookup"><span data-stu-id="e7212-152">When PLINQ Chooses Sequential Mode</span></span>  
 <span data-ttu-id="e7212-153">PLINQ는 항상 빠른 쿼리 순차적으로 실행 되는 쿼리를 실행 하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="e7212-153">PLINQ will always attempt to execute a query at least as fast as the query would run sequentially.</span></span> <span data-ttu-id="e7212-154">PLINQ에서 검사 하지 않습니다 방법을. 계산 되지만 비용이 많이 드는 사용자 대리자, 이거나 얼마나 큰 입력된 소스, "shapes" 특정 쿼리에 대 한 확인지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="e7212-154">Although PLINQ does not look at how computationally expensive the user delegates are, or how big the input source is, it does look for certain query "shapes."</span></span> <span data-ttu-id="e7212-155">특히 쿼리 연산자 또는 병렬 모드에서 느리게 실행 쿼리 연산자의 조합을 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="e7212-155">Specifically, it looks for query operators or combinations of operators that typically cause a query to execute more slowly in parallel mode.</span></span> <span data-ttu-id="e7212-156">이러한 셰이프를 발견 하면 기본적으로 plinq가 순차 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="e7212-156">When it finds such shapes, PLINQ by default falls back to sequential mode.</span></span>  
  
 <span data-ttu-id="e7212-157">그러나 특정 쿼리 성능을 측정 하므로 후 실제로 실행 더 빠르게 병렬 모드에서 결정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e7212-157">However, after measuring a specific query's performance, you may determine that it actually runs faster in parallel mode.</span></span> <span data-ttu-id="e7212-158">이러한 경우에 사용할 수 있습니다는 <xref:System.Linq.ParallelExecutionMode.ForceParallelism?displayProperty=nameWithType> 통해 플래그는 <xref:System.Linq.ParallelEnumerable.WithExecutionMode%2A> 메서드를 plinq에서 쿼리를 병렬화 하도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="e7212-158">In such cases you can use the <xref:System.Linq.ParallelExecutionMode.ForceParallelism?displayProperty=nameWithType> flag via the <xref:System.Linq.ParallelEnumerable.WithExecutionMode%2A> method to instruct PLINQ to parallelize the query.</span></span> <span data-ttu-id="e7212-159">자세한 내용은 [방법: PLINQ에 실행 모드 지정](../../../docs/standard/parallel-programming/how-to-specify-the-execution-mode-in-plinq.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="e7212-159">For more information, see [How to: Specify the Execution Mode in PLINQ](../../../docs/standard/parallel-programming/how-to-specify-the-execution-mode-in-plinq.md).</span></span>  
  
 <span data-ttu-id="e7212-160">다음 목록에서는 기본적으로 PLINQ 순차 모드에서 실행 되는 쿼리 형태를 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="e7212-160">The following list describes the query shapes that PLINQ by default will execute in sequential mode:</span></span>  
  
-   <span data-ttu-id="e7212-161">Select를 포함 하는 쿼리 인덱싱된 인덱싱된 SelectMany Where, 또는 이후를 제거 하거나 원래 인덱스를 다시 정렬 하지 않은 순서 지정 또는 필터링 연산자 ElementAt 절.</span><span class="sxs-lookup"><span data-stu-id="e7212-161">Queries that contain a Select, indexed Where, indexed SelectMany, or ElementAt clause after an ordering or filtering operator that has removed or rearranged original indices.</span></span>  
  
-   <span data-ttu-id="e7212-162">TakeWhile, Take, Skip, SkipWhile 연산자를 포함 하 고 소스 시퀀스에서 인덱스가 없는 원래 순서로 쿼리 합니다.</span><span class="sxs-lookup"><span data-stu-id="e7212-162">Queries that contain a Take, TakeWhile, Skip, SkipWhile operator and where indices in the source sequence are not in the original order.</span></span>  
  
-   <span data-ttu-id="e7212-163">Zip 또는 SequenceEquals를 포함하는 쿼리. 데이터 소스 중 하나에서 원래 순서대로 인덱스가 유지되고 다른 데이터 소스는 인덱싱 가능한 배열 또는 IList(T)가 아닌 경우</span><span class="sxs-lookup"><span data-stu-id="e7212-163">Queries that contain Zip or SequenceEquals, unless one of the data sources has an originally ordered index and the other data source is indexable (i.e. an array or IList(T)).</span></span>  
  
-   <span data-ttu-id="e7212-164">인덱싱 가능 데이터 원본에 적용 하지 않는 한 Concat를 포함 하는 쿼리.</span><span class="sxs-lookup"><span data-stu-id="e7212-164">Queries that contain Concat, unless it is applied to indexable data sources.</span></span>  
  
-   <span data-ttu-id="e7212-165">인덱싱 가능 데이터 원본에 적용 하지 않는 한 반대의 경우를 포함 하는 쿼리.</span><span class="sxs-lookup"><span data-stu-id="e7212-165">Queries that contain Reverse, unless applied to an indexable data source.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="e7212-166">참고 항목</span><span class="sxs-lookup"><span data-stu-id="e7212-166">See Also</span></span>  
 [<span data-ttu-id="e7212-167">PLINQ(병렬 LINQ)</span><span class="sxs-lookup"><span data-stu-id="e7212-167">Parallel LINQ (PLINQ)</span></span>](../../../docs/standard/parallel-programming/parallel-linq-plinq.md)

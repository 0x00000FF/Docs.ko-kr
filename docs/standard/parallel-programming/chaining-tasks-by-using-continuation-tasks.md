---
title: 연속 작업을 사용하여 작업 연결
ms.custom: ''
ms.date: 03/30/2017
ms.prod: .net
ms.reviewer: ''
ms.suite: ''
ms.technology: dotnet-standard
ms.tgt_pltfrm: ''
ms.topic: article
dev_langs:
- csharp
- vb
helpviewer_keywords:
- tasks, continuations
ms.assetid: 0b45e9a2-de28-46ce-8212-1817280ed42d
caps.latest.revision: 30
author: rpetrusha
ms.author: ronpet
manager: wpickett
ms.workload:
- dotnet
- dotnetcore
ms.openlocfilehash: ff475259d1835a048d6260cabf4f1d46d2436954
ms.sourcegitcommit: 2042de78fcdceebb6b8ac4b7a292b93e8782cbf5
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 04/27/2018
---
# <a name="chaining-tasks-by-using-continuation-tasks"></a><span data-ttu-id="3c6bc-102">연속 작업을 사용하여 작업 연결</span><span class="sxs-lookup"><span data-stu-id="3c6bc-102">Chaining Tasks by Using Continuation Tasks</span></span>
<span data-ttu-id="3c6bc-103">비동기 프로그래밍에서는 한 비동기 작업이 완료 시 두 번째 작업을 호출하고 해당 작업에 데이터를 전달하는 것이 일반적입니다.</span><span class="sxs-lookup"><span data-stu-id="3c6bc-103">In asynchronous programming, it is very common for one asynchronous operation, on completion, to invoke a second operation and pass data to it.</span></span> <span data-ttu-id="3c6bc-104">일반적으로 이 작업은 콜백 메서드를 통해 수행되었습니다.</span><span class="sxs-lookup"><span data-stu-id="3c6bc-104">Traditionally, this has been done by using callback methods.</span></span> <span data-ttu-id="3c6bc-105">작업 병렬 라이브러리에서는 *연속 작업*이 동일한 기능을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="3c6bc-105">In the Task Parallel Library, the same functionality is provided by *continuation tasks*.</span></span> <span data-ttu-id="3c6bc-106">연속 작업(연속이라고도 함)은 선행 작업이 완료될 때 다른 작업( *선행*이라고 함)이 호출하는 비동기 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="3c6bc-106">A continuation task (also known just as a continuation) is an asynchronous task that is invoked by another task, which is known as the *antecedent*, when the antecedent finishes.</span></span>  
  
 <span data-ttu-id="3c6bc-107">연속은 비교적 사용이 용이하지만 매우 강력하고 유연합니다.</span><span class="sxs-lookup"><span data-stu-id="3c6bc-107">Continuations are relatively easy to use, but are nevertheless very powerful and flexible.</span></span> <span data-ttu-id="3c6bc-108">예를 들어 다음 작업을 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3c6bc-108">For example, you can:</span></span>  
  
-   <span data-ttu-id="3c6bc-109">선행 작업의 데이터를 연속 작업에 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="3c6bc-109">Pass data from the antecedent to the continuation.</span></span>  
  
-   <span data-ttu-id="3c6bc-110">연속 작업이 호출되거나 호출되지 않는 정확한 조건을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="3c6bc-110">Specify the precise conditions under which the continuation will be invoked or not invoked.</span></span>  
  
-   <span data-ttu-id="3c6bc-111">시작되기 전이나 실행 중일 때 함께 연속 작업을 취소합니다.</span><span class="sxs-lookup"><span data-stu-id="3c6bc-111">Cancel a continuation either before it starts or cooperatively as it is running.</span></span>  
  
-   <span data-ttu-id="3c6bc-112">연속 작업을 예약하는 방법에 대한 힌트를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="3c6bc-112">Provide hints about how the continuation should be scheduled.</span></span>  
  
-   <span data-ttu-id="3c6bc-113">동일한 선행 작업에서 여러 개의 연속 작업을 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="3c6bc-113">Invoke multiple continuations from the same antecedent.</span></span>  
  
-   <span data-ttu-id="3c6bc-114">여러 선행 작업 중 하나 또는 모두가 완료되면 하나의 연속 작업을 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="3c6bc-114">Invoke one continuation when all or any one of multiple antecedents complete.</span></span>  
  
-   <span data-ttu-id="3c6bc-115">연속 작업을 임의 길이까지 차례로 연결합니다.</span><span class="sxs-lookup"><span data-stu-id="3c6bc-115">Chain continuations one after another to any arbitrary length.</span></span>  
  
-   <span data-ttu-id="3c6bc-116">연속 작업을 사용하여 선행 작업에서 발생한 예외를 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="3c6bc-116">Use a continuation to handle exceptions thrown by the antecedent.</span></span>  
  
## <a name="about-continuations"></a><span data-ttu-id="3c6bc-117">연속 작업 정보</span><span class="sxs-lookup"><span data-stu-id="3c6bc-117">About continuations</span></span>  
 <span data-ttu-id="3c6bc-118">연속 작업은 <xref:System.Threading.Tasks.TaskStatus.WaitingForActivation> 상태로 만들어지는 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="3c6bc-118">A continuation is a task that is created in the <xref:System.Threading.Tasks.TaskStatus.WaitingForActivation> state.</span></span> <span data-ttu-id="3c6bc-119">선행 작업이 완료되면 자동으로 활성화됩니다.</span><span class="sxs-lookup"><span data-stu-id="3c6bc-119">It is activated automatically when its antecedent task or tasks complete.</span></span> <span data-ttu-id="3c6bc-120">사용자 코드에서 연속 작업에 대해 <xref:System.Threading.Tasks.Task.Start%2A?displayProperty=nameWithType>를 호출하면 <xref:System.InvalidOperationException?displayProperty=nameWithType> 예외가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="3c6bc-120">Calling <xref:System.Threading.Tasks.Task.Start%2A?displayProperty=nameWithType> on a continuation in user code throws an <xref:System.InvalidOperationException?displayProperty=nameWithType> exception.</span></span>  
  
 <span data-ttu-id="3c6bc-121">연속 작업 자체는 <xref:System.Threading.Tasks.Task> 이며 작업이 시작된 스레드를 차단하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3c6bc-121">A continuation is itself a <xref:System.Threading.Tasks.Task> and does not block the thread on which it is started.</span></span> <span data-ttu-id="3c6bc-122">연속 작업이 완료될 때까지 차단하려면 <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> 메서드를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="3c6bc-122">Call the <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> method to block until the continuation task finishes.</span></span>  
  
## <a name="creating-a-continuation-for-a-single-antecedent"></a><span data-ttu-id="3c6bc-123">단일 선행 작업에 대한 연속 작업 만들기</span><span class="sxs-lookup"><span data-stu-id="3c6bc-123">Creating a continuation for a single antecedent</span></span>  
 <span data-ttu-id="3c6bc-124"><xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> 메서드를 호출하여 선행 작업이 완료되었을 때 실행되는 연속 작업을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="3c6bc-124">You create a continuation that executes when its antecedent has completed by calling the <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="3c6bc-125">다음 예제에서는 기본 패턴을 보여 줍니다(이해하기 쉽도록 예외 처리는 생략됨).</span><span class="sxs-lookup"><span data-stu-id="3c6bc-125">The following example shows the basic pattern, (for clarity, exception handling is omitted).</span></span> <span data-ttu-id="3c6bc-126">현재 요일의 이름을 나타내는 `taskA`개체를 반환하는 선행 작업 <xref:System.DayOfWeek> 를 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="3c6bc-126">It executes an antecedent task, `taskA`, that returns a <xref:System.DayOfWeek> object that indicates the name of the current day of the week.</span></span> <span data-ttu-id="3c6bc-127">선행 작업이 완료되면 연속 작업 `taskB`에 선행 작업이 전달되고 해당 결과를 포함하는 문자열을 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="3c6bc-127">When the antecedent finishes, the continuation task, `taskB`, is passed the antecedent and displays a string that includes its result.</span></span>  
  
 [!code-csharp[TPL_Continuations#1](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_continuations/cs/simple1.cs#1)]
 [!code-vb[TPL_Continuations#1](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuations/vb/simple1.vb#1)]  
  
## <a name="creating-a-continuation-for-multiple-antecedents"></a><span data-ttu-id="3c6bc-128">여러 선행 작업에 대한 연속 작업 만들기</span><span class="sxs-lookup"><span data-stu-id="3c6bc-128">Creating a continuation for multiple antecedents</span></span>  
 <span data-ttu-id="3c6bc-129">작업 그룹 중 하나 또는 모두가 완료되었을 때 실행되는 연속 작업을 만들 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3c6bc-129">You can also create a continuation that will run when any or all of a group of tasks has completed.</span></span> <span data-ttu-id="3c6bc-130">모든 선행 작업이 완료되었을 때 연속 작업을 실행하려면 static(Visual Basic에서는 `Shared`) <xref:System.Threading.Tasks.Task.WhenAll%2A?displayProperty=nameWithType> 메서드 또는 인스턴스 <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A?displayProperty=nameWithType> 메서드를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="3c6bc-130">To execute a continuation when all antecedent tasks have completed, you call the static (`Shared` in Visual Basic) <xref:System.Threading.Tasks.Task.WhenAll%2A?displayProperty=nameWithType> method or the instance <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="3c6bc-131">선행 작업 중 하나가 완료되었을 때 연속 작업을 실행하려면 static(Visual Basic에서는 `Shared`) <xref:System.Threading.Tasks.Task.WhenAny%2A?displayProperty=nameWithType> 메서드 또는 인스턴스 <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAny%2A?displayProperty=nameWithType> 메서드를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="3c6bc-131">To execute a continuation when any of the antecedent tasks has completed, you call the static (`Shared` in Visual Basic) <xref:System.Threading.Tasks.Task.WhenAny%2A?displayProperty=nameWithType> method or the instance <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAny%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="3c6bc-132"><xref:System.Threading.Tasks.Task.WhenAll%2A?displayProperty=nameWithType> 및 <xref:System.Threading.Tasks.Task.WhenAny%2A?displayProperty=nameWithType> 오버로드 호출은 호출 스레드를 차단하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3c6bc-132">Note that calls to the <xref:System.Threading.Tasks.Task.WhenAll%2A?displayProperty=nameWithType> and <xref:System.Threading.Tasks.Task.WhenAny%2A?displayProperty=nameWithType> overloads do not block the calling thread.</span></span>  <span data-ttu-id="3c6bc-133">그러나 일반적으로는 <xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29?displayProperty=nameWithType> 및 <xref:System.Threading.Tasks.Task.WhenAll%28System.Threading.Tasks.Task%5B%5D%29?displayProperty=nameWithType> 메서드를 제외하고 모두 호출하여 반환된 <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> 속성을 검색하므로, 호출 스레드가 차단됩니다.</span><span class="sxs-lookup"><span data-stu-id="3c6bc-133">However, you typically call all but the <xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29?displayProperty=nameWithType> and  <xref:System.Threading.Tasks.Task.WhenAll%28System.Threading.Tasks.Task%5B%5D%29?displayProperty=nameWithType> methods to retrieve the returned  <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> property, which does block the calling thread.</span></span>  
  
 <span data-ttu-id="3c6bc-134">다음 예제에서는 <xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29?displayProperty=nameWithType> 메서드를 호출하여 10개 선행 작업의 결과를 반영하는 연속 작업을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="3c6bc-134">The following example calls the <xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29?displayProperty=nameWithType> method to create a continuation task that reflects the results of its ten antecedent tasks.</span></span> <span data-ttu-id="3c6bc-135">각 선행 작업은 1에서 10까지의 인덱스 값을 제곱합니다.</span><span class="sxs-lookup"><span data-stu-id="3c6bc-135">Each antecedent task squares an index value that ranges from one to ten.</span></span> <span data-ttu-id="3c6bc-136">선행 작업이 성공적으로 완료될 경우(<xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> 속성이 <xref:System.Threading.Tasks.TaskStatus.RanToCompletion?displayProperty=nameWithType>임) 연속 작업의 <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> 속성은 각 선행 작업에서 반환된 <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> 값의 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="3c6bc-136">If the antecedents complete successfully (their <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> property is <xref:System.Threading.Tasks.TaskStatus.RanToCompletion?displayProperty=nameWithType>), the <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> property of the continuation is an array of the <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> values returned by each antecedent.</span></span> <span data-ttu-id="3c6bc-137">예제에서는 값을 더하여 1과 10 사이의 모든 숫자의 제곱 합계를 계산합니다.</span><span class="sxs-lookup"><span data-stu-id="3c6bc-137">The example adds them to compute the sum of squares for all numbers between one and ten.</span></span>  
  
 [!code-csharp[TPL_Continuations#5](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_continuations/cs/whenall1.cs#5)]
 [!code-vb[TPL_Continuations#5](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuations/vb/whenall1.vb#5)]  
  
## <a name="continuation-options"></a><span data-ttu-id="3c6bc-138">연속 옵션</span><span class="sxs-lookup"><span data-stu-id="3c6bc-138">Continuation options</span></span>  
 <span data-ttu-id="3c6bc-139">단일 작업 연속을 만드는 경우 <xref:System.Threading.Tasks.TaskContinuationOptions?displayProperty=nameWithType> 열거형 값을 받는 <xref:System.Threading.Tasks.Task.ContinueWith%2A> 오버로드를 사용하여 연속 작업이 시작되는 조건을 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3c6bc-139">When you create a single-task continuation, you can use a <xref:System.Threading.Tasks.Task.ContinueWith%2A> overload that takes a <xref:System.Threading.Tasks.TaskContinuationOptions?displayProperty=nameWithType> enumeration value to specify the conditions under which the continuation starts.</span></span> <span data-ttu-id="3c6bc-140">예를 들어 선행 작업이 성공적으로 완료되거나 오류 상태로 완료되는 경우에만 연속 작업이 실행되도록 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3c6bc-140">For example, you can specify that the continuation is to run only if the antecedent completes successfully, or only if it completes in a faulted state.</span></span> <span data-ttu-id="3c6bc-141">선행 작업이 연속 작업을 호출할 준비가 되었을 때 조건이 true가 아니면 연속 작업이 <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> 상태로 바로 전환되며 그 후에 시작할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="3c6bc-141">If the condition is not true when the antecedent is ready to invoke the continuation, the continuation transitions directly to the <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> state and cannot be started after that.</span></span>  
  
 <span data-ttu-id="3c6bc-142"><xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A?displayProperty=nameWithType> 메서드 오버로드와 같은 많은 다중 작업 연속 메서드에는 <xref:System.Threading.Tasks.TaskContinuationOptions?displayProperty=nameWithType> 매개 변수도 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="3c6bc-142">A number of multi-task continuation methods, such as overloads of the <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A?displayProperty=nameWithType> method, also include a <xref:System.Threading.Tasks.TaskContinuationOptions?displayProperty=nameWithType> parameter.</span></span> <span data-ttu-id="3c6bc-143">그러나 모든 <xref:System.Threading.Tasks.TaskContinuationOptions?displayProperty=nameWithType> 열거형 멤버의 하위 집합만 유효합니다.</span><span class="sxs-lookup"><span data-stu-id="3c6bc-143">Only a subset of all <xref:System.Threading.Tasks.TaskContinuationOptions?displayProperty=nameWithType> enumeration members are valid, however.</span></span> <span data-ttu-id="3c6bc-144"><xref:System.Threading.Tasks.TaskCreationOptions?displayProperty=nameWithType> 열거형에 해당 항목이 있는 <xref:System.Threading.Tasks.TaskContinuationOptions?displayProperty=nameWithType> 값(예: <xref:System.Threading.Tasks.TaskContinuationOptions.AttachedToParent?displayProperty=nameWithType>, <xref:System.Threading.Tasks.TaskContinuationOptions.LongRunning?displayProperty=nameWithType> 및 <xref:System.Threading.Tasks.TaskContinuationOptions.PreferFairness?displayProperty=nameWithType>)을 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3c6bc-144">You can specify <xref:System.Threading.Tasks.TaskContinuationOptions?displayProperty=nameWithType> values that have counterparts in the <xref:System.Threading.Tasks.TaskCreationOptions?displayProperty=nameWithType> enumeration, such as <xref:System.Threading.Tasks.TaskContinuationOptions.AttachedToParent?displayProperty=nameWithType>, <xref:System.Threading.Tasks.TaskContinuationOptions.LongRunning?displayProperty=nameWithType>, and <xref:System.Threading.Tasks.TaskContinuationOptions.PreferFairness?displayProperty=nameWithType>.</span></span> <span data-ttu-id="3c6bc-145">다중 작업 연속에 `NotOn` 또는 `OnlyOn` 옵션을 지정하는 경우 런타임에 <xref:System.ArgumentOutOfRangeException> 예외가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="3c6bc-145">If you specify any of the `NotOn` or `OnlyOn` options with a multi-task continuation, an <xref:System.ArgumentOutOfRangeException> exception will be thrown at run time.</span></span>  
  
 <span data-ttu-id="3c6bc-146">작업 연속 옵션에 대한 자세한 내용은 <xref:System.Threading.Tasks.TaskContinuationOptions> 항목을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="3c6bc-146">For more information on task continuation options, see the <xref:System.Threading.Tasks.TaskContinuationOptions> topic.</span></span>  
  
## <a name="passing-data-to-a-continuation"></a><span data-ttu-id="3c6bc-147">연속 작업에 데이터 전달</span><span class="sxs-lookup"><span data-stu-id="3c6bc-147">Passing Data to a Continuation</span></span>  
 <span data-ttu-id="3c6bc-148"><xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> 메서드는 연속 작업의 사용자 대리자에게 선행 작업에 대한 참조를 인수로 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="3c6bc-148">The <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> method passes a reference to the antecedent to the user delegate of the continuation as an argument.</span></span> <span data-ttu-id="3c6bc-149">선행 작업이 <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> 개체이고 작업이 완료될 때까지 실행된 경우 연속 작업이 해당 작업의 <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> 속성에 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3c6bc-149">If the antecedent is a <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> object, and the task ran until it was completed, then the continuation can access the <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> property of the task.</span></span>  
  
 <span data-ttu-id="3c6bc-150"><xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> 속성은 작업이 완료될 때까지 차단됩니다.</span><span class="sxs-lookup"><span data-stu-id="3c6bc-150">The <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> property blocks until the task has completed.</span></span> <span data-ttu-id="3c6bc-151">그러나 작업이 취소되거나 오류가 발생한 경우 <xref:System.Threading.Tasks.Task%601.Result%2A> 속성에 액세스하려고 하면 <xref:System.AggregateException> 예외가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="3c6bc-151">However, if the task was canceled or faulted, attempting to access the <xref:System.Threading.Tasks.Task%601.Result%2A> property throws an <xref:System.AggregateException> exception.</span></span> <span data-ttu-id="3c6bc-152">다음 예제와 같이 <xref:System.Threading.Tasks.TaskContinuationOptions.OnlyOnRanToCompletion> 옵션을 사용하여 이 문제를 방지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3c6bc-152">You can avoid this problem by using the <xref:System.Threading.Tasks.TaskContinuationOptions.OnlyOnRanToCompletion> option, as shown in the following example.</span></span>  
  
 [!code-csharp[TPL_Continuations#2](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_continuations/cs/result1.cs#2)]
 [!code-vb[TPL_Continuations#2](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuations/vb/result1.vb#2)]  
  
 <span data-ttu-id="3c6bc-153">선행 작업이 성공적으로 완료될 때까지 실행되지 않은 경우에도 연속 작업을 실행하려면 예외로부터 보호해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3c6bc-153">If you want the continuation to run even if the antecedent did not run to successful completion, you must guard against the exception.</span></span> <span data-ttu-id="3c6bc-154">한 가지 방법은 선행 작업의 <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> 속성을 테스트하고 상태가 <xref:System.Threading.Tasks.TaskStatus.Faulted> 또는 <xref:System.Threading.Tasks.TaskStatus.Canceled>가 아닌 경우에만 <xref:System.Threading.Tasks.Task%601.Result%2A> 속성에 액세스하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="3c6bc-154">One approach is to test the <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> property of the antecedent, and only attempt to access the <xref:System.Threading.Tasks.Task%601.Result%2A> property if the status is not <xref:System.Threading.Tasks.TaskStatus.Faulted> or <xref:System.Threading.Tasks.TaskStatus.Canceled>.</span></span> <span data-ttu-id="3c6bc-155">선행 작업의 <xref:System.Threading.Tasks.Task.Exception%2A> 속성을 검사할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3c6bc-155">You can also examine the <xref:System.Threading.Tasks.Task.Exception%2A> property of the antecedent.</span></span> <span data-ttu-id="3c6bc-156">자세한 내용은 [예외 처리](../../../docs/standard/parallel-programming/exception-handling-task-parallel-library.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="3c6bc-156">For more information, see [Exception Handling](../../../docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span></span> <span data-ttu-id="3c6bc-157">다음 예제에서는 상태가 <xref:System.Threading.Tasks.TaskStatus.RanToCompletion?displayProperty=nameWithType>인 경우에만 선행 작업의 <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> 속성에 액세스하도록 이전 예제를 수정합니다.</span><span class="sxs-lookup"><span data-stu-id="3c6bc-157">The following example modifies the previous example to access antecedent's <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> property only if its status is <xref:System.Threading.Tasks.TaskStatus.RanToCompletion?displayProperty=nameWithType>.</span></span>  
  
 [!code-csharp[TPL_Continuations#7](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_continuations/cs/result2.cs#7)]
 [!code-vb[TPL_Continuations#7](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuations/vb/result2.vb#7)]  
  
## <a name="canceling-a-continuation"></a><span data-ttu-id="3c6bc-158">연속 작업 취소</span><span class="sxs-lookup"><span data-stu-id="3c6bc-158">Canceling a Continuation</span></span>  
 <span data-ttu-id="3c6bc-159">다음과 같은 경우 연속 작업의 <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> 속성이 <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType>로 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="3c6bc-159">The <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> property of a continuation is set to <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> in the following situations:</span></span>  
  
-   <span data-ttu-id="3c6bc-160">취소 요청에 대한 응답으로 <xref:System.OperationCanceledException> 예외를 발생시키는 경우.</span><span class="sxs-lookup"><span data-stu-id="3c6bc-160">It throws an <xref:System.OperationCanceledException> exception in response to a cancellation request.</span></span> <span data-ttu-id="3c6bc-161">모든 작업과 마찬가지로 연속 작업에 전달된 것과 동일한 토큰이 예외에 포함되어 있으면 협업적 취소의 인정으로 처리됩니다.</span><span class="sxs-lookup"><span data-stu-id="3c6bc-161">Just as with any task, if the exception contains the same token that was passed to the continuation, it is treated as an acknowledgement of cooperative cancellation.</span></span>  
  
-   <span data-ttu-id="3c6bc-162">연속 작업에 <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> 속성이 `true`인 <xref:System.Threading.CancellationToken?displayProperty=nameWithType>이 전달된 경우.</span><span class="sxs-lookup"><span data-stu-id="3c6bc-162">The continuation is passed a <xref:System.Threading.CancellationToken?displayProperty=nameWithType> whose <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> property is `true`.</span></span> <span data-ttu-id="3c6bc-163">이 경우에는 연속 작업이 시작되지 않고 <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> 상태로 전환됩니다.</span><span class="sxs-lookup"><span data-stu-id="3c6bc-163">In this case, the continuation does not start, and it transitions to the <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> state.</span></span>  
  
-   <span data-ttu-id="3c6bc-164"><xref:System.Threading.Tasks.TaskContinuationOptions> 인수로 설정된 조건이 충족되지 않았으므로 연속 작업이 실행되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3c6bc-164">The continuation never runs because the condition set by its <xref:System.Threading.Tasks.TaskContinuationOptions> argument was not met.</span></span> <span data-ttu-id="3c6bc-165">예를 들어 선행 작업이 <xref:System.Threading.Tasks.TaskStatus.Faulted?displayProperty=nameWithType> 상태로 전환되는 경우 <xref:System.Threading.Tasks.TaskContinuationOptions.NotOnFaulted?displayProperty=nameWithType> 옵션이 전달된 연속 작업이 실행되지 않고 <xref:System.Threading.Tasks.TaskStatus.Canceled> 상태로 전환됩니다.</span><span class="sxs-lookup"><span data-stu-id="3c6bc-165">For example, if an antecedent goes into a <xref:System.Threading.Tasks.TaskStatus.Faulted?displayProperty=nameWithType> state, its continuation that was passed the <xref:System.Threading.Tasks.TaskContinuationOptions.NotOnFaulted?displayProperty=nameWithType> option will not run but will transition to the <xref:System.Threading.Tasks.TaskStatus.Canceled> state.</span></span>  
  
 <span data-ttu-id="3c6bc-166">작업과 해당 연속 작업이 동일한 논리 작업의 두 부분을 나타내는 경우 다음 예제와 같이 두 작업에 모두 동일한 취소 토큰을 전달할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3c6bc-166">If a task and its continuation represent two parts of the same logical operation, you can pass the same cancellation token to both tasks, as shown in the following example.</span></span> <span data-ttu-id="3c6bc-167">취소 토큰은 33으로 나눌 수 있는 정수 목록을 생성하는 선행 작업으로 구성되며 연속 작업에 전달됩니다.</span><span class="sxs-lookup"><span data-stu-id="3c6bc-167">It consists of an antecedent that generates a list of integers that are divisible by 33, which it passes to the continuation.</span></span> <span data-ttu-id="3c6bc-168">그런 다음 연속 작업이 목록을 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="3c6bc-168">The continuation in turn displays the list.</span></span> <span data-ttu-id="3c6bc-169">선행 작업과 연속 작업은 모두 임의 간격 동안 정기적으로 일시 중지됩니다.</span><span class="sxs-lookup"><span data-stu-id="3c6bc-169">Both the antecedent and the continuation pause regularly for random intervals.</span></span> <span data-ttu-id="3c6bc-170">또한 <xref:System.Threading.Timer?displayProperty=nameWithType> 개체는 5초 시간 제한 간격 후에 `Elapsed` 메서드를 실행하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="3c6bc-170">In addition, a <xref:System.Threading.Timer?displayProperty=nameWithType> object is used to execute the `Elapsed` method after a five-second timeout interval.</span></span> <span data-ttu-id="3c6bc-171">이 메서드는 현재 실행 중인 작업이 <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> 메서드를 호출하게 하는 <xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType> 메서드를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="3c6bc-171">This calls the <xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType> method, which causes the currently executing task to call the <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="3c6bc-172">선행 작업이나 해당 연속 작업이 실행 중일 때 <xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType> 메서드를 호출할지 여부는 임의로 생성된 일시 중지 기간에 따라 달라집니다.</span><span class="sxs-lookup"><span data-stu-id="3c6bc-172">Whether the <xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType> method is called when the antecedent or its continuation is executing depends on the duration of the randomly generated pauses.</span></span> <span data-ttu-id="3c6bc-173">선행 작업이 취소되면 연속 작업은 시작되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3c6bc-173">If the antecedent is canceled, the continuation will not start.</span></span> <span data-ttu-id="3c6bc-174">선행 작업이 취소되지 않은 경우에도 토큰을 사용하여 연속 작업을 취소할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3c6bc-174">If the antecedent is not canceled, the token can still be used to cancel the continuation.</span></span>  
  
 [!code-csharp[TPL_Continuations#3](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_continuations/cs/cancellation1.cs#3)]
 [!code-vb[TPL_Continuations#3](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuations/vb/cancellation1.vb#3)]  
  
 <span data-ttu-id="3c6bc-175">연속 작업을 만들 때 <xref:System.Threading.Tasks.TaskContinuationOptions.NotOnCanceled?displayProperty=nameWithType> 옵션을 지정하면 연속 작업에 취소 토큰을 제공하지 않고 선행 작업이 취소된 경우에도 연속 작업이 실행되지 않도록 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3c6bc-175">You can also prevent a continuation from executing if its antecedent is canceled without supplying the continuation a cancellation token by specifying the <xref:System.Threading.Tasks.TaskContinuationOptions.NotOnCanceled?displayProperty=nameWithType> option when you create the continuation.</span></span> <span data-ttu-id="3c6bc-176">다음은 간단한 예제입니다.</span><span class="sxs-lookup"><span data-stu-id="3c6bc-176">The following is a simple example.</span></span>  
  
 [!code-csharp[TPL_Continuations#8](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_continuations/cs/cancellation2.cs#8)]
 [!code-vb[TPL_Continuations#8](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuations/vb/cancellation2.vb#8)]  
  
 <span data-ttu-id="3c6bc-177">연속 작업이 <xref:System.Threading.Tasks.TaskStatus.Canceled> 상태로 전환된 후 연속 작업에 대해 지정된 <xref:System.Threading.Tasks.TaskContinuationOptions> 에 따라 이후의 연속 작업에 영향을 줄 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3c6bc-177">After a continuation goes into the <xref:System.Threading.Tasks.TaskStatus.Canceled> state, it may affect continuations that follow, depending on the <xref:System.Threading.Tasks.TaskContinuationOptions> that were specified for those continuations.</span></span>  
  
 <span data-ttu-id="3c6bc-178">삭제된 연속 작업은 시작되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3c6bc-178">Continuations that are disposed will not start.</span></span>  
  
## <a name="continuations-and-child-tasks"></a><span data-ttu-id="3c6bc-179">연속 작업 및 자식 작업</span><span class="sxs-lookup"><span data-stu-id="3c6bc-179">Continuations and Child Tasks</span></span>  
 <span data-ttu-id="3c6bc-180">연속 작업은 선행 작업 및 연결된 모든 자식 작업이 완료될 때까지 실행되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3c6bc-180">A continuation does not run until the antecedent and all of its attached child tasks have completed.</span></span> <span data-ttu-id="3c6bc-181">연속 작업은 분리된 자식 작업이 완료되기를 기다리지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3c6bc-181">The continuation does not wait for detached child tasks to finish.</span></span> <span data-ttu-id="3c6bc-182">다음 두 예제에서는 연속 작업을 만드는 선행 작업에 연결된 자식 작업과 분리된 자식 작업을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="3c6bc-182">The following two examples illustrate child tasks that are attached to and detached from an antecedent that creates a continuation.</span></span> <span data-ttu-id="3c6bc-183">다음 예제에서는 모든 자식 작업이 완료된 후에만 연속 작업이 실행되며 예제를 여러 번 실행해도 매번 동일한 출력이 생성됩니다.</span><span class="sxs-lookup"><span data-stu-id="3c6bc-183">In the following example, the continuation runs only after all child tasks have completed, and running the example multiple times produces identical output each time.</span></span> <span data-ttu-id="3c6bc-184">기본적으로 <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> 메서드는 기본 작업 생성 옵션이 <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType>인 부모 작업을 만들기 때문에 예제에서는 <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> 메서드를 호출하여 선행 작업을 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="3c6bc-184">Note that the example launches the antecedent by calling the <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> method, since by default the <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> method creates a parent task whose default task creation option is <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType>.</span></span>  
  
 [!code-csharp[TPL_Continuations#9](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_continuations/cs/attached1.cs#9)]
 [!code-vb[TPL_Continuations#9](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuations/vb/attached1.vb#9)]  
  
 <span data-ttu-id="3c6bc-185">그러나 자식 작업이 선행 작업에서 분리된 경우 자식 작업의 상태에 관계없이 선행 작업이 종료된 즉시 연속 작업이 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="3c6bc-185">If child tasks are detached from the antecedent, however, the continuation runs as soon as the antecedent has terminated, regardless of the state of the child tasks.</span></span> <span data-ttu-id="3c6bc-186">따라서 다음 예제를 여러 번 실행하면 작업 스케줄러가 각 자식 작업을 처리한 방식에 따라 다른 출력이 생성될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3c6bc-186">As a result, multiple runs of the following example can produce variable output that depends on how the task scheduler handled each child task.</span></span>  
  
 [!code-csharp[TPL_Continuations#10](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_continuations/cs/detached1.cs#10)]
 [!code-vb[TPL_Continuations#10](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuations/vb/detached1.vb#10)]  
  
 <span data-ttu-id="3c6bc-187">선행 작업의 최종 상태는 연결된 자식 작업의 최종 상태에 따라 달라집니다.</span><span class="sxs-lookup"><span data-stu-id="3c6bc-187">The final status of the antecedent task depends on the final status of any attached child tasks.</span></span> <span data-ttu-id="3c6bc-188">분리된 자식 작업의 상태는 부모에 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3c6bc-188">The status of detached child tasks does not affect the parent.</span></span> <span data-ttu-id="3c6bc-189">자세한 내용은 [연결된 자식 작업과 분리된 자식 작업](../../../docs/standard/parallel-programming/attached-and-detached-child-tasks.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="3c6bc-189">For more information, see [Attached and Detached Child Tasks](../../../docs/standard/parallel-programming/attached-and-detached-child-tasks.md).</span></span>  
  
## <a name="associating-state-with-continuations"></a><span data-ttu-id="3c6bc-190">연속 작업에 상태 연결</span><span class="sxs-lookup"><span data-stu-id="3c6bc-190">Associating State with Continuations</span></span>  
 <span data-ttu-id="3c6bc-191">연속 작업에 임의 상태를 연결할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3c6bc-191">You can associate arbitrary state with a task continuation.</span></span> <span data-ttu-id="3c6bc-192"><xref:System.Threading.Tasks.Task.ContinueWith%2A> 메서드는 각각 연속 상태를 나타내는 <xref:System.Object> 값을 받는 오버로드된 버전을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="3c6bc-192">The <xref:System.Threading.Tasks.Task.ContinueWith%2A> method provides overloaded versions that each take an <xref:System.Object> value that represents the state of the continuation.</span></span> <span data-ttu-id="3c6bc-193">나중에 <xref:System.Threading.Tasks.Task.AsyncState%2A?displayProperty=nameWithType> 속성을 사용하여 이 상태 개체에 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3c6bc-193">You can later access this state object by using the <xref:System.Threading.Tasks.Task.AsyncState%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="3c6bc-194">값을 제공하지 않을 경우 이 상태 개체는 `null` 입니다.</span><span class="sxs-lookup"><span data-stu-id="3c6bc-194">This state object is `null` if you do not provide a value.</span></span>  
  
 <span data-ttu-id="3c6bc-195">연속 상태는 [APM(비동기 프로그래밍 모델)](../../../docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md) 을 사용하는 기존 코드를 TPL을 사용하도록 변환하는 경우에 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="3c6bc-195">Continuation state is useful when you convert existing code that uses the [Asynchronous Programming Model (APM)](../../../docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md) to use the TPL.</span></span> <span data-ttu-id="3c6bc-196">APM에서는 일반적으로 **Begin***Method* 메서드에 개체 상태를 제공하고 나중에 <xref:System.IAsyncResult.AsyncState%2A?displayProperty=nameWithType> 속성을 통해 해당 상태에 액세스합니다.</span><span class="sxs-lookup"><span data-stu-id="3c6bc-196">In the APM, you typically provide object state in the **Begin***Method* method and later access that state by using the <xref:System.IAsyncResult.AsyncState%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="3c6bc-197"><xref:System.Threading.Tasks.Task.ContinueWith%2A> 메서드를 사용하면 APM을 사용하는 코드를 TPL을 사용하도록 변환할 때 이 상태를 보존할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3c6bc-197">By using the <xref:System.Threading.Tasks.Task.ContinueWith%2A> method, you can preserve this state when you convert code that uses the APM to use the TPL.</span></span>  
  
 <span data-ttu-id="3c6bc-198">Visual Studio 디버거에서 <xref:System.Threading.Tasks.Task> 개체로 작업하는 경우에도 연속 상태가 유용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3c6bc-198">Continuation state can also be useful when you work with <xref:System.Threading.Tasks.Task> objects in the Visual Studio debugger.</span></span> <span data-ttu-id="3c6bc-199">예를 들어 **병렬 작업** 창의 **작업** 열에는 각 작업에 대한 상태 개체의 문자열 표현이 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="3c6bc-199">For example, in the **Parallel Tasks** window, the **Task** column displays the string representation of the state object for each task.</span></span> <span data-ttu-id="3c6bc-200">**병렬 작업** 창에 대한 자세한 내용은 [작업 창 사용](/visualstudio/debugger/using-the-tasks-window)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="3c6bc-200">For more information about the **Parallel Tasks** window, see [Using the Tasks Window](/visualstudio/debugger/using-the-tasks-window).</span></span>  
  
 <span data-ttu-id="3c6bc-201">다음 예제에서는 연속 상태를 사용하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="3c6bc-201">The following example shows how to use continuation state.</span></span> <span data-ttu-id="3c6bc-202">연속 작업 체인을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="3c6bc-202">It creates a chain of continuation tasks.</span></span> <span data-ttu-id="3c6bc-203">각 작업은 <xref:System.DateTime> 메서드의 `state` 매개 변수에 대해 현재 시간인 <xref:System.Threading.Tasks.Task.ContinueWith%2A> 개체를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="3c6bc-203">Each task provides the current time, a <xref:System.DateTime> object, for the `state` parameter of the <xref:System.Threading.Tasks.Task.ContinueWith%2A> method.</span></span> <span data-ttu-id="3c6bc-204">각 <xref:System.DateTime> 개체는 연속 작업이 만들어진 시간을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="3c6bc-204">Each <xref:System.DateTime> object represents the time at which the continuation task is created.</span></span> <span data-ttu-id="3c6bc-205">각 작업은 작업 완료 시간을 나타내는 두 번째 <xref:System.DateTime> 개체를 결과로 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="3c6bc-205">Each task produces as its result a second <xref:System.DateTime> object that represents the time at which the task finishes.</span></span> <span data-ttu-id="3c6bc-206">이 예제에서는 모든 작업이 완료된 후 만든 시간과 각 연속 작업의 완료 시간이 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="3c6bc-206">After all tasks finish, this example displays the creation time and the time at which each continuation task finishes.</span></span>  
  
 [!code-csharp[TPL_ContinuationState#1](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_continuationstate/cs/continuationstate.cs#1)]
 [!code-vb[TPL_ContinuationState#1](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuationstate/vb/continuationstate.vb#1)]  
  
## <a name="handling-exceptions-thrown-from-continuations"></a><span data-ttu-id="3c6bc-207">연속 작업에서 발생한 예외 처리</span><span class="sxs-lookup"><span data-stu-id="3c6bc-207">Handling Exceptions Thrown from Continuations</span></span>  
 <span data-ttu-id="3c6bc-208">선행-연속 관계는 부모-자식 관계가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="3c6bc-208">An antecedent-continuation relationship is not a parent-child relationship.</span></span> <span data-ttu-id="3c6bc-209">연속 작업에서 발생한 예외는 선행 작업으로 전파되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3c6bc-209">Exceptions thrown by continuations are not propagated to the antecedent.</span></span> <span data-ttu-id="3c6bc-210">따라서 다른 작업에서 처리하는 것처럼 연속 작업에서 발생한 예외를 다음과 같이 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="3c6bc-210">Therefore, handle exceptions thrown by continuations as you would handle them in any other task, as follows:</span></span>  
  
-   <span data-ttu-id="3c6bc-211"><xref:System.Threading.Tasks.Task.Wait%2A>, <xref:System.Threading.Tasks.Task.WaitAll%2A>또는 <xref:System.Threading.Tasks.Task.WaitAny%2A> 메서드나 해당하는 제네릭 항목을 사용하여 연속 작업을 기다릴 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3c6bc-211">You can use the <xref:System.Threading.Tasks.Task.Wait%2A>, <xref:System.Threading.Tasks.Task.WaitAll%2A>, or <xref:System.Threading.Tasks.Task.WaitAny%2A> method, or its generic counterpart, to wait on the continuation.</span></span> <span data-ttu-id="3c6bc-212">다음 예제와 같이 동일한 `try` 문에서 선행 작업과 해당 연속 작업을 기다릴 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3c6bc-212">You can wait for an antecedent and its continuations in the same `try` statement, as shown in the following example.</span></span>  
  
     [!code-csharp[TPL_Continuations#6](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_continuations/cs/exception1.cs#6)]
     [!code-vb[TPL_Continuations#6](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuations/vb/exception1.vb#6)]  
  
-   <span data-ttu-id="3c6bc-213">두 번째 연속 작업을 사용하여 첫 번째 연속 작업의 <xref:System.Threading.Tasks.Task.Exception%2A> 속성을 관찰할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3c6bc-213">You can use a second continuation to observe the <xref:System.Threading.Tasks.Task.Exception%2A> property of the first continuation.</span></span> <span data-ttu-id="3c6bc-214">다음 예제에서는 작업이 존재하지 않는 파일을 읽으려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="3c6bc-214">In the following example, a task attempts to read from a non-existent file.</span></span> <span data-ttu-id="3c6bc-215">그런 다음 연속 작업이 선행 작업의 예외 정보를 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="3c6bc-215">The continuation then displays information about the exception in the antecedent task.</span></span>  
  
     [!code-csharp[TPL_Continuations#4](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_continuations/cs/exception2.cs#4)]
     [!code-vb[TPL_Continuations#4](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuations/vb/exception2.vb#4)]  
  
     <span data-ttu-id="3c6bc-216"><xref:System.Threading.Tasks.TaskContinuationOptions.OnlyOnFaulted?displayProperty=nameWithType> 옵션으로 실행되었기 때문에 연속 작업은 선행 작업에서 예외가 발생한 경우에만 실행되므로 선행 작업의 <xref:System.Threading.Tasks.Task.Exception%2A> 속성이 `null`이 아니라고 가정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3c6bc-216">Because it was run with the <xref:System.Threading.Tasks.TaskContinuationOptions.OnlyOnFaulted?displayProperty=nameWithType> option, the continuation executes only if an exception occurs in the antecedent, and therefore it can assume that the antecedent's <xref:System.Threading.Tasks.Task.Exception%2A> property is not `null`.</span></span> <span data-ttu-id="3c6bc-217">선행 작업에 예외가 발생했는지 여부에 관계없이 연속 작업이 실행되는 경우 다음 코드 조각과 같이 예외를 처리하기 전에 선행 작업의 <xref:System.Threading.Tasks.Task.Exception%2A> 속성이 `null` 이 아닌지 여부를 확인해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3c6bc-217">If the continuation executes whether or not an exception is thrown in the antecedent, it would have to check whether the antecedent's <xref:System.Threading.Tasks.Task.Exception%2A> property is not `null` before attempting to handle the exception, as the following code fragment shows.</span></span>  
  
     [!code-csharp[TPL_Continuations#11](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_continuations/cs/exception2.cs#11)]
     [!code-vb[TPL_Continuations#11](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuations/vb/exception2.vb#11)]  
  
     <span data-ttu-id="3c6bc-218">자세한 내용은 [예외 처리](../../../docs/standard/parallel-programming/exception-handling-task-parallel-library.md) 및 [NIB: 방법: 작업에서 throw된 예외 처리](https://msdn.microsoft.com/library/d6c47ec8-9de9-4880-beb3-ff19ae51565d)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="3c6bc-218">For more information, see [Exception Handling](../../../docs/standard/parallel-programming/exception-handling-task-parallel-library.md) and [NIB: How to: Handle Exceptions Thrown by Tasks](https://msdn.microsoft.com/library/d6c47ec8-9de9-4880-beb3-ff19ae51565d).</span></span>  
  
-   <span data-ttu-id="3c6bc-219">연속 작업이 <xref:System.Threading.Tasks.TaskContinuationOptions.AttachedToParent?displayProperty=nameWithType> 옵션으로 만든 연결된 자식 작업인 경우 다른 연결된 자식과 마찬가지로 부모가 해당 예외를 호출 스레드로 다시 전파합니다.</span><span class="sxs-lookup"><span data-stu-id="3c6bc-219">If the continuation is an attached child task that was created by using the <xref:System.Threading.Tasks.TaskContinuationOptions.AttachedToParent?displayProperty=nameWithType> option, its exceptions will be propagated by the parent back to the calling thread, as is the case in any other attached child.</span></span> <span data-ttu-id="3c6bc-220">자세한 내용은 [연결된 자식 작업과 분리된 자식 작업](../../../docs/standard/parallel-programming/attached-and-detached-child-tasks.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="3c6bc-220">For more information, see [Attached and Detached Child Tasks](../../../docs/standard/parallel-programming/attached-and-detached-child-tasks.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="3c6bc-221">참고 항목</span><span class="sxs-lookup"><span data-stu-id="3c6bc-221">See Also</span></span>  
 [<span data-ttu-id="3c6bc-222">TPL(작업 병렬 라이브러리)</span><span class="sxs-lookup"><span data-stu-id="3c6bc-222">Task Parallel Library (TPL)</span></span>](../../../docs/standard/parallel-programming/task-parallel-library-tpl.md)

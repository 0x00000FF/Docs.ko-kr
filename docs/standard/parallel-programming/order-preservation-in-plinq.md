---
title: "PLINQ에서 순서 유지"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-standard
ms.tgt_pltfrm: 
ms.topic: article
dev_langs:
- csharp
- vb
helpviewer_keywords: PLINQ queries, order preservation
ms.assetid: 10d202bc-19e1-4b5c-bbf1-9a977322a9ca
caps.latest.revision: "19"
author: rpetrusha
ms.author: ronpet
manager: wpickett
ms.openlocfilehash: 060459cf8f408e40ddc394fbcda6a022ec6379de
ms.sourcegitcommit: 4f3fef493080a43e70e951223894768d36ce430a
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 11/21/2017
---
# <a name="order-preservation-in-plinq"></a><span data-ttu-id="c0574-102">PLINQ에서 순서 유지</span><span class="sxs-lookup"><span data-stu-id="c0574-102">Order Preservation in PLINQ</span></span>
<span data-ttu-id="c0574-103">PLINQ의 목표는 정확성을 유지 하면서 성능을 극대화할 수입니다.</span><span class="sxs-lookup"><span data-stu-id="c0574-103">In PLINQ, the goal is to maximize performance while maintaining correctness.</span></span> <span data-ttu-id="c0574-104">쿼리 가능한 한 빠르게 실행 되지만 여전히 올바른 결과 생성 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c0574-104">A query should run as fast as possible but still produce the correct results.</span></span> <span data-ttu-id="c0574-105">경우에 따라 정확성 필요 소스 시퀀스의 순서를 보존 해야 합니다. 그러나 순서 계산이 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c0574-105">In some cases, correctness requires the order of the source sequence to be preserved; however, ordering can be computationally expensive.</span></span> <span data-ttu-id="c0574-106">따라서 기본적으로 PLINQ 유지 하지 않습니다는 소스 시퀀스의 순서.</span><span class="sxs-lookup"><span data-stu-id="c0574-106">Therefore, by default, PLINQ does not preserve the order of the source sequence.</span></span> <span data-ttu-id="c0574-107">이런 점에서 PLINQ 유사한 [!INCLUDE[vbtecdlinq](../../../includes/vbtecdlinq-md.md)], 하지만 순서는 유지 하는 LINQ to Objects와 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="c0574-107">In this regard, PLINQ resembles [!INCLUDE[vbtecdlinq](../../../includes/vbtecdlinq-md.md)], but is unlike LINQ to Objects, which does preserve ordering.</span></span>  
  
 <span data-ttu-id="c0574-108">기본 동작을 재정의 하려면 켤 수 있습니다 순서 유지를 사용 하 여는 <xref:System.Linq.ParallelEnumerable.AsOrdered%2A> 소스 시퀀스에는 연산자입니다.</span><span class="sxs-lookup"><span data-stu-id="c0574-108">To override the default behavior, you can turn on order-preservation by using the <xref:System.Linq.ParallelEnumerable.AsOrdered%2A> operator on the source sequence.</span></span> <span data-ttu-id="c0574-109">사용 하 여 나중에 쿼리에서 순서 유지 해제 한 다음는 <xref:System.Linq.ParallelEnumerable.AsUnordered%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="c0574-109">You can then turn off order preservation later in the query by using the <xref:System.Linq.ParallelEnumerable.AsUnordered%2A> method.</span></span> <span data-ttu-id="c0574-110">두 가지 방법, 쿼리는 쿼리를 병렬로 실행할 것인지를 결정 하는 추론에 따라 또는 순차적으로 처리 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c0574-110">With both methods, the query is processed based on the heuristics that determine whether to execute the query as parallel or as sequential.</span></span> <span data-ttu-id="c0574-111">자세한 내용은 [PLINQ의 속도 향상 이해](../../../docs/standard/parallel-programming/understanding-speedup-in-plinq.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="c0574-111">For more information, see [Understanding Speedup in PLINQ](../../../docs/standard/parallel-programming/understanding-speedup-in-plinq.md).</span></span>  
  
 <span data-ttu-id="c0574-112">다음 예제에서는 어떤 방식으로든에서 결과 정렬 하려고 하지 않고도 조건을 일치 하는 모든 요소에 대해 필터링 하는 순서가 지정 되지 않은 병렬 쿼리를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="c0574-112">The following example shows an unordered parallel query that filters for all the elements that match a condition, without trying to order the results in any way.</span></span>  
  
 [!code-csharp[PLINQ#8](../../../samples/snippets/csharp/VS_Snippets_Misc/plinq/cs/plinqsamples.cs#8)]
 [!code-vb[PLINQ#8](../../../samples/snippets/visualbasic/VS_Snippets_Misc/plinq/vb/plinq2_vb.vb#8)]  
  
 <span data-ttu-id="c0574-113">이 쿼리를 제외한 아니라 몇 가지 조건을 충족 시키는 1000 도시 조건을 만족 하는 소스 시퀀스의 처음 1000 개의 도시를 반드시 생성 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c0574-113">This query does not necessarily produce the first 1000 cities in the source sequence that meet the condition, but rather some set of 1000 cities that meet the condition.</span></span> <span data-ttu-id="c0574-114">PLINQ 쿼리 연산자에는 동시 작업으로 처리 하는 여러 개의 하위 시퀀스로 소스 시퀀스를 분할 합니다.</span><span class="sxs-lookup"><span data-stu-id="c0574-114">PLINQ query operators partition the source sequence into multiple subsequences that are processed as concurrent tasks.</span></span> <span data-ttu-id="c0574-115">순서 유지를 지정 하지 않은 경우의 결과를 각 파티션에 임의의 순서로 쿼리의 다음 단계로 전달 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c0574-115">If order preservation is not specified, the results from each partition are handed off to the next stage of the query in an arbitrary order.</span></span> <span data-ttu-id="c0574-116">또한 파티션 처리는 나머지 요소를 계속 하기 전에 결과의 하위 집합을 얻을 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c0574-116">Also, a partition may yield a subset of its results before it continues to process the remaining elements.</span></span> <span data-ttu-id="c0574-117">결과 순서 될 때마다 다 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c0574-117">The resulting order may be different every time.</span></span> <span data-ttu-id="c0574-118">응용 프로그램 운영 체제 스레드를 예약 하는 방법에 따라 달라 지므로이 제어할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="c0574-118">Your application cannot control this because it depends on how the operating system schedules the threads.</span></span>  
  
 <span data-ttu-id="c0574-119">다음 예제를 사용 하 여 기본 동작 재정의 <xref:System.Linq.ParallelEnumerable.AsOrdered%2A> 소스 시퀀스에는 연산자입니다.</span><span class="sxs-lookup"><span data-stu-id="c0574-119">The following example overrides the default behavior by using the <xref:System.Linq.ParallelEnumerable.AsOrdered%2A> operator on the source sequence.</span></span> <span data-ttu-id="c0574-120">이렇게 하면 <xref:System.Linq.ParallelEnumerable.Take%2A> 메서드가 소스 시퀀스에서 조건을 충족하는 처음 1000개의 도시를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="c0574-120">This ensures that the <xref:System.Linq.ParallelEnumerable.Take%2A> method returns the first 1000 cities in the source sequence that meet the condition.</span></span>  
  
 [!code-csharp[PLINQ#9](../../../samples/snippets/csharp/VS_Snippets_Misc/plinq/cs/plinqsamples.cs#9)]
 [!code-vb[PLINQ#9](../../../samples/snippets/visualbasic/VS_Snippets_Misc/plinq/vb/plinq2_vb.vb#9)]  
  
 <span data-ttu-id="c0574-121">그러나이 쿼리 아마도 실행 되지 않습니다 순서가 지정 되지 않은 버전으로 빠른 전체 파티션에서 원래 순서 지정 한 추적 하 고 병합 시 순서 지정이 일치 하는지 확인 해야 하기 때문에.</span><span class="sxs-lookup"><span data-stu-id="c0574-121">However, this query probably does not run as fast as the unordered version because it must keep track of the original ordering throughout the partitions and at merge time ensure that the ordering is consistent.</span></span> <span data-ttu-id="c0574-122">사용 하는 권장 따라서 <xref:System.Linq.ParallelEnumerable.AsOrdered%2A> 필요한 경우에 하 고 필요로 하는 쿼리 부분에 대해서만 합니다.</span><span class="sxs-lookup"><span data-stu-id="c0574-122">Therefore, we recommend that you use <xref:System.Linq.ParallelEnumerable.AsOrdered%2A> only when it is required, and only for those parts of the query that require it.</span></span> <span data-ttu-id="c0574-123">순서 유지는 더 이상 필요를 사용 하 여 <xref:System.Linq.ParallelEnumerable.AsUnordered%2A> 을 해제 합니다.</span><span class="sxs-lookup"><span data-stu-id="c0574-123">When order preservation is no longer required, use <xref:System.Linq.ParallelEnumerable.AsUnordered%2A> to turn it off.</span></span> <span data-ttu-id="c0574-124">다음 예제에서는 두 개의 쿼리를 작성 하 여 이것을 달성 합니다.</span><span class="sxs-lookup"><span data-stu-id="c0574-124">The following example achieves this by composing two queries.</span></span>  
  
 [!code-csharp[PLINQ#6](../../../samples/snippets/csharp/VS_Snippets_Misc/plinq/cs/plinqsamples.cs#6)]
 [!code-vb[PLINQ#6](../../../samples/snippets/visualbasic/VS_Snippets_Misc/plinq/vb/plinq2_vb.vb#6)]  
  
 <span data-ttu-id="c0574-125">PLINQ 쿼리의 다른 부분에 대 한 주문 부과 연산자에서 생성 되는 시퀀스의 순서 유지 됨을 참고 합니다.</span><span class="sxs-lookup"><span data-stu-id="c0574-125">Note that PLINQ preserves the ordering of a sequence produced by order-imposing operators for the rest of the query.</span></span> <span data-ttu-id="c0574-126">즉, 같은 연산자 <xref:System.Linq.ParallelEnumerable.OrderBy%2A> 및 <xref:System.Linq.ParallelEnumerable.ThenBy%2A> 를 호출 하 여 호출 된 것 처럼 처리 <xref:System.Linq.ParallelEnumerable.AsOrdered%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="c0574-126">In other words, operators such as <xref:System.Linq.ParallelEnumerable.OrderBy%2A> and <xref:System.Linq.ParallelEnumerable.ThenBy%2A> are treated as if they were followed by a call to <xref:System.Linq.ParallelEnumerable.AsOrdered%2A>.</span></span>  
  
## <a name="query-operators-and-ordering"></a><span data-ttu-id="c0574-127">쿼리 연산자 및 순서 지정</span><span class="sxs-lookup"><span data-stu-id="c0574-127">Query Operators and Ordering</span></span>  
 <span data-ttu-id="c0574-128">다음 쿼리 연산자 소개 순서 유지 될 때까지 또는 쿼리에서 모든 후속 작업으로 <xref:System.Linq.ParallelEnumerable.AsUnordered%2A> 호출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c0574-128">The following query operators introduce order preservation into all subsequent operations in a query, or until <xref:System.Linq.ParallelEnumerable.AsUnordered%2A> is called:</span></span>  
  
-   <xref:System.Linq.ParallelEnumerable.OrderBy%2A>  
  
-   <xref:System.Linq.ParallelEnumerable.OrderByDescending%2A>  
  
-   <xref:System.Linq.ParallelEnumerable.ThenBy%2A>  
  
-   <xref:System.Linq.ParallelEnumerable.ThenByDescending%2A>  
  
 <span data-ttu-id="c0574-129">다음 PLINQ 쿼리 연산자 경우에 따라 해야 올바른 결과 생성 하기 위해 정렬 된 소스 시퀀스:</span><span class="sxs-lookup"><span data-stu-id="c0574-129">The following PLINQ query operators may in some cases require ordered source sequences to produce correct results:</span></span>  
  
-   <xref:System.Linq.ParallelEnumerable.Reverse%2A>  
  
-   <xref:System.Linq.ParallelEnumerable.SequenceEqual%2A>  
  
-   <xref:System.Linq.ParallelEnumerable.TakeWhile%2A>  
  
-   <xref:System.Linq.ParallelEnumerable.SkipWhile%2A>  
  
-   <xref:System.Linq.ParallelEnumerable.Zip%2A>  
  
 <span data-ttu-id="c0574-130">일부 PLINQ 쿼리 연산자는 소스 시퀀스의 정렬 또는 순서가 지정 되지 않은 여부에 따라 다르게 동작 합니다.</span><span class="sxs-lookup"><span data-stu-id="c0574-130">Some PLINQ query operators behave differently, depending on whether their source sequence is ordered or unordered.</span></span> <span data-ttu-id="c0574-131">다음 표에서 이러한 연산자를 나열합니다.</span><span class="sxs-lookup"><span data-stu-id="c0574-131">The following table lists these operators.</span></span>  
  
|<span data-ttu-id="c0574-132">연산자</span><span class="sxs-lookup"><span data-stu-id="c0574-132">Operator</span></span>|<span data-ttu-id="c0574-133">소스 시퀀스 정렬 되는 경우의 결과</span><span class="sxs-lookup"><span data-stu-id="c0574-133">Result when the source sequence is ordered</span></span>|<span data-ttu-id="c0574-134">소스 시퀀스 정렬 되지 않은 경우의 결과</span><span class="sxs-lookup"><span data-stu-id="c0574-134">Result when the source sequence is unordered</span></span>|  
|--------------|------------------------------------------------|--------------------------------------------------|  
|<xref:System.Linq.ParallelEnumerable.Aggregate%2A>|<span data-ttu-id="c0574-135">결합성 없음 또는 비가 작업에 대 한 비결 정적 출력</span><span class="sxs-lookup"><span data-stu-id="c0574-135">Nondeterministic output for nonassociative or noncommutative operations</span></span>|<span data-ttu-id="c0574-136">결합성 없음 또는 비가 작업에 대 한 비결 정적 출력</span><span class="sxs-lookup"><span data-stu-id="c0574-136">Nondeterministic output for nonassociative or noncommutative operations</span></span>|  
|<xref:System.Linq.ParallelEnumerable.All%2A>|<span data-ttu-id="c0574-137">적용할 수 없음</span><span class="sxs-lookup"><span data-stu-id="c0574-137">Not applicable</span></span>|<span data-ttu-id="c0574-138">적용할 수 없음</span><span class="sxs-lookup"><span data-stu-id="c0574-138">Not applicable</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Any%2A>|<span data-ttu-id="c0574-139">적용할 수 없음</span><span class="sxs-lookup"><span data-stu-id="c0574-139">Not applicable</span></span>|<span data-ttu-id="c0574-140">적용할 수 없음</span><span class="sxs-lookup"><span data-stu-id="c0574-140">Not applicable</span></span>|  
|<xref:System.Linq.ParallelEnumerable.AsEnumerable%2A>|<span data-ttu-id="c0574-141">적용할 수 없음</span><span class="sxs-lookup"><span data-stu-id="c0574-141">Not applicable</span></span>|<span data-ttu-id="c0574-142">적용할 수 없음</span><span class="sxs-lookup"><span data-stu-id="c0574-142">Not applicable</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Average%2A>|<span data-ttu-id="c0574-143">결합성 없음 또는 비가 작업에 대 한 비결 정적 출력</span><span class="sxs-lookup"><span data-stu-id="c0574-143">Nondeterministic output for nonassociative or noncommutative operations</span></span>|<span data-ttu-id="c0574-144">결합성 없음 또는 비가 작업에 대 한 비결 정적 출력</span><span class="sxs-lookup"><span data-stu-id="c0574-144">Nondeterministic output for nonassociative or noncommutative operations</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Cast%2A>|<span data-ttu-id="c0574-145">정렬 된 결과</span><span class="sxs-lookup"><span data-stu-id="c0574-145">Ordered results</span></span>|<span data-ttu-id="c0574-146">순서가 지정 되지 않은 결과</span><span class="sxs-lookup"><span data-stu-id="c0574-146">Unordered results</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Concat%2A>|<span data-ttu-id="c0574-147">정렬 된 결과</span><span class="sxs-lookup"><span data-stu-id="c0574-147">Ordered results</span></span>|<span data-ttu-id="c0574-148">순서가 지정 되지 않은 결과</span><span class="sxs-lookup"><span data-stu-id="c0574-148">Unordered results</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Count%2A>|<span data-ttu-id="c0574-149">적용할 수 없음</span><span class="sxs-lookup"><span data-stu-id="c0574-149">Not applicable</span></span>|<span data-ttu-id="c0574-150">적용할 수 없음</span><span class="sxs-lookup"><span data-stu-id="c0574-150">Not applicable</span></span>|  
|<xref:System.Linq.ParallelEnumerable.DefaultIfEmpty%2A>|<span data-ttu-id="c0574-151">적용할 수 없음</span><span class="sxs-lookup"><span data-stu-id="c0574-151">Not applicable</span></span>|<span data-ttu-id="c0574-152">적용할 수 없음</span><span class="sxs-lookup"><span data-stu-id="c0574-152">Not applicable</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Distinct%2A>|<span data-ttu-id="c0574-153">정렬 된 결과</span><span class="sxs-lookup"><span data-stu-id="c0574-153">Ordered results</span></span>|<span data-ttu-id="c0574-154">순서가 지정 되지 않은 결과</span><span class="sxs-lookup"><span data-stu-id="c0574-154">Unordered results</span></span>|  
|<xref:System.Linq.ParallelEnumerable.ElementAt%2A>|<span data-ttu-id="c0574-155">지정 된 요소를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="c0574-155">Return specified element</span></span>|<span data-ttu-id="c0574-156">임의 요소</span><span class="sxs-lookup"><span data-stu-id="c0574-156">Arbitrary element</span></span>|  
|<xref:System.Linq.ParallelEnumerable.ElementAtOrDefault%2A>|<span data-ttu-id="c0574-157">지정 된 요소를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="c0574-157">Return specified element</span></span>|<span data-ttu-id="c0574-158">임의 요소</span><span class="sxs-lookup"><span data-stu-id="c0574-158">Arbitrary element</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Except%2A>|<span data-ttu-id="c0574-159">순서가 지정 되지 않은 결과</span><span class="sxs-lookup"><span data-stu-id="c0574-159">Unordered results</span></span>|<span data-ttu-id="c0574-160">순서가 지정 되지 않은 결과</span><span class="sxs-lookup"><span data-stu-id="c0574-160">Unordered results</span></span>|  
|<xref:System.Linq.ParallelEnumerable.First%2A>|<span data-ttu-id="c0574-161">지정 된 요소를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="c0574-161">Return specified element</span></span>|<span data-ttu-id="c0574-162">임의 요소</span><span class="sxs-lookup"><span data-stu-id="c0574-162">Arbitrary element</span></span>|  
|<xref:System.Linq.ParallelEnumerable.FirstOrDefault%2A>|<span data-ttu-id="c0574-163">지정 된 요소를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="c0574-163">Return specified element</span></span>|<span data-ttu-id="c0574-164">임의 요소</span><span class="sxs-lookup"><span data-stu-id="c0574-164">Arbitrary element</span></span>|  
|<xref:System.Linq.ParallelEnumerable.ForAll%2A>|<span data-ttu-id="c0574-165">병렬에서 불명확 하 게 실행</span><span class="sxs-lookup"><span data-stu-id="c0574-165">Executes nondeterministically in parallel</span></span>|<span data-ttu-id="c0574-166">병렬에서 불명확 하 게 실행</span><span class="sxs-lookup"><span data-stu-id="c0574-166">Executes nondeterministically in parallel</span></span>|  
|<xref:System.Linq.ParallelEnumerable.GroupBy%2A>|<span data-ttu-id="c0574-167">정렬 된 결과</span><span class="sxs-lookup"><span data-stu-id="c0574-167">Ordered results</span></span>|<span data-ttu-id="c0574-168">순서가 지정 되지 않은 결과</span><span class="sxs-lookup"><span data-stu-id="c0574-168">Unordered results</span></span>|  
|<xref:System.Linq.ParallelEnumerable.GroupJoin%2A>|<span data-ttu-id="c0574-169">정렬 된 결과</span><span class="sxs-lookup"><span data-stu-id="c0574-169">Ordered results</span></span>|<span data-ttu-id="c0574-170">순서가 지정 되지 않은 결과</span><span class="sxs-lookup"><span data-stu-id="c0574-170">Unordered results</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Intersect%2A>|<span data-ttu-id="c0574-171">정렬 된 결과</span><span class="sxs-lookup"><span data-stu-id="c0574-171">Ordered results</span></span>|<span data-ttu-id="c0574-172">순서가 지정 되지 않은 결과</span><span class="sxs-lookup"><span data-stu-id="c0574-172">Unordered results</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Join%2A>|<span data-ttu-id="c0574-173">정렬 된 결과</span><span class="sxs-lookup"><span data-stu-id="c0574-173">Ordered results</span></span>|<span data-ttu-id="c0574-174">순서가 지정 되지 않은 결과</span><span class="sxs-lookup"><span data-stu-id="c0574-174">Unordered results</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Last%2A>|<span data-ttu-id="c0574-175">지정 된 요소를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="c0574-175">Return specified element</span></span>|<span data-ttu-id="c0574-176">임의 요소</span><span class="sxs-lookup"><span data-stu-id="c0574-176">Arbitrary element</span></span>|  
|<xref:System.Linq.ParallelEnumerable.LastOrDefault%2A>|<span data-ttu-id="c0574-177">지정 된 요소를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="c0574-177">Return specified element</span></span>|<span data-ttu-id="c0574-178">임의 요소</span><span class="sxs-lookup"><span data-stu-id="c0574-178">Arbitrary element</span></span>|  
|<xref:System.Linq.ParallelEnumerable.LongCount%2A>|<span data-ttu-id="c0574-179">적용할 수 없음</span><span class="sxs-lookup"><span data-stu-id="c0574-179">Not applicable</span></span>|<span data-ttu-id="c0574-180">적용할 수 없음</span><span class="sxs-lookup"><span data-stu-id="c0574-180">Not applicable</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Min%2A>|<span data-ttu-id="c0574-181">적용할 수 없음</span><span class="sxs-lookup"><span data-stu-id="c0574-181">Not applicable</span></span>|<span data-ttu-id="c0574-182">적용할 수 없음</span><span class="sxs-lookup"><span data-stu-id="c0574-182">Not applicable</span></span>|  
|<xref:System.Linq.ParallelEnumerable.OrderBy%2A>|<span data-ttu-id="c0574-183">시퀀스 순서를 재정렬 합니다.</span><span class="sxs-lookup"><span data-stu-id="c0574-183">Reorders the sequence</span></span>|<span data-ttu-id="c0574-184">새 섹션 정렬 시작</span><span class="sxs-lookup"><span data-stu-id="c0574-184">Starts new ordered section</span></span>|  
|<xref:System.Linq.ParallelEnumerable.OrderByDescending%2A>|<span data-ttu-id="c0574-185">시퀀스 순서를 재정렬 합니다.</span><span class="sxs-lookup"><span data-stu-id="c0574-185">Reorders the sequence</span></span>|<span data-ttu-id="c0574-186">새 섹션 정렬 시작</span><span class="sxs-lookup"><span data-stu-id="c0574-186">Starts new ordered section</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Range%2A>|<span data-ttu-id="c0574-187">해당 사항 없음 (과 동일한 기본값 <xref:System.Linq.ParallelEnumerable.AsParallel%2A> )</span><span class="sxs-lookup"><span data-stu-id="c0574-187">Not applicable (same default as <xref:System.Linq.ParallelEnumerable.AsParallel%2A> )</span></span>|<span data-ttu-id="c0574-188">적용할 수 없음</span><span class="sxs-lookup"><span data-stu-id="c0574-188">Not applicable</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Repeat%2A>|<span data-ttu-id="c0574-189">해당 사항 없음 (과 동일한 기본값 <xref:System.Linq.ParallelEnumerable.AsParallel%2A>)</span><span class="sxs-lookup"><span data-stu-id="c0574-189">Not applicable (same default as <xref:System.Linq.ParallelEnumerable.AsParallel%2A>)</span></span>|<span data-ttu-id="c0574-190">적용할 수 없음</span><span class="sxs-lookup"><span data-stu-id="c0574-190">Not applicable</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Reverse%2A>|<span data-ttu-id="c0574-191">역순으로</span><span class="sxs-lookup"><span data-stu-id="c0574-191">Reverses</span></span>|<span data-ttu-id="c0574-192">아무 작업도 수행하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c0574-192">Does nothing</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Select%2A>|<span data-ttu-id="c0574-193">정렬 된 결과</span><span class="sxs-lookup"><span data-stu-id="c0574-193">Ordered results</span></span>|<span data-ttu-id="c0574-194">순서가 지정 되지 않은 결과</span><span class="sxs-lookup"><span data-stu-id="c0574-194">Unordered results</span></span>|  
|<span data-ttu-id="c0574-195"><xref:System.Linq.ParallelEnumerable.Select%2A>(인덱스)</span><span class="sxs-lookup"><span data-stu-id="c0574-195"><xref:System.Linq.ParallelEnumerable.Select%2A> (indexed)</span></span>|<span data-ttu-id="c0574-196">정렬 된 결과</span><span class="sxs-lookup"><span data-stu-id="c0574-196">Ordered results</span></span>|<span data-ttu-id="c0574-197">순서가 지정 되지 않은 결과입니다.</span><span class="sxs-lookup"><span data-stu-id="c0574-197">Unordered results.</span></span>|  
|<xref:System.Linq.ParallelEnumerable.SelectMany%2A>|<span data-ttu-id="c0574-198">정렬 된 결과입니다.</span><span class="sxs-lookup"><span data-stu-id="c0574-198">Ordered results.</span></span>|<span data-ttu-id="c0574-199">순서가 지정 되지 않은 결과</span><span class="sxs-lookup"><span data-stu-id="c0574-199">Unordered results</span></span>|  
|<span data-ttu-id="c0574-200"><xref:System.Linq.ParallelEnumerable.SelectMany%2A>(인덱스)</span><span class="sxs-lookup"><span data-stu-id="c0574-200"><xref:System.Linq.ParallelEnumerable.SelectMany%2A> (indexed)</span></span>|<span data-ttu-id="c0574-201">정렬 된 결과입니다.</span><span class="sxs-lookup"><span data-stu-id="c0574-201">Ordered results.</span></span>|<span data-ttu-id="c0574-202">순서가 지정 되지 않은 결과입니다.</span><span class="sxs-lookup"><span data-stu-id="c0574-202">Unordered results.</span></span>|  
|<xref:System.Linq.ParallelEnumerable.SequenceEqual%2A>|<span data-ttu-id="c0574-203">순서가 지정 된 비교</span><span class="sxs-lookup"><span data-stu-id="c0574-203">Ordered comparison</span></span>|<span data-ttu-id="c0574-204">순서가 지정 되지 않은 비교</span><span class="sxs-lookup"><span data-stu-id="c0574-204">Unordered comparison</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Single%2A>|<span data-ttu-id="c0574-205">적용할 수 없음</span><span class="sxs-lookup"><span data-stu-id="c0574-205">Not applicable</span></span>|<span data-ttu-id="c0574-206">적용할 수 없음</span><span class="sxs-lookup"><span data-stu-id="c0574-206">Not applicable</span></span>|  
|<xref:System.Linq.ParallelEnumerable.SingleOrDefault%2A>|<span data-ttu-id="c0574-207">적용할 수 없음</span><span class="sxs-lookup"><span data-stu-id="c0574-207">Not applicable</span></span>|<span data-ttu-id="c0574-208">적용할 수 없음</span><span class="sxs-lookup"><span data-stu-id="c0574-208">Not applicable</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Skip%2A>|<span data-ttu-id="c0574-209">먼저 건너뜁니다  *n*  요소</span><span class="sxs-lookup"><span data-stu-id="c0574-209">Skips first *n* elements</span></span>|<span data-ttu-id="c0574-210">모든 건너뜁니다  *n*  요소</span><span class="sxs-lookup"><span data-stu-id="c0574-210">Skips any *n* elements</span></span>|  
|<xref:System.Linq.ParallelEnumerable.SkipWhile%2A>|<span data-ttu-id="c0574-211">정렬 된 결과입니다.</span><span class="sxs-lookup"><span data-stu-id="c0574-211">Ordered results.</span></span>|<span data-ttu-id="c0574-212">비결 정적입니다.</span><span class="sxs-lookup"><span data-stu-id="c0574-212">Nondeterministic.</span></span> <span data-ttu-id="c0574-213">SkipWhile 현재 임의 순서에 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="c0574-213">Performs SkipWhile on the current arbitrary order</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Sum%2A>|<span data-ttu-id="c0574-214">결합성 없음 또는 비가 작업에 대 한 비결 정적 출력</span><span class="sxs-lookup"><span data-stu-id="c0574-214">Nondeterministic output for nonassociative or noncommutative operations</span></span>|<span data-ttu-id="c0574-215">결합성 없음 또는 비가 작업에 대 한 비결 정적 출력</span><span class="sxs-lookup"><span data-stu-id="c0574-215">Nondeterministic output for nonassociative or noncommutative operations</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Take%2A>|<span data-ttu-id="c0574-216">첫 번째는 `n` 요소</span><span class="sxs-lookup"><span data-stu-id="c0574-216">Takes first `n` elements</span></span>|<span data-ttu-id="c0574-217">사용 `n` 요소</span><span class="sxs-lookup"><span data-stu-id="c0574-217">Takes any `n` elements</span></span>|  
|<xref:System.Linq.ParallelEnumerable.TakeWhile%2A>|<span data-ttu-id="c0574-218">정렬 된 결과</span><span class="sxs-lookup"><span data-stu-id="c0574-218">Ordered results</span></span>|<span data-ttu-id="c0574-219">비결 정적입니다.</span><span class="sxs-lookup"><span data-stu-id="c0574-219">Nondeterministic.</span></span> <span data-ttu-id="c0574-220">TakeWhile 현재 임의 순서에 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="c0574-220">Performs TakeWhile on the current arbitrary order</span></span>|  
|<xref:System.Linq.ParallelEnumerable.ThenBy%2A>|<span data-ttu-id="c0574-221">조항`OrderBy`</span><span class="sxs-lookup"><span data-stu-id="c0574-221">Supplements `OrderBy`</span></span>|<span data-ttu-id="c0574-222">조항`OrderBy`</span><span class="sxs-lookup"><span data-stu-id="c0574-222">Supplements `OrderBy`</span></span>|  
|<xref:System.Linq.ParallelEnumerable.ThenByDescending%2A>|<span data-ttu-id="c0574-223">조항`OrderBy`</span><span class="sxs-lookup"><span data-stu-id="c0574-223">Supplements `OrderBy`</span></span>|<span data-ttu-id="c0574-224">조항`OrderBy`</span><span class="sxs-lookup"><span data-stu-id="c0574-224">Supplements `OrderBy`</span></span>|  
|<xref:System.Linq.ParallelEnumerable.ToArray%2A>|<span data-ttu-id="c0574-225">정렬 된 결과</span><span class="sxs-lookup"><span data-stu-id="c0574-225">Ordered results</span></span>|<span data-ttu-id="c0574-226">순서가 지정 되지 않은 결과</span><span class="sxs-lookup"><span data-stu-id="c0574-226">Unordered results</span></span>|  
|<xref:System.Linq.ParallelEnumerable.ToDictionary%2A>|<span data-ttu-id="c0574-227">적용할 수 없음</span><span class="sxs-lookup"><span data-stu-id="c0574-227">Not applicable</span></span>|<span data-ttu-id="c0574-228">적용할 수 없음</span><span class="sxs-lookup"><span data-stu-id="c0574-228">Not applicable</span></span>|  
|<xref:System.Linq.ParallelEnumerable.ToList%2A>|<span data-ttu-id="c0574-229">정렬 된 결과</span><span class="sxs-lookup"><span data-stu-id="c0574-229">Ordered results</span></span>|<span data-ttu-id="c0574-230">순서가 지정 되지 않은 결과</span><span class="sxs-lookup"><span data-stu-id="c0574-230">Unordered results</span></span>|  
|<xref:System.Linq.ParallelEnumerable.ToLookup%2A>|<span data-ttu-id="c0574-231">정렬 된 결과</span><span class="sxs-lookup"><span data-stu-id="c0574-231">Ordered results</span></span>|<span data-ttu-id="c0574-232">순서가 지정 되지 않은 결과</span><span class="sxs-lookup"><span data-stu-id="c0574-232">Unordered results</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Union%2A>|<span data-ttu-id="c0574-233">정렬 된 결과</span><span class="sxs-lookup"><span data-stu-id="c0574-233">Ordered results</span></span>|<span data-ttu-id="c0574-234">순서가 지정 되지 않은 결과</span><span class="sxs-lookup"><span data-stu-id="c0574-234">Unordered results</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Where%2A>|<span data-ttu-id="c0574-235">정렬 된 결과</span><span class="sxs-lookup"><span data-stu-id="c0574-235">Ordered results</span></span>|<span data-ttu-id="c0574-236">순서가 지정 되지 않은 결과</span><span class="sxs-lookup"><span data-stu-id="c0574-236">Unordered results</span></span>|  
|<span data-ttu-id="c0574-237"><xref:System.Linq.ParallelEnumerable.Where%2A>(인덱스)</span><span class="sxs-lookup"><span data-stu-id="c0574-237"><xref:System.Linq.ParallelEnumerable.Where%2A> (indexed)</span></span>|<span data-ttu-id="c0574-238">정렬 된 결과</span><span class="sxs-lookup"><span data-stu-id="c0574-238">Ordered results</span></span>|<span data-ttu-id="c0574-239">순서가 지정 되지 않은 결과</span><span class="sxs-lookup"><span data-stu-id="c0574-239">Unordered results</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Zip%2A>|<span data-ttu-id="c0574-240">정렬 된 결과</span><span class="sxs-lookup"><span data-stu-id="c0574-240">Ordered results</span></span>|<span data-ttu-id="c0574-241">순서가 지정 되지 않은 결과</span><span class="sxs-lookup"><span data-stu-id="c0574-241">Unordered results</span></span>|  
  
 <span data-ttu-id="c0574-242">순서가 지정 되지 않은 결과 적극적으로 섞 습니다 되지 않습니다. 단순히 없는에 적용 된 특별 한 정렬 논리입니다.</span><span class="sxs-lookup"><span data-stu-id="c0574-242">Unordered results are not actively shuffled; they simply do not have any special ordering logic applied to them.</span></span> <span data-ttu-id="c0574-243">경우에 따라 순서가 지정 되지 않은 쿼리는 소스 시퀀스의 순서을 유지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c0574-243">In some cases, an unordered query may retain the ordering of the source sequence.</span></span> <span data-ttu-id="c0574-244">인덱스는 Select 연산자를 사용 하는 쿼리에 대 한 출력 요소 증가 시켜 인덱스, 하지만 어떤 인덱스에 대 한 보장은 없습니다 요소에 할당 될 순서 대로 상황이 개선 됩니다는 PLINQ 보장 합니다.</span><span class="sxs-lookup"><span data-stu-id="c0574-244">For queries that use the indexed Select operator, PLINQ guarantees that the output elements will come out in the order of increasing indices, but makes no guarantees about which indices will be assigned to which elements.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="c0574-245">참고 항목</span><span class="sxs-lookup"><span data-stu-id="c0574-245">See Also</span></span>  
 [<span data-ttu-id="c0574-246">PLINQ(병렬 LINQ)</span><span class="sxs-lookup"><span data-stu-id="c0574-246">Parallel LINQ (PLINQ)</span></span>](../../../docs/standard/parallel-programming/parallel-linq-plinq.md)  
 [<span data-ttu-id="c0574-247">병렬 프로그래밍</span><span class="sxs-lookup"><span data-stu-id="c0574-247">Parallel Programming</span></span>](../../../docs/standard/parallel-programming/index.md)

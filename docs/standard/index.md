---
title: ".NET 정보"
description: ".NET 플랫폼에 대해 알아봅니다."
keywords: .NET, .NET Core
author: richlander
ms.author: ronpet
ms.date: 10/31/2016
ms.topic: article
ms.prod: .net
ms.technology: dotnet-standard
ms.devlang: dotnet
ms.assetid: bbfe6465-329d-4982-869d-472e7ef85d93
ms.translationtype: Human Translation
ms.sourcegitcommit: 7bbd8f5d94127b35697ad267b2661da2c757aa20
ms.openlocfilehash: 0fbe1dda72ad666304f5c817f4bfd477c3e81d83
ms.contentlocale: ko-kr
ms.lasthandoff: 05/02/2017

---

# <a name="net-platform-guide"></a><span data-ttu-id="13bf5-104">.NET 플랫폼 가이드</span><span class="sxs-lookup"><span data-stu-id="13bf5-104">.NET Platform Guide</span></span>

> [!NOTE]
> <span data-ttu-id="13bf5-105">간단한 .NET Core 응용 프로그램을 만드는 방법을 알아보려면 [".NET Core 시작" 자습서](../core/getting-started.md)를 확인해 보세요.</span><span class="sxs-lookup"><span data-stu-id="13bf5-105">Check out the ["Getting Started with .NET Core" tutorials](../core/getting-started.md) to learn how to create a simple .NET Core application.</span></span> <span data-ttu-id="13bf5-106">첫 번째 앱을 만들고 실행하는 데 몇 분밖에 걸리지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="13bf5-106">It only takes a few minutes to get your first app up and running.</span></span>

<span data-ttu-id="13bf5-107">.NET은 범용 개발 플랫폼입니다.</span><span class="sxs-lookup"><span data-stu-id="13bf5-107">.NET is a general purpose development platform.</span></span> <span data-ttu-id="13bf5-108">범용 솔루션이 사용되는 모든 종류의 앱 유형이나 작업에 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13bf5-108">It can be used for any kind of app type or workload where general purpose solutions are used.</span></span> <span data-ttu-id="13bf5-109">자동 메모리 관리, 최신 프로그래밍 언어 등 고품질 응용 프로그램을 효율적으로 쉽게 빌드할 수 있게 해주며 대부분의 개발자에게 유용한 몇 가지 주요 기능이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13bf5-109">It has several key features that are attractive to many developers, including automatic memory management and modern programming languages, that make it easier to efficiently build high-quality applications.</span></span> <span data-ttu-id="13bf5-110">.NET은 기본 메모리 및 API에 대한 하위 수준 액세스를 제공하는 동시에 다양한 편의 기능이 있는 상위 수준의 프로그래밍 환경을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="13bf5-110">.NET enables a high-level programming environment with many convenience features, while providing low-level access to native memory and APIs.</span></span>

<span data-ttu-id="13bf5-111">C#, F# 및 Visual Basic은 .NET 플랫폼을 대상으로 하고 사용하는 인기 있는 언어입니다.</span><span class="sxs-lookup"><span data-stu-id="13bf5-111">C#, F# and Visual Basic are popular languages that target and rely on the .NET platform.</span></span> <span data-ttu-id="13bf5-112">.NET 언어는 비동기 프로그래밍 모델, Language-Integrated Query, 제네릭 형식, 형식 시스템 리플렉션 등의 주요 기능으로 알려져 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13bf5-112">The .NET languages are known for key features such as their asynchronous programming model, language-integrated query, generic types and type system reflection.</span></span> <span data-ttu-id="13bf5-113">이 언어는 개체 지향 및 기능 프로그래밍 패러다임에 대한 유용한 옵션도 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="13bf5-113">The languages also provide great options for both object-oriented and functional programming paradigms.</span></span>

<span data-ttu-id="13bf5-114">이러한 언어의 철학과 구문은 다양하지만 공유 형식 시스템에서 제공하는 대칭성도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13bf5-114">There is great diversity across these languages, in philosophy and syntax, but also symmetry provided by a shared type system.</span></span> <span data-ttu-id="13bf5-115">이 형식 시스템은 기본 런타임 환경에서 제공됩니다.</span><span class="sxs-lookup"><span data-stu-id="13bf5-115">This type system is provided by the underlying runtime environment.</span></span> <span data-ttu-id="13bf5-116">.NET은 다양한 언어(예: 동적 및 정적으로 형식화된 언어)의 요구 사항을 지원하고 언어 간에 상호 운용될 수 있도록 하는 "공용 언어 런타임"의 개념을 중심으로 설계되었습니다.</span><span class="sxs-lookup"><span data-stu-id="13bf5-116">.NET was designed around the idea of a "common language runtime" that could support the requirements of diverse languages -- for example, dynamic and statically typed languages -- and enable interoperability between them.</span></span> <span data-ttu-id="13bf5-117">예를 들어 의미 체계 또는 기능의 손실 없이 언어 간에 `People` 개체 컬렉션을 전달할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13bf5-117">For example, it's possible to pass a collection of `People` objects between languages with no loss in semantics or capability.</span></span>

<span data-ttu-id="13bf5-118">플랫폼의 기본 사항을 지정하는 개방형 [.NET 표준](https://github.com/dotnet/coreclr/blob/master/Documentation/project-docs/dotnet-standards.md)에 따라 여러 [.NET 구현 및 제품](components.md)을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13bf5-118">Multiple [.NET implementations and products](components.md) are available, based on open [.NET Standards](https://github.com/dotnet/coreclr/blob/master/Documentation/project-docs/dotnet-standards.md) that specify the fundamentals of the platform.</span></span> <span data-ttu-id="13bf5-119">응용 프로그램 종류(예: 데스크톱, 모바일, 게임, 클라우드)에 따라 개별적으로 최적화되며 많은 칩(예: x86/x64, ARM)과 운영 체제(예: Windows, Linux, iOS, Android, macOS)를 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="13bf5-119">They are separately optimized for different application types (for example, desktop, mobile, gaming, cloud) and support many chips (for example, x86/x64, ARM) and operating systems (for example, Windows, Linux, iOS, Android, macOS).</span></span> <span data-ttu-id="13bf5-120">오픈 소스도 환경의 OSI 승인 라이선스로 여러 .NET 구현과 많은 라이브러리를 사용할 수 있는 .NET 에코시스템의 중요한 부분입니다.</span><span class="sxs-lookup"><span data-stu-id="13bf5-120">Open source is also an important part of the .NET ecosystem, with multiple .NET implementations and many libraries available under OSI-approved licenses.</span></span>

- <span data-ttu-id="13bf5-121">[C#](../csharp/index.md)에 대한 자세한 정보</span><span class="sxs-lookup"><span data-stu-id="13bf5-121">Learn about [C#](../csharp/index.md)</span></span>
- <span data-ttu-id="13bf5-122">[F#](../fsharp/index.md)에 대한 자세한 정보</span><span class="sxs-lookup"><span data-stu-id="13bf5-122">Learn about [F#](../fsharp/index.md)</span></span>
- <span data-ttu-id="13bf5-123">[.NET API 라이브러리](../../api/index.md) 찾아보기</span><span class="sxs-lookup"><span data-stu-id="13bf5-123">Browse the [.NET API Library](../../api/index.md)</span></span>
- [<span data-ttu-id="13bf5-124">공용 언어 런타임 소개</span><span class="sxs-lookup"><span data-stu-id="13bf5-124">Introduction to the Common Language Runtime</span></span>](https://github.com/dotnet/coreclr/blob/master/Documentation/botr/intro-to-clr.md)

<a name="fundamentals"></a><span data-ttu-id="13bf5-125">기본 사항</span><span class="sxs-lookup"><span data-stu-id="13bf5-125">Fundamentals</span></span>
------------

<span data-ttu-id="13bf5-126">**다중 언어** - .NET은 여러 언어에서 자체적으로 실행하거나 동일한 .NET 구성 요소를 공유 통화로 사용하는 다른 언어와 상호 운용하기 위해 사용할 수 있는 잘 정의된 형식 시스템, 파일 형식, 런타임, 프레임워크 및 도구를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="13bf5-126">**Multi-Language** -- .NET provides a well-defined type system, file formats, runtime, framework and tools that can be used by multiple languages, both for their own execution and also to interoperate with other languages using those same components of .NET as their shared currency.</span></span>

<span data-ttu-id="13bf5-127">**관리되는 메모리** - .NET은 가비지 수집기를 통해 메모리를 자동으로 관리합니다.</span><span class="sxs-lookup"><span data-stu-id="13bf5-127">**Managed Memory** -- .NET automatically manages memory for you via a garbage collector.</span></span> <span data-ttu-id="13bf5-128">항상 라이브 개체를 참조하여 버퍼 오버런, 액세스 위반 등의 까다로운 문제를 방지하도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="13bf5-128">It ensures that you always reference live objects, guaranteeing that you avoid nasty problems like buffer overruns and access violations.</span></span> <span data-ttu-id="13bf5-129">여기에는 배열 범위 검사가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="13bf5-129">This includes array bounds checking.</span></span>

<span data-ttu-id="13bf5-130">**형식 안전성** - 기능 및 메모리 표현의 기본 .NET 모델은 "형식"입니다.</span><span class="sxs-lookup"><span data-stu-id="13bf5-130">**Type Safety** -- The primary .NET model for functionality and memory representation is "types".</span></span> <span data-ttu-id="13bf5-131">형식은 모양과 필요에 따라 동작을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="13bf5-131">Types define shape and optionally behavior.</span></span> <span data-ttu-id="13bf5-132">런타임에서는 해당 정의 및 지정된 멤버의 표시 여부에 따라 형식에 호출 코드가 적용되도록 하여 일관성 있고 신뢰할 수 있는 안전한 결과를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="13bf5-132">The runtime ensures that calling code can only operate on types according to their definition and specified visibility of members, providing consistent, reliable and secure results.</span></span>

<a name="features"></a><span data-ttu-id="13bf5-133">기능</span><span class="sxs-lookup"><span data-stu-id="13bf5-133">Features</span></span>
--------

<span data-ttu-id="13bf5-134">**사용자 정의 값 형식** - 값 형식은 클래스의 경우처럼 "참조로 전달"하지 않고 "값으로 전달"하는 의미 체계를 제공하므로 유용한 형식 범주입니다.</span><span class="sxs-lookup"><span data-stu-id="13bf5-134">**User-defined Value Types** -- Value types are a useful category of types since they offer the semantic of "pass by value" instead of "pass by reference", as is the case for classes.</span></span> <span data-ttu-id="13bf5-135">값 형식은 숫자 데이터에 특히 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="13bf5-135">Value types are most obviously usefully for numeric data.</span></span> <span data-ttu-id="13bf5-136">.NET에서는 정수 등의 기본 형식과 사용자 정의 형식 둘 다에 값 형식을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13bf5-136">.NET enables value types for both primitive types, like integers, and user-defined types.</span></span>

<span data-ttu-id="13bf5-137">**제네릭 형식** - 제네릭 형식은 인스턴스화별로 지정할 수 있는 하나 이상의 형식 매개 변수가 있는 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="13bf5-137">**Generic types** -- Generic types are types with one or more type parameters that can be specified on a per-instantiation basis.</span></span> <span data-ttu-id="13bf5-138">이 형식은 콘텐츠를 개체 형식으로 표시하거나 여러 형식 정의가 필요한 여러 형식에 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="13bf5-138">This is useful for many types, which otherwise would  expose contents as the Object type or require multiple type definitions.</span></span> <span data-ttu-id="13bf5-139">예를 들어 컬렉션 형식의 지정된 인스턴스화를 사용자, GPS 위치 또는 문자열과 관련된 것으로 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13bf5-139">For example, a given instantiation of a collection type can be made specific to People, GPS locations or strings.</span></span>

<span data-ttu-id="13bf5-140">**리플렉션** - .NET에서는 이진 파일 내의 형식을 설명하는 메타데이터 형식을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="13bf5-140">**Reflection** -- .NET defines a metadata format that describes the types within a binary.</span></span> <span data-ttu-id="13bf5-141">리플렉션 하위 시스템은 이 데이터를 사용하며 런타임에 형식을 읽고 인스턴스화하기 위한 API를 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="13bf5-141">The reflection subsystem uses this data, exposing APIs for both reading and instantiating types at runtime.</span></span> <span data-ttu-id="13bf5-142">이 기능은 프로그램의 정확한 구현을 미리 알기 어려운 동적 시나리오에 매우 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="13bf5-142">This facility is very useful for dynamic scenarios where it is not convenient to know the exact implementation of a program ahead of time.</span></span>

<span data-ttu-id="13bf5-143">**유연한 코드 생성** - .NET에서는 .NET 이진 파일을 기계어 코드로 변환하는 특정 방법을 규정하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="13bf5-143">**Flexible code generation** -- .NET does not prescribe a specific approach to transforming .NET binaries into machine code.</span></span> <span data-ttu-id="13bf5-144">해석, JIT(Just-In-Time) 컴파일, JIT 대체를 사용한 AOT(Ahead-Of-Time) 컴파일, JIT 대체를 사용하지 않는 AOT 컴파일 등 많은 방법이 성공적으로 사용되었습니다.</span><span class="sxs-lookup"><span data-stu-id="13bf5-144">Many approaches have been used successfully, including interpretation, just-in-time (JIT) compilation, ahead-of-time (AOT) compilation with JIT fallback and AOT compilation with no JIT fallback.</span></span> <span data-ttu-id="13bf5-145">이러한 전략은 각각 중요하며 함께 사용할 수 있는 경우도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13bf5-145">Each of these strategies can be valuable and there are opportunities for using them together.</span></span>

<span data-ttu-id="13bf5-146">**플랫폼 간** - .NET은 처음부터 플랫폼 간으로 설계되었습니다.</span><span class="sxs-lookup"><span data-stu-id="13bf5-146">**Cross-platform** -- .NET was intended to be cross platform from its inception.</span></span> <span data-ttu-id="13bf5-147">이진 형식과 명령 집합에 운영 체제, CPU 및 포인터 크기 제약이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="13bf5-147">The binary format and the instruction set are operating system, CPU and pointer-size agnostic.</span></span> <span data-ttu-id="13bf5-148">32비트 Windows 컴퓨터에서 실행되도록 2000에서 빌드된 지정된 .NET 이진 파일을 수정하지 않고 ARM64 iOS 장치의 2016에서 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13bf5-148">A given .NET binary built in 2000 to run on a 32-bit Windows machine can run on the ARM64 iOS device on 2016 without modification.</span></span>

<a name="open-source"></a><span data-ttu-id="13bf5-149">소스 열기</span><span class="sxs-lookup"><span data-stu-id="13bf5-149">Open source</span></span>
-----------

<span data-ttu-id="13bf5-150">.NET의 [.NET Core](https://github.com/dotnet/core) 및 [Mono](https://github.com/mono/mono) 구현은 MIT 라이선스를 사용하는 오픈 소스입니다.</span><span class="sxs-lookup"><span data-stu-id="13bf5-150">The [.NET Core](https://github.com/dotnet/core) and [Mono](https://github.com/mono/mono) implementations of .NET are open source, using the MIT license.</span></span> <span data-ttu-id="13bf5-151">설명서에서는 [Creative Commons CC-BY](https://creativecommons.org/licenses/by/4.0/) 라이선스를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="13bf5-151">Documentation uses the [Creative Commons CC-BY](https://creativecommons.org/licenses/by/4.0/) license.</span></span> <span data-ttu-id="13bf5-152">.NET Core 및 Mono는 Microsoft의 후원과 많은 커뮤니티 참가자의 도움을 받습니다.</span><span class="sxs-lookup"><span data-stu-id="13bf5-152">.NET Core and Mono are sponsored by Microsoft and have many contributors from the community.</span></span> 

<span data-ttu-id="13bf5-153">이러한 범용 런타임을 학술 연구, 교육/학습 또는 상용 제품의 기초로 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13bf5-153">These general purpose runtimes can be used as the basis of academic research or teaching/learning or commercial products.</span></span> <span data-ttu-id="13bf5-154">개방적인 특성 때문에 버그가 있거나 새로운 기능을 원할 경우 누구든지 업스트림 제품 코드에 다시 참가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="13bf5-154">Their open nature also means that anyone can contribute back to the upstream product code given a bug or the desire for a new feature.</span></span>

<a name="projects"></a><span data-ttu-id="13bf5-155">프로젝트</span><span class="sxs-lookup"><span data-stu-id="13bf5-155">Projects</span></span>
--------

- <span data-ttu-id="13bf5-156">[CoreCLR](https://github.com/dotnet/coreclr) - .NET Core에서 사용되는 .NET 런타임입니다.</span><span class="sxs-lookup"><span data-stu-id="13bf5-156">[CoreCLR](https://github.com/dotnet/coreclr) - .NET runtime, used by .NET Core.</span></span>
- <span data-ttu-id="13bf5-157">[Mono](https://github.com/mono/mono) - Xamarin 등에서 사용되는 .NET 런타임입니다.</span><span class="sxs-lookup"><span data-stu-id="13bf5-157">[Mono](https://github.com/mono/mono) - .NET runtime, used by Xamarin and others.</span></span>
- <span data-ttu-id="13bf5-158">[CoreFX](https://github.com/dotnet/coreclr) - .NET Core에서 사용되며 소스 공유를 통해 Mono에서 부분적으로 사용되는 .NET 클래스 라이브러리입니다.</span><span class="sxs-lookup"><span data-stu-id="13bf5-158">[CoreFX](https://github.com/dotnet/coreclr) - .NET class libraries, used by .NET Core and to a degree by Mono via source sharing.</span></span>
- <span data-ttu-id="13bf5-159">[Roslyn](https://github.com/dotnet/roslyn) - 대부분의 .NET 플랫폼과 도구에서 사용되는 C# 및 Visual Basic 컴파일러입니다.</span><span class="sxs-lookup"><span data-stu-id="13bf5-159">[Roslyn](https://github.com/dotnet/roslyn) - C# and Visual Basic compilers, used by most .NET platforms and tools.</span></span> <span data-ttu-id="13bf5-160">소스 코드를 읽고, 쓰고, 분석하기 위한 API를 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="13bf5-160">Exposes APIs for reading, writing and analyzing source code.</span></span>
- <span data-ttu-id="13bf5-161">[F#](https://github.com/microsoft/visualfsharp) - F# 컴파일러입니다.</span><span class="sxs-lookup"><span data-stu-id="13bf5-161">[F#](https://github.com/microsoft/visualfsharp) - F# compiler.</span></span>
- <span data-ttu-id="13bf5-162">[Xamarin SDK](http://open.xamarin.com) - C# 및 F#으로 Android, iOS 및 macOS를 작성하는 데 필요한 도구 및 라이브러리입니다.</span><span class="sxs-lookup"><span data-stu-id="13bf5-162">[Xamarin SDK](http://open.xamarin.com) - Tools and libraries needed to write Android, iOS and macOS in C# and F#.</span></span>

<a name="standardized"></a><span data-ttu-id="13bf5-163">표준화됨</span><span class="sxs-lookup"><span data-stu-id="13bf5-163">Standardized</span></span>
------------

<span data-ttu-id="13bf5-164">.NET은 해당 기능을 간략하게 설명하며 새 구현을 만드는 데 사용할 수 있는 개방형 [ECMA 표준](https://github.com/dotnet/coreclr/blob/master/Documentation/project-docs/dotnet-standards.md)을 통해 지정됩니다.</span><span class="sxs-lookup"><span data-stu-id="13bf5-164">.NET is specified via open [ECMA standards](https://github.com/dotnet/coreclr/blob/master/Documentation/project-docs/dotnet-standards.md) that outline its capabilities and that can be used to make a new implementation.</span></span> <span data-ttu-id="13bf5-165">다른 .NET 구현도 있으며, Mono와 Unity가 Microsoft 구현보다 가장 많이 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="13bf5-165">There are other .NET implementations, with Mono and Unity being the most popular beyond the Microsoft ones.</span></span>



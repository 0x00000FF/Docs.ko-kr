---
title: 정규식의 앵커
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- atomic zero-width assertions
- regular expressions, anchors
- regular expressions, atomic zero-width assertions
- anchors, in regular expressions
- metacharacters, atomic zero-width assertions
- metacharacters, anchors
- .NET Framework regular expressions, anchors
- .NET Framework regular expressions, atomic zero-width assertions
ms.assetid: 336391f6-2614-499b-8b1b-07a6837108a7
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: 24a579acacf41df24779252e1064e1c271310edc
ms.sourcegitcommit: ed7b4b9b77d35e94a35a2634e8c874f46603fb2b
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 06/26/2018
ms.locfileid: "36948591"
---
# <a name="anchors-in-regular-expressions"></a><span data-ttu-id="6cd31-102">정규식의 앵커</span><span class="sxs-lookup"><span data-stu-id="6cd31-102">Anchors in Regular Expressions</span></span>
<a name="top"></a> <span data-ttu-id="6cd31-103">앵커 또는 원자성 너비가 0인 어설션은 문자열에서 일치 항목이 나타나야 하는 위치를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="6cd31-103">Anchors, or atomic zero-width assertions, specify a position in the string where a match must occur.</span></span> <span data-ttu-id="6cd31-104">검색 식에서 앵커를 사용하면 정규식 엔진은 문자열을 통과하거나 문자를 사용하지 않고, 지정된 위치에서만 일치 항목을 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="6cd31-104">When you use an anchor in your search expression, the regular expression engine does not advance through the string or consume characters; it looks for a match in the specified position only.</span></span> <span data-ttu-id="6cd31-105">예를 들어 `^` 기호는 줄이나 문자열의 시작 부분에서 일치 항목 찾기를 시작하도록 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="6cd31-105">For example, `^` specifies that the match must start at the beginning of a line or string.</span></span> <span data-ttu-id="6cd31-106">따라서 정규식 `^http:` 은 줄의 시작 부분에 나타날 때만 "http:"을 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="6cd31-106">Therefore, the regular expression `^http:` matches "http:" only when it occurs at the beginning of a line.</span></span> <span data-ttu-id="6cd31-107">다음 표에서는 .NET의 정규식에서 지원하는 앵커를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="6cd31-107">The following table lists the anchors supported by the regular expressions in .NET.</span></span>  
  
|<span data-ttu-id="6cd31-108">앵커</span><span class="sxs-lookup"><span data-stu-id="6cd31-108">Anchor</span></span>|<span data-ttu-id="6cd31-109">설명</span><span class="sxs-lookup"><span data-stu-id="6cd31-109">Description</span></span>|  
|------------|-----------------|  
|`^`|<span data-ttu-id="6cd31-110">기본적으로 일치 항목은 문자열의 시작 부분에서 발생해야 합니다. 다중 선에서는 줄의 시작 부분에서 발생해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="6cd31-110">By default, the match must occur at the beginning of the string; in multiline mode, it must occur at the beginning of the line.</span></span> <span data-ttu-id="6cd31-111">자세한 내용은 [문자열 또는 줄의 시작](#Start)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="6cd31-111">For more information, see [Start of String or Line](#Start).</span></span>|  
|`$`|<span data-ttu-id="6cd31-112">기본적으로 일치 항목은 문자열의 끝부분 또는 문자열의 끝부분 `\n` 앞에서 발생해야 합니다. 다중 선에서는 줄의 끝부분 또는 줄의 끝 `\n` 앞에서 발생해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="6cd31-112">By default, the match must occur at the end of the string or before `\n` at the end of the string; in multiline mode, it must occur at the end of the line or before `\n` at the end of the line.</span></span> <span data-ttu-id="6cd31-113">자세한 내용은 [문자열 또는 줄의 끝](#End)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="6cd31-113">For more information, see [End of String or Line](#End).</span></span>|  
|`\A`|<span data-ttu-id="6cd31-114">일치 항목이 문자열의 시작 부분에만 있어야 합니다(여러 줄 지원 없음).</span><span class="sxs-lookup"><span data-stu-id="6cd31-114">The match must occur at the beginning of the string only (no multiline support).</span></span> <span data-ttu-id="6cd31-115">자세한 내용은 [문자열의 시작만](#StartOnly)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="6cd31-115">For more information, see [Start of String Only](#StartOnly).</span></span>|  
|`\Z`|<span data-ttu-id="6cd31-116">일치 항목이 문자열의 끝이나 문자열의 끝에 있는 `\n` 앞에 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="6cd31-116">The match must occur at the end of the string, or before `\n` at the end of the string.</span></span> <span data-ttu-id="6cd31-117">자세한 내용은 [문자열의 끝 또는 줄 바꿈 종료 전](#EndOrNOnly)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="6cd31-117">For more information, see [End of String or Before Ending Newline](#EndOrNOnly).</span></span>|  
|`\z`|<span data-ttu-id="6cd31-118">일치 항목이 문자열의 끝 부분에만 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="6cd31-118">The match must occur at the end of the string only.</span></span> <span data-ttu-id="6cd31-119">자세한 내용은 [문자열의 끝만](#EndOnly)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="6cd31-119">For more information, see [End of String Only](#EndOnly).</span></span>|  
|`\G`|<span data-ttu-id="6cd31-120">일치 항목이 이전 일치 항목이 종료된 위치에서 시작해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="6cd31-120">The match must start at the position where the previous match ended.</span></span> <span data-ttu-id="6cd31-121">자세한 내용은 [연속 일치](#Contiguous)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="6cd31-121">For more information, see [Contiguous Matches](#Contiguous).</span></span>|  
|`\b`|<span data-ttu-id="6cd31-122">일치 항목이 단어 경계에 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="6cd31-122">The match must occur on a word boundary.</span></span> <span data-ttu-id="6cd31-123">자세한 내용은 [단어 경계](#WordBoundary)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="6cd31-123">For more information, see [Word Boundary](#WordBoundary).</span></span>|  
|`\B`|<span data-ttu-id="6cd31-124">일치 항목이 단어 경계에 있으면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="6cd31-124">The match must not occur on a word boundary.</span></span> <span data-ttu-id="6cd31-125">자세한 내용은 [비단어 경계](#NonwordBoundary)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="6cd31-125">For more information, see [Non-Word Boundary](#NonwordBoundary).</span></span>|  
  
<a name="Start"></a>   
## <a name="start-of-string-or-line-"></a><span data-ttu-id="6cd31-126">문자열 또는 줄의 시작: ^</span><span class="sxs-lookup"><span data-stu-id="6cd31-126">Start of String or Line: ^</span></span>  
 <span data-ttu-id="6cd31-127">기본적으로 `^` 앵커는 다음 패턴이 문자열의 첫 번째 문자 위치에서 시작하도록 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="6cd31-127">By default, the `^` anchor specifies that the following pattern must begin at the first character position of the string.</span></span> <span data-ttu-id="6cd31-128">`^` 기호를 <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> 옵션과 함께 사용하는 경우([정규식 옵션](../../../docs/standard/base-types/regular-expression-options.md) 참조) 일치 항목이 각 줄의 시작 부분에 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="6cd31-128">If you use `^` with the <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> option (see [Regular Expression Options](../../../docs/standard/base-types/regular-expression-options.md)), the match must occur at the beginning of each line.</span></span>  
  
 <span data-ttu-id="6cd31-129">다음 예제에서는 일부 전문 야구팀이 있던 기간(년)에 대한 정보를 추출하는 정규식에서 `^` 앵커를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="6cd31-129">The following example uses the `^` anchor in a regular expression that extracts information about the years during which some professional baseball teams existed.</span></span> <span data-ttu-id="6cd31-130">이 예제에서는 <xref:System.Text.RegularExpressions.Regex.Matches%2A?displayProperty=nameWithType> 메서드의 오버로드 두 개를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="6cd31-130">The example calls two overloads of the <xref:System.Text.RegularExpressions.Regex.Matches%2A?displayProperty=nameWithType> method:</span></span>  
  
-   <span data-ttu-id="6cd31-131"><xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29> 오버로드에 대한 호출은 입력 문자열에서 정규식 패턴과 일치하는 첫 번째 하위 문자열만 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="6cd31-131">The call to the <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29> overload finds only the first substring in the input string that matches the regular expression pattern.</span></span>  
  
-   <span data-ttu-id="6cd31-132">`options` 매개 변수를 <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType>으로 설정한 <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> 오버로드에 대한 호출은 모든 하위 문자열 5개를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="6cd31-132">The call to the <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> overload with the `options` parameter set to <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> finds all five substrings.</span></span>  
  
 [!code-csharp[Conceptual.RegEx.Language.Assertions#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.assertions/cs/startofstring1.cs#1)]
 [!code-vb[Conceptual.RegEx.Language.Assertions#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.assertions/vb/startofstring1.vb#1)]  
  
 <span data-ttu-id="6cd31-133">정규식 패턴 `^((\w+(\s?)){2,}),\s(\w+\s\w+),(\s\d{4}(-(\d{4}|present))?,?)+` 는 다음 테이블과 같이 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="6cd31-133">The regular expression pattern `^((\w+(\s?)){2,}),\s(\w+\s\w+),(\s\d{4}(-(\d{4}|present))?,?)+` is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="6cd31-134">무늬</span><span class="sxs-lookup"><span data-stu-id="6cd31-134">Pattern</span></span>|<span data-ttu-id="6cd31-135">설명</span><span class="sxs-lookup"><span data-stu-id="6cd31-135">Description</span></span>|  
|-------------|-----------------|  
|`^`|<span data-ttu-id="6cd31-136">입력 문자열의 시작 부분(또는 메서드가 <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> 옵션과 함께 호출될 경우 줄의 시작 부분)에서 일치 항목 찾기를 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="6cd31-136">Begin the match at the beginning of the input string (or the beginning of the line if the method is called with the <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> option).</span></span>|  
|`((\w+(\s?)){2,}`|<span data-ttu-id="6cd31-137">단어 문자 하나 이상과 0 또는 공백 하나 순으로 정확히 두 번 나타내는 일치 항목을 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="6cd31-137">Match one or more word characters followed either by zero or by one space exactly two times.</span></span> <span data-ttu-id="6cd31-138">이 그룹은 첫 번째 캡처링 그룹입니다.</span><span class="sxs-lookup"><span data-stu-id="6cd31-138">This is the first capturing group.</span></span> <span data-ttu-id="6cd31-139">이 식은 두 번째 및 세 번째 캡처링 그룹도 정의합니다. 두 번째 캡처 도구는 캡처된 단어로 구성되고 세 번째는 캡처된 공백으로 구성됩니다.</span><span class="sxs-lookup"><span data-stu-id="6cd31-139">This expression also defines a second and third capturing group: The second consists of the captured word, and the third consists of the captured spaces.</span></span>|  
|`,\s`|<span data-ttu-id="6cd31-140">쉼표, 공백 문자 순의 일치 항목을 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="6cd31-140">Match a comma followed by a white-space character.</span></span>|  
|`(\w+\s\w+)`|<span data-ttu-id="6cd31-141">단어 문자 하나 이상, 공백, 단어 문자 하나 이상 순의 일치 항목을 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="6cd31-141">Match one or more word characters followed by a space, followed by one or more word characters.</span></span> <span data-ttu-id="6cd31-142">이 그룹은 네 번째 캡처링 그룹입니다.</span><span class="sxs-lookup"><span data-stu-id="6cd31-142">This is the fourth capturing group.</span></span>|  
|`,`|<span data-ttu-id="6cd31-143">쉼표 하나를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="6cd31-143">Match a comma.</span></span>|  
|`\s\d{4}`|<span data-ttu-id="6cd31-144">공백, 10 진수 4개 순의 일치 항목을 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="6cd31-144">Match a space followed by four decimal digits.</span></span>|  
|<code>(-(\d{4}&#124;present))?</code>|<span data-ttu-id="6cd31-145">하이픈과 10진수 4개 또는 문자열 "present" 순으로 나타나는 일치 항목 0개 또는 하나를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="6cd31-145">Match zero or one occurrence of a hyphen followed by four decimal digits or the string "present".</span></span> <span data-ttu-id="6cd31-146">이 그룹은 6번째 캡처 그룹입니다.</span><span class="sxs-lookup"><span data-stu-id="6cd31-146">This is the sixth capturing group.</span></span> <span data-ttu-id="6cd31-147">7번째 캡처 그룹도 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="6cd31-147">It also includes a seventh capturing group.</span></span>|  
|`,?`|<span data-ttu-id="6cd31-148">쉼표 0개 또는 1개를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="6cd31-148">Match zero or one occurrence of a comma.</span></span>|  
|<code>(\s\d{4}(-(\d{4}&#124;present))?,?)+</code>|<span data-ttu-id="6cd31-149">공백, 10진수 4개, 하이픈과 10진수 4개 또는 문자열 "present", 쉼표 0개 또는 하나 순으로 나타나는 일치 항목 하나 이상을 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="6cd31-149">Match one or more occurrences of the following: a space, four decimal digits, zero or one occurrence of a hyphen followed by four decimal digits or the string "present", and zero or one comma.</span></span> <span data-ttu-id="6cd31-150">이 그룹은 5번째 캡처 그룹입니다.</span><span class="sxs-lookup"><span data-stu-id="6cd31-150">This is the fifth capturing group.</span></span>|  
  
 [<span data-ttu-id="6cd31-151">맨 위로 이동</span><span class="sxs-lookup"><span data-stu-id="6cd31-151">Back to top</span></span>](#top)  
  
<a name="End"></a>   
## <a name="end-of-string-or-line-"></a><span data-ttu-id="6cd31-152">문자열 또는 줄의 끝: $</span><span class="sxs-lookup"><span data-stu-id="6cd31-152">End of String or Line: $</span></span>  
 <span data-ttu-id="6cd31-153">`$` 앵커는 선행 패턴이 입력 문자열의 끝이나 입력 문자열 끝에 있는 `\n` 앞에 나타나도록 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="6cd31-153">The `$` anchor specifies that the preceding pattern must occur at the end of the input string, or before `\n` at the end of the input string.</span></span>  
  
 <span data-ttu-id="6cd31-154">`$`를 <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> 옵션과 함께 사용하면 일치 항목이 줄의 끝 부분에 나타날 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6cd31-154">If you use `$` with the <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> option, the match can also occur at the end of a line.</span></span> <span data-ttu-id="6cd31-155">`$` 는 `\n` 과 일치하지만 `\r\n` (캐리지 리턴 및 줄 바꿈 문자 조합 또는 CR/LF)과는 일치하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="6cd31-155">Note that `$` matches `\n` but does not match `\r\n` (the combination of carriage return and newline characters, or CR/LF).</span></span> <span data-ttu-id="6cd31-156">CR/LF 문자 조합을 찾으려면 정규식 패턴에 `\r?$` 를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="6cd31-156">To match the CR/LF character combination, include `\r?$` in the regular expression pattern.</span></span>  
  
 <span data-ttu-id="6cd31-157">다음 예제에서는 `$` 앵커를 [문자열 또는 줄의 시작](#Start) 섹션의 예제에서 사용된 정규식 패턴에 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="6cd31-157">The following example adds the `$` anchor to the regular expression pattern used in the example in the [Start of String or Line](#Start) section.</span></span> <span data-ttu-id="6cd31-158">텍스트 5줄을 포함하는 원래 입력 문자열에서 사용될 경우 <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29?displayProperty=nameWithType> 메서드는 일치 항목을 찾을 수 없습니다. 이는 첫 번째 줄의 끝 부분이 `$` 패턴과 일치하지 않기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="6cd31-158">When used with the original input string, which includes five lines of text, the <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29?displayProperty=nameWithType> method is unable to find a match, because the end of the first line does not match the `$` pattern.</span></span> <span data-ttu-id="6cd31-159">원래 입력 문자열을 문자열 배열로 분할하면 <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29?displayProperty=nameWithType> 메서드는 5줄의 각 줄을 찾는 데 성공합니다.</span><span class="sxs-lookup"><span data-stu-id="6cd31-159">When the original input string is split into a string array, the <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29?displayProperty=nameWithType> method succeeds in matching each of the five lines.</span></span> <span data-ttu-id="6cd31-160">`options` 매개 변수를 <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType>으로 설정하여 <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> 메서드를 호출하면 정규식 패턴에서 캐리지 리턴 요소(\u+000D)를 고려하지 않으므로 일치 항목이 발견되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="6cd31-160">When the <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> method is called with the `options` parameter set to <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType>, no matches are found because the regular expression pattern does not account for the carriage return element (\u+000D).</span></span> <span data-ttu-id="6cd31-161">그러나 `$`를 `\r?$`로 바꿔서 정규식 패턴을 수정할 경우 `options` 매개 변수를 <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType>으로 설정하여 <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> 메서드를 다시 호출하면 일치 항목 5개가 발견됩니다.</span><span class="sxs-lookup"><span data-stu-id="6cd31-161">However, when the regular expression pattern is modified by replacing `$` with `\r?$`, calling the <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> method with the `options` parameter set to <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> again finds five matches.</span></span>  
  
 [!code-csharp[Conceptual.RegEx.Language.Assertions#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.assertions/cs/endofstring1.cs#2)]
 [!code-vb[Conceptual.RegEx.Language.Assertions#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.assertions/vb/endofstring1.vb#2)]  
  
 [<span data-ttu-id="6cd31-162">맨 위로 이동</span><span class="sxs-lookup"><span data-stu-id="6cd31-162">Back to top</span></span>](#top)  
  
<a name="StartOnly"></a>   
## <a name="start-of-string-only-a"></a><span data-ttu-id="6cd31-163">문자열의 시작만: \A</span><span class="sxs-lookup"><span data-stu-id="6cd31-163">Start of String Only: \A</span></span>  
 <span data-ttu-id="6cd31-164">`\A` 앵커는 일치 항목 찾기가 입력 문자열의 시작 부분에서 수행되도록 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="6cd31-164">The `\A` anchor specifies that a match must occur at the beginning of the input string.</span></span> <span data-ttu-id="6cd31-165">`\A`는 <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> 옵션을 무시한다는 점을 제외하고 `^` 앵커와 동일합니다.</span><span class="sxs-lookup"><span data-stu-id="6cd31-165">It is identical to the `^` anchor, except that `\A` ignores the <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> option.</span></span> <span data-ttu-id="6cd31-166">따라서 여러 줄 입력 문자열에서 첫 번째 줄의 시작 부분만 찾을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6cd31-166">Therefore, it can only match the start of the first line in a multiline input string.</span></span>  
  
 <span data-ttu-id="6cd31-167">다음 예제는 `^` 및 `$` 앵커에 대한 예제와 비슷합니다.</span><span class="sxs-lookup"><span data-stu-id="6cd31-167">The following example is similar to the examples for the `^` and `$` anchors.</span></span> <span data-ttu-id="6cd31-168">일부 전문 야구팀이 있던 기간(년)에 대한 정보를 추출하는 정규식에서 `\A` 앵커를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="6cd31-168">It uses the `\A` anchor in a regular expression that extracts information about the years during which some professional baseball teams existed.</span></span> <span data-ttu-id="6cd31-169">입력 문자열은 5줄을 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="6cd31-169">The input string includes five lines.</span></span> <span data-ttu-id="6cd31-170"><xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> 메서드에 대한 호출은 입력 문자열에서 정규식 패턴과 일치하는 첫 번째 하위 문자열만 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="6cd31-170">The call to the <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> method finds only the first substring in the input string that matches the regular expression pattern.</span></span> <span data-ttu-id="6cd31-171">예제에서 볼 수 있듯이 <xref:System.Text.RegularExpressions.RegexOptions.Multiline> 옵션은 아무 영향도 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="6cd31-171">As the example shows, the <xref:System.Text.RegularExpressions.RegexOptions.Multiline> option has no effect.</span></span>  
  
 [!code-csharp[Conceptual.RegEx.Language.Assertions#3](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.assertions/cs/startofstring2.cs#3)]
 [!code-vb[Conceptual.RegEx.Language.Assertions#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.assertions/vb/startofstring2.vb#3)]  
  
 [<span data-ttu-id="6cd31-172">맨 위로 이동</span><span class="sxs-lookup"><span data-stu-id="6cd31-172">Back to top</span></span>](#top)  
  
<a name="EndOrNOnly"></a>   
## <a name="end-of-string-or-before-ending-newline-z"></a><span data-ttu-id="6cd31-173">문자열의 끝 또는 줄 바꿈 종료 전: \Z</span><span class="sxs-lookup"><span data-stu-id="6cd31-173">End of String or Before Ending Newline: \Z</span></span>  
 <span data-ttu-id="6cd31-174">`\Z` 앵커는 일치 항목 찾기가 입력 문자열의 끝이나 입력 문자열의 끝에 있는 `\n` 앞에서 수행되도록 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="6cd31-174">The `\Z` anchor specifies that a match must occur at the end of the input string, or before `\n` at the end of the input string.</span></span> <span data-ttu-id="6cd31-175">`\Z`는 <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> 옵션을 무시한다는 점을 제외하고 `$` 앵커와 동일합니다.</span><span class="sxs-lookup"><span data-stu-id="6cd31-175">It is identical to the `$` anchor, except that `\Z` ignores the <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> option.</span></span> <span data-ttu-id="6cd31-176">따라서 여러 줄 문자열에서는 마지막 줄의 끝이나 `\n` 앞의 마지막 줄만 찾을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6cd31-176">Therefore, in a multiline string, it can only match the end of the last line, or the last line before `\n`.</span></span>  
  
 <span data-ttu-id="6cd31-177">`\Z` 는 `\n` 과 일치하지만 `\r\n` (CR/LF 문자 조합)과는 일치하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="6cd31-177">Note that `\Z` matches `\n` but does not match `\r\n` (the CR/LF character combination).</span></span> <span data-ttu-id="6cd31-178">CR/LF를 찾으려면 정규식 패턴에 `\r?\Z` 를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="6cd31-178">To match CR/LF, include `\r?\Z` in the regular expression pattern.</span></span>  
  
 <span data-ttu-id="6cd31-179">다음 예제에서는 일부 전문 야구팀이 있던 기간(년)에 대한 정보를 추출하는 `\Z` 문자열 또는 줄의 시작 [섹션의 예제와 비슷한 정규식에서](#Start) 앵커를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="6cd31-179">The following example uses the `\Z` anchor in a regular expression that is similar to the example in the [Start of String or Line](#Start) section, which extracts information about the years during which some professional baseball teams existed.</span></span> <span data-ttu-id="6cd31-180">정규식 `\r?\Z` 의 하위 식 `^((\w+(\s?)){2,}),\s(\w+\s\w+),(\s\d{4}(-(\d{4}|present))?,?)+\r?\Z` 는 문자열 끝과 일치하고 `\n` 또는 `\r\n`으로 끝나는 문자열과도 일치합니다.</span><span class="sxs-lookup"><span data-stu-id="6cd31-180">The subexpression `\r?\Z` in the regular expression `^((\w+(\s?)){2,}),\s(\w+\s\w+),(\s\d{4}(-(\d{4}|present))?,?)+\r?\Z` matches the end of a string, and also matches a string that ends with `\n` or `\r\n`.</span></span> <span data-ttu-id="6cd31-181">따라서 배열의 각 요소는 정규식 패턴과 일치합니다.</span><span class="sxs-lookup"><span data-stu-id="6cd31-181">As a result, each element in the array matches the regular expression pattern.</span></span>  
  
 [!code-csharp[Conceptual.RegEx.Language.Assertions#4](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.assertions/cs/endofstring2.cs#4)]
 [!code-vb[Conceptual.RegEx.Language.Assertions#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.assertions/vb/endofstring2.vb#4)]  
  
 [<span data-ttu-id="6cd31-182">맨 위로 이동</span><span class="sxs-lookup"><span data-stu-id="6cd31-182">Back to top</span></span>](#top)  
  
<a name="EndOnly"></a>   
## <a name="end-of-string-only-z"></a><span data-ttu-id="6cd31-183">문자열의 끝만: \z</span><span class="sxs-lookup"><span data-stu-id="6cd31-183">End of String Only: \z</span></span>  
 <span data-ttu-id="6cd31-184">`\z` 앵커는 일치 항목 찾기가 입력 문자열의 끝 부분에서 수행되도록 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="6cd31-184">The `\z` anchor specifies that a match must occur at the end of the input string.</span></span> <span data-ttu-id="6cd31-185">`$` 언어 요소와 같이 `\z`는 <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> 옵션을 무시합니다.</span><span class="sxs-lookup"><span data-stu-id="6cd31-185">Like the `$` language element, `\z` ignores the <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> option.</span></span> <span data-ttu-id="6cd31-186">`\Z` 언어 요소와 달리 `\z`는 문자열 끝에서 `\n` 문자를 찾지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="6cd31-186">Unlike the `\Z` language element, `\z` does not match a `\n` character at the end of a string.</span></span> <span data-ttu-id="6cd31-187">따라서 입력 문자열의 마지막 줄만 찾을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6cd31-187">Therefore, it can only match the last line of the input string.</span></span>  
  
 <span data-ttu-id="6cd31-188">다음 예제에서는 일부 전문 야구팀이 있던 기간(년)에 대한 정보를 추출하는 이전 섹션의 예제와 동일한 정규식에서 `\z` 앵커를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="6cd31-188">The following example uses the `\z` anchor in a regular expression that is otherwise identical to the example in the previous section, which extracts information about the years during which some professional baseball teams existed.</span></span> <span data-ttu-id="6cd31-189">예제에서는 정규식 패턴 `^((\w+(\s?)){2,}),\s(\w+\s\w+),(\s\d{4}(-(\d{4}|present))?,?)+\r?\z`를 사용하여 문자열 배열에서 요소 5개를 각각 찾으려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="6cd31-189">The example tries to match each of five elements in a string array with the regular expression pattern `^((\w+(\s?)){2,}),\s(\w+\s\w+),(\s\d{4}(-(\d{4}|present))?,?)+\r?\z`.</span></span> <span data-ttu-id="6cd31-190">문자열 중 두 개는 캐리지 리턴 및 줄 바꿈 문자로 끝나고, 하나는 줄 바꿈 문자로 끝나고, 두 개는 캐리지 리턴과 줄 바꿈 문자가 둘 다 없이 끝납니다.</span><span class="sxs-lookup"><span data-stu-id="6cd31-190">Two of the strings end with carriage return and line feed characters, one ends with a line feed character, and two end with neither a carriage return nor a line feed character.</span></span> <span data-ttu-id="6cd31-191">출력과 같이 캐리지 리턴이나 줄 바꿈 문자가 없는 문자열만 패턴과 일치합니다.</span><span class="sxs-lookup"><span data-stu-id="6cd31-191">As the output shows, only the strings without a carriage return or line feed character match the pattern.</span></span>  
  
 [!code-csharp[Conceptual.RegEx.Language.Assertions#5](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.assertions/cs/endofstring3.cs#5)]
 [!code-vb[Conceptual.RegEx.Language.Assertions#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.assertions/vb/endofstring3.vb#5)]  
  
 [<span data-ttu-id="6cd31-192">맨 위로 이동</span><span class="sxs-lookup"><span data-stu-id="6cd31-192">Back to top</span></span>](#top)  
  
<a name="Contiguous"></a>   
## <a name="contiguous-matches-g"></a><span data-ttu-id="6cd31-193">연속 일치: \G</span><span class="sxs-lookup"><span data-stu-id="6cd31-193">Contiguous Matches: \G</span></span>  
 <span data-ttu-id="6cd31-194">`\G` 앵커는 일치 항목 찾기가 이전 일치 항목 찾기가 끝난 지점에서 수행되도록 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="6cd31-194">The `\G` anchor specifies that a match must occur at the point where the previous match ended.</span></span> <span data-ttu-id="6cd31-195">이 앵커를 <xref:System.Text.RegularExpressions.Regex.Matches%2A?displayProperty=nameWithType> 또는 <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> 메서드와 함께 사용하면 모든 일치 항목이 연속으로 나타납니다.</span><span class="sxs-lookup"><span data-stu-id="6cd31-195">When you use this anchor with the <xref:System.Text.RegularExpressions.Regex.Matches%2A?displayProperty=nameWithType> or <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> method, it ensures that all matches are contiguous.</span></span>  
  
 <span data-ttu-id="6cd31-196">다음 예제에서는 정규식을 사용하여 쉼표로 구분된 문자열에서 설치류의 이름을 추출합니다.</span><span class="sxs-lookup"><span data-stu-id="6cd31-196">The following example uses a regular expression to extract the names of rodent species from a comma-delimited string.</span></span>  
  
 [!code-csharp[Conceptual.RegEx.Language.Assertions#6](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.assertions/cs/contiguous1.cs#6)]
 [!code-vb[Conceptual.RegEx.Language.Assertions#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.assertions/vb/contiguous1.vb#6)]  
  
 <span data-ttu-id="6cd31-197">정규식 `\G(\w+\s?\w*),?` 는 다음 테이블과 같이 해석됩니다.</span><span class="sxs-lookup"><span data-stu-id="6cd31-197">The regular expression `\G(\w+\s?\w*),?` is interpreted as shown in the following table.</span></span>  
  
|<span data-ttu-id="6cd31-198">무늬</span><span class="sxs-lookup"><span data-stu-id="6cd31-198">Pattern</span></span>|<span data-ttu-id="6cd31-199">설명</span><span class="sxs-lookup"><span data-stu-id="6cd31-199">Description</span></span>|  
|-------------|-----------------|  
|`\G`|<span data-ttu-id="6cd31-200">마지막 일치 항목 찾기가 종료된 위치에서 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="6cd31-200">Begin where the last match ended.</span></span>|  
|`\w+`|<span data-ttu-id="6cd31-201">하나 이상의 단어 문자를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="6cd31-201">Match one or more word characters.</span></span>|  
|`\s?`|<span data-ttu-id="6cd31-202">0개 또는 1개의 공백을 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="6cd31-202">Match zero or one space.</span></span>|  
|`\w*`|<span data-ttu-id="6cd31-203">0개 이상의 단어 문자를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="6cd31-203">Match zero or more word characters.</span></span>|  
|`(\w+\s?\w*)`|<span data-ttu-id="6cd31-204">단어 문자 하나 이상, 공백 0개 이상, 단어 문자 0개 이상 순의 일치 항목을 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="6cd31-204">Match one or more word characters followed by zero or one space, followed by zero or more word characters.</span></span> <span data-ttu-id="6cd31-205">이 그룹은 첫 번째 캡처링 그룹입니다.</span><span class="sxs-lookup"><span data-stu-id="6cd31-205">This is the first capturing group.</span></span>|  
|`,?`|<span data-ttu-id="6cd31-206">리터럴 쉼표 문자 0개 또는 하나를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="6cd31-206">Match zero or one occurrence of a literal comma character.</span></span>|  
  
 [<span data-ttu-id="6cd31-207">맨 위로 이동</span><span class="sxs-lookup"><span data-stu-id="6cd31-207">Back to top</span></span>](#top)  
  
<a name="WordBoundary"></a>   
## <a name="word-boundary-b"></a><span data-ttu-id="6cd31-208">단어 경계: \b</span><span class="sxs-lookup"><span data-stu-id="6cd31-208">Word Boundary: \b</span></span>  
 <span data-ttu-id="6cd31-209">`\b` 앵커는 일치 항목 찾기가 단어 문자( `\w` 언어 요소)와 비단어 문자( `\W` 언어 요소) 사이 경계에서 수행되도록 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="6cd31-209">The `\b` anchor specifies that the match must occur on a boundary between a word character (the `\w` language element) and a non-word character (the `\W` language element).</span></span> <span data-ttu-id="6cd31-210">단어 문자는 영숫자 문자 및 밑줄로 구성되고, 비단어 문자는 영숫자나 밑줄이 아닌 문자입니다.</span><span class="sxs-lookup"><span data-stu-id="6cd31-210">Word characters consist of alphanumeric characters and underscores; a non-word character is any character that is not alphanumeric or an underscore.</span></span> <span data-ttu-id="6cd31-211">자세한 내용은 [문자 클래스](../../../docs/standard/base-types/character-classes-in-regular-expressions.md)를 참조하세요. 일치 항목은 문자열의 시작 또는 끝의 단어 경계에 있을 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6cd31-211">(For more information, see [Character Classes](../../../docs/standard/base-types/character-classes-in-regular-expressions.md).) The match may also occur on a word boundary at the beginning or end of the string.</span></span>  
  
 <span data-ttu-id="6cd31-212">`\b` 앵커는 하위 식이 단어의 시작이나 끝이 아닌 전체 단어와 일치하는지 확인하는 데 자주 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="6cd31-212">The `\b` anchor is frequently used to ensure that a subexpression matches an entire word instead of just the beginning or end of a word.</span></span> <span data-ttu-id="6cd31-213">다음 예제의 정규식 `\bare\w*\b` 는 이 사용법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="6cd31-213">The regular expression `\bare\w*\b` in the following example illustrates this usage.</span></span> <span data-ttu-id="6cd31-214">하위 문자열 "are"로 시작하는 단어를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="6cd31-214">It matches any word that begins with the substring "are".</span></span> <span data-ttu-id="6cd31-215">예제 출력에서는 `\b` 가 입력 문자열의 시작 및 끝과 둘 다 일치함을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="6cd31-215">The output from the example also illustrates that `\b` matches both the beginning and the end of the input string.</span></span>  
  
 [!code-csharp[Conceptual.RegEx.Language.Assertions#7](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.assertions/cs/word1.cs#7)]
 [!code-vb[Conceptual.RegEx.Language.Assertions#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.assertions/vb/word1.vb#7)]  
  
 <span data-ttu-id="6cd31-216">정규식 패턴은 다음 테이블과 같이 해석됩니다.</span><span class="sxs-lookup"><span data-stu-id="6cd31-216">The regular expression pattern is interpreted as shown in the following table.</span></span>  
  
|<span data-ttu-id="6cd31-217">무늬</span><span class="sxs-lookup"><span data-stu-id="6cd31-217">Pattern</span></span>|<span data-ttu-id="6cd31-218">설명</span><span class="sxs-lookup"><span data-stu-id="6cd31-218">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="6cd31-219">단어 경계에서 일치 항목 찾기를 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="6cd31-219">Begin the match at a word boundary.</span></span>|  
|`are`|<span data-ttu-id="6cd31-220">"are"를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="6cd31-220">Match the substring "are".</span></span>|  
|`\w*`|<span data-ttu-id="6cd31-221">0개 이상의 단어 문자를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="6cd31-221">Match zero or more word characters.</span></span>|  
|`\b`|<span data-ttu-id="6cd31-222">단어 경계에서 일치 항목 찾기를 끝냅니다.</span><span class="sxs-lookup"><span data-stu-id="6cd31-222">End the match at a word boundary.</span></span>|  
  
 [<span data-ttu-id="6cd31-223">맨 위로 이동</span><span class="sxs-lookup"><span data-stu-id="6cd31-223">Back to top</span></span>](#top)  
  
<a name="NonwordBoundary"></a>   
## <a name="non-word-boundary-b"></a><span data-ttu-id="6cd31-224">비단어 경계: \B</span><span class="sxs-lookup"><span data-stu-id="6cd31-224">Non-Word Boundary: \B</span></span>  
 <span data-ttu-id="6cd31-225">`\B` 앵커는 일치 항목 찾기가 단어 경계에서 수행되지 않도록 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="6cd31-225">The `\B` anchor specifies that the match must not occur on a word boundary.</span></span> <span data-ttu-id="6cd31-226">`\b` 앵커와 반대 작업을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="6cd31-226">It is the opposite of the `\b` anchor.</span></span>  
  
 <span data-ttu-id="6cd31-227">다음 예제에서는 `\B` 앵커를 사용하여 단어에서 하위 문자열 "qu"를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="6cd31-227">The following example uses the `\B` anchor to locate occurrences of the substring "qu" in a word.</span></span> <span data-ttu-id="6cd31-228">정규식 패턴 `\Bqu\w+` 는 단어를 시작하지 않고 단어의 끝으로 계속되는 "qu"로 시작하는 하위 문자열을 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="6cd31-228">The regular expression pattern `\Bqu\w+` matches a substring that begins with a "qu" that does not start a word and that continues to the end of the word.</span></span>  
  
 [!code-csharp[Conceptual.RegEx.Language.Assertions#8](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.assertions/cs/nonword1.cs#8)]
 [!code-vb[Conceptual.RegEx.Language.Assertions#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.assertions/vb/nonword1.vb#8)]  
  
 <span data-ttu-id="6cd31-229">정규식 패턴은 다음 테이블과 같이 해석됩니다.</span><span class="sxs-lookup"><span data-stu-id="6cd31-229">The regular expression pattern is interpreted as shown in the following table.</span></span>  
  
|<span data-ttu-id="6cd31-230">무늬</span><span class="sxs-lookup"><span data-stu-id="6cd31-230">Pattern</span></span>|<span data-ttu-id="6cd31-231">설명</span><span class="sxs-lookup"><span data-stu-id="6cd31-231">Description</span></span>|  
|-------------|-----------------|  
|`\B`|<span data-ttu-id="6cd31-232">단어 경계에서 일치 항목 찾기를 시작하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="6cd31-232">Do not begin the match at a word boundary.</span></span>|  
|`qu`|<span data-ttu-id="6cd31-233">"qu" 하위 문자열을 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="6cd31-233">Match the substring "qu".</span></span>|  
|`\w+`|<span data-ttu-id="6cd31-234">하나 이상의 단어 문자를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="6cd31-234">Match one or more word characters.</span></span>|  
  
## <a name="see-also"></a><span data-ttu-id="6cd31-235">참고 항목</span><span class="sxs-lookup"><span data-stu-id="6cd31-235">See Also</span></span>  
 [<span data-ttu-id="6cd31-236">정규식 언어 - 빠른 참조</span><span class="sxs-lookup"><span data-stu-id="6cd31-236">Regular Expression Language - Quick Reference</span></span>](../../../docs/standard/base-types/regular-expression-language-quick-reference.md)  
 [<span data-ttu-id="6cd31-237">정규식 옵션</span><span class="sxs-lookup"><span data-stu-id="6cd31-237">Regular Expression Options</span></span>](../../../docs/standard/base-types/regular-expression-options.md)

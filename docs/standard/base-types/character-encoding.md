---
title: .NET의 문자 인코딩
ms.date: 12/22/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- encoding, understanding
- encoding, choosing
- encoding, fallback strategy
ms.assetid: bf6d9823-4c2d-48af-b280-919c5af66ae9
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: cac7e0fca4a009b7f5b6f677abed70cf2519052d
ms.sourcegitcommit: c7f3e2e9d6ead6cc3acd0d66b10a251d0c66e59d
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 09/08/2018
ms.locfileid: "44200474"
---
# <a name="character-encoding-in-net"></a><span data-ttu-id="c956a-102">.NET의 문자 인코딩</span><span class="sxs-lookup"><span data-stu-id="c956a-102">Character Encoding in .NET</span></span>
<span data-ttu-id="c956a-103">문자는 다양한 방법으로 표현할 수 있는 추상 엔터티입니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-103">Characters are abstract entities that can be represented in many different ways.</span></span> <span data-ttu-id="c956a-104">문자 인코딩은 지원되는 문자 집합의 각 문자와 해당 문자를 나타내는 일부 값의 쌍을 만드는 시스템입니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-104">A character encoding is a system that pairs each character in a supported character set with some value that represents that character.</span></span> <span data-ttu-id="c956a-105">예를 들어 모르스 부호는 로마 알파벳의 각 문자와 전화선을 통한 전송에 적합한 점과 대시 패턴의 쌍을 만드는 문자 인코딩입니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-105">For example, Morse code is a character encoding that pairs each character in the Roman alphabet with a pattern of dots and dashes that are suitable for transmission over telegraph lines.</span></span> <span data-ttu-id="c956a-106">컴퓨터의 문자 인코딩은 지원되는 문자 집합의 각 문자와 해당 문자를 나타내는 숫자 값의 쌍을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-106">A character encoding for computers pairs each character in a supported character set with a numeric value that represents that character.</span></span> <span data-ttu-id="c956a-107">문자 인코딩에는 다음 두 가지 구성 요소가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-107">A character encoding has two distinct components:</span></span>  
  
-   <span data-ttu-id="c956a-108">인코더 - 문자 시퀀스를 숫자 값(바이트) 시퀀스로 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-108">An encoder, which translates a sequence of characters into a sequence of numeric values (bytes).</span></span>  
  
-   <span data-ttu-id="c956a-109">디코더 - 바이트 시퀀스를 문자 시퀀스로 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-109">A decoder, which translates a sequence of bytes into a sequence of characters.</span></span>  
  
 <span data-ttu-id="c956a-110">문자 인코딩은 인코더와 디코더가 작동하는 규칙을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-110">Character encoding describes the rules by which an encoder and a decoder operate.</span></span> <span data-ttu-id="c956a-111">예를 들어 <xref:System.Text.UTF8Encoding> 클래스는 1-4바이트를 사용하여 단일 유니코드 문자를 나타내는 UTF-8(8비트 유니코드 변환 형식)으로 인코딩 및 디코딩하는 규칙을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-111">For example, the <xref:System.Text.UTF8Encoding> class describes the rules for encoding to, and decoding from, 8-bit Unicode Transformation Format (UTF-8), which uses one to four bytes to represent a single Unicode character.</span></span> <span data-ttu-id="c956a-112">인코딩 및 디코딩에 유효성 검사가 포함될 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-112">Encoding and decoding can also include validation.</span></span> <span data-ttu-id="c956a-113">예를 들어 <xref:System.Text.UnicodeEncoding> 클래스는 모든 서로게이트를 검사하여 유효한 서로게이트 쌍을 구성하는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-113">For example, the <xref:System.Text.UnicodeEncoding> class checks all surrogates  to make sure they constitute valid surrogate pairs.</span></span> <span data-ttu-id="c956a-114">서로게이트 쌍은 코드 포인트가 U+D800에서 U+DBFF 사이의 범위인 문자와 코드 포인트가 U+DC00에서 U+DFFF 사이의 범위인 문자가 이 순서로 결합되어 구성됩니다.  대체(fallback) 전략은 인코더에서 잘못된 문자를 처리하는 방법 또는 디코더에서 잘못된 바이트를 처리하는 방법을 결정합니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-114">(A surrogate pair consists of a character with a code point that ranges from U+D800 to U+DBFF followed by a character with a code point that ranges from U+DC00 to U+DFFF.)  A fallback strategy determines how an encoder handles invalid characters or how a decoder handles invalid bytes.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="c956a-115">.NET 인코딩 클래스는 문자 데이터를 저장 및 변환하는 방법을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-115">.NET encoding classes provide a way to store and convert character data.</span></span> <span data-ttu-id="c956a-116">이진 데이터를 문자열 형식으로 저장하는 데 사용하면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-116">They should not be used to store binary data in string form.</span></span> <span data-ttu-id="c956a-117">사용되는 인코딩에 따라 인코딩 클래스를 통해 이진 데이터를 문자열로 변환할 때 예기치 못한 동작이 발생하고 부정확하거나 손상된 데이터가 생성될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-117">Depending on the encoding used, converting binary data to string format with the encoding classes can introduce unexpected behavior and produce inaccurate or corrupted data.</span></span> <span data-ttu-id="c956a-118">이진 데이터를 문자열 형식으로 변환하려면 <xref:System.Convert.ToBase64String%2A?displayProperty=nameWithType> 메서드를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-118">To convert binary data to a string form, use the <xref:System.Convert.ToBase64String%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="c956a-119">.NET에서는 UTF-16 인코딩(<xref:System.Text.UnicodeEncoding> 클래스로 표시)을 사용하여 문자와 문자열을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-119">.NET uses the UTF-16 encoding (represented by the <xref:System.Text.UnicodeEncoding> class) to represent characters and strings.</span></span> <span data-ttu-id="c956a-120">공용 언어 런타임을 대상으로 하는 응용 프로그램은 인코더를 사용하여 공용 언어 런타임에서 지원하는 유니코드 문자 표현을 다른 인코딩 체계에 매핑합니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-120">Applications that target the common language runtime use encoders to map Unicode character representations supported by the common language runtime to other encoding schemes.</span></span> <span data-ttu-id="c956a-121">디코더를 사용하여 문자를 비유니코드 인코딩에서 유니코드로 매핑합니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-121">They use decoders to map characters from non-Unicode encodings to Unicode.</span></span>  
  
 <span data-ttu-id="c956a-122">이 항목은 다음 섹션으로 구성되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-122">This topic consists of the following sections:</span></span>  
  
-   [<span data-ttu-id="c956a-123">.NET의 인코딩</span><span class="sxs-lookup"><span data-stu-id="c956a-123">Encodings in .NET</span></span>](../../../docs/standard/base-types/character-encoding.md#Encodings)  
  
-   [<span data-ttu-id="c956a-124">인코딩 클래스 선택</span><span class="sxs-lookup"><span data-stu-id="c956a-124">Selecting an Encoding Class</span></span>](../../../docs/standard/base-types/character-encoding.md#Selecting)  
  
-   [<span data-ttu-id="c956a-125">인코딩 개체 사용</span><span class="sxs-lookup"><span data-stu-id="c956a-125">Using an Encoding Object</span></span>](../../../docs/standard/base-types/character-encoding.md#Using)  
  
-   [<span data-ttu-id="c956a-126">대체(fallback) 전략 선택</span><span class="sxs-lookup"><span data-stu-id="c956a-126">Choosing a Fallback Strategy</span></span>](../../../docs/standard/base-types/character-encoding.md#FallbackStrategy)  
  
-   [<span data-ttu-id="c956a-127">Implementing a Custom Fallback Strategy</span><span class="sxs-lookup"><span data-stu-id="c956a-127">Implementing a Custom Fallback Strategy</span></span>](../../../docs/standard/base-types/character-encoding.md#Custom)  
  
<a name="Encodings"></a>   
## <a name="encodings-in-net"></a><span data-ttu-id="c956a-128">.NET의 인코딩</span><span class="sxs-lookup"><span data-stu-id="c956a-128">Encodings in .NET</span></span>  
 <span data-ttu-id="c956a-129">.NET의 모든 문자 인코딩 클래스는 모든 문자 인코딩에 공통된 기능을 정의하는 추상 클래스인 <xref:System.Text.Encoding?displayProperty=nameWithType> 클래스에서 상속됩니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-129">All character encoding classes in .NET inherit from the <xref:System.Text.Encoding?displayProperty=nameWithType> class, which is an abstract class that defines the functionality common to all character encodings.</span></span> <span data-ttu-id="c956a-130">.NET에서 구현된 개별 인코딩 개체에 액세스하려면 다음을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-130">To access the individual encoding objects implemented in .NET, do the following:</span></span>  
  
-   <span data-ttu-id="c956a-131">.NET에서 사용할 수 있는 표준 문자 인코딩(ASCII, UTF-7, UTF-8, UTF-16 및 UTF-32)을 나타내는 개체를 반환하는 <xref:System.Text.Encoding> 클래스의 정적 속성을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-131">Use the static properties of the <xref:System.Text.Encoding> class, which return objects that represent the standard character encodings available in .NET (ASCII, UTF-7, UTF-8, UTF-16, and UTF-32).</span></span> <span data-ttu-id="c956a-132">예를 들어 <xref:System.Text.Encoding.Unicode%2A?displayProperty=nameWithType> 속성은 <xref:System.Text.UnicodeEncoding> 개체를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-132">For example, the <xref:System.Text.Encoding.Unicode%2A?displayProperty=nameWithType> property returns a <xref:System.Text.UnicodeEncoding> object.</span></span> <span data-ttu-id="c956a-133">각 개체는 교체 대체(fallback)를 사용하여 인코딩할 수 없는 문자열과 디코딩할 수 없는 바이트를 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-133">Each object uses replacement fallback to handle strings that it cannot encode and bytes that it cannot decode.</span></span> <span data-ttu-id="c956a-134">자세한 내용은 [Replacement Fallback](../../../docs/standard/base-types/character-encoding.md#Replacement) 섹션을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="c956a-134">(For more information, see the [Replacement Fallback](../../../docs/standard/base-types/character-encoding.md#Replacement) section.)</span></span>  
  
-   <span data-ttu-id="c956a-135">인코딩의 클래스 생성자를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-135">Call the encoding's class constructor.</span></span> <span data-ttu-id="c956a-136">이런 방식으로 ASCII, UTF-7, UTF-8, UTF-16 및 UTF-32 인코딩에 대한 개체를 인스턴스화할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-136">Objects for the ASCII, UTF-7, UTF-8, UTF-16, and UTF-32 encodings can be instantiated in this way.</span></span> <span data-ttu-id="c956a-137">기본적으로 각 개체는 교체 대체(fallback)를 사용하여 인코딩할 수 없는 문자열과 디코딩할 수 없는 바이트를 처리하지만 대신 예외가 발생하도록 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-137">By default, each object uses replacement fallback to handle strings that it cannot encode and bytes that it cannot decode, but you can specify that an exception should be thrown instead.</span></span> <span data-ttu-id="c956a-138">자세한 내용은 [Replacement Fallback](../../../docs/standard/base-types/character-encoding.md#Replacement) 및 [Exception Fallback](../../../docs/standard/base-types/character-encoding.md#Exception) 섹션을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="c956a-138">(For more information, see the [Replacement Fallback](../../../docs/standard/base-types/character-encoding.md#Replacement) and [Exception Fallback](../../../docs/standard/base-types/character-encoding.md#Exception) sections.)</span></span>  
  
-   <span data-ttu-id="c956a-139"><xref:System.Text.Encoding.%23ctor%28System.Int32%29?displayProperty=nameWithType> 생성자를 호출하고 인코딩을 나타내는 정수를 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-139">Call the <xref:System.Text.Encoding.%23ctor%28System.Int32%29?displayProperty=nameWithType> constructor and pass it an integer that represents the encoding.</span></span> <span data-ttu-id="c956a-140">표준 인코딩 개체는 교체 대체(fallback)를 사용하고, 코드 페이지와 DBCS(더블바이트 문자 집합) 인코딩 개체는 최적 맞춤 대체(fallback)를 사용하여 인코딩할 수 없는 문자열과 디코딩할 수 없는 바이트를 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-140">Standard encoding objects use replacement fallback, and code page and double-byte character set (DBCS) encoding objects use best-fit fallback to handle strings that they cannot encode and bytes that they cannot decode.</span></span> <span data-ttu-id="c956a-141">자세한 내용은 [Best-Fit Fallback](../../../docs/standard/base-types/character-encoding.md#BestFit) 섹션을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="c956a-141">(For more information, see the [Best-Fit Fallback](../../../docs/standard/base-types/character-encoding.md#BestFit) section.)</span></span>  
  
-   <span data-ttu-id="c956a-142">.NET에서 사용할 수 있는 표준, 코드 페이지 또는 DBCS 인코딩을 반환하는 <xref:System.Text.Encoding.GetEncoding%2A?displayProperty=nameWithType> 메서드를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-142">Call the <xref:System.Text.Encoding.GetEncoding%2A?displayProperty=nameWithType> method, which returns any standard, code page, or DBCS encoding available in .NET.</span></span> <span data-ttu-id="c956a-143">오버로드를 통해 인코더와 디코더 둘 다에 대체(fallback) 개체를 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-143">Overloads let you specify a fallback object for both the encoder and the decoder.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="c956a-144">유니코드 표준은 지원되는 모든 스크립트의 각 문자에 코드 포인트(숫자)와 이름을 할당합니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-144">The Unicode Standard assigns a code point (a number) and a name to each character in every supported script.</span></span> <span data-ttu-id="c956a-145">예를 들어 "A" 문자는 코드 포인트 U+0041 및 이름 "LATIN CAPITAL LETTER A"로 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-145">For example, the character "A" is represented by the code point U+0041 and the name "LATIN CAPITAL LETTER A".</span></span> <span data-ttu-id="c956a-146">UTF(유니코드 변환 형식) 인코딩은 코드 포인트를 하나 이상의 바이트 시퀀스로 인코딩하는 방법을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-146">The Unicode Transformation Format (UTF) encodings define ways to encode that code point into a sequence of one or more bytes.</span></span> <span data-ttu-id="c956a-147">유니코드 인코딩 체계를 사용하면 모든 문자 집합의 문자를 단일 인코딩으로 나타낼 수 있으므로 국제 응용 프로그램 개발이 간소화됩니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-147">A Unicode encoding scheme simplifies world-ready application development because it allows characters from any character set to be represented in a single encoding.</span></span> <span data-ttu-id="c956a-148">응용 프로그램 개발자가 더 이상 특정 언어나 쓰기 시스템을 위한 문자를 생성하는 데 사용된 인코딩 체계를 추적할 필요가 없으며 손상 없이 전 세계 시스템 간에 데이터를 공유할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-148">Application developers no longer have to keep track of the encoding scheme that was used to produce characters for a specific language or writing system, and data can be shared among systems internationally without being corrupted.</span></span>  
>   
>  <span data-ttu-id="c956a-149">.NET에서는 유니코드 표준에서 정의된 세 가지 인코딩인 UTF-8, UTF-16 및 UTF-32를 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-149">.NET supports three encodings defined by the Unicode standard: UTF-8, UTF-16, and UTF-32.</span></span> <span data-ttu-id="c956a-150">자세한 내용은 [유니코드 홈페이지](https://www.unicode.org/)에서 유니코드 표준을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="c956a-150">For more information, see The Unicode Standard at the [Unicode home page](https://www.unicode.org/).</span></span>  
  
 <span data-ttu-id="c956a-151"><xref:System.Text.Encoding.GetEncodings%2A?displayProperty=nameWithType> 메서드를 호출하여 .NET에서 사용할 수 있는 모든 인코딩에 대한 정보를 검색할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-151">You can retrieve information about all the encodings available in .NET by calling the <xref:System.Text.Encoding.GetEncodings%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="c956a-152">.NET에서는 다음 표에 나열된 문자 인코딩 시스템을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-152">.NET supports the character encoding systems listed in the following table.</span></span>  
  
|<span data-ttu-id="c956a-153">인코딩</span><span class="sxs-lookup"><span data-stu-id="c956a-153">Encoding</span></span>|<span data-ttu-id="c956a-154">클래스</span><span class="sxs-lookup"><span data-stu-id="c956a-154">Class</span></span>|<span data-ttu-id="c956a-155">설명</span><span class="sxs-lookup"><span data-stu-id="c956a-155">Description</span></span>|<span data-ttu-id="c956a-156">장점/단점</span><span class="sxs-lookup"><span data-stu-id="c956a-156">Advantages/disadvantages</span></span>|  
|--------------|-----------|-----------------|-------------------------------|  
|<span data-ttu-id="c956a-157">ASCII</span><span class="sxs-lookup"><span data-stu-id="c956a-157">ASCII</span></span>|<xref:System.Text.ASCIIEncoding>|<span data-ttu-id="c956a-158">바이트의 하위 7비트를 사용하여 제한된 범위의 문자를 인코딩합니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-158">Encodes a limited range of characters by using the lower seven bits of a byte.</span></span>|<span data-ttu-id="c956a-159">이 인코딩은 U+0000에서 U+007F 사이의 문자 값만 지원하므로 대부분의 경우 국제화된 응용 프로그램에는 적합하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-159">Because this encoding only supports character values from U+0000 through U+007F, in most cases it is inadequate for internationalized applications.</span></span>|  
|<span data-ttu-id="c956a-160">UTF-7</span><span class="sxs-lookup"><span data-stu-id="c956a-160">UTF-7</span></span>|<xref:System.Text.UTF7Encoding>|<span data-ttu-id="c956a-161">7비트 ASCII 문자 시퀀스로 문자를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-161">Represents characters as sequences of 7-bit ASCII characters.</span></span> <span data-ttu-id="c956a-162">비 ASCII 유니코드 문자는 ASCII 문자의 이스케이프 시퀀스로 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-162">Non-ASCII Unicode characters are represented by an escape sequence of ASCII characters.</span></span>|<span data-ttu-id="c956a-163">UTF-7은 전자 메일 및 뉴스 그룹 프로토콜과 같은 프로토콜을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-163">UTF-7 supports protocols such as email and newsgroup protocols.</span></span> <span data-ttu-id="c956a-164">그러나 UTF-7은 특별히 안전하거나 강력하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-164">However, UTF-7 is not particularly secure or robust.</span></span> <span data-ttu-id="c956a-165">경우에 따라 1비트를 변경해도 전체 UTF-7 문자열의 해석이 완전히 바뀔 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-165">In some cases, changing one bit can radically alter the interpretation of an entire UTF-7 string.</span></span> <span data-ttu-id="c956a-166">다른 UTF-7 문자열이 동일한 텍스트를 인코딩할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-166">In other cases, different UTF-7 strings can encode the same text.</span></span> <span data-ttu-id="c956a-167">비 ASCII 문자를 포함하는 시퀀스의 경우 UTF-7에서 UTF-8보다 많은 공간이 필요하며 인코딩/디코딩 속도가 느려집니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-167">For sequences that include non-ASCII characters, UTF-7 requires more space than UTF-8, and encoding/decoding is slower.</span></span> <span data-ttu-id="c956a-168">따라서 가능하면 UTF-7 대신 UTF-8을 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-168">Consequently, you should use UTF-8 instead of UTF-7 if possible.</span></span>|  
|<span data-ttu-id="c956a-169">UTF-8</span><span class="sxs-lookup"><span data-stu-id="c956a-169">UTF-8</span></span>|<xref:System.Text.UTF8Encoding>|<span data-ttu-id="c956a-170">각 유니코드 코드 포인트를 1-4바이트의 시퀀스로 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-170">Represents each Unicode code point as a sequence of one to four bytes.</span></span>|<span data-ttu-id="c956a-171">UTF-8은 8비트 데이터 크기를 지원하며 기존의 많은 운영 체제에서 제대로 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-171">UTF-8 supports 8-bit data sizes and works well with many existing operating systems.</span></span> <span data-ttu-id="c956a-172">ASCII 문자 범위의 경우 UTF-8은 ASCII 인코딩과 동일하며 광범위한 문자 집합을 허용합니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-172">For the ASCII range of characters, UTF-8 is identical to ASCII encoding and allows a broader set of characters.</span></span> <span data-ttu-id="c956a-173">그러나 CJK(중국어-일본어-한국어) 스크립트의 경우 UTF-8에서 각 문자에 대해 3바이트를 요구할 수 있으며 데이터 크기가 UTF-16보다 커질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-173">However, for Chinese-Japanese-Korean (CJK) scripts, UTF-8 can require three bytes for each character, and can potentially cause larger data sizes than UTF-16.</span></span> <span data-ttu-id="c956a-174">때로는 HTML 태그와 같은 ASCII 데이터의 양이 CJK 범위의 크기 증가와 관련이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-174">Note that sometimes the amount of ASCII data, such as HTML tags, justifies the increased size for the CJK range.</span></span>|  
|<span data-ttu-id="c956a-175">UTF-16</span><span class="sxs-lookup"><span data-stu-id="c956a-175">UTF-16</span></span>|<xref:System.Text.UnicodeEncoding>|<span data-ttu-id="c956a-176">각 유니코드 코드 포인트를 한두 개의 16비트 정수 시퀀스로 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-176">Represents each Unicode code point as a sequence of one or two 16-bit integers.</span></span> <span data-ttu-id="c956a-177">가장 일반적인 유니코드 문자에는 UTF-16 코드 포인트 한 개만 있으면 됩니다. 단, 유니코드 보조 문자(U+10000 이상)에는 UTF-16 서로게이트 코드 포인트 두 개가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-177">Most common Unicode characters require only one UTF-16 code point, although Unicode supplementary characters (U+10000 and greater) require two UTF-16 surrogate code points.</span></span> <span data-ttu-id="c956a-178">little-endian 및 big-endian 바이트 순서가 둘 다 지원됩니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-178">Both little-endian and big-endian byte orders are supported.</span></span>|<span data-ttu-id="c956a-179">UTF-16 인코딩은 공용 언어 런타임에서 <xref:System.Char> 및 <xref:System.String> 값을 나타내는 데 사용되며 Windows 운영 체제에서 `WCHAR` 값을 나타내는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-179">UTF-16 encoding is used by the common language runtime to represent <xref:System.Char> and <xref:System.String> values, and it is used by the Windows operating system to represent `WCHAR` values.</span></span>|  
|<span data-ttu-id="c956a-180">UTF-32</span><span class="sxs-lookup"><span data-stu-id="c956a-180">UTF-32</span></span>|<xref:System.Text.UTF32Encoding>|<span data-ttu-id="c956a-181">각 유니코드 코드 포인트를 32비트 정수 한 개로 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-181">Represents each Unicode code point as a 32-bit integer.</span></span> <span data-ttu-id="c956a-182">little-endian 및 big-endian 바이트 순서가 둘 다 지원됩니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-182">Both little-endian and big-endian byte orders are supported.</span></span>|<span data-ttu-id="c956a-183">UTF-32 인코딩은 인코딩된 공간이 너무 중요한 운영 체제에서 응용 프로그램이 UTF-16 인코딩의 서로게이트 코드 포인트 동작을 방지하려는 경우에 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-183">UTF-32 encoding is used when applications want to avoid the surrogate code point behavior of UTF-16 encoding on operating systems for which encoded space is too important.</span></span> <span data-ttu-id="c956a-184">디스플레이에 렌더링되는 단일 문자 모양은 여전히 둘 이상의 UTF-32 문자로 인코딩될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-184">Single glyphs rendered on a display can still be encoded with more than one UTF-32 character.</span></span>|  
|<span data-ttu-id="c956a-185">ANSI/ISO 인코딩</span><span class="sxs-lookup"><span data-stu-id="c956a-185">ANSI/ISO encodings</span></span>||<span data-ttu-id="c956a-186">다양한 코드 페이지에 대해 지원됩니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-186">Provides support for a variety of code pages.</span></span> <span data-ttu-id="c956a-187">Windows 운영 체제에서 코드 페이지는 특정 언어 또는 언어 그룹을 지원하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-187">On Windows operating systems, code pages are used to support a specific language or group of languages.</span></span> <span data-ttu-id="c956a-188">.NET에서 지원되는 코드 페이지를 나열하는 표는 <xref:System.Text.Encoding> 클래스를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="c956a-188">For a table that lists the code pages supported by .NET, see the <xref:System.Text.Encoding> class.</span></span> <span data-ttu-id="c956a-189"><xref:System.Text.Encoding.GetEncoding%28System.Int32%29?displayProperty=nameWithType> 메서드를 호출하여 특정 코드 페이지에 대한 인코딩 개체를 검색할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-189">You can retrieve an encoding object for a particular code page by calling the <xref:System.Text.Encoding.GetEncoding%28System.Int32%29?displayProperty=nameWithType> method.</span></span>|<span data-ttu-id="c956a-190">코드 페이지에는 256개의 코드 포인트가 포함되며 0부터 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-190">A code page contains 256 code points and is zero-based.</span></span> <span data-ttu-id="c956a-191">대부분의 코드 페이지에서 코드 포인트 0-127은 ASCII 문자 집합을 나타내고, 코드 포인트 128-255는 코드 페이지마다 상당한 차이가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-191">In most code pages, code points 0 through 127 represent the ASCII character set, and code points 128 through 255 differ significantly between code pages.</span></span> <span data-ttu-id="c956a-192">예를 들어 코드 페이지 1252는 영어, 독일어, 프랑스어 등 라틴 문자 쓰기 시스템에 대한 문자를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-192">For example, code page 1252 provides the characters for Latin writing systems, including English, German, and French.</span></span> <span data-ttu-id="c956a-193">코드 페이지 1252의 마지막 128개 코드 포인트에는 악센트 문자가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-193">The last 128 code points in code page 1252 contain the accent characters.</span></span> <span data-ttu-id="c956a-194">코드 페이지 1253은 그리스어 문자 체계에 필요한 문자 코드를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-194">Code page 1253 provides character codes that are required in the Greek writing system.</span></span> <span data-ttu-id="c956a-195">코드 페이지 1253의 마지막 128개 코드 포인트에는 그리스어 문자가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-195">The last 128 code points in code page 1253 contain the Greek characters.</span></span> <span data-ttu-id="c956a-196">따라서, ANSI 코드 페이지를 사용하는 응용 프로그램은 참조된 코드 페이지를 나타내는 식별자를 포함하지 않는 한 동일한 텍스트 스트림에 그리스어와 독일어를 저장할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-196">As a result, an application that relies on ANSI code pages cannot store Greek and German in the same text stream unless it includes an identifier that indicates the referenced code page.</span></span>|  
|<span data-ttu-id="c956a-197">DBCS(더블바이트 문자 집합) 인코딩</span><span class="sxs-lookup"><span data-stu-id="c956a-197">Double-byte character set (DBCS) encodings</span></span>||<span data-ttu-id="c956a-198">256자가 넘는 문자를 포함하는 언어(예: 중국어, 일본어 및 한국어)를 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-198">Supports languages, such as Chinese, Japanese, and Korean, that contain more than 256 characters.</span></span> <span data-ttu-id="c956a-199">DBCS에서는 한 쌍의 코드 포인트(더블바이트)가 각 문자를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-199">In a DBCS, a pair of code points (a double byte) represents each character.</span></span> <span data-ttu-id="c956a-200"><xref:System.Text.Encoding.IsSingleByte%2A?displayProperty=nameWithType> 속성은 DBCS 인코딩에 대해 `false`를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-200">The <xref:System.Text.Encoding.IsSingleByte%2A?displayProperty=nameWithType> property returns `false` for DBCS encodings.</span></span> <span data-ttu-id="c956a-201"><xref:System.Text.Encoding.GetEncoding%28System.Int32%29?displayProperty=nameWithType> 메서드를 호출하여 특정 DBCS에 대한 인코딩 개체를 검색할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-201">You can retrieve an encoding object for a particular DBCS by calling the <xref:System.Text.Encoding.GetEncoding%28System.Int32%29?displayProperty=nameWithType> method.</span></span>|<span data-ttu-id="c956a-202">DBCS에서는 한 쌍의 코드 포인트(더블바이트)가 각 문자를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-202">In a DBCS, a pair of code points (a double byte) represents each character.</span></span> <span data-ttu-id="c956a-203">응용 프로그램에서 DBCS 데이터를 처리할 때 DBCS 문자의 첫 번째 바이트(선행 바이트)는 바로 뒤에 오는 후행 바이트와 함께 처리됩니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-203">When an application handles DBCS data, the first byte of a DBCS character (the lead byte) is processed in combination with the trail byte that immediately follows it.</span></span> <span data-ttu-id="c956a-204">한 쌍의 더블바이트 코드 포인트가 코드 페이지에 따라 서로 다른 문자를 나타낼 수 있기 때문에 이 구성표에서는 여전히 동일한 데이터 스트림에 두 언어(예: 일본어 및 중국어)를 함께 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-204">Because a single pair of double-byte code points can represent different characters depending on the code page, this scheme still does not allow for the combination of two languages, such as Japanese and Chinese, in the same data stream.</span></span>|  
  
 <span data-ttu-id="c956a-205">이러한 인코딩을 통해 유니코드 문자는 물론 레거시 응용 프로그램에서 가장 일반적으로 사용되는 인코딩으로 작업할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-205">These encodings enable you to work with Unicode characters as well as with encodings that are most commonly used in legacy applications.</span></span> <span data-ttu-id="c956a-206">또한 <xref:System.Text.Encoding> 에서 파생되는 클래스를 정의하고 해당 멤버를 재정의하여 사용자 지정 인코딩을 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-206">In addition, you can create a custom encoding by defining a class that derives from <xref:System.Text.Encoding> and overriding its members.</span></span>  
  
### <a name="platform-notes-includenetcoreincludesnet-core-mdmd"></a><span data-ttu-id="c956a-207">플랫폼 참고 사항: [!INCLUDE[net_core](../../../includes/net-core-md.md)]</span><span class="sxs-lookup"><span data-stu-id="c956a-207">Platform Notes: [!INCLUDE[net_core](../../../includes/net-core-md.md)]</span></span>  
 <span data-ttu-id="c956a-208">기본적으로 [!INCLUDE[net_core](../../../includes/net-core-md.md)] 에서는 코드 페이지 28591 이외의 코드 페이지 인코딩 및 유니코드 인코딩(예: UTF-8 및 UTF-16)을 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-208">By default, [!INCLUDE[net_core](../../../includes/net-core-md.md)] does not make available any code page encodings other than code page 28591 and the Unicode encodings, such as UTF-8 and UTF-16.</span></span> <span data-ttu-id="c956a-209">그러나 .NET을 대상으로 하는 표준 Windows 앱에 있는 코드 페이지 인코딩을 해당 앱에 추가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-209">However, you can add the code page encodings found in standard Windows apps that target .NET to your app.</span></span> <span data-ttu-id="c956a-210">자세한 내용은 <xref:System.Text.CodePagesEncodingProvider> 항목을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="c956a-210">For complete information, see the <xref:System.Text.CodePagesEncodingProvider> topic.</span></span>  
  
<a name="Selecting"></a>   
## <a name="selecting-an-encoding-class"></a><span data-ttu-id="c956a-211">인코딩 클래스 선택</span><span class="sxs-lookup"><span data-stu-id="c956a-211">Selecting an Encoding Class</span></span>  
 <span data-ttu-id="c956a-212">응용 프로그램에서 사용할 인코딩을 선택할 수 있는 경우 유니코드 인코딩인 <xref:System.Text.UTF8Encoding> 또는 <xref:System.Text.UnicodeEncoding>를 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-212">If you have the opportunity to choose the encoding to be used by your application, you should use a Unicode encoding, preferably either <xref:System.Text.UTF8Encoding> or <xref:System.Text.UnicodeEncoding>.</span></span> <span data-ttu-id="c956a-213">.NET에서는 세 번째 유니코드 인코딩인 <xref:System.Text.UTF32Encoding>도 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-213">(.NET also supports a third Unicode encoding, <xref:System.Text.UTF32Encoding>.)</span></span>  
  
 <span data-ttu-id="c956a-214">ASCII 인코딩(<xref:System.Text.ASCIIEncoding>)을 사용하려는 경우 <xref:System.Text.UTF8Encoding> 을 대신 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-214">If you are planning to use an ASCII encoding (<xref:System.Text.ASCIIEncoding>), choose <xref:System.Text.UTF8Encoding> instead.</span></span> <span data-ttu-id="c956a-215">두 인코딩은 ASCII 문자 집합에서 동일하지만 <xref:System.Text.UTF8Encoding> 에는 다음과 같은 이점이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-215">The two encodings are identical for the ASCII character set, but <xref:System.Text.UTF8Encoding> has the following advantages:</span></span>  
  
-   <span data-ttu-id="c956a-216"><xref:System.Text.ASCIIEncoding> 은 U+0000에서 U+007F 사이의 유니코드 문자 값만 지원하는 반면, 모든 유니코드 문자를 나타낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-216">It can represent every Unicode character, whereas <xref:System.Text.ASCIIEncoding> supports only the Unicode character values between U+0000 and U+007F.</span></span>  
  
-   <span data-ttu-id="c956a-217">오류 검색 및 향상된 보안을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-217">It provides error detection and better security.</span></span>  
  
-   <span data-ttu-id="c956a-218">최대한 빠르도록 조정되었으며 다른 인코딩보다 더 빨라야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-218">It has been tuned to be as fast as possible and should be faster than any other encoding.</span></span> <span data-ttu-id="c956a-219">완전히 ASCII인 콘텐츠의 경우에도 <xref:System.Text.UTF8Encoding> 으로 수행된 작업이 <xref:System.Text.ASCIIEncoding>으로 수행된 작업보다 더 빠릅니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-219">Even for content that is entirely ASCII, operations performed with <xref:System.Text.UTF8Encoding> are faster than operations performed with <xref:System.Text.ASCIIEncoding>.</span></span>  
  
 <span data-ttu-id="c956a-220"><xref:System.Text.ASCIIEncoding> 은 레거시 응용 프로그램에만 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-220">You should consider using <xref:System.Text.ASCIIEncoding> only for legacy applications.</span></span> <span data-ttu-id="c956a-221">그러나 레거시 응용 프로그램의 경우에도 다음과 같은 이유로 <xref:System.Text.UTF8Encoding> 이 더 적합할 수 있습니다(기본 설정 가정).</span><span class="sxs-lookup"><span data-stu-id="c956a-221">However, even for legacy applications, <xref:System.Text.UTF8Encoding> might be a better choice for the following reasons (assuming default settings):</span></span>  
  
-   <span data-ttu-id="c956a-222">응용 프로그램에 엄격하게 ASCII가 아닌 콘텐츠가 있고 <xref:System.Text.ASCIIEncoding>으로 인코딩하는 경우 각각의 비 ASCII 문자가 물음표(?)로 인코딩됩니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-222">If your application has content that is not strictly ASCII and encodes it with <xref:System.Text.ASCIIEncoding>, each non-ASCII character encodes as a question mark (?).</span></span> <span data-ttu-id="c956a-223">그런 후에 응용 프로그램에서 이 데이터를 디코딩하면 정보가 손실됩니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-223">If the application then decodes this data, the information is lost.</span></span>  
  
-   <span data-ttu-id="c956a-224">응용 프로그램에 엄격하게 ASCII가 아닌 콘텐츠가 있고 <xref:System.Text.UTF8Encoding>으로 인코딩하는 경우 결과를 ASCII로 해석하면 인식할 수 없는 것처럼 보입니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-224">If your application has content that is not strictly ASCII and encodes it with <xref:System.Text.UTF8Encoding>, the result seems unintelligible if interpreted as ASCII.</span></span> <span data-ttu-id="c956a-225">그러나 응용 프로그램이 UTF-8 디코더를 사용하여 이 데이터를 디코딩하면 데이터가 성공적으로 라운드트립을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-225">However, if the application then uses a UTF-8 decoder to decode this data, the data performs a round trip successfully.</span></span>  
  
 <span data-ttu-id="c956a-226">웹 응용 프로그램에서는 웹 요청에 대한 응답으로 클라이언트에 전송되는 문자가 클라이언트에서 사용되는 인코딩을 반영해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-226">In a web application, characters sent to the client in response to a web request should reflect the encoding used on the client.</span></span> <span data-ttu-id="c956a-227">대부분의 경우 사용자에게 필요한 인코딩으로 텍스트를 표시하기 위해 <xref:System.Web.HttpResponse.ContentEncoding%2A?displayProperty=nameWithType> 속성을 <xref:System.Web.HttpRequest.ContentEncoding%2A?displayProperty=nameWithType> 속성에서 반환된 값으로 설정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-227">In most cases, you should set the <xref:System.Web.HttpResponse.ContentEncoding%2A?displayProperty=nameWithType> property to the value returned by the <xref:System.Web.HttpRequest.ContentEncoding%2A?displayProperty=nameWithType> property to display text in the encoding that the user expects.</span></span>  
  
<a name="Using"></a>   
## <a name="using-an-encoding-object"></a><span data-ttu-id="c956a-228">인코딩 개체 사용</span><span class="sxs-lookup"><span data-stu-id="c956a-228">Using an Encoding Object</span></span>  
 <span data-ttu-id="c956a-229">인코더는 문자의 문자열(가장 일반적으로 유니코드 문자)을 해당 숫자(바이트)로 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-229">An encoder converts a string of characters (most commonly, Unicode characters) to its numeric (byte) equivalent.</span></span> <span data-ttu-id="c956a-230">예를 들어 콘솔에 표시될 수 있도록 ASCII 인코더를 사용하여 유니코드 문자를 ASCII로 변환할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-230">For example, you might use an ASCII encoder to convert Unicode characters to ASCII so that they can be displayed at the console.</span></span> <span data-ttu-id="c956a-231">변환을 수행하려면 <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> 메서드를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-231">To perform the conversion, you call the <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="c956a-232">인코딩을 수행하기 전에 인코딩된 문자를 저장하는 데 필요한 바이트 수를 확인하려는 경우 <xref:System.Text.Encoding.GetByteCount%2A> 메서드를 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-232">If you want to determine how many bytes are needed to store the encoded characters before performing the encoding, you can call the <xref:System.Text.Encoding.GetByteCount%2A> method.</span></span>  
  
 <span data-ttu-id="c956a-233">다음 예제에서는 싱글바이트 배열을 사용하여 두 개의 별도 작업에서 문자열을 인코딩합니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-233">The following example uses a single byte array to encode strings in two separate operations.</span></span> <span data-ttu-id="c956a-234">바이트 배열에서 ASCII로 인코딩된 다음 바이트 집합의 시작 위치를 나타내는 인덱스를 유지 관리합니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-234">It maintains an index that indicates the starting position in the byte array for the next set of ASCII-encoded bytes.</span></span> <span data-ttu-id="c956a-235"><xref:System.Text.ASCIIEncoding.GetByteCount%28System.String%29?displayProperty=nameWithType> 메서드를 호출하여 바이트 배열이 인코딩된 문자열을 포함하기에 충분히 큰지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-235">It calls the <xref:System.Text.ASCIIEncoding.GetByteCount%28System.String%29?displayProperty=nameWithType> method to ensure that the byte array is large enough to accommodate the encoded string.</span></span> <span data-ttu-id="c956a-236">그런 다음 <xref:System.Text.ASCIIEncoding.GetBytes%28System.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Byte%5B%5D%2CSystem.Int32%29?displayProperty=nameWithType> 메서드를 호출하여 문자열의 문자를 인코딩합니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-236">It then calls the <xref:System.Text.ASCIIEncoding.GetBytes%28System.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Byte%5B%5D%2CSystem.Int32%29?displayProperty=nameWithType> method to encode the characters in the string.</span></span>  
  
 [!code-csharp[Conceptual.Encoding#8](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.encoding/cs/getbytes1.cs#8)]
 [!code-vb[Conceptual.Encoding#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.encoding/vb/getbytes1.vb#8)]  
  
 <span data-ttu-id="c956a-237">디코더는 특정 문자 인코딩을 반영하는 바이트 배열을 문자 배열 또는 문자열의 문자 집합으로 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-237">A decoder converts a byte array that reflects a particular character encoding into a set of characters, either in a character array or in a string.</span></span> <span data-ttu-id="c956a-238">바이트 배열을 문자 배열로 디코딩하려면 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 메서드를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-238">To decode a byte array into a character array, you call the <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="c956a-239">바이트 배열을 문자열로 디코딩하려면 <xref:System.Text.Encoding.GetString%2A> 메서드를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-239">To decode a byte array into a string, you call the <xref:System.Text.Encoding.GetString%2A> method.</span></span> <span data-ttu-id="c956a-240">디코딩을 수행하기 전에 디코딩된 바이트를 저장하는 데 필요한 문자 수를 확인하려는 경우 <xref:System.Text.Encoding.GetCharCount%2A> 메서드를 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-240">If you want to determine how many characters are needed to store the decoded bytes before performing the decoding, you can call the <xref:System.Text.Encoding.GetCharCount%2A> method.</span></span>  
  
 <span data-ttu-id="c956a-241">다음 예제에서는 세 개의 문자열을 인코딩한 후 단일 문자 배열로 디코딩합니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-241">The following example encodes three strings and then decodes them into a single array of characters.</span></span> <span data-ttu-id="c956a-242">문자 배열에서 디코딩된 다음 문자 집합의 시작 위치를 나타내는 인덱스를 유지 관리합니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-242">It maintains an index that indicates the starting position in the character array for the next set of decoded characters.</span></span> <span data-ttu-id="c956a-243"><xref:System.Text.ASCIIEncoding.GetCharCount%2A> 메서드를 호출하여 문자 배열이 디코딩된 모든 문자를 포함하기에 충분히 큰지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-243">It calls the <xref:System.Text.ASCIIEncoding.GetCharCount%2A> method to ensure that the character array is large enough to accommodate all the decoded characters.</span></span> <span data-ttu-id="c956a-244">그런 다음 <xref:System.Text.ASCIIEncoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29?displayProperty=nameWithType> 메서드를 호출하여 바이트 배열을 디코딩합니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-244">It then calls the <xref:System.Text.ASCIIEncoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29?displayProperty=nameWithType> method to decode the byte array.</span></span>  
  
 [!code-csharp[Conceptual.Encoding#9](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.encoding/cs/getchars1.cs#9)]
 [!code-vb[Conceptual.Encoding#9](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.encoding/vb/getchars1.vb#9)]  
  
 <span data-ttu-id="c956a-245"><xref:System.Text.Encoding> 에서 파생된 클래스의 인코딩 및 디코딩 메서드는 전체 데이터 집합에서 작동하도록 설계되었습니다. 즉, 인코딩 또는 디코딩할 모든 데이터가 단일 메서드 호출에서 제공됩니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-245">The encoding and decoding methods of a class derived from <xref:System.Text.Encoding> are designed to work on a complete set of data; that is, all the data to be encoded or decoded is supplied in a single method call.</span></span> <span data-ttu-id="c956a-246">그러나 스트림으로 데이터가 제공되고, 인코딩 또는 디코딩할 데이터를 별도의 읽기 작업에서만 사용할 수 있는 경우도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-246">However, in some cases, data is available in a stream, and the data to be encoded or decoded may be available only from separate read operations.</span></span> <span data-ttu-id="c956a-247">이 경우 인코딩 또는 디코딩 작업이 이전 호출에서 저장된 상태를 기억해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-247">This requires the encoding or decoding operation to remember any saved state from its previous invocation.</span></span> <span data-ttu-id="c956a-248"><xref:System.Text.Encoder> 및 <xref:System.Text.Decoder> 에서 파생된 클래스의 메서드는 여러 메서드 호출에 걸쳐 있는 인코딩 및 디코딩 작업을 처리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-248">Methods of classes derived from <xref:System.Text.Encoder> and <xref:System.Text.Decoder> are able to handle encoding and decoding operations that span multiple method calls.</span></span>  
  
 <span data-ttu-id="c956a-249">특정 인코딩에 대한 <xref:System.Text.Encoder> 개체는 해당 인코딩의 <xref:System.Text.Encoding.GetEncoder%2A?displayProperty=nameWithType> 속성에서 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-249">An <xref:System.Text.Encoder> object for a particular encoding is available from that encoding's <xref:System.Text.Encoding.GetEncoder%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="c956a-250">특정 인코딩에 대한 <xref:System.Text.Decoder> 개체는 해당 인코딩의 <xref:System.Text.Encoding.GetDecoder%2A?displayProperty=nameWithType> 속성에서 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-250">A <xref:System.Text.Decoder> object for a particular encoding is available from that encoding's <xref:System.Text.Encoding.GetDecoder%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="c956a-251">디코딩 작업의 경우 <xref:System.Text.Decoder>에서 파생된 클래스에 <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> 메서드가 포함되지만 <xref:System.Text.Encoding.GetString%2A?displayProperty=nameWithType>에 해당하는 메서드가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-251">For decoding operations, note that classes derived from <xref:System.Text.Decoder> include a <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> method, but they do not have a method that corresponds to <xref:System.Text.Encoding.GetString%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="c956a-252">다음 예제에서는 유니코드 바이트 배열 디코딩에 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 및 <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> 메서드를 사용하는 경우의 차이점을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-252">The following example illustrates the difference between using the <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> and <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> methods for decoding a Unicode byte array.</span></span> <span data-ttu-id="c956a-253">이 예제에서는 일부 유니코드 문자를 포함하는 문자열을 파일로 인코딩한 다음 두 개의 디코딩 메서드를 사용하여 한 번에 10바이트씩 디코딩합니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-253">The example encodes a string that contains some Unicode characters to a file, and then uses the two decoding methods to decode them ten bytes at a time.</span></span> <span data-ttu-id="c956a-254">10번째 및 11번째 바이트에서 서로게이트 쌍이 발생하기 때문에 별도 메서드 호출에서 디코딩됩니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-254">Because a surrogate pair occurs in the tenth and eleventh bytes, it is decoded in separate method calls.</span></span> <span data-ttu-id="c956a-255">출력에서 볼 수 있듯이 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 메서드는 바이트를 올바르게 디코딩할 수 없으며, 대신 U+FFFD(REPLACEMENT CHARACTER)로 바꿉니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-255">As the output shows, the <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> method is not able to correctly decode the bytes and instead replaces them with U+FFFD (REPLACEMENT CHARACTER).</span></span> <span data-ttu-id="c956a-256">반면, <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> 메서드는 바이트 배열을 성공적으로 디코딩하여 원래 문자열을 가져올 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-256">On the other hand, the <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> method is able to successfully decode the byte array to get the original string.</span></span>  
  
 [!code-csharp[Conceptual.Encoding#10](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.encoding/cs/stream1.cs#10)]
 [!code-vb[Conceptual.Encoding#10](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.encoding/vb/stream1.vb#10)]  
  
<a name="FallbackStrategy"></a>   
## <a name="choosing-a-fallback-strategy"></a><span data-ttu-id="c956a-257">대체(fallback) 전략 선택</span><span class="sxs-lookup"><span data-stu-id="c956a-257">Choosing a Fallback Strategy</span></span>  
 <span data-ttu-id="c956a-258">메서드가 문자를 인코딩 또는 디코딩하려고 하는데 매핑이 없는 경우 실패한 매핑의 처리 방법을 결정하는 대체(fallback) 전략을 구현해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-258">When a method tries to encode or decode a character but no mapping exists, it must implement a fallback strategy that determines how the failed mapping should be handled.</span></span> <span data-ttu-id="c956a-259">다음 세 가지 유형의 대체 (fallback) 전략이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-259">There are three types of fallback strategies:</span></span>  
  
-   <span data-ttu-id="c956a-260">Best-Fit Fallback</span><span class="sxs-lookup"><span data-stu-id="c956a-260">Best-fit fallback</span></span>  
  
-   <span data-ttu-id="c956a-261">Replacement Fallback</span><span class="sxs-lookup"><span data-stu-id="c956a-261">Replacement fallback</span></span>  
  
-   <span data-ttu-id="c956a-262">Exception Fallback</span><span class="sxs-lookup"><span data-stu-id="c956a-262">Exception fallback</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="c956a-263">인코딩 작업의 가장 일반적인 문제는 유니코드 문자를 특정 코드 페이지 인코딩에 매핑할 수 없는 경우에 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-263">The most common problems in encoding operations occur when a Unicode character cannot be mapped to a particular code page encoding.</span></span> <span data-ttu-id="c956a-264">디코딩 작업의 가장 일반적인 문제는 잘못된 바이트 시퀀스를 유효한 유니코드 문자로 변환할 수 없는 경우에 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-264">The most common problems in decoding operations occur when invalid byte sequences cannot be translated into valid Unicode characters.</span></span> <span data-ttu-id="c956a-265">이러한 이유로 특정 인코딩 개체에서 사용하는 대체(fallback) 전략을 알고 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-265">For these reasons, you should know which fallback strategy a particular encoding object uses.</span></span> <span data-ttu-id="c956a-266">가능하면 개체를 인스턴스화할 때 인코딩 개체에서 사용할 대체(fallback) 전략을 지정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-266">Whenever possible, you should specify the fallback strategy used by an encoding object when you instantiate the object.</span></span>  
  
<a name="BestFit"></a>   
### <a name="best-fit-fallback"></a><span data-ttu-id="c956a-267">Best-Fit Fallback</span><span class="sxs-lookup"><span data-stu-id="c956a-267">Best-Fit Fallback</span></span>  
 <span data-ttu-id="c956a-268">대상 인코딩에 문자와 정확히 일치하는 항목이 없을 경우 인코더가 유사한 문자에 매핑하려고 시도할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-268">When a character does not have an exact match in the target encoding, the encoder can try to map it to a similar character.</span></span> <span data-ttu-id="c956a-269">최적 대체(fallback)는 주로 디코딩 문제가 아니라 인코딩 문제입니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-269">(Best-fit fallback is mostly an encoding rather than a decoding issue.</span></span> <span data-ttu-id="c956a-270">성공적으로 유니코드에 매핑할 수 없는 문자가 포함된 코드 페이지는 거의 없습니다. 최적 대체(fallback)는 <xref:System.Text.Encoding.GetEncoding%28System.Int32%29?displayProperty=nameWithType> 및 <xref:System.Text.Encoding.GetEncoding%28System.String%29?displayProperty=nameWithType> 오버로드를 통해 검색되는 코드 페이지 및 더블바이트 문자 집합 인코딩의 기본값입니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-270">There are very few code pages that contain characters that cannot be successfully mapped to Unicode.) Best-fit fallback is the default for code page and double-byte character set encodings that are retrieved by the <xref:System.Text.Encoding.GetEncoding%28System.Int32%29?displayProperty=nameWithType> and <xref:System.Text.Encoding.GetEncoding%28System.String%29?displayProperty=nameWithType> overloads.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="c956a-271">이론적으로 .NET에서 제공되는 유니코드 인코딩 클래스(<xref:System.Text.UTF8Encoding>, <xref:System.Text.UnicodeEncoding> 및 <xref:System.Text.UTF32Encoding>)는 모든 문자 집합의 모든 문자를 지원하므로 최적 대체(fallback) 문제를 제거하는 데 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-271">In theory, the Unicode encoding classes provided in .NET (<xref:System.Text.UTF8Encoding>, <xref:System.Text.UnicodeEncoding>, and <xref:System.Text.UTF32Encoding>) support every character in every character set, so they can be used to eliminate best-fit fallback issues.</span></span>  
  
 <span data-ttu-id="c956a-272">최적 전략은 코드 페이지마다 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-272">Best-fit strategies vary for different code pages.</span></span> <span data-ttu-id="c956a-273">예를 들어 일부 코드 페이지에서는 전자 라틴 문자가 더 일반적인 반자 라틴 문자에 매핑됩니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-273">For example, for some code pages, full-width Latin characters map to the more common half-width Latin characters.</span></span> <span data-ttu-id="c956a-274">다른 코드 페이지에서는 이 매핑이 수행되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-274">For other code pages, this mapping is not made.</span></span> <span data-ttu-id="c956a-275">적극적인 최적 전략에서도 일부 인코딩의 일부 문자는 상상할 수 있는 최적 항목이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-275">Even under an aggressive best-fit strategy, there is no imaginable fit for some characters in some encodings.</span></span> <span data-ttu-id="c956a-276">예를 들어 중국어 표의 문자에는 코드 페이지 1252에 적합한 매핑이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-276">For example, a Chinese ideograph has no reasonable mapping to code page 1252.</span></span> <span data-ttu-id="c956a-277">이 경우 대체 문자열이 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-277">In this case, a replacement string is used.</span></span> <span data-ttu-id="c956a-278">기본적으로 이 문자열은 단일 QUESTION MARK(U+003F)입니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-278">By default, this string is just a single QUESTION MARK (U+003F).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="c956a-279">최적 전략은 자세히 문서화되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-279">Best-fit strategies are not documented in detail.</span></span> <span data-ttu-id="c956a-280">그러나 여러 가지 코드 페이지가 [유니코드 컨소시엄](https://www.unicode.org/Public/MAPPINGS/VENDORS/MICSFT/WindowsBestFit/) 웹 사이트에서 문서화됩니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-280">However, several code pages are documented at the [Unicode Consortium's](https://www.unicode.org/Public/MAPPINGS/VENDORS/MICSFT/WindowsBestFit/) website.</span></span> <span data-ttu-id="c956a-281">매핑 파일을 해석하는 방법에 대한 설명은 해당 폴더의 **readme.txt** 파일을 검토하세요.</span><span class="sxs-lookup"><span data-stu-id="c956a-281">Please review the **readme.txt** file in that folder for a description of how to interpret the mapping files.</span></span>
  
 <span data-ttu-id="c956a-282">다음 예제에서는 코드 페이지 1252(서유럽 언어에 대한 Windows 코드 페이지)를 사용하여 최적 매핑과 해당 결점을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-282">The following example uses code page 1252 (the Windows code page for Western European languages) to illustrate best-fit mapping and its drawbacks.</span></span> <span data-ttu-id="c956a-283"><xref:System.Text.Encoding.GetEncoding%28System.Int32%29?displayProperty=nameWithType> 메서드는 코드 페이지 1252에 대한 인코딩 개체를 검색하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-283">The <xref:System.Text.Encoding.GetEncoding%28System.Int32%29?displayProperty=nameWithType> method is used to retrieve an encoding object for code page 1252.</span></span> <span data-ttu-id="c956a-284">기본적으로 지원하지 않는 유니코드 문자에 대해 최적 매핑을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-284">By default, it uses a best-fit mapping for Unicode characters that it does not support.</span></span> <span data-ttu-id="c956a-285">이 예제에서는 CIRCLED LATIN CAPITAL LETTER S(U+24C8), SUPERSCRIPT FIVE(U+2075) 및 INFINITY(U+221E)라는 3개의 비 ASCII 문자가 공백으로 구분되어 포함된 문자열을 인스턴스화합니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-285">The example instantiates a string that contains three non-ASCII characters - CIRCLED LATIN CAPITAL LETTER S (U+24C8), SUPERSCRIPT FIVE (U+2075), and INFINITY (U+221E) - separated by spaces.</span></span> <span data-ttu-id="c956a-286">예제의 출력에서 볼 수 있듯이, 문자열을 인코딩할 때 공백이 아닌 원래 문자 3자가 QUESTION MARK(U+003F), DIGIT FIVE(U+0035) 및 DIGIT EIGHT(U+0038)으로 대체됩니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-286">As the output from the example shows, when the string is encoded, the three original non-space characters are replaced by QUESTION MARK (U+003F), DIGIT FIVE (U+0035), and DIGIT EIGHT (U+0038).</span></span> <span data-ttu-id="c956a-287">DIGIT EIGHT은 지원되지 않는 INFINITY 문자에 대한 특히 부적절한 대체이고, QUESTION MARK는 원래 문자에 사용할 수 있는 매핑이 없음을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-287">DIGIT EIGHT is a particularly poor replacement for the unsupported INFINITY character, and QUESTION MARK indicates that no mapping was available for the original character.</span></span>  
  
 [!code-csharp[Conceptual.Encoding#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.encoding/cs/bestfit1.cs#1)]
 [!code-vb[Conceptual.Encoding#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.encoding/vb/bestfit1.vb#1)]  
  
 <span data-ttu-id="c956a-288">최적 매핑은 유니코드 데이터를 코드 페이지 데이터로 인코딩하는 <xref:System.Text.Encoding> 개체에 대한 기본 동작이며, 이 동작에 의존하는 레거시 응용 프로그램이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-288">Best-fit mapping is the default behavior for an <xref:System.Text.Encoding> object that encodes Unicode data into code page data, and there are legacy applications that rely on this behavior.</span></span> <span data-ttu-id="c956a-289">그러나 대부분의 새 응용 프로그램은 보안상의 이유로 최적 동작을 피해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-289">However, most new applications should avoid best-fit behavior for security reasons.</span></span> <span data-ttu-id="c956a-290">예를 들어 응용 프로그램에서 최적 인코딩을 통해 도메인 이름을 넣으면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-290">For example, applications should not put a domain name through a best-fit encoding.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="c956a-291">인코딩에 대한 사용자 지정 최적 대체(fallback) 매핑을 구현할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-291">You can also implement a custom best-fit fallback mapping for an encoding.</span></span> <span data-ttu-id="c956a-292">자세한 내용은 [Implementing a Custom Fallback Strategy](../../../docs/standard/base-types/character-encoding.md#Custom) 섹션을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="c956a-292">For more information, see the [Implementing a Custom Fallback Strategy](../../../docs/standard/base-types/character-encoding.md#Custom) section.</span></span>  
  
 <span data-ttu-id="c956a-293">최적 대체(fallback)가 인코딩 개체에 대한 기본값인 경우 <xref:System.Text.Encoding.GetEncoding%28System.Int32%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29?displayProperty=nameWithType> 또는 <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29?displayProperty=nameWithType> 오버로드를 호출하여 <xref:System.Text.Encoding> 개체를 검색할 때 다른 대체(fallback) 전략을 선택할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-293">If best-fit fallback is the default for an encoding object, you can choose another fallback strategy when you retrieve an <xref:System.Text.Encoding> object by calling the <xref:System.Text.Encoding.GetEncoding%28System.Int32%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29?displayProperty=nameWithType> or <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29?displayProperty=nameWithType> overload.</span></span> <span data-ttu-id="c956a-294">다음 섹션에는 코드 페이지 1252로 매핑할 수 없는 각 문자를 별표(\*)로 대체하는 예제가 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-294">The following section includes an example that replaces each character that cannot be mapped to code page 1252 with an asterisk (\*).</span></span>  
  
 [!code-csharp[Conceptual.Encoding#3](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.encoding/cs/bestfit1a.cs#3)]
 [!code-vb[Conceptual.Encoding#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.encoding/vb/bestfit1a.vb#3)]  
  
<a name="Replacement"></a>   
### <a name="replacement-fallback"></a><span data-ttu-id="c956a-295">Replacement Fallback</span><span class="sxs-lookup"><span data-stu-id="c956a-295">Replacement Fallback</span></span>  
 <span data-ttu-id="c956a-296">대상 구성표에 문자와 정확히 일치하는 항목이 없고 매핑할 수 있는 적절한 문자가 없는 경우 응용 프로그램에서 대체 문자 또는 문자열을 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-296">When a character does not have an exact match in the target scheme, but there is no appropriate character that it can be mapped to, the application can specify a replacement character or string.</span></span> <span data-ttu-id="c956a-297">이는 유니코드 디코더의 기본 동작으로, 디코딩할 수 없는 모든 2바이트 시퀀스를 REPLACEMENT_CHARACTER(U+FFFD)로 대체합니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-297">This is the default behavior for the Unicode decoder, which replaces any two-byte sequence that it cannot decode with REPLACEMENT_CHARACTER (U+FFFD).</span></span> <span data-ttu-id="c956a-298"><xref:System.Text.ASCIIEncoding> 클래스의 기본 동작이기도 하며, 인코딩 또는 디코딩할 수 없는 각 문자를 물음표로 대체합니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-298">It is also the default behavior of the <xref:System.Text.ASCIIEncoding> class, which replaces each character that it cannot encode or decode with a question mark.</span></span> <span data-ttu-id="c956a-299">다음 예제에서는 이전 예제의 유니코드 문자열에 대한 문자 대체를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-299">The following example illustrates character replacement for the Unicode string from the previous example.</span></span> <span data-ttu-id="c956a-300">출력에서 볼 수 있듯이, ASCII 바이트 값으로 디코딩할 수 없는 각 문자는 물음표의 ASCII 코드인 0x3F로 대체됩니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-300">As the output shows, each character that cannot be decoded into an ASCII byte value is replaced by 0x3F, which is the ASCII code for a question mark.</span></span>  
  
 [!code-csharp[Conceptual.Encoding#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.encoding/cs/replacementascii.cs#2)]
 [!code-vb[Conceptual.Encoding#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.encoding/vb/replacementascii.vb#2)]  
  
 <span data-ttu-id="c956a-301">.NET에는 문자가 인코딩 또는 디코딩 작업에서 정확히 매핑되지 않는 경우 대체 문자열로 바꾸는 <xref:System.Text.EncoderReplacementFallback> 및 <xref:System.Text.DecoderReplacementFallback> 클래스가 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-301">.NET includes the <xref:System.Text.EncoderReplacementFallback> and <xref:System.Text.DecoderReplacementFallback> classes, which substitute a replacement string if a character does not map exactly in an encoding or decoding operation.</span></span> <span data-ttu-id="c956a-302">기본적으로 이 대체 문자열은 물음표지만 클래스 생성자 오버로드를 호출하여 다른 문자열을 선택할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-302">By default, this replacement string is a question mark, but you can call a class constructor overload to choose a different string.</span></span> <span data-ttu-id="c956a-303">요구 사항은 아니지만 일반적으로 대체 문자열은 단일 문자입니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-303">Typically, the replacement string is a single character, although this is not a requirement.</span></span> <span data-ttu-id="c956a-304">다음 예제에서는 별표(\*)를 사용하는 <xref:System.Text.EncoderReplacementFallback> 개체를 대체 문자열로 인스턴스화하여 코드 페이지 1252 인코더의 동작을 변경합니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-304">The following example changes the behavior of the code page 1252 encoder by instantiating an <xref:System.Text.EncoderReplacementFallback> object that uses an asterisk (\*) as a replacement string.</span></span>  
  
 [!code-csharp[Conceptual.Encoding#3](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.encoding/cs/bestfit1a.cs#3)]
 [!code-vb[Conceptual.Encoding#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.encoding/vb/bestfit1a.vb#3)]  
  
> [!NOTE]
>  <span data-ttu-id="c956a-305">인코딩에 대한 대체 클래스를 구현할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-305">You can also implement a replacement class for an encoding.</span></span> <span data-ttu-id="c956a-306">자세한 내용은 [Implementing a Custom Fallback Strategy](../../../docs/standard/base-types/character-encoding.md#Custom) 섹션을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="c956a-306">For more information, see the [Implementing a Custom Fallback Strategy](../../../docs/standard/base-types/character-encoding.md#Custom) section.</span></span>  
  
 <span data-ttu-id="c956a-307">QUESTION MARK(U+003F) 외에도 일반적으로 유니코드 REPLACEMENT CHARACTER(U+FFFD)가 대체 문자열로 사용됩니다. 특히 유니코드 문자로 변환할 수 없는 바이트 시퀀스를 디코딩하는 경우에 해당합니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-307">In addition to QUESTION MARK (U+003F), the Unicode REPLACEMENT CHARACTER (U+FFFD) is commonly used as a replacement string, particularly when decoding byte sequences that cannot be successfully translated into Unicode characters.</span></span> <span data-ttu-id="c956a-308">그러나 자유롭게 대체 문자열을 선택할 수 있으며 여러 문자를 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-308">However, you are free to choose any replacement string, and it can contain multiple characters.</span></span>  
  
<a name="Exception"></a>   
### <a name="exception-fallback"></a><span data-ttu-id="c956a-309">예외 대체(fallback)</span><span class="sxs-lookup"><span data-stu-id="c956a-309">Exception Fallback</span></span>  
 <span data-ttu-id="c956a-310">최적 대체(fallback) 또는 대체 문자열을 제공하는 대신 인코더가 문자 집합을 인코딩할 수 없는 경우 <xref:System.Text.EncoderFallbackException> 이 발생하고, 디코더가 바이트 배열을 디코딩할 수 없는 경우 <xref:System.Text.DecoderFallbackException> 이 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-310">Instead of providing a best-fit fallback or a replacement string, an encoder can throw an <xref:System.Text.EncoderFallbackException> if it is unable to encode a set of characters, and a decoder can throw a <xref:System.Text.DecoderFallbackException> if it is unable to decode a byte array.</span></span> <span data-ttu-id="c956a-311">인코딩 및 디코딩 작업에서 예외를 발생시키려면 <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29?displayProperty=nameWithType> 메서드에 각각 <xref:System.Text.EncoderExceptionFallback> 개체 및 <xref:System.Text.DecoderExceptionFallback> 개체를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-311">To throw an exception in encoding and decoding operations, you supply an <xref:System.Text.EncoderExceptionFallback> object and a <xref:System.Text.DecoderExceptionFallback> object, respectively, to the <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="c956a-312">다음 예제에서는 <xref:System.Text.ASCIIEncoding> 클래스를 사용한 예외 대체(fallback)를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-312">The following example illustrates exception fallback with the <xref:System.Text.ASCIIEncoding> class.</span></span>  
  
 [!code-csharp[Conceptual.Encoding#4](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.encoding/cs/exceptionascii.cs#4)]
 [!code-vb[Conceptual.Encoding#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.encoding/vb/exceptionascii.vb#4)]  
  
> [!NOTE]
>  <span data-ttu-id="c956a-313">인코딩 작업에 대한 사용자 지정 예외 처리기를 구현할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-313">You can also implement a custom exception handler for an encoding operation.</span></span> <span data-ttu-id="c956a-314">자세한 내용은 [Implementing a Custom Fallback Strategy](../../../docs/standard/base-types/character-encoding.md#Custom) 섹션을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="c956a-314">For more information, see the [Implementing a Custom Fallback Strategy](../../../docs/standard/base-types/character-encoding.md#Custom) section.</span></span>  
  
 <span data-ttu-id="c956a-315"><xref:System.Text.EncoderFallbackException> 및 <xref:System.Text.DecoderFallbackException> 개체는 예외를 발생시킨 조건에 대한 다음 정보를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-315">The <xref:System.Text.EncoderFallbackException> and <xref:System.Text.DecoderFallbackException> objects provide the following information about the condition that caused the exception:</span></span>  
  
-   <span data-ttu-id="c956a-316"><xref:System.Text.EncoderFallbackException> 개체에는 인코딩할 수 없는 문자가 알 수 없는 서로게이트 쌍을 나타내는지(이 경우 메서드에서 <xref:System.Text.EncoderFallbackException.IsUnknownSurrogate%2A> 가 반환됨) 또는 알 수 없는 단일 문자를 나타내는지(이 경우 메서드에서 `true`가 반환됨)를 표시하는 `false`메서드가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-316">The <xref:System.Text.EncoderFallbackException> object includes an <xref:System.Text.EncoderFallbackException.IsUnknownSurrogate%2A> method, which indicates whether the character or characters that cannot be encoded represent an unknown surrogate pair (in which case, the method returns `true`) or an unknown single character (in which case, the method returns `false`).</span></span> <span data-ttu-id="c956a-317">서로게이트 쌍의 문자는 <xref:System.Text.EncoderFallbackException.CharUnknownHigh%2A?displayProperty=nameWithType> 및 <xref:System.Text.EncoderFallbackException.CharUnknownLow%2A?displayProperty=nameWithType> 속성에서 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-317">The characters in the surrogate pair are available from the <xref:System.Text.EncoderFallbackException.CharUnknownHigh%2A?displayProperty=nameWithType> and <xref:System.Text.EncoderFallbackException.CharUnknownLow%2A?displayProperty=nameWithType> properties.</span></span> <span data-ttu-id="c956a-318">알 수 없는 단일 문자는 <xref:System.Text.EncoderFallbackException.CharUnknown%2A?displayProperty=nameWithType> 속성에서 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-318">The unknown single character is available from the <xref:System.Text.EncoderFallbackException.CharUnknown%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="c956a-319"><xref:System.Text.EncoderFallbackException.Index%2A?displayProperty=nameWithType> 속성은 인코딩할 수 없는 첫 번째 문자가 발견된 문자열의 위치를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-319">The <xref:System.Text.EncoderFallbackException.Index%2A?displayProperty=nameWithType> property indicates the position in the string at which the first character that could not be encoded was found.</span></span>  
  
-   <span data-ttu-id="c956a-320"><xref:System.Text.DecoderFallbackException> 개체에는 디코딩할 수 없는 바이트 배열을 반환하는 <xref:System.Text.DecoderFallbackException.BytesUnknown%2A> 속성이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-320">The <xref:System.Text.DecoderFallbackException> object includes a <xref:System.Text.DecoderFallbackException.BytesUnknown%2A> property that returns an array of bytes that cannot be decoded.</span></span> <span data-ttu-id="c956a-321"><xref:System.Text.DecoderFallbackException.Index%2A?displayProperty=nameWithType> 속성은 알 수 없는 바이트의 시작 위치를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-321">The <xref:System.Text.DecoderFallbackException.Index%2A?displayProperty=nameWithType> property indicates the starting position of the unknown bytes.</span></span>  
  
 <span data-ttu-id="c956a-322"><xref:System.Text.EncoderFallbackException> 및 <xref:System.Text.DecoderFallbackException> 개체는 예외에 대한 적절한 진단 정보를 제공하지만 인코딩 또는 디코딩 버퍼에 대한 액세스는 제공하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-322">Although the <xref:System.Text.EncoderFallbackException> and <xref:System.Text.DecoderFallbackException> objects provide adequate diagnostic information about the exception, they do not provide access to the encoding or decoding buffer.</span></span> <span data-ttu-id="c956a-323">따라서 인코딩 또는 디코딩 메서드 내에서 잘못된 데이터를 바꾸거나 수정할 수 있도록 허용하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-323">Therefore, they do not allow invalid data to be replaced or corrected within the encoding or decoding method.</span></span>  
  
<a name="Custom"></a>   
## <a name="implementing-a-custom-fallback-strategy"></a><span data-ttu-id="c956a-324">사용자 지정 대체(fallback) 전략 구현</span><span class="sxs-lookup"><span data-stu-id="c956a-324">Implementing a Custom Fallback Strategy</span></span>  
 <span data-ttu-id="c956a-325">코드 페이지에서 내부적으로 구현되는 최적 매핑 외에도 .NET에는 대체(fallback) 전략을 구현하기 위한 다음과 같은 클래스가 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-325">In addition to the best-fit mapping that is implemented internally by code pages, .NET includes the following classes for implementing a fallback strategy:</span></span>  
  
-   <span data-ttu-id="c956a-326"><xref:System.Text.EncoderReplacementFallback> 및 <xref:System.Text.EncoderReplacementFallbackBuffer> 를 사용하여 인코딩 작업에서 문자를 바꿉니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-326">Use <xref:System.Text.EncoderReplacementFallback> and <xref:System.Text.EncoderReplacementFallbackBuffer> to replace characters in encoding operations.</span></span>  
  
-   <span data-ttu-id="c956a-327"><xref:System.Text.DecoderReplacementFallback> 및 <xref:System.Text.DecoderReplacementFallbackBuffer> 를 사용하여 디코딩 작업에서 문자를 바꿉니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-327">Use <xref:System.Text.DecoderReplacementFallback> and <xref:System.Text.DecoderReplacementFallbackBuffer> to replace characters in decoding operations.</span></span>  
  
-   <span data-ttu-id="c956a-328"><xref:System.Text.EncoderExceptionFallback> 및 <xref:System.Text.EncoderExceptionFallbackBuffer> 를 사용하여 문자를 인코딩할 수 없는 경우 <xref:System.Text.EncoderFallbackException> 을 발생시킵니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-328">Use <xref:System.Text.EncoderExceptionFallback> and <xref:System.Text.EncoderExceptionFallbackBuffer> to throw an <xref:System.Text.EncoderFallbackException> when a character cannot be encoded.</span></span>  
  
-   <span data-ttu-id="c956a-329"><xref:System.Text.DecoderExceptionFallback> 및 <xref:System.Text.DecoderExceptionFallbackBuffer> 를 사용하여 문자를 디코딩할 수 없는 경우 <xref:System.Text.DecoderFallbackException> 을 발생시킵니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-329">Use <xref:System.Text.DecoderExceptionFallback> and <xref:System.Text.DecoderExceptionFallbackBuffer> to throw a <xref:System.Text.DecoderFallbackException> when a character cannot be decoded.</span></span>  
  
 <span data-ttu-id="c956a-330">또한 다음 단계를 수행하여 최적 대체(fallback), 교체 대체(fallback) 또는 예외 대체(fallback)를 사용하는 사용자 지정 솔루션을 구현할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-330">In addition, you can implement a custom solution that uses best-fit fallback, replacement fallback, or exception fallback, by following these steps:</span></span>  
  
1.  <span data-ttu-id="c956a-331">인코딩 작업의 경우 <xref:System.Text.EncoderFallback> 에서 클래스를 파생시키고, 디코딩 작업의 경우 <xref:System.Text.DecoderFallback> 에서 클래스를 파생시킵니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-331">Derive a class from <xref:System.Text.EncoderFallback> for encoding operations, and from <xref:System.Text.DecoderFallback> for decoding operations.</span></span>  
  
2.  <span data-ttu-id="c956a-332">인코딩 작업의 경우 <xref:System.Text.EncoderFallbackBuffer> 에서 클래스를 파생시키고, 디코딩 작업의 경우 <xref:System.Text.DecoderFallbackBuffer> 에서 클래스를 파생시킵니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-332">Derive a class from <xref:System.Text.EncoderFallbackBuffer> for encoding operations, and from <xref:System.Text.DecoderFallbackBuffer> for decoding operations.</span></span>  
  
3.  <span data-ttu-id="c956a-333">예외 대체(fallback)의 경우 미리 정의된 <xref:System.Text.EncoderFallbackException> 및 <xref:System.Text.DecoderFallbackException> 클래스가 요구를 충족하지 않는 경우 <xref:System.Exception> 또는 <xref:System.ArgumentException>과 같은 예외 개체에서 클래스를 파생시킵니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-333">For exception fallback, if the predefined <xref:System.Text.EncoderFallbackException> and <xref:System.Text.DecoderFallbackException> classes do not meet your needs, derive a class from an exception object such as <xref:System.Exception> or <xref:System.ArgumentException>.</span></span>  
  
### <a name="deriving-from-encoderfallback-or-decoderfallback"></a><span data-ttu-id="c956a-334">EncoderFallback 또는 DecoderFallback에서 파생</span><span class="sxs-lookup"><span data-stu-id="c956a-334">Deriving from EncoderFallback or DecoderFallback</span></span>  
 <span data-ttu-id="c956a-335">사용자 지정 대체(fallback) 솔루션을 구현하려면 인코딩 작업의 경우 <xref:System.Text.EncoderFallback> 에서 상속하고 디코딩 작업의 경우 <xref:System.Text.DecoderFallback> 에서 상속하는 클래스를 만들어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-335">To implement a custom fallback solution, you must create a class that inherits from <xref:System.Text.EncoderFallback> for encoding operations, and from <xref:System.Text.DecoderFallback> for decoding operations.</span></span> <span data-ttu-id="c956a-336">이러한 클래스의 인스턴스는 <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29?displayProperty=nameWithType> 메서드에 전달되며 인코딩 클래스와 대체(fallback) 구현 간의 중개자 역할을 합니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-336">Instances of these classes are passed to the <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29?displayProperty=nameWithType> method and serve as the intermediary between the encoding class and the fallback implementation.</span></span>  
  
 <span data-ttu-id="c956a-337">인코더 또는 디코더에 대한 사용자 지정 대체(fallback) 솔루션을 만드는 경우 다음과 같은 멤버를 구현해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-337">When you create a custom fallback solution for an encoder or decoder, you must implement the following members:</span></span>  
  
-   <span data-ttu-id="c956a-338">최적, 교체 또는 예외 대체(fallback)가 단일 문자를 대체하기 위해 반환할 수 있는 최대 문자 수를 반환하는 <xref:System.Text.EncoderFallback.MaxCharCount%2A?displayProperty=nameWithType> 또는 <xref:System.Text.DecoderFallback.MaxCharCount%2A?displayProperty=nameWithType> 속성.</span><span class="sxs-lookup"><span data-stu-id="c956a-338">The <xref:System.Text.EncoderFallback.MaxCharCount%2A?displayProperty=nameWithType> or <xref:System.Text.DecoderFallback.MaxCharCount%2A?displayProperty=nameWithType> property, which returns the maximum possible number of characters that the best-fit, replacement, or exception fallback can return to replace a single character.</span></span> <span data-ttu-id="c956a-339">사용자 지정 예외 대체(fallback)의 경우 해당 값은 0입니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-339">For a custom exception fallback, its value is zero.</span></span>  
  
-   <span data-ttu-id="c956a-340">사용자 지정 <xref:System.Text.EncoderFallbackBuffer> 또는 <xref:System.Text.DecoderFallbackBuffer> 구현을 반환하는 <xref:System.Text.EncoderFallback.CreateFallbackBuffer%2A?displayProperty=nameWithType> 또는 <xref:System.Text.DecoderFallback.CreateFallbackBuffer%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="c956a-340">The <xref:System.Text.EncoderFallback.CreateFallbackBuffer%2A?displayProperty=nameWithType> or <xref:System.Text.DecoderFallback.CreateFallbackBuffer%2A?displayProperty=nameWithType> method, which returns your custom <xref:System.Text.EncoderFallbackBuffer> or <xref:System.Text.DecoderFallbackBuffer> implementation.</span></span> <span data-ttu-id="c956a-341">메서드는 성공적으로 인코딩할 수 없는 첫 번째 문자를 발견할 때 인코더에 의해 호출되거나 성공적으로 디코딩할 수 없는 첫 번째 바이트를 발견할 때 디코더에 의해 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-341">The method is called by the encoder when it encounters the first character that it is unable to successfully encode, or by the decoder when it encounters the first byte that it is unable to successfully decode.</span></span>  
  
### <a name="deriving-from-encoderfallbackbuffer-or-decoderfallbackbuffer"></a><span data-ttu-id="c956a-342">EncoderFallbackBuffer 또는 DecoderFallbackBuffer에서 파생</span><span class="sxs-lookup"><span data-stu-id="c956a-342">Deriving from EncoderFallbackBuffer or DecoderFallbackBuffer</span></span>  
 <span data-ttu-id="c956a-343">사용자 지정 대체(fallback) 솔루션을 구현하려면 인코딩 작업의 경우 <xref:System.Text.EncoderFallbackBuffer> 에서 상속하고 디코딩 작업의 경우 <xref:System.Text.DecoderFallbackBuffer> 에서 상속하는 클래스도 만들어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-343">To implement a custom fallback solution, you must also create a class that inherits from <xref:System.Text.EncoderFallbackBuffer> for encoding operations, and from <xref:System.Text.DecoderFallbackBuffer> for decoding operations.</span></span> <span data-ttu-id="c956a-344">이러한 클래스의 인스턴스는 <xref:System.Text.EncoderFallback.CreateFallbackBuffer%2A> 및 <xref:System.Text.EncoderFallback> 클래스의 <xref:System.Text.DecoderFallback> 메서드에서 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-344">Instances of these classes are returned by the <xref:System.Text.EncoderFallback.CreateFallbackBuffer%2A> method  of the <xref:System.Text.EncoderFallback> and <xref:System.Text.DecoderFallback> classes.</span></span> <span data-ttu-id="c956a-345"><xref:System.Text.EncoderFallback.CreateFallbackBuffer%2A?displayProperty=nameWithType> 메서드는 인코딩할 수 없는 첫 번째 문자를 발견할 때 인코더에 의해 호출되고, <xref:System.Text.DecoderFallback.CreateFallbackBuffer%2A?displayProperty=nameWithType> 메서드는 디코딩할 수 없는 바이트를 하나 이상 발견할 때 디코더에 의해 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-345">The <xref:System.Text.EncoderFallback.CreateFallbackBuffer%2A?displayProperty=nameWithType> method is called by the encoder when it encounters the first character that it is not able to encode, and the <xref:System.Text.DecoderFallback.CreateFallbackBuffer%2A?displayProperty=nameWithType> method is called by the decoder when it encounters one or more bytes that it is not able to decode.</span></span> <span data-ttu-id="c956a-346"><xref:System.Text.EncoderFallbackBuffer> 및 <xref:System.Text.DecoderFallbackBuffer> 클래스는 대체(fallback) 구현을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-346">The <xref:System.Text.EncoderFallbackBuffer> and <xref:System.Text.DecoderFallbackBuffer> classes provide the fallback implementation.</span></span> <span data-ttu-id="c956a-347">각 인스턴스는 인코딩할 수 없는 문자 또는 디코딩할 수 없는 바이트를 대체하는 대체(fallback) 문자가 포함된 버퍼를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-347">Each instance represents a buffer that contains the fallback characters that will replace the character that cannot be encoded or the byte sequence that cannot be decoded.</span></span>  
  
 <span data-ttu-id="c956a-348">인코더 또는 디코더에 대한 사용자 지정 대체(fallback) 솔루션을 만드는 경우 다음과 같은 멤버를 구현해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-348">When you create a custom fallback solution for an encoder or decoder, you must implement the following members:</span></span>  
  
-   <span data-ttu-id="c956a-349"><xref:System.Text.EncoderFallbackBuffer.Fallback%2A?displayProperty=nameWithType> 또는 <xref:System.Text.DecoderFallbackBuffer.Fallback%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="c956a-349">The <xref:System.Text.EncoderFallbackBuffer.Fallback%2A?displayProperty=nameWithType> or <xref:System.Text.DecoderFallbackBuffer.Fallback%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="c956a-350"><xref:System.Text.EncoderFallbackBuffer.Fallback%2A?displayProperty=nameWithType>은 인코딩할 수 없는 문자 정보를 대체(fallback) 버퍼에 제공하기 위해 인코더에서 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-350"><xref:System.Text.EncoderFallbackBuffer.Fallback%2A?displayProperty=nameWithType> is called by the encoder to provide the fallback buffer with information about the character that it cannot encode.</span></span> <span data-ttu-id="c956a-351">인코딩할 문자가 서로게이트 쌍일 수 있으므로 이 메서드는 오버로드됩니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-351">Because the character to be encoded may be a surrogate pair, this method is overloaded.</span></span> <span data-ttu-id="c956a-352">하나의 오버로드에는 인코딩할 문자 및 문자열에서 해당 인덱스가 전달됩니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-352">One overload is passed the character to be encoded and its index in the string.</span></span> <span data-ttu-id="c956a-353">두 번째 오버로드에는 상위 및 하위 서로게이트와 문자열에서 해당 인덱스가 전달됩니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-353">The second overload is passed the high and low surrogate along with its index in the string.</span></span> <span data-ttu-id="c956a-354"><xref:System.Text.DecoderFallbackBuffer.Fallback%2A?displayProperty=nameWithType> 메서드는 디코딩할 수 없는 바이트 정보를 대체(fallback) 버퍼에 제공하기 위해 디코더에서 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-354">The <xref:System.Text.DecoderFallbackBuffer.Fallback%2A?displayProperty=nameWithType> method is called by the decoder to provide the fallback buffer with information about the bytes that it cannot decode.</span></span> <span data-ttu-id="c956a-355">이 메서드에는 디코딩할 수 없는 바이트 배열 및 첫 번째 바이트의 인덱스가 전달됩니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-355">This method is passed an array of bytes that it cannot decode, along with the index of the first byte.</span></span> <span data-ttu-id="c956a-356">대체(fallback) 버퍼가 최적 또는 교체 문자를 제공할 수 있는 경우 대체(fallback) 메서드에서 `true` 를 반환해야 하고, 그러지 않으면 `false`를 반환해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-356">The fallback method should return `true` if the fallback buffer can supply a best-fit or replacement character or characters; otherwise, it should return `false`.</span></span> <span data-ttu-id="c956a-357">예외 대체(fallback)의 경우 대체(fallback) 메서드에서 예외를 발생시켜야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-357">For an exception fallback, the fallback method should throw an exception.</span></span>  
  
-   <span data-ttu-id="c956a-358">인코더 또는 디코더가 대체(fallback) 버퍼에서 다음 문자를 가져오기 위해 반복적으로 호출하는 <xref:System.Text.EncoderFallbackBuffer.GetNextChar%2A?displayProperty=nameWithType> 또는 <xref:System.Text.DecoderFallbackBuffer.GetNextChar%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="c956a-358">The <xref:System.Text.EncoderFallbackBuffer.GetNextChar%2A?displayProperty=nameWithType> or <xref:System.Text.DecoderFallbackBuffer.GetNextChar%2A?displayProperty=nameWithType> method, which is called repeatedly by the encoder or decoder to get the next character from the fallback buffer.</span></span> <span data-ttu-id="c956a-359">모든 대체(fallback) 문자가 반환되고 나면 메서드에서 U+0000을 반환해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-359">When all fallback characters have been returned, the method should return U+0000.</span></span>  
  
-   <span data-ttu-id="c956a-360">대체(fallback) 버퍼에 남아 있는 문자 수를 반환하는 <xref:System.Text.EncoderFallbackBuffer.Remaining%2A?displayProperty=nameWithType> 또는 <xref:System.Text.DecoderFallbackBuffer.Remaining%2A?displayProperty=nameWithType> 속성</span><span class="sxs-lookup"><span data-stu-id="c956a-360">The <xref:System.Text.EncoderFallbackBuffer.Remaining%2A?displayProperty=nameWithType> or <xref:System.Text.DecoderFallbackBuffer.Remaining%2A?displayProperty=nameWithType> property, which returns the number of characters remaining in the fallback buffer.</span></span>  
  
-   <span data-ttu-id="c956a-361">대체(fallback) 버퍼의 현재 위치를 이전 문자로 이동하는 <xref:System.Text.EncoderFallbackBuffer.MovePrevious%2A?displayProperty=nameWithType> 또는 <xref:System.Text.DecoderFallbackBuffer.MovePrevious%2A?displayProperty=nameWithType> 메서드</span><span class="sxs-lookup"><span data-stu-id="c956a-361">The <xref:System.Text.EncoderFallbackBuffer.MovePrevious%2A?displayProperty=nameWithType> or <xref:System.Text.DecoderFallbackBuffer.MovePrevious%2A?displayProperty=nameWithType> method, which moves the current position in the fallback buffer to the previous character.</span></span>  
  
-   <span data-ttu-id="c956a-362">대체(fallback) 버퍼를 다시 초기화하는 <xref:System.Text.EncoderFallbackBuffer.Reset%2A?displayProperty=nameWithType> 또는 <xref:System.Text.DecoderFallbackBuffer.Reset%2A?displayProperty=nameWithType> 메서드</span><span class="sxs-lookup"><span data-stu-id="c956a-362">The <xref:System.Text.EncoderFallbackBuffer.Reset%2A?displayProperty=nameWithType> or <xref:System.Text.DecoderFallbackBuffer.Reset%2A?displayProperty=nameWithType> method, which reinitializes the fallback buffer.</span></span>  
  
 <span data-ttu-id="c956a-363">대체(fallback) 구현이 최적 대체(fallback) 또는 교체 대체(fallback)인 경우 <xref:System.Text.EncoderFallbackBuffer> 및 <xref:System.Text.DecoderFallbackBuffer> 에서 파생된 클래스가 두 개의 전용 인스턴스 필드(버퍼의 정확한 문자 수 및 버퍼에서 반환할 다음 문자의 인덱스)도 유지 관리합니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-363">If the fallback implementation is a best-fit fallback or a replacement fallback, the classes derived from <xref:System.Text.EncoderFallbackBuffer> and <xref:System.Text.DecoderFallbackBuffer> also maintain two private instance fields: the exact number of characters in the buffer; and the index of the next character in the buffer to return.</span></span>  
  
### <a name="an-encoderfallback-example"></a><span data-ttu-id="c956a-364">EncoderFallback 예제</span><span class="sxs-lookup"><span data-stu-id="c956a-364">An EncoderFallback Example</span></span>  
 <span data-ttu-id="c956a-365">이전 예제에서는 교체 대체(fallback)를 사용하여 ASCII 문자에 응답하지 않은 유니코드 문자를 별표(\*)로 대체했습니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-365">An earlier example used replacement fallback to replace Unicode characters that did not correspond to ASCII characters with an asterisk (\*).</span></span> <span data-ttu-id="c956a-366">다음 예제에서는 사용자 지정 최적 대체(fallback) 구현을 대신 사용하여 보다 효과적인 비 ASCII 문자 매핑을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-366">The following example uses a custom best-fit fallback implementation instead to provide a better mapping of non-ASCII characters.</span></span>  
  
 <span data-ttu-id="c956a-367">다음 코드에서는 비 ASCII 문자의 최적 매핑을 처리하기 위해 `CustomMapper` 에서 파생된 <xref:System.Text.EncoderFallback> 라는 클래스를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-367">The following code defines a class named `CustomMapper` that is derived from <xref:System.Text.EncoderFallback> to handle the best-fit mapping of non-ASCII characters.</span></span> <span data-ttu-id="c956a-368">해당 `CreateFallbackBuffer` 메서드는 `CustomMapperFallbackBuffer` 구현을 제공하는 <xref:System.Text.EncoderFallbackBuffer> 개체를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-368">Its `CreateFallbackBuffer` method returns a `CustomMapperFallbackBuffer` object, which provides the <xref:System.Text.EncoderFallbackBuffer> implementation.</span></span> <span data-ttu-id="c956a-369">`CustomMapper` 클래스는 <xref:System.Collections.Generic.Dictionary%602> 개체를 사용하여 지원되지 않는 유니코드 문자(키 값) 및 해당 8비트 문자(64비트 정수에서는 연속된 2바이트에 저장됨)의 매핑을 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-369">The `CustomMapper` class uses a <xref:System.Collections.Generic.Dictionary%602> object to store the mappings of unsupported Unicode characters (the key value) and their corresponding 8-bit characters (which are stored in two consecutive bytes in a 64-bit integer).</span></span> <span data-ttu-id="c956a-370">대체(fallback) 버퍼에서 이 매핑을 사용할 수 있도록 `CustomMapper` 인스턴스가 `CustomMapperFallbackBuffer` 클래스 생성자에 매개 변수로 전달됩니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-370">To make this mapping available to the fallback buffer, the `CustomMapper` instance is passed as a parameter to the `CustomMapperFallbackBuffer` class constructor.</span></span> <span data-ttu-id="c956a-371">가장 긴 매핑은 유니코드 문자 U+221E에 해당하는 문자열 "INF"이므로 `MaxCharCount` 속성은 3을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-371">Because the longest mapping is the string "INF" for the Unicode character U+221E, the `MaxCharCount` property returns 3.</span></span>  
  
 [!code-csharp[Conceptual.Encoding#5](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.encoding/cs/custom1.cs#5)]
 [!code-vb[Conceptual.Encoding#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.encoding/vb/custom1.vb#5)]  
  
 <span data-ttu-id="c956a-372">다음 코드에서는 `CustomMapperFallbackBuffer` 에서 파생된 <xref:System.Text.EncoderFallbackBuffer>클래스를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-372">The following code defines the `CustomMapperFallbackBuffer` class, which is derived from <xref:System.Text.EncoderFallbackBuffer>.</span></span> <span data-ttu-id="c956a-373">최적 매핑을 포함하며 `CustomMapper` 인스턴스에서 정의된 사전은 해당 클래스 생성자에서 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-373">The dictionary that contains best-fit mappings and that is defined in the `CustomMapper` instance is available from its class constructor.</span></span> <span data-ttu-id="c956a-374">ASCII 인코더가 인코딩할 수 없는 유니코드 문자가 매핑 사전에 정의된 경우 해당 `Fallback` 메서드가 `true` 를 반환하고, 그러지 않으면 `false`를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-374">Its `Fallback` method returns `true` if any of the Unicode characters that the ASCII encoder cannot encode are defined in the mapping dictionary; otherwise, it returns `false`.</span></span> <span data-ttu-id="c956a-375">각 대체(fallback)에서 private `count` 변수는 반환해야 하는 남은 문자 수를 나타내고, private `index` 변수는 문자열 버퍼 `charsToReturn`에서 반환할 다음 문자의 위치를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-375">For each fallback, the private `count` variable indicates the number of characters that remain to be returned, and the private `index` variable indicates the position in the string buffer, `charsToReturn`, of the next character to return.</span></span>  
  
 [!code-csharp[Conceptual.Encoding#6](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.encoding/cs/custom1.cs#6)]
 [!code-vb[Conceptual.Encoding#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.encoding/vb/custom1.vb#6)]  
  
 <span data-ttu-id="c956a-376">다음 코드는 `CustomMapper` 개체를 인스턴스화하고 해당 인스턴스를 <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29?displayProperty=nameWithType> 메서드에 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-376">The following code then instantiates the `CustomMapper` object and passes an instance of it to the <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="c956a-377">출력은 최적 대체(fallback) 구현에서 원래 문자열에 있는 3자의 비 ASCII 문자를 성공적으로 처리했음을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="c956a-377">The output indicates that the best-fit fallback implementation successfully handles the three non-ASCII characters in the original string.</span></span>  
  
 [!code-csharp[Conceptual.Encoding#7](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.encoding/cs/custom1.cs#7)]
 [!code-vb[Conceptual.Encoding#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.encoding/vb/custom1.vb#7)]  
  
## <a name="see-also"></a><span data-ttu-id="c956a-378">참고 항목</span><span class="sxs-lookup"><span data-stu-id="c956a-378">See also</span></span>

- <xref:System.Text.Encoder>  
- <xref:System.Text.Decoder>  
- <xref:System.Text.DecoderFallback>  
- <xref:System.Text.Encoding>  
- <xref:System.Text.EncoderFallback>  
- [<span data-ttu-id="c956a-379">전역화 및 지역화</span><span class="sxs-lookup"><span data-stu-id="c956a-379">Globalization and Localization</span></span>](../../../docs/standard/globalization-localization/index.md)

---
title: "응용 프로그램 도메인 리소스 모니터링"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-standard
ms.tgt_pltfrm: 
ms.topic: article
helpviewer_keywords:
- monitoring managed memory use by application domain
- application domains, memory use
- memory use, monitoring
- application domains, resource monitoring
ms.assetid: 318bedf8-7f35-4f00-b34a-2b7b8e3fa315
caps.latest.revision: "8"
author: rpetrusha
ms.author: ronpet
manager: wpickett
ms.openlocfilehash: 62a514f94857044af5020d36a1cfd6ce06741ac7
ms.sourcegitcommit: 4f3fef493080a43e70e951223894768d36ce430a
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 11/21/2017
---
# <a name="application-domain-resource-monitoring"></a><span data-ttu-id="a867c-102">응용 프로그램 도메인 리소스 모니터링</span><span class="sxs-lookup"><span data-stu-id="a867c-102">Application Domain Resource Monitoring</span></span>
<span data-ttu-id="a867c-103">응용 프로그램 도메인 리소스 모니터링 (ARM)에 호스트를 응용 프로그램 도메인 별로 CPU 및 메모리 사용량을 모니터링할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a867c-103">Application domain resource monitoring (ARM) enables hosts to monitor CPU and memory usage by application domain.</span></span> <span data-ttu-id="a867c-104">ASP.NET 같은 장기 실행 프로세스의 많은 응용 프로그램 도메인을 사용 하는 호스트에 대 한 유용 합니다.</span><span class="sxs-lookup"><span data-stu-id="a867c-104">This is useful for hosts such as ASP.NET that use many application domains in a long-running process.</span></span> <span data-ttu-id="a867c-105">호스트는 문제가 있는 응용 프로그램을 식별할 수 있으 나만 전체 프로세스의 성능이 저하 되는지 하는 응용 프로그램의 응용 프로그램 도메인을 언로드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a867c-105">The host can unload the application domain of an application that is adversely affecting the performance of the entire process, but only if it can identify the problematic application.</span></span> <span data-ttu-id="a867c-106">ARM 이러한 결정을 내리는 데 사용할 수 있는 정보를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="a867c-106">ARM provides information that can be used to assist in making such decisions.</span></span>  
  
 <span data-ttu-id="a867c-107">예를 들어 호스팅 서비스가 ASP.NET 서버에서 실행 되는 많은 응용 프로그램을 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a867c-107">For example, a hosting service might have many applications running on an ASP.NET server.</span></span> <span data-ttu-id="a867c-108">한 응용 프로그램 프로세스에서 너무 많은 메모리 또는 프로세서 시간이 너무 오래 사용을 시작 하면 호스팅 서비스에서 문제가 발생 하는 응용 프로그램 도메인을 식별 하기 ARM를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a867c-108">If one application in the process begins consuming too much memory or too much processor time, the hosting service can use ARM to identify the application domain that is causing the problem.</span></span>  
  
 <span data-ttu-id="a867c-109">ARM은가 볍 라이브 응용 프로그램에서 사용 하도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="a867c-109">ARM is sufficiently lightweight to use in live applications.</span></span> <span data-ttu-id="a867c-110">ETW (Windows 용) 또는 직접 관리 또는 네이티브 Api를 통해 이벤트 추적을 사용 하 여 정보에 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a867c-110">You can access the information by using event tracing for Windows (ETW) or directly through managed or native APIs.</span></span>  
  
## <a name="enabling-resource-monitoring"></a><span data-ttu-id="a867c-111">리소스 모니터링을 사용 하도록 설정</span><span class="sxs-lookup"><span data-stu-id="a867c-111">Enabling Resource Monitoring</span></span>  
 <span data-ttu-id="a867c-112">ARM 네 가지 방법으로 사용할 수 있는: 공용 언어 런타임 (CLR)이 시작 될 때 구성 파일을를 제공 하 여 관리 되지 않는 사용 하 여 호스팅 API 관리 코드를 사용 하거나 ARM ETW 이벤트를 수신 합니다.</span><span class="sxs-lookup"><span data-stu-id="a867c-112">ARM can be enabled in four ways: by supplying a configuration file when the common language runtime (CLR) is started, by using an unmanaged hosting API, by using managed code, or by listening to ARM ETW events.</span></span>  
  
 <span data-ttu-id="a867c-113">ARM이 활성화 되는 즉시 프로세스의 모든 응용 프로그램 도메인에서 데이터 수집 시작 합니다. ARM을 활성화 하기 전 응용 프로그램 도메인이 만들어진 경우 ARM 활성화 응용 프로그램 도메인이 만들어진 때가 아니라 누적 데이터 시작 됩니다. 활성화 되 면 ARM은 해제할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="a867c-113">As soon as ARM is enabled, it begins collecting data on all application domains in the process.If an application domain was created before ARM is enabled, cumulative data starts when ARM is enabled, not when the application domain was created.Once it is enabled, ARM cannot be disabled.</span></span>  
  
-   <span data-ttu-id="a867c-114">추가 하 여 ARM CLR 시작에 사용할 수 있습니다는 [ \<appDomainResourceMonitoring >](../../../docs/framework/configure-apps/file-schema/runtime/appdomainresourcemonitoring-element.md) 구성 파일을 설정 하는 요소는 `enabled` 특성을 `true`합니다.</span><span class="sxs-lookup"><span data-stu-id="a867c-114">You can enable ARM at CLR startup by adding the [\<appDomainResourceMonitoring>](../../../docs/framework/configure-apps/file-schema/runtime/appdomainresourcemonitoring-element.md) element to the configuration file, and setting the `enabled` attribute to `true`.</span></span> <span data-ttu-id="a867c-115">값이 `false` ARM 시작 시 사용할 수 없습니다 (기본값)만 의미 이므로, 다른 인증 메커니즘 중 하나를 사용 하 여 나중에 활성화할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a867c-115">A value of `false` (the default) means only that ARM is not enabled at startup; you can activate it later by using one of the other activation mechanisms.</span></span>  
  
-   <span data-ttu-id="a867c-116">호스트를 요청 하 여 ARM을 활성화할 수는 [ICLRAppDomainResourceMonitor](../../../docs/framework/unmanaged-api/hosting/iclrappdomainresourcemonitor-interface.md) 인터페이스를 호스트 합니다.</span><span class="sxs-lookup"><span data-stu-id="a867c-116">The host can enable ARM by requesting the [ICLRAppDomainResourceMonitor](../../../docs/framework/unmanaged-api/hosting/iclrappdomainresourcemonitor-interface.md) hosting interface.</span></span> <span data-ttu-id="a867c-117">이 인터페이스 성공적으로 가져온 후에 ARM 활성화 됩니다.</span><span class="sxs-lookup"><span data-stu-id="a867c-117">Once this interface is successfully obtained, ARM is enabled.</span></span>  
  
-   <span data-ttu-id="a867c-118">관리 코드는 정적 설정 하 여 ARM를 사용할 수 있습니다 (`Shared` Visual basic에서) <xref:System.AppDomain.MonitoringIsEnabled%2A?displayProperty=nameWithType> 속성을 `true`합니다.</span><span class="sxs-lookup"><span data-stu-id="a867c-118">Managed code can enable ARM by setting the static (`Shared` in Visual Basic) <xref:System.AppDomain.MonitoringIsEnabled%2A?displayProperty=nameWithType> property to `true`.</span></span> <span data-ttu-id="a867c-119">속성이 설정 되는 즉시 ARM 활성화 됩니다.</span><span class="sxs-lookup"><span data-stu-id="a867c-119">As soon as the property is set, ARM is enabled.</span></span>  
  
-   <span data-ttu-id="a867c-120">ETW 이벤트를 수신 하 여 시작 된 후 ARM을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a867c-120">You can enable ARM after startup by listening to ETW events.</span></span> <span data-ttu-id="a867c-121">ARM을 사용 하 고 공용 공급자를 사용 하도록 설정 하면 모든 응용 프로그램 도메인에 대 한 이벤트를 발생 시키기 시작 `Microsoft-Windows-DotNETRuntime` 를 사용 하 여는 `AppDomainResourceManagementKeyword` 키워드입니다.</span><span class="sxs-lookup"><span data-stu-id="a867c-121">ARM is enabled and begins raising events for all application domains when you enable the public provider `Microsoft-Windows-DotNETRuntime` by using the `AppDomainResourceManagementKeyword` keyword.</span></span> <span data-ttu-id="a867c-122">데이터와 응용 프로그램 도메인과 스레드 상관 관계를 분석 하려면 설정도 해야는 `Microsoft-Windows-DotNETRuntimeRundown` 인 공급자는 `ThreadingKeyword` 키워드입니다.</span><span class="sxs-lookup"><span data-stu-id="a867c-122">To correlate data with application domains and threads, you must also enable the `Microsoft-Windows-DotNETRuntimeRundown` provider with the `ThreadingKeyword` keyword.</span></span>  
  
## <a name="using-arm"></a><span data-ttu-id="a867c-123">ARM를 사용 하 여</span><span class="sxs-lookup"><span data-stu-id="a867c-123">Using ARM</span></span>  
 <span data-ttu-id="a867c-124">ARM에서는 세 가지 종류의 메모리 사용에 대 한 정보 및 응용 프로그램 도메인에서 사용 되는 총 프로세서 시간을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="a867c-124">ARM provides the total processor time that is used by an application domain and three kinds of information about memory use.</span></span>  
  
-   <span data-ttu-id="a867c-125">**응용 프로그램 도메인에 대 한 프로세서 시간 (초) 총**: 시간의 수명 동안 응용 프로그램 도메인에서 실행 하는 데 걸린 모든 스레드에 대 한 운영 체제에서 보고 한 스레드 시간을 추가 하 여이 계산 됩니다.</span><span class="sxs-lookup"><span data-stu-id="a867c-125">**Total processor time for an application domain, in seconds**: This is calculated by adding up the thread times reported by the operating system for all threads that spent time executing in the application domain during its lifetime.</span></span> <span data-ttu-id="a867c-126">차단 되거나 대기 중인 스레드 프로세서 시간을 사용 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="a867c-126">Blocked or sleeping threads do not use processor time.</span></span> <span data-ttu-id="a867c-127">스레드가 네이티브 코드를 호출 스레드가 네이티브 코드에서 소비한 시간 생성 되었으므로 호출 응용 프로그램 도메인에 대 한 수에 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="a867c-127">When a thread calls into native code, the time that the thread spends in native code is included in the count for the application domain where the call was made.</span></span>  
  
    -   <span data-ttu-id="a867c-128">관리 되는 API: <xref:System.AppDomain.MonitoringTotalProcessorTime%2A?displayProperty=nameWithType> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="a867c-128">Managed API: <xref:System.AppDomain.MonitoringTotalProcessorTime%2A?displayProperty=nameWithType> property.</span></span>  
  
    -   <span data-ttu-id="a867c-129">API 호스팅: [iclrappdomainresourcemonitor:: Getcurrentcputime](../../../docs/framework/unmanaged-api/hosting/iclrappdomainresourcemonitor-getcurrentcputime-method.md) 메서드.</span><span class="sxs-lookup"><span data-stu-id="a867c-129">Hosting API: [ICLRAppDomainResourceMonitor::GetCurrentCpuTime](../../../docs/framework/unmanaged-api/hosting/iclrappdomainresourcemonitor-getcurrentcputime-method.md) method.</span></span>  
  
    -   <span data-ttu-id="a867c-130">ETW 이벤트: `ThreadCreated`, `ThreadAppDomainEnter`, 및 `ThreadTerminated` 이벤트입니다.</span><span class="sxs-lookup"><span data-stu-id="a867c-130">ETW events: `ThreadCreated`, `ThreadAppDomainEnter`, and `ThreadTerminated` events.</span></span> <span data-ttu-id="a867c-131">공급자 및 키워드에 대 한 내용은 "AppDomain 리소스 모니터링 이벤트"를 참조 [CLR ETW 이벤트](../../../docs/framework/performance/clr-etw-events.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="a867c-131">For information about providers and keywords, see "AppDomain Resource Monitoring Events" in [CLR ETW Events](../../../docs/framework/performance/clr-etw-events.md).</span></span>  
  
-   <span data-ttu-id="a867c-132">**바이트에서의 수명 동안 응용 프로그램 도메인으로 만든 관리 되는 할당 총**: 할당 된 개체의 수명이 짧은 수 있으므로 총 할당 항상 응용 프로그램 도메인의 메모리 사용을 반영 하지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="a867c-132">**Total managed allocations made by an application domain during its lifetime, in bytes**: Total allocations do not always reflect memory use by an application domain, because the allocated objects might be short-lived.</span></span> <span data-ttu-id="a867c-133">그러나 할당 하 고 큰 수의 개체를 해제 하는 응용 프로그램, 경우에 할당의 비용 상당한 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a867c-133">However, if an application allocates and frees huge numbers of objects, the cost of the allocations could be significant.</span></span>  
  
    -   <span data-ttu-id="a867c-134">관리 되는 API: <xref:System.AppDomain.MonitoringTotalAllocatedMemorySize%2A?displayProperty=nameWithType> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="a867c-134">Managed API: <xref:System.AppDomain.MonitoringTotalAllocatedMemorySize%2A?displayProperty=nameWithType> property.</span></span>  
  
    -   <span data-ttu-id="a867c-135">API 호스팅: [iclrappdomainresourcemonitor:: Getcurrentallocated](../../../docs/framework/unmanaged-api/hosting/iclrappdomainresourcemonitor-getcurrentallocated-method.md) 메서드.</span><span class="sxs-lookup"><span data-stu-id="a867c-135">Hosting API: [ICLRAppDomainResourceMonitor::GetCurrentAllocated](../../../docs/framework/unmanaged-api/hosting/iclrappdomainresourcemonitor-getcurrentallocated-method.md) method.</span></span>  
  
    -   <span data-ttu-id="a867c-136">ETW 이벤트: `AppDomainMemAllocated` 이벤트 `Allocated` 필드입니다.</span><span class="sxs-lookup"><span data-stu-id="a867c-136">ETW events: `AppDomainMemAllocated` event, `Allocated` field.</span></span>  
  
-   <span data-ttu-id="a867c-137">**관리 되는 메모리를 바이트 단위로 응용 프로그램 도메인에서 참조 하는 가장 최근의 전체 차단 수집에도 유지 되 고**:이 번호는 정확한 full, 한 후에 차단 수집 합니다.</span><span class="sxs-lookup"><span data-stu-id="a867c-137">**Managed memory, in bytes, that is referenced by an application domain and that survived the most recent full, blocking collection**: This number is accurate only after a full, blocking collection.</span></span> <span data-ttu-id="a867c-138">(즉 백그라운드에서 발생 하 고 응용 프로그램을 차단 하지 않습니다는 동시 컬렉션입니다.) 예를 들어는 <xref:System.GC.Collect?displayProperty=nameWithType> 메서드 오버 로드 하면 전체 차단 수집 합니다.</span><span class="sxs-lookup"><span data-stu-id="a867c-138">(This is in contrast to concurrent collections, which occur in the background and do not block the application.) For example, the <xref:System.GC.Collect?displayProperty=nameWithType> method overload causes a full, blocking collection.</span></span>  
  
    -   <span data-ttu-id="a867c-139">관리 되는 API: <xref:System.AppDomain.MonitoringSurvivedMemorySize%2A?displayProperty=nameWithType> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="a867c-139">Managed API: <xref:System.AppDomain.MonitoringSurvivedMemorySize%2A?displayProperty=nameWithType> property.</span></span>  
  
    -   <span data-ttu-id="a867c-140">API 호스팅: [iclrappdomainresourcemonitor:: Getcurrentsurvived](../../../docs/framework/unmanaged-api/hosting/iclrappdomainresourcemonitor-getcurrentsurvived-method.md) 메서드, `pAppDomainBytesSurvived` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="a867c-140">Hosting API: [ICLRAppDomainResourceMonitor::GetCurrentSurvived](../../../docs/framework/unmanaged-api/hosting/iclrappdomainresourcemonitor-getcurrentsurvived-method.md) method, `pAppDomainBytesSurvived` parameter.</span></span>  
  
    -   <span data-ttu-id="a867c-141">ETW 이벤트: `AppDomainMemSurvived` 이벤트 `Survived` 필드입니다.</span><span class="sxs-lookup"><span data-stu-id="a867c-141">ETW events: `AppDomainMemSurvived` event, `Survived` field.</span></span>  
  
-   <span data-ttu-id="a867c-142">**관리 되는 메모리 (바이트), 프로세스에 의해 참조 되는 및 가장 최근의 전체 차단 수집에도 유지 되는 총**: 개별 응용 프로그램 도메인에 대 한 남은 메모리는이 수와 비교할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a867c-142">**Total managed memory, in bytes, that is referenced by the process and that survived the most recent full, blocking collection**: The survived memory for individual application domains can be compared to this number.</span></span>  
  
    -   <span data-ttu-id="a867c-143">관리 되는 API: <xref:System.AppDomain.MonitoringSurvivedProcessMemorySize%2A?displayProperty=nameWithType> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="a867c-143">Managed API: <xref:System.AppDomain.MonitoringSurvivedProcessMemorySize%2A?displayProperty=nameWithType> property.</span></span>  
  
    -   <span data-ttu-id="a867c-144">API 호스팅: [iclrappdomainresourcemonitor:: Getcurrentsurvived](../../../docs/framework/unmanaged-api/hosting/iclrappdomainresourcemonitor-getcurrentsurvived-method.md) 메서드, `pTotalBytesSurvived` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="a867c-144">Hosting API: [ICLRAppDomainResourceMonitor::GetCurrentSurvived](../../../docs/framework/unmanaged-api/hosting/iclrappdomainresourcemonitor-getcurrentsurvived-method.md) method, `pTotalBytesSurvived` parameter.</span></span>  
  
    -   <span data-ttu-id="a867c-145">ETW 이벤트: `AppDomainMemSurvived` 이벤트 `ProcessSurvived` 필드입니다.</span><span class="sxs-lookup"><span data-stu-id="a867c-145">ETW events: `AppDomainMemSurvived` event, `ProcessSurvived` field.</span></span>  
  
### <a name="determining-when-a-full-blocking-collection-occurs"></a><span data-ttu-id="a867c-146">전체 시기를 결정 하는, 차단 수집이 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="a867c-146">Determining When a Full, Blocking Collection Occurs</span></span>  
 <span data-ttu-id="a867c-147">남은 메모리의 수를 정확 하 게 하는 시기를 확인 하려면 전체 차단 수집 발생 했을 때만 알고 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a867c-147">To determine when counts of survived memory are accurate, you need to know when a full, blocking collection has just occurred.</span></span> <span data-ttu-id="a867c-148">이 작업을 수행 하는 방법은 ARM 통계를 검사 하는 데 API에 따라 달라 집니다.</span><span class="sxs-lookup"><span data-stu-id="a867c-148">The method for doing this depends on the API you use to examine ARM statistics.</span></span>  
  
#### <a name="managed-api"></a><span data-ttu-id="a867c-149">관리 되는 API</span><span class="sxs-lookup"><span data-stu-id="a867c-149">Managed API</span></span>  
 <span data-ttu-id="a867c-150">속성을 사용 하는 경우는 <xref:System.AppDomain> 사용할 수 있습니다 클래스는 <xref:System.GC.RegisterForFullGCNotification%2A?displayProperty=nameWithType> 전체 컬렉션에 대 한 알림을 등록 합니다.</span><span class="sxs-lookup"><span data-stu-id="a867c-150">If you use the properties of the <xref:System.AppDomain> class, you can use the <xref:System.GC.RegisterForFullGCNotification%2A?displayProperty=nameWithType> method to register for notification of full collections.</span></span> <span data-ttu-id="a867c-151">컬렉션의 접근 방식 보다는 컬렉션의 완료를 대기 하는 사용 하는 임계값 중요 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="a867c-151">The threshold you use is not important, because you are waiting for the completion of a collection rather than the approach of a collection.</span></span> <span data-ttu-id="a867c-152">호출할 수 있습니다는 <xref:System.GC.WaitForFullGCComplete%2A?displayProperty=nameWithType> 메서드를 전체 수집이 완료 될 때까지 차단 합니다.</span><span class="sxs-lookup"><span data-stu-id="a867c-152">You can then call the <xref:System.GC.WaitForFullGCComplete%2A?displayProperty=nameWithType> method, which blocks until a full collection has completed.</span></span> <span data-ttu-id="a867c-153">루프에서 메서드를 호출 하 고 메서드가 반환 될 때마다 필요한 분석을 수행 하는 스레드를 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a867c-153">You can create a thread that calls the method in a loop and does any necessary analysis whenever the method returns.</span></span>  
  
 <span data-ttu-id="a867c-154">호출할 수 있습니다는 <xref:System.GC.CollectionCount%2A?displayProperty=nameWithType> 메서드 주기적으로 보려는 경우에 2 세대 컬렉션 개수 증가 했습니다.</span><span class="sxs-lookup"><span data-stu-id="a867c-154">Alternatively, you can call the <xref:System.GC.CollectionCount%2A?displayProperty=nameWithType> method periodically to see if the count of generation 2 collections has increased.</span></span> <span data-ttu-id="a867c-155">폴링 빈도 따라이 기술을 제공 하지 않는 있습니다을 정확한 것으로 전체 컬렉션의 항목을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="a867c-155">Depending on the polling frequency, this technique might not provide as accurate an indication of the occurrence of a full collection.</span></span>  
  
#### <a name="hosting-api"></a><span data-ttu-id="a867c-156">호스팅 API</span><span class="sxs-lookup"><span data-stu-id="a867c-156">Hosting API</span></span>  
 <span data-ttu-id="a867c-157">관리 되지 않는 호스팅 API를 사용 하는 경우 호스트에 전달 해야 CLR 구현의 [IHostGCManager](../../../docs/framework/unmanaged-api/hosting/ihostgcmanager-interface.md) 인터페이스입니다.</span><span class="sxs-lookup"><span data-stu-id="a867c-157">If you use the unmanaged hosting API, your host must pass the CLR an implementation of the [IHostGCManager](../../../docs/framework/unmanaged-api/hosting/ihostgcmanager-interface.md) interface.</span></span> <span data-ttu-id="a867c-158">CLR에서는 [ihostgcmanager:: Suspensionending](../../../docs/framework/unmanaged-api/hosting/ihostgcmanager-suspensionending-method.md) 수집이 발생 하는 동안 일시 중단 된 스레드의 실행 될 때 메서드.</span><span class="sxs-lookup"><span data-stu-id="a867c-158">The CLR calls the [IHostGCManager::SuspensionEnding](../../../docs/framework/unmanaged-api/hosting/ihostgcmanager-suspensionending-method.md) method when it resumes execution of threads that have been suspended while a collection occurs.</span></span> <span data-ttu-id="a867c-159">CLR은 호스트 전체 또는 부분 컬렉션 했는지 여부를 결정할 수 있도록는 메서드의 매개 변수로 완료 된 컬렉션의 생성을 전달 합니다.</span><span class="sxs-lookup"><span data-stu-id="a867c-159">The CLR passes the generation of the completed collection as a parameter of the method, so the host can determine whether the collection was full or partial.</span></span> <span data-ttu-id="a867c-160">구현에서 [ihostgcmanager:: Suspensionending](../../../docs/framework/unmanaged-api/hosting/ihostgcmanager-suspensionending-method.md) 메서드 업데이트 되는 즉시 개수 검색 되도록 하려면 유지 된 메모리를 쿼리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a867c-160">Your implementation of the [IHostGCManager::SuspensionEnding](../../../docs/framework/unmanaged-api/hosting/ihostgcmanager-suspensionending-method.md) method can query for survived memory, to ensure that the counts are retrieved as soon as they are updated.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="a867c-161">참고 항목</span><span class="sxs-lookup"><span data-stu-id="a867c-161">See Also</span></span>  
 <xref:System.AppDomain.MonitoringIsEnabled%2A?displayProperty=nameWithType>  
 [<span data-ttu-id="a867c-162">ICLRAppDomainResourceMonitor 인터페이스</span><span class="sxs-lookup"><span data-stu-id="a867c-162">ICLRAppDomainResourceMonitor Interface</span></span>](../../../docs/framework/unmanaged-api/hosting/iclrappdomainresourcemonitor-interface.md)  
 [<span data-ttu-id="a867c-163">\<appDomainResourceMonitoring></span><span class="sxs-lookup"><span data-stu-id="a867c-163">\<appDomainResourceMonitoring></span></span>](../../../docs/framework/configure-apps/file-schema/runtime/appdomainresourcemonitoring-element.md)  
 [<span data-ttu-id="a867c-164">CLR ETW 이벤트</span><span class="sxs-lookup"><span data-stu-id="a867c-164">CLR ETW Events</span></span>](../../../docs/framework/performance/clr-etw-events.md)

---
title: "아키텍처 원칙"
description: "ASP.NET Core와 Azure의 최신 웹 응용 프로그램을 설계 | 아키텍처 원칙"
author: ardalis
ms.author: wiwagn
ms.date: 10/06/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.workload:
- dotnet
- dotnetcore
ms.openlocfilehash: bdb215d64253fb7d22ae2c5648030336850006b5
ms.sourcegitcommit: f28752eab00d2bd97e971542c0f49ce63cfbc239
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 01/29/2018
---
# <a name="architectural-principles"></a>아키텍처 원칙

> "빌더 건물 빌드된 경우 방법은 프로그래머가 프로그램을 작성 했습니다. 다음와 함께 제공 된 첫 번째 woodpecker 문명이 손상 됩니다."  
> _\- Gerald Weinberg_

## <a name="summary"></a>요약

설계 하 고 염두에서 유지 관리와 소프트웨어 솔루션을 디자인 해야 합니다. 이 섹션에서 설명 하는 원칙 잘 정리 되 고 유지 가능한 응용 프로그램에서 발생 시키는 아키텍처 결정을 향해 안내해 수 있습니다. 일반적으로 이러한 원칙은 안내 메시징 시스템 또는 응용 프로그램의 다른 부분에 긴밀히 연결 되어 있지 않지만 대신 명시적 인터페이스를 통해 통신 하는 개별 구성 요소에서 응용 프로그램을 구축 합니다.

## <a name="common-design-principles"></a>일반적인 디자인 원칙

### <a name="separation-of-concerns"></a>문제의 분리

개발 하는 경우 기본 원칙은 **Separation**합니다. 이 원칙은 어설션 소프트웨어를 구분 하도록 수행 된 작업의 종류에 따라 합니다. 예를 들어 응용 프로그램에서 사용자에 게 표시할 주목할 만한 항목을 식별 하기 위한 논리를 포함 하 고 더욱 분명 하 게 되도록 특정 방식에서 등의 항목 형식을 지정 합니다. 동작의 서식을 지정 하려면 어떤 항목이 선택에 대 한 책임만 동시 서로 관련 된 문제를 분리 하므로 이러한 항목을 서식 지정에 대 한 책임 동작와에서 별도로 유지 되어야 합니다.

아키텍처 측면에서 응용 프로그램 인프라 및 사용자 인터페이스 논리의 핵심 비즈니스 동작을 분리 하 여이 원칙을 따르며를 논리적으로 작성할 수 있습니다. 이상적으로 비즈니스 규칙 및 논리는 응용 프로그램의 다른 프로젝트에 종속 되는 별도 프로젝트에 있어야 합니다. 이렇게 하면 비즈니스 모델은 쉽게 테스트 하 고 하위 수준 구현 세부 정보를 완벽 하 게 결합 되지 않고 개발할 수 있습니다. 분리 하는 응용 프로그램 아키텍처의 계층 사용는 주요 고려 합니다.

### <a name="encapsulation"></a>캡슐화

응용 프로그램의 다른 부분을 사용할지 **캡슐화** 를 응용 프로그램의 다른 부분에서 분리 합니다. 응용 프로그램 구성 요소 및 레이어는 외부 계약을 위반 하지 않는 상태로 자신의 공동 작업자를 중단시 키 지 않고도 내부 구현을 조정 할 수 있어야 합니다. 캡슐화의 적절 한 사용 하므로 개체 및 패키지도 동일한 인터페이스 유지 대체 구현으로 바꿀 수 있습니다 느슨한 결합 및 모듈식 방식으로 응용 프로그램 디자인을 달성할 수 있습니다.

클래스 캡슐화를 바깥쪽 클래스의 내부 상태에 대 한 액세스를 제한 하 여 수행 합니다. 외부 행위자를 개체의 상태를 처리 하려는 경우 개체의 전용 상태에 대 한 직접 액세스는 것이 아니라 잘 정의 된 함수 (또는 속성 setter)를 통해 수행 해야 것입니다. 마찬가지로, 응용 프로그램 구성 요소 및 응용 프로그램 자체의 공동 작업자 상태를 직접 수정할 수로 허용 되지 않고 사용에 대 한 잘 정의 된 인터페이스를 노출 해야 합니다. 으로 공용 계약 유지 관리를 수행 하므로 끊긴다는 공동 작업자 걱정 하지 않고 시간에 따라 진화 하는 응용 프로그램의 내부 디자인을 해제 합니다.

### <a name="dependency-inversion"></a>종속성 반전

응용 프로그램 내에서 종속성 방향 세부 정보를 구현 하지 추상화의 방향에 있어야 합니다. 대부분의 응용 프로그램의 런타임 실행 방향 흐름에서는 컴파일 시간 종속성 되도록 기록 됩니다. 이 직접 종속성 그래프를 생성합니다. 즉, C, 모듈에서 다음 컴파일 타임 A에서 함수를 호출 하는 함수 B 모듈에서 모듈 A 호출이 그림 4-1에 나와 있는 것 처럼 C에 따라 달라 집니다 B에 종속 하는 경우.

![](./media/image4-1.png)

**그림 4-1.** 직접 종속성 그래프입니다.

메서드를 호출할 수 있도록 A에 대 한 런타임 시 호출 B B에서 구현 하는 추상화에 A를 허용 하지만 인터페이스에 따라 달라 지도록 B에 의해 제어는 컴파일 타임에 종속성 반전 원칙 적용 (따라서 *반전* 일반적인 컴파일 시간 종속성)입니다. 런타임 시 프로그램 실행의 흐름을 그대로 유지 인터페이스 소개 의미 이러한 인터페이스의 다른 구현을 쉽게 연결할 수 있습니다.

![](./media/image4-2.png)

**그림 4-2입니다.** 반전 된 종속성 그래프입니다.

**종속성 반전** 의 구현 세부 사항에 따라 다르며 구현 방식은 그 보다는 상위 수준의 추상화에 쓸 수 있으므로 느슨하게 결합 된 응용 프로그램을 빌드할 때 핵심 부분입니다. 결과 응용 프로그램은 결과적으로 더 테스트할 수, 모듈식 및 유지 관리할 수 있습니다. 연습 *종속성 주입* 종속성 반전 원칙에 따라 가능한 이루어집니다.

### <a name="explicit-dependencies"></a>명시적 종속 관계

**메서드 및 클래스 올바르게 작동 하는 데 필요한 모든 공동 개체를 명시적으로 요구 해야 합니다.** 클래스 생성자는 유효한 상태에 있으려면와 제대로 작동 하는 데 필요한 작업을 식별 하는 클래스에 대 한 기회를 제공 합니다. 이러한 클래스는 되 고 있는 제대로 동작 특정 전역 또는 인프라 구성 요소가 충족 되는지는 생성 된 나누고를 호출할 수 있는 클래스를 정의 하는 경우 *악의적인* 해당 클라이언트와 합니다. 생성자 계약 이지만 다음 개체 사실은 런타임에 (가능한 경우 아무 것도 클래스는 기본 생성자를 사용 하 여 방금), 지정 된 것만 하면 되는 클라이언트 게이트웨이가 필요한 다른 지정 되어 있습니다.

명시적 종속 관계 원칙을 따르면 클래스와 메서드가 작동 하는 데 필요한 수준에 대 한 고객에 게 되는 합니다. 이렇게 하면 코드를 더 많은 자동 문서화 및 하는 방법의 형태로 요구 하는 제공으로 신뢰 되는 이후 보다 사용자 친화적인 계약 여 코딩 또는 생성자 매개 변수를 사용 하 고 개체가 작동 하는 올바르게 런타임에 합니다.

### <a name="single-responsibility"></a>단일 책임

단일 책임 원칙 개체 지향 디자인에 적용 되지만 비슷한 분리 하는 아키텍처 원칙으로 간주할 수도 있습니다. 대화 상자가 표시 개체 하나만 책임에 있어야 하 고 변경할 이유가 하나만 가져야 합니다. 특히 개체 변경 해야 하는 경우에만 한 책임을 실행 하는 방식으로 업데이트 해야 합니다. 이 원칙은 더 생성 하는 데 도움이 느슨하게 결합 된 및 모듈식 시스템 다양 한 종류의 새로운 동작은 이후 구현 될 수 있습니다 추가 해야 기존 클래스를 추가 하는 대신 새 클래스로 됩니다. 새 클래스 추가 항상 코드가 없는 이후 기존 클래스를 변경 하는 보다 더 안전 하 게 아직 새 클래스에 따라 달라 집니다.

모놀리식 응용 프로그램에서 응용 프로그램의 계층을 높은 수준에서 단일 책임 원칙을 적용할 수도 있습니다. 프레젠테이션 책임 UI 프로젝트에 유지 해야, 데이터 액세스 동안 책임 인프라 프로젝트 내에서 유지 해야 합니다. 비즈니스 논리를 쉽게 테스트할 수 고 다른 책임에서 독립적으로 개발할 수 있는 응용 프로그램 core 프로젝트에 유지 되어야 합니다.

이 원칙은 응용 프로그램 아키텍처에 적용 하 고 논리적 끝점에 해당 하는 데 걸리는 microservices를 얻게 됩니다. 지정 된 마이크로 서비스를 단일 책임이 있어야 합니다. 시스템의 동작을 확장 해야 할 경우 기존 작업을 추가 하는 대신 추가 microservices를 추가 하 여 작업을 수행할 것이 좋습니다.

[Microservices 아키텍처에 대 한 자세한 정보](http://aka.ms/MicroservicesEbook)

### <a name="dont-repeat-yourself-dry"></a>(건조) 직접 반복 안 함

응용 프로그램 오류의 자주 소스 이것은 여러 위치에서 특정 개념이 관련 된 동작을 지정 하지 않아야 합니다. 어느 시점 부터는 요구 사항에 대 한 변경 내용이 가능성 및이 동작을 변경 해야 합니다 해당 동작의 인스턴스를 하나 이상 업데이트 되지 것입니다는 시스템의 일관 되지 않은 동작이 발생 합니다.

논리를 복제 하는 대신 프로그래밍 구문에 캡슐화 합니다. 이 동작을 통해 단일 기관을 생성 하 고 새 구문을이 동작으로 사용 해야 하는 응용 프로그램의 다른 부분에는이 확인 합니다.

> [!NOTE]
> 바인딩 함께 동시 반복 되는 동작 하지 않습니다. 예를 들어 두 개의 서로 다른 상수 모두 동일한 값을 포함 해 서 한다는 의미 하나만 상수 나면 개념적으로 서로 다른 것을 참조 하는 경우.

### <a name="persistence-ignorance"></a>지 속성 무시

**지 속성 무시** (PI) 형식을 참조 유지 해야 하지만 해당 코드를 지 속성 기술 선택 영향을 받지 않습니다. 이러한 형식은.net에서은 라고도 일반 이전 CLR 개체 (POCOs)는 특정 기본 클래스에서 상속 하거나 특정 인터페이스를 구현 하는 필요 하지 않습니다. 지 속성 무시 동일한 비즈니스 모델 응용 프로그램에 대 한 추가적인 유연성을 제공 하는 여러 가지 방법으로 유지 될 수 있기 때문에 유용 합니다. 지 속성 선택 항목을 다른 한 데이터베이스 기술에서 시간이 지남에 따라 변경 될 수 있습니다 또는 추가적인 지 속성 형식의와 관계 없이 응용 프로그램이 시작 하는 것 외에도 해야 할 수 있습니다 (예를 들어 Redis 캐시 또는 외에 Azure DocumentDb를 사용 하는 관계형 데이터베이스)입니다.

이 원칙을 위반의 몇 가지 예는 다음과 같습니다.

-   필수 기본 클래스

-   필요한 인터페이스 구현

-   자체 (예: 활성 레코드 패턴)를 저장 해야 하는 클래스

-   필수 기본 생성자

-   Virtual 키워드를 요구 하는 속성

-   지 속성 관련 필수 특성

클래스 위의 기능이 나 동작 중 하나일 요구 사항을 유지 되어야 하는 형식과 지 속성 기술, 나중에 새 데이터 액세스 전략을 채택 하는 것이 어려울 선택 간의 결합을 추가 합니다.

### <a name="bounded-contexts"></a>Bounded 컨텍스트

**컨텍스트 제한** Domain-Driven 디자인에서 중앙 패턴 됩니다. 별도 개념적 모듈로 분할 하 여 대규모 응용 프로그램 또는 조직에 복잡성이 수행 하는 작업량과 하는 방법을 제공 합니다. 각 개념적 모듈 다음는 다른 컨텍스트에서 분리 되는 컨텍스트를 나타냅니다 (따라서 경계)와 독립적으로 개발할 수 있습니다. 각 경계 컨텍스트 내부에 개념에 대 한 고유 이름을 선택할 가능 해야 합니다. 및 지 속성 저장소에 대 한 단독 액세스 있어야 합니다.

여기에 최소한 개별 웹 응용 프로그램 데이터베이스를 다른 응용 프로그램과 공유 하지 않고 자신의 비즈니스 모델에 대 한 자신의 지 속성 저장소와 함께 자체 bounded 컨텍스트 위해 노력 해야 합니다. 공유 데이터베이스에 대 한 비즈니스 논리를 메뉴를 사용 하는 대신 프로그래밍 방식 인터페이스를 통해 바인딩된 컨텍스트 간 통신에서 발생 하 고 수행 하는 이벤트를 발생 하는 변경 사항에 따라 배치 키를 누릅니다. 컨텍스트 맵도 자신의 개별 bounded 컨텍스트도 구현 이상적으로 microservices에 밀접 하 게 제한.

> ### <a name="references--modern-web-applications"></a>참조-최신 웹 응용 프로그램
> - 문제의 분리  
> <http://deviq.com/separation-of-concerns/>
> - **Encapsulation** <http://deviq.com/encapsulation/>
> - **종속성 반전 원칙**  
> <http://deviq.com/dependency-inversion-principle/>
> - **명시적 종속성 원칙**  
> <http://deviq.com/explicit-dependencies-principle/>
> - **사용자가 직접 반복 안 함**  
> <http://deviq.com/don-t-repeat-yourself/>
> - 지 속성 무시  
> <http://deviq.com/persistence-ignorance/>
> - **Bounded 컨텍스트**  
> <https://martinfowler.com/bliki/BoundedContext.html>

> [!div class="step-by-step"]
[이전] [다음] (공통-웹-응용 프로그램-architectures.md) (choose-between-traditional-web-and-single-page-apps.md)

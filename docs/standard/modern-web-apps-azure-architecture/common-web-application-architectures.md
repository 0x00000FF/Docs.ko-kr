---
title: "일반적인 웹 응용 프로그램 아키텍처"
description: "ASP.NET Core 및 Microsoft Azure로 웹 응용 프로그램을 설계 | 일반적인 웹 응용 프로그램 아키텍처"
author: ardalis
ms.author: wiwagn
ms.date: 10/06/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.openlocfilehash: b6236cfab290211f930d6a1987075abeade4fd6d
ms.sourcegitcommit: 4f3fef493080a43e70e951223894768d36ce430a
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 11/21/2017
---
#<a name="common-web-application-architectures"></a><span data-ttu-id="75885-103">일반적인 웹 응용 프로그램 아키텍처</span><span class="sxs-lookup"><span data-stu-id="75885-103">Common Web Application Architectures</span></span>

> <span data-ttu-id="75885-104">"아키텍처는 비용이 많이 드는 좋은 생각 되 면, 잘못 된 아키텍처를 시도 하십시오."</span><span class="sxs-lookup"><span data-stu-id="75885-104">"If you think good architecture is expensive, try bad architecture."</span></span>  
> <span data-ttu-id="75885-105">_-Brian Foote 및 Yoder 있습니다._</span><span class="sxs-lookup"><span data-stu-id="75885-105">_- Brian Foote and Joseph Yoder_</span></span>

## <a name="summary"></a><span data-ttu-id="75885-106">요약</span><span class="sxs-lookup"><span data-stu-id="75885-106">Summary</span></span>

<span data-ttu-id="75885-107">대부분의 일반적인.NET 응용 프로그램은 실행 파일 또는 단일 IIS appdomain 내에서 실행 되는 단일 웹 응용 프로그램에 해당 하는 하나의 단위로 배포 합니다.</span><span class="sxs-lookup"><span data-stu-id="75885-107">Most traditional .NET applications are deployed as single units corresponding to an executable or a single web application running within a single IIS appdomain.</span></span> <span data-ttu-id="75885-108">이 가장 간단한 배포 모델 및 상태일 때 잘 많은 내부 및 공용 더 작은 응용 프로그램을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="75885-108">This is the simplest deployment model and serves many internal and smaller public applications very well.</span></span> <span data-ttu-id="75885-109">하지만이 단일 배포 단위인도 들어 가장 중요 업무용 응용 프로그램 혜택을 받을 여러 계층에 일부 논리 분리에서입니다.</span><span class="sxs-lookup"><span data-stu-id="75885-109">However, even given this single unit of deployment, most non-trivial business applications benefit from some logical separation into several layers.</span></span>

## <a name="what-is-a-monolithic-application"></a><span data-ttu-id="75885-110">단일 응용 프로그램 이란?</span><span class="sxs-lookup"><span data-stu-id="75885-110">What is a monolithic application?</span></span>

<span data-ttu-id="75885-111">단일 응용 프로그램은 완전히 독립적인, 해당 동작 면에서입니다.</span><span class="sxs-lookup"><span data-stu-id="75885-111">A monolithic application is one that is entirely self-contained, in terms of its behavior.</span></span> <span data-ttu-id="75885-112">해당 작업을 수행 하는 과정에서 다른 서비스 또는 데이터 저장소와 상호 작용할 수도 있고 해당 동작의 코어에서 자체 프로세스로 실행 전체 응용 프로그램은 일반적으로 하나의 단위로 배포 합니다.</span><span class="sxs-lookup"><span data-stu-id="75885-112">It may interact with other services or data stores in the course of performing its operations, but the core of its behavior runs within its own process and the entire application is typically deployed as a single unit.</span></span> <span data-ttu-id="75885-113">일반적으로 이러한 응용 프로그램을 수평으로 확장 하는 경우 전체 응용 프로그램이 여러 서버 또는 가상 컴퓨터에서 중복 됩니다.</span><span class="sxs-lookup"><span data-stu-id="75885-113">If such an application needs to scale horizontally, typically the entire application is duplicated across multiple servers or virtual machines.</span></span>

## <a name="all-in-one-applications"></a><span data-ttu-id="75885-114">내부에서 올인원 응용 프로그램</span><span class="sxs-lookup"><span data-stu-id="75885-114">All-in-One applications</span></span>

<span data-ttu-id="75885-115">응용 프로그램 아키텍처에 대 한 프로젝트의 수를 최소로 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="75885-115">The smallest possible number of projects for an application architecture is one.</span></span> <span data-ttu-id="75885-116">이 아키텍처에서 응용 프로그램의 전체 로직이 단일 프로젝트에 포함 된 단일 어셈블리로 컴파일된 있고, 단일 단위로 배포 합니다.</span><span class="sxs-lookup"><span data-stu-id="75885-116">In this architecture, the entire logic of the application is contained in a single project, compiled to a single assembly, and deployed as a single unit.</span></span>

<span data-ttu-id="75885-117">새 ASP.NET Core 프로젝트 명령줄 또는 Visual Studio에서 만든 시작 간단한 "내부에서 올인원" monolith 합니다.</span><span class="sxs-lookup"><span data-stu-id="75885-117">A new ASP.NET Core project, whether created in Visual Studio or from the command line, starts out as a simple "all-in-one" monolith.</span></span> <span data-ttu-id="75885-118">프레젠테이션, 비즈니스 및 데이터 액세스 논리를 포함 하 여 응용 프로그램의 동작을 모두 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="75885-118">It contains all of the behavior of the application, including presentation, business, and data access logic.</span></span> <span data-ttu-id="75885-119">그림 5-1 단일 프로젝트 응용 프로그램의 파일 구조를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="75885-119">Figure 5-1 shows the file structure of a single-project app.</span></span>

<span data-ttu-id="75885-120">**그림 5-1입니다.**</span><span class="sxs-lookup"><span data-stu-id="75885-120">**Figure 5-1.**</span></span> <span data-ttu-id="75885-121">단일 프로젝트 ASP.NET Core 응용 프로그램</span><span class="sxs-lookup"><span data-stu-id="75885-121">A single project ASP.NET Core app</span></span>

![](./media/image5-1.png)

<span data-ttu-id="75885-122">단일 프로젝트 시나리오에서 분리 하는 폴더를 사용 하 여 수행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="75885-122">In a single project scenario, separation of concerns is achieved through the use of folders.</span></span> <span data-ttu-id="75885-123">기본 서식 파일에 데이터 및 서비스에 대 한 모델, 뷰 및 컨트롤러의 MVC 패턴 책임에 대 한 별도 폴더와 폴더를 추가로 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="75885-123">The default template includes separate folders for MVC pattern responsibilities of Models, Views, and Controllers, as well as additional folders for Data and Services.</span></span> <span data-ttu-id="75885-124">이 정렬에서 프레젠테이션 세부 정보를 Views 폴더에 가능한 한 제한 된 및 데이터 액세스에 대 한 구현 세부 정보는 Data 폴더에 보관 하는 클래스를 제한 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="75885-124">In this arrangement, presentation details should be limited as much as possible to the Views folder, and data access implementation details should be limited to classes kept in the Data folder.</span></span> <span data-ttu-id="75885-125">비즈니스 논리는 서비스와 모델 폴더 내에서 클래스에 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="75885-125">Business logic should reside in services and classes within the Models folder.</span></span>

<span data-ttu-id="75885-126">간단 하지만 단일 프로젝트 모놀리식 솔루션에 몇 가지 단점이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="75885-126">Although simple, the single-project monolithic solution has some disadvantages.</span></span> <span data-ttu-id="75885-127">프로젝트의 크기와 복잡성 증가, 파일 및 폴더의 수가 함께 증가 계속 됩니다.</span><span class="sxs-lookup"><span data-stu-id="75885-127">As the project's size and complexity grows, the number of files and folders will continue to grow as well.</span></span> <span data-ttu-id="75885-128">UI 문제 (모델, 뷰, 컨트롤러), 그룹화 되지 않은 함께 사전순으로 여러 폴더에 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="75885-128">UI concerns (models, views, controllers) reside in multiple folders, which are not grouped together alphabetically.</span></span> <span data-ttu-id="75885-129">이 문제 ModelBinders, 필터 등의 추가 UI 수준 구문 자신의 폴더에 추가 될 때만 나쁜를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="75885-129">This issue only gets worse when additional UI-level constructs, such as Filters or ModelBinders, are added in their own folders.</span></span> <span data-ttu-id="75885-130">비즈니스 논리 모델 및 서비스 폴더 간의 분산 하 고 있는 폴더의 클래스는 다른 사용자에 의존 해야 합니다는 명확한 표시가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="75885-130">Business logic is scattered between the Models and Services folders, and there is no clear indication of which classes in which folders should depend on which others.</span></span> <span data-ttu-id="75885-131">이 처럼 프로젝트 수준에서 조직의 경우가 많으므로 [코드](http://deviq.com/spaghetti-code/)합니다.</span><span class="sxs-lookup"><span data-stu-id="75885-131">This lack of organization at the project level frequently leads to [spaghetti code](http://deviq.com/spaghetti-code/).</span></span>

<span data-ttu-id="75885-132">이러한 문제를 해결 하려면 응용 프로그램이 종종 발전 하면서 각 프로젝트 특정에 있는 것으로 간주 되는 다중 프로젝트 솔루션으로 *레이어* 응용 프로그램의 합니다.</span><span class="sxs-lookup"><span data-stu-id="75885-132">In order to address these issues, applications often evolve into multi-project solutions, where each project is considered to reside in a particular *layer* of the application.</span></span>

## <a name="what-are-layers"></a><span data-ttu-id="75885-133">계층은 무엇입니까?</span><span class="sxs-lookup"><span data-stu-id="75885-133">What are layers?</span></span>

<span data-ttu-id="75885-134">응용 프로그램 복잡성에서 성장 함에 따라 해당 복잡성을 관리 하기 가지 방법은 해당 책임이 나 문제에 따라 응용 프로그램을 나눌 수입니다.</span><span class="sxs-lookup"><span data-stu-id="75885-134">As applications grow in complexity, one way to manage that complexity is to break the application up according to its responsibilities or concerns.</span></span> <span data-ttu-id="75885-135">문제 원칙을 분리 하 여 따르며 개발자가 특정 기능을 구현 하는 쉽게 찾을 수 있도록 구성 증가 코드 베이스를 유지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="75885-135">This follows the separation of concerns principle, and can help keep a growing codebase organized so that developers can easily find where certain functionality is implemented.</span></span> <span data-ttu-id="75885-136">계층화 아키텍처는 하지만 여러 가지 장점이 방금 코드 조직 외을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="75885-136">Layered architecture offers a number of advantages beyond just code organization, though.</span></span>

<span data-ttu-id="75885-137">코드를 계층으로 구성 하 여 응용 프로그램에 걸쳐 공통 하위 수준 기능을 재사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="75885-137">By organizing code into layers, common low-level functionality can be reused throughout the application.</span></span> <span data-ttu-id="75885-138">더 적은 코드를 작성할 필요가 것을 의미 하 고 건조 원칙을 한 번만 구현을 표준화 하기 위해 응용 프로그램을 허용할 수 있기 때문이 다시 사용 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="75885-138">This reuse is beneficial because it means less code needs to be written and because it can allow the application to standardize on a single implementation, following the DRY principle.</span></span>

<span data-ttu-id="75885-139">계층화 된 아키텍처와 응용 프로그램에 레이어 다른 레이어가와 통신할 수 제한을 적용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="75885-139">With a layered architecture, applications can enforce restrictions on which layers can communicate with other layers.</span></span> <span data-ttu-id="75885-140">이렇게 하면 캡슐화를 달성 합니다.</span><span class="sxs-lookup"><span data-stu-id="75885-140">This helps to achieve encapsulation.</span></span> <span data-ttu-id="75885-141">레이어를 변경 하거나 대체 하는 경우에 함께 작동 하는 계층에만 영향을 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="75885-141">When a layer is changed or replaced, only those layers that work with it should be impacted.</span></span> <span data-ttu-id="75885-142">제한 하 여 계층에 다른 계층 변경의 영향을 최소화할 수 있습니다 단일 변경 전체 응용 프로그램에 영향을 주지 않도록 따라 달라 집니다.</span><span class="sxs-lookup"><span data-stu-id="75885-142">By limiting which layers depend on which other layers, the impact of changes can be mitigated so that a single change doesn't impact the entire application.</span></span>

<span data-ttu-id="75885-143">레이어 (및 캡슐화) 보다 쉽게 응용 프로그램 내에서 기능을 대체 합니다.</span><span class="sxs-lookup"><span data-stu-id="75885-143">Layers (and encapsulation) make it much easier to replace functionality within the application.</span></span> <span data-ttu-id="75885-144">예를 들어 응용 프로그램 지 속성에 대 한 자체 SQL Server 데이터베이스 사용 처음 되지만 나중에 클라우드 기반 지 속성 전략 또는 web API 뒤에 있는 하나를 사용 하도록 선택할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="75885-144">For example, an application might initially use its own SQL Server database for persistence, but later could choose to use a cloud-based persistence strategy, or one behind a web API.</span></span> <span data-ttu-id="75885-145">응용 프로그램에 논리적 계층 내에서 해당 지 속성 구현을 캡슐화 제대로 하는 경우 해당 SQL Server 특정 계층을 동일한 공용 인터페이스를 구현 하 여 새 변환기도 대체할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="75885-145">If the application has properly encapsulated its persistence implementation within a logical layer, that SQL Server specific layer could be replaced by a new one implementing the same public interface.</span></span>

<span data-ttu-id="75885-146">구현 향후 요구 사항 변화에 대 한 응답에서을 바꾸는 가능성이 외에도 응용 프로그램 계층도 쉽게 만들 수 구현을 테스트 목적으로 교체 합니다.</span><span class="sxs-lookup"><span data-stu-id="75885-146">In addition to the potential of swapping out implementations in response to future changes in requirements, application layers can also make it easier to swap out implementations for testing purposes.</span></span> <span data-ttu-id="75885-147">실제 데이터 계층 또는 응용 프로그램의 UI 계층에 대해 작동 하는 테스트를 작성 하는 대신 요청에 대 한 알려진된 응답을 제공 하는 가짜 구현으로 이러한 계층 테스트 시 바꿀 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="75885-147">Instead of having to write tests that operate against the real data layer or UI layer of the application, these layers can be replaced at test time with fake implementations that provide known responses to requests.</span></span> <span data-ttu-id="75885-148">이 일반적으로 인해 테스트 훨씬 쉽게 작성 하 고 훨씬 빠르게 테스트 다시 실행에 비해 실행 응용 프로그램의 실제 인프라입니다.</span><span class="sxs-lookup"><span data-stu-id="75885-148">This typically makes tests much easier to write and much faster to run when compared to running tests again the application's real infrastructure.</span></span>

<span data-ttu-id="75885-149">논리 쌓기 엔터프라이즈 소프트웨어 응용 프로그램에서 코드를 향상 시키기 위한 일반적인 방법 이며 여러 가지 방법으로 계층으로 코드를 구성할 수 있는 합니다.</span><span class="sxs-lookup"><span data-stu-id="75885-149">Logical layering is a common technique for improving the organization of code in enterprise software applications, and there are several ways in which code can be organized into layers.</span></span>

> [!NOTE]
> <span data-ttu-id="75885-150">*레이어* 응용 프로그램 내에서 논리적 분리를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="75885-150">*Layers* represent logical separation within the application.</span></span> <span data-ttu-id="75885-151">응용 프로그램 논리 서버 또는 프로세스를 구분 하려면 물리적으로 배포 된 경우 이러한 별도 실제 배포 대상 이라고 *계층*합니다.</span><span class="sxs-lookup"><span data-stu-id="75885-151">In the event that application logic is physically distributed to separate servers or processes, these separate physical deployment targets are referred to as *tiers*.</span></span> <span data-ttu-id="75885-152">이것은 가능한 경우 단일 계층에 배포 되는 N 계층 응용 프로그램에 매우 일반적입니다.</span><span class="sxs-lookup"><span data-stu-id="75885-152">It's possible, and quite common, to have an N-Layer application that is deployed to a single tier.</span></span>

## <a name="traditional-n-layer-architecture-applications"></a><span data-ttu-id="75885-153">기존의 "N 레이어" 아키텍처 응용 프로그램</span><span class="sxs-lookup"><span data-stu-id="75885-153">Traditional "N-Layer" architecture applications</span></span>

<span data-ttu-id="75885-154">에 응용 프로그램 논리의 가장 일반적인 조직 계층화 그림 5-2에 표시 된 것입니다.</span><span class="sxs-lookup"><span data-stu-id="75885-154">The most common organization of application logic into layers it shown in Figure 5-2.</span></span>

<span data-ttu-id="75885-155">**그림 5-2입니다.**</span><span class="sxs-lookup"><span data-stu-id="75885-155">**Figure 5-2.**</span></span> <span data-ttu-id="75885-156">일반적인 응용 프로그램 계층입니다.</span><span class="sxs-lookup"><span data-stu-id="75885-156">Typical application layers.</span></span>

![](./media/image5-2.png)

<span data-ttu-id="75885-157">이들이 레이어는 UI로 축약 BLL (Business Logic Layer) 및 DAL (데이터 액세스 계층).</span><span class="sxs-lookup"><span data-stu-id="75885-157">These layers are frequently abbreviated as UI, BLL (Business Logic Layer), and DAL (Data Access Layer).</span></span> <span data-ttu-id="75885-158">이 아키텍처를 사용 하 여 사용자만 BLL와 상호 작용 하는 UI 계층을 통해 요청을 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="75885-158">Using this architecture, users make requests through the UI layer, which interacts only with the BLL.</span></span> <span data-ttu-id="75885-159">차례로 BLL, 데이터 액세스 요청에 대 한 DAL를 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="75885-159">The BLL, in turn, can call the DAL for data access requests.</span></span> <span data-ttu-id="75885-160">UI 계층 하지 않아야 모든 요청에는 dal과 직접 또는 다른 수단을 통해 직접 지 속성 상호 작용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="75885-160">The UI layer should not make any requests to the DAL directly, nor should it interact with persistence directly through other means.</span></span> <span data-ttu-id="75885-161">마찬가지로, BLL 상호 작용 해야 지 속성 DAL을 통해 이동 하 여 합니다.</span><span class="sxs-lookup"><span data-stu-id="75885-161">Likewise, the BLL should only interact with persistence by going through the DAL.</span></span> <span data-ttu-id="75885-162">이러한 방식으로 각 계층에는 잘 알려진 책임 있습니다.</span><span class="sxs-lookup"><span data-stu-id="75885-162">In this way, each layer has its own well-known responsibility.</span></span>

<span data-ttu-id="75885-163">하나이 기존의 계층화 접근 방법의 단점은 맨 아래에 컴파일 시간 종속성 위에서 실행입니다.</span><span class="sxs-lookup"><span data-stu-id="75885-163">One disadvantage of this traditional layering approach is that compile-time dependencies run from the top to the bottom.</span></span> <span data-ttu-id="75885-164">즉, UI 계층 DAL에 따라 달라 지는 BLL에 따라 달라 집니다.</span><span class="sxs-lookup"><span data-stu-id="75885-164">That is, the UI layer depends on the BLL, which depends on the DAL.</span></span> <span data-ttu-id="75885-165">이 일반적으로 보유 하 고 가장 중요 한 논리는 응용 프로그램에서 BLL 종속 데이터 액세스 구현 세부 정보 (및 자주 데이터베이스의 존재에) 임을 의미 합니다.</span><span class="sxs-lookup"><span data-stu-id="75885-165">This means that the BLL, which usually holds the most important logic in the application, is dependent on data access implementation details (and often on the existence of a database).</span></span> <span data-ttu-id="75885-166">이러한 아키텍처에 비즈니스 논리를 테스트는 테스트 데이터베이스 요구 어렵습니다.</span><span class="sxs-lookup"><span data-stu-id="75885-166">Testing business logic in such an architecture is often difficult, requiring a test database.</span></span> <span data-ttu-id="75885-167">다음 섹션에서 확인할 수 종속성 반전 원칙을이 문제를 해결 하기 위해 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="75885-167">The dependency inversion principle can be used to address this issue, as you'll see in the next section.</span></span>

<span data-ttu-id="75885-168">그림 5-3 책임 (또는 계층)에 의해 세 개의 프로젝트도 응용 프로그램을 분할 하는 예제 솔루션을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="75885-168">Figure 5-3 shows an example solution, breaking the application into three projects by responsibility (or layer).</span></span>

<span data-ttu-id="75885-169">**그림 5-3입니다.**</span><span class="sxs-lookup"><span data-stu-id="75885-169">**Figure 5-3.**</span></span> <span data-ttu-id="75885-170">세 가지 프로젝트와 함께 간단한 모놀리식 응용 프로그램입니다.</span><span class="sxs-lookup"><span data-stu-id="75885-170">A simple monolithic application with three projects.</span></span>

![](./media/image5-3.png)

<span data-ttu-id="75885-171">이 응용 프로그램에서는 여러 프로젝트 구성을 위한 목적으로 사용 하지만 계속 단일 단위로 배포 및 클라이언트에서 단일 웹 앱으로 상호 작용 합니다.</span><span class="sxs-lookup"><span data-stu-id="75885-171">Although this application uses several projects for organizational purposes, it is still deployed as a single unit and its clients will interact with it as a single web app.</span></span> <span data-ttu-id="75885-172">그러면 매우 간단한 배포 프로세스 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="75885-172">This allows for very simple deployment process.</span></span> <span data-ttu-id="75885-173">그림 5-4 이러한 응용 프로그램 수 있습니다는 방법을 보여 줍니다. Windows Azure를 사용 하 여 호스팅됩니다.</span><span class="sxs-lookup"><span data-stu-id="75885-173">Figure 5-4 shows how such an app might be hosted using Windows Azure.</span></span>

![](./media/image5-4.png)

<span data-ttu-id="75885-174">**그림 5-4입니다.**</span><span class="sxs-lookup"><span data-stu-id="75885-174">**Figure 5-4.**</span></span> <span data-ttu-id="75885-175">Azure 웹 앱의 간단한 배포</span><span class="sxs-lookup"><span data-stu-id="75885-175">Simple deployment of Azure Web App</span></span>

<span data-ttu-id="75885-176">응용 프로그램 요구 사항이 증가, 처럼 더 복잡 하 고 강력한 배포 솔루션 필요할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="75885-176">As application needs grow, more complex and robust deployment solutions may be required.</span></span> <span data-ttu-id="75885-177">그림 5-5에는 추가 기능을 지 원하는 더 복잡 한 배포 계획의 예가 나와 있습니다.</span><span class="sxs-lookup"><span data-stu-id="75885-177">Figure 5-5 shows an example of a more complex deployment plan that supports additional capabilities.</span></span>

![](./media/image5-5.png)

<span data-ttu-id="75885-178">**그림 5-5입니다.**</span><span class="sxs-lookup"><span data-stu-id="75885-178">**Figure 5-5.**</span></span> <span data-ttu-id="75885-179">Azure 앱 서비스에 웹 응용 프로그램 배포</span><span class="sxs-lookup"><span data-stu-id="75885-179">Deploying a web app to an Azure App Service</span></span>

<span data-ttu-id="75885-180">내부적으로이 프로젝트의이 조직 책임을 기반으로 하는 여러 프로젝트에 응용 프로그램의 유지 관리 용이성 향상 됩니다.</span><span class="sxs-lookup"><span data-stu-id="75885-180">Internally, this project's organization into multiple projects based on responsibility improves the maintainability of the application.</span></span>

<span data-ttu-id="75885-181">이 단위는 클라우드 기반 주문형으로 확장성 활용 하기 위해 내부 또는 외부 확장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="75885-181">This unit can be scaled up or out to take advantage of cloud-based on-demand scalability.</span></span> <span data-ttu-id="75885-182">수직 확장 응용 프로그램을 호스팅하는 서버에 추가 CPU, 메모리, 디스크 공간 부족 또는 기타 리소스를 추가 하는 것을 의미 합니다.</span><span class="sxs-lookup"><span data-stu-id="75885-182">Scaling up means adding additional CPU, memory, disk space, or other resources to the server(s) hosting your app.</span></span> <span data-ttu-id="75885-183">스케일 아웃는 이러한 서버의 추가 인스턴스 추가 여부를 물리적 서버 또는 가상 컴퓨터.</span><span class="sxs-lookup"><span data-stu-id="75885-183">Scaling out means adding additional instances of such servers, whether these are physical servers or virtual machines.</span></span> <span data-ttu-id="75885-184">응용 프로그램은 여러 인스턴스에서 호스트 되는 경우 부하 분산 장치는 개별 응용 프로그램 인스턴스에 요청을 할당 하는 데 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="75885-184">When your app is hosted across multiple instances, a load balancer is used to assign requests to individual app instances.</span></span>

<span data-ttu-id="75885-185">Azure의 웹 응용 프로그램을 확장 하는 가장 간단한 방법은 응용 프로그램의 앱 서비스 계획에서 수동으로 크기 조정을 구성 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="75885-185">The simplest approach to scaling a web application in Azure is to configure scaling manually in the application's App Service Plan.</span></span> <span data-ttu-id="75885-186">그림 5-6 인스턴스 개수를 서비스 응용 프로그램을 구성 하려면 적절 한 Azure 대시보드 화면을 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="75885-186">Figure 5-6 show the appropriate Azure dashboard screen to configure how many instances are serving an app.</span></span>

![](./media/image5-6.png)

<span data-ttu-id="75885-187">**그림 5-6입니다.**</span><span class="sxs-lookup"><span data-stu-id="75885-187">**Figure 5-6.**</span></span> <span data-ttu-id="75885-188">앱 서비스 계획 Azure에서 크기 조정 합니다.</span><span class="sxs-lookup"><span data-stu-id="75885-188">App Service Plan scaling in Azure.</span></span>

## <a name="clean-architecture"></a><span data-ttu-id="75885-189">클린 아키텍처</span><span class="sxs-lookup"><span data-stu-id="75885-189">Clean architecture</span></span>

<span data-ttu-id="75885-190">Domain-Driven 디자인 (DDD) 원칙 뿐만 아니라 종속성 반전 원칙에 따라 응용 프로그램에서 비슷한 아키텍처 도착 하는 경향이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="75885-190">Applications that follow the Dependency Inversion Principle as well as Domain-Driven Design (DDD) principles tend to arrive at a similar architecture.</span></span> <span data-ttu-id="75885-191">이 아키텍처 수 년에 걸쳐 많은 이름으로 떨어졌습니다.</span><span class="sxs-lookup"><span data-stu-id="75885-191">This architecture has gone by many names over the years.</span></span> <span data-ttu-id="75885-192">첫 번째 이름 중 하나는 6 각형 아키텍처, 포트 및 어댑터 옵니다.</span><span class="sxs-lookup"><span data-stu-id="75885-192">One of the first names was Hexagonal Architecture, followed by Ports-and-Adapters.</span></span> <span data-ttu-id="75885-193">으로 인용 된 최근는 [양 파형 아키텍처](http://jeffreypalermo.com/blog/the-onion-architecture-part-1/) 또는 [클린 아키텍처](https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html)합니다.</span><span class="sxs-lookup"><span data-stu-id="75885-193">More recently, it's been cited as the [Onion Architecture](http://jeffreypalermo.com/blog/the-onion-architecture-part-1/) or [Clean Architecture](https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html).</span></span> <span data-ttu-id="75885-194">이 마지막 이름 기준으로이 전자책 (영문)의 아키텍처를 설명 하는 데 사용 되는 정리 아키텍처입니다.</span><span class="sxs-lookup"><span data-stu-id="75885-194">It is this last name, Clean Architecture, that is used as the basis for describing the architecture in this e-book.</span></span>

> [!NOTE]
> <span data-ttu-id="75885-195">용어 클린 아키텍처 DDD를 사용 하 여 빌드되지 않은 하는 것에 대 한도 DDD 원칙을 사용 하 여 빌드된 응용 프로그램에 적용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="75885-195">The term Clean Architecture can be applied to applications that are built using DDD Principles as well as to those that are not built using DDD.</span></span> <span data-ttu-id="75885-196">전자의 경우의 경우이 조합은로 참조할 수 있습니다 "클린 DDD 아키텍처"으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="75885-196">In the case of the former, this combination may be referred to as "Clean DDD Architecture".</span></span>

<span data-ttu-id="75885-197">클린 아키텍처 응용 프로그램의 가운데에 비즈니스 논리 및 응용 프로그램 모델을 전환합니다.</span><span class="sxs-lookup"><span data-stu-id="75885-197">Clean architecture puts the business logic and application model at the center of the application.</span></span> <span data-ttu-id="75885-198">이 종속성 데이터 액세스 또는 기타 인프라 고려 사항에 의존 하는 비즈니스 논리를 대신 반전: 응용 프로그램 코어에 인프라 및 구현 세부 사항에 따라 달라 집니다.</span><span class="sxs-lookup"><span data-stu-id="75885-198">Instead of having business logic depend on data access or other infrastructure concerns, this dependency is inverted: infrastructure and implementation details depend on the Application Core.</span></span> <span data-ttu-id="75885-199">이 다음 인프라 계층에 정의 된 형식에 의해 구현 되는 응용 프로그램 핵심에서 추상화를 또는 인터페이스를 정의 하 여 달성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="75885-199">This is achieved by defining abstractions, or interfaces, in the Application Core, which are then implemented by types defined in the Infrastructure layer.</span></span> <span data-ttu-id="75885-200">이 아키텍처를 시각화 하는 일반적인 방법은 일련의 동심원는 양 파형 비슷합니다를 사용 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="75885-200">A common way of visualizing this architecture is to use a series of concentric circles, similar to an onion.</span></span> <span data-ttu-id="75885-201">그림 5-X 아키텍처 표현의이 스타일의 예를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="75885-201">Figure 5-X shows an example of this style of architectural representation.</span></span>

![](./media/image5-7.png)

<span data-ttu-id="75885-202">**그림 5-7입니다.**</span><span class="sxs-lookup"><span data-stu-id="75885-202">**Figure 5-7.**</span></span> <span data-ttu-id="75885-203">아키텍처를 정리 합니다. 양 파형 보기</span><span class="sxs-lookup"><span data-stu-id="75885-203">Clean Architecture; onion view</span></span>

<span data-ttu-id="75885-204">이 다이어그램에 종속성 가장 안쪽 원의 향해 흐릅니다.</span><span class="sxs-lookup"><span data-stu-id="75885-204">In this diagram, dependencies flow toward the innermost circle.</span></span> <span data-ttu-id="75885-205">따라서 (함이 다이어그램의 핵심 위치에서 해당 이름을 가진) 응용 프로그램 코어에 종속성이 없는 다른 응용 프로그램 계층에 있는지 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="75885-205">Thus, you can see that the Application Core (which takes its name from its position at the core of this diagram) has no dependencies on other application layers.</span></span> <span data-ttu-id="75885-206">매우 가운데에는 응용 프로그램의 엔터티 및 인터페이스입니다.</span><span class="sxs-lookup"><span data-stu-id="75885-206">At the very center are the application's entities and interfaces.</span></span> <span data-ttu-id="75885-207">바로 바깥쪽 이지만 아직 응용 프로그램 코어에에서는 일반적으로 내부 원에 정의 된 인터페이스를 구현 하는 도메인 서비스입니다.</span><span class="sxs-lookup"><span data-stu-id="75885-207">Just outside, but still in the Application Core, are domain services, which typically implement interfaces defined in the inner circle.</span></span> <span data-ttu-id="75885-208">외부의 응용 프로그램 핵심 사용자 인터페이스 및 인프라 계층 모두 종속에 응용 프로그램 코어만 서로 (반드시).</span><span class="sxs-lookup"><span data-stu-id="75885-208">Outside of the Application Core, both the User Interface and the Infrastructure layers depend on the Application Core, but not on one another (necessarily).</span></span>

<span data-ttu-id="75885-209">그림 5-X UI 및 기타 계층 간에 종속성을 더 잘 반영 하는 보다 일반적인 가로 레이어 다이어그램을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="75885-209">Figure 5-X shows a more traditional horizontal layer diagram that better reflects the dependency between the UI and other layers.</span></span>

![](./media/image5-8.png)

<span data-ttu-id="75885-210">**그림 5-8입니다.**</span><span class="sxs-lookup"><span data-stu-id="75885-210">**Figure 5-8.**</span></span> <span data-ttu-id="75885-211">아키텍처를 정리 합니다. 가로 계층 보기</span><span class="sxs-lookup"><span data-stu-id="75885-211">Clean Architecture; horizontal layer view</span></span>

<span data-ttu-id="75885-212">참고는 실선으로 된 화살표는 나타내고 컴파일 시간 종속성 파선된 화살표는 런타임 전용 종속성을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="75885-212">Note that the solid arrows represent compile-time dependencies, while the dashed arrow represents a runtime-only dependency.</span></span> <span data-ttu-id="75885-213">정리 아키텍처를 사용 하 여 UI 계층으로 컴파일 타임에 응용 프로그램 코어에 정의 된 인터페이스를 이상적 해야가 구현 형식에 대 한 지식에에서 정의 되어 있지 인프라 계층.</span><span class="sxs-lookup"><span data-stu-id="75885-213">Using the clean architecture, the UI layer works with interfaces defined in the Application Core at compile time, and ideally should not have any knowledge of the implementation types defined in the Infrastructure layer.</span></span> <span data-ttu-id="75885-214">하지만 런타임 시, 이러한 구현 형식이 됩니다 응용 프로그램을 실행 하는 데 필요한 때문 있어야 하 고 종속성 주입을 통해 응용 프로그램 코어 인터페이스까지 유선 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="75885-214">At runtime, however, these implementation types will be required for the app to execute, so they will need to be present and wired up to the Application Core interfaces via dependency injection.</span></span>

<span data-ttu-id="75885-215">그림 5-9에서는 이러한 권장 사항을 따르면 빌드할 때 ASP.NET Core 응용 프로그램의 아키텍처를 보다 자세하게 표시를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="75885-215">Figure 5-9 shows a more detailed view of an ASP.NET Core application's architecture when built following these recommendations.</span></span>

![ASPNET 핵심 아키텍처](./media/image5-9.png)

<span data-ttu-id="75885-217">**그림 5-9입니다.**</span><span class="sxs-lookup"><span data-stu-id="75885-217">**Figure 5-9.**</span></span> <span data-ttu-id="75885-218">ASP.NET Core 아키텍처 다이어그램 아키텍처 정리를 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="75885-218">ASP.NET Core architecture diagram following Clean Architecture.</span></span>

<span data-ttu-id="75885-219">응용 프로그램 핵심 인프라에 의존 하지, 때문에이 계층에 대 한 자동화 된 단위 테스트를 작성 하려면 매우 쉽습니다.</span><span class="sxs-lookup"><span data-stu-id="75885-219">Because the Application Core doesn't depend on Infrastructure, it is very easy to write automated unit tests for this layer.</span></span> <span data-ttu-id="75885-220">그림 5-10 및 11 5 테스트가이 아키텍처에 맞추는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="75885-220">Figures 5-10 and 5-11 show how tests fit into this architecture.</span></span>

![UnitTestCore](./media/image5-10.png)

<span data-ttu-id="75885-222">**그림 5-10입니다.**</span><span class="sxs-lookup"><span data-stu-id="75885-222">**Figure 5-10.**</span></span> <span data-ttu-id="75885-223">에서 단위 테스트를 응용 프로그램 코어 격리 합니다.</span><span class="sxs-lookup"><span data-stu-id="75885-223">Unit testing Application Core in isolation.</span></span>

![IntegrationTests](./media/image5-11.png)

<span data-ttu-id="75885-225">**그림 5-11입니다.**</span><span class="sxs-lookup"><span data-stu-id="75885-225">**Figure 5-11.**</span></span> <span data-ttu-id="75885-226">통합 인프라 구현 외부 종속성이 테스트 합니다.</span><span class="sxs-lookup"><span data-stu-id="75885-226">Integration testing Infrastructure implementations with external dependencies.</span></span>

<span data-ttu-id="75885-227">UI 계층 직접 종속성 인프라 프로젝트에 정의 된 형식에 대 한를 매우 쉽게 구현을을 쉽게 테스트할 하나 걸러 내 거 나 응용 프로그램 요구 사항의 변화에 대 한 응답에도 마찬가지로 합니다.</span><span class="sxs-lookup"><span data-stu-id="75885-227">Since the UI layer doesn't have any direct dependency on types defined in the Infrastructure project, it is likewise very easy to swap out implementations, either to facilitate testing or in response to changing application requirements.</span></span> <span data-ttu-id="75885-228">ASP.NET Core의 기본 제공 사용 및 종속성 주입에 대 한 지원 구조 특수 모놀리식 응용 프로그램에 가장 적합 한 방식으로이 아키텍처를 사용 하면 합니다.</span><span class="sxs-lookup"><span data-stu-id="75885-228">ASP.NET Core's built-in use of and support for dependency injection makes this architecture the most appropriate way to structure non-trivial monolithic applications.</span></span>

<span data-ttu-id="75885-229">단일 응용 프로그램에 대 한 응용 프로그램 코어, 인프라 및 사용자 인터페이스 프로젝트는 모든 실행 단일 응용 프로그램으로.</span><span class="sxs-lookup"><span data-stu-id="75885-229">For monolithic applications the Application Core, Infrastructure, and User Interface projects are all run as a single application.</span></span> <span data-ttu-id="75885-230">런타임 응용 프로그램 아키텍처 그림 5-12와 같은 문제가 나타날 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="75885-230">The runtime application architecture might look something like Figure 5-12.</span></span>

![ASPNET 핵심 아키텍처 2](./media/image5-12.png)

<span data-ttu-id="75885-232">**그림 5-12입니다.**</span><span class="sxs-lookup"><span data-stu-id="75885-232">**Figure 5-12.**</span></span> <span data-ttu-id="75885-233">샘플 ASP.NET Core 응용 프로그램의 런타임 아키텍처입니다.</span><span class="sxs-lookup"><span data-stu-id="75885-233">A sample ASP.NET Core app's runtime architecture.</span></span>

### <a name="organizing-code-in-clean-architecture"></a><span data-ttu-id="75885-234">코드 새로 아키텍처의 구성</span><span class="sxs-lookup"><span data-stu-id="75885-234">Organizing Code in Clean Architecture</span></span>

<span data-ttu-id="75885-235">클린 아키텍처 솔루션에서는 각 프로젝트는 명확한 책임이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="75885-235">In a Clean Architecture solution, each project has clear responsibilities.</span></span> <span data-ttu-id="75885-236">따라서 각 프로젝트에 속하는 특정 형식 및 자주 적절 한 프로젝트에서 이러한 형식에 해당 폴더를 찾을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="75885-236">As such, certain types will belong in each project and you'll frequently find folders corresponding to these types in the appropriate project.</span></span>

<span data-ttu-id="75885-237">응용 프로그램 코어 엔터티, 서비스 및 인터페이스를 포함 하는 비즈니스 모델을 보유 합니다.</span><span class="sxs-lookup"><span data-stu-id="75885-237">The Application Core holds the business model, which includes entities, services, and interfaces.</span></span> <span data-ttu-id="75885-238">이러한 인터페이스는 데이터 액세스, 파일 시스템 액세스, 네트워크 호출 등의 인프라를 사용 하 여 수행 되는 작업에 대 한 추상화를 포함 합니다. 경우에 따라 서비스 또는이 계층에 정의 된 인터페이스 UI 또는 인프라에 없는 종속 되어 있는 비 엔터티 형식에서 실행 되도록 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="75885-238">These interfaces include abstractions for operations that will be performed using Infrastructure, such as data access, file system access, network calls, etc. Sometimes services or interfaces defined at this layer will need to work with non-entity types that have no dependencies on UI or Infrastructure.</span></span> <span data-ttu-id="75885-239">이러한 간단한 데이터 전송 개체 (Dto)로 정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="75885-239">These can be defined as simple Data Transfer Objects (DTOs).</span></span>

> ### <a name="application-core-types"></a><span data-ttu-id="75885-240">응용 프로그램 코어 유형</span><span class="sxs-lookup"><span data-stu-id="75885-240">Application Core Types</span></span>
> -   <span data-ttu-id="75885-241">(비즈니스 모델 클래스 유지 되는) 엔터티</span><span class="sxs-lookup"><span data-stu-id="75885-241">Entities (business model classes that are persisted)</span></span>
> -   <span data-ttu-id="75885-242">인터페이스</span><span class="sxs-lookup"><span data-stu-id="75885-242">Interfaces</span></span>
> -   <span data-ttu-id="75885-243">서비스</span><span class="sxs-lookup"><span data-stu-id="75885-243">Services</span></span>
> -   <span data-ttu-id="75885-244">Dto</span><span class="sxs-lookup"><span data-stu-id="75885-244">DTOs</span></span>

<span data-ttu-id="75885-245">인프라 프로젝트에는 데이터 액세스 구현 일반적으로 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="75885-245">The Infrastructure project will typically include data access implementations.</span></span> <span data-ttu-id="75885-246">일반적인 ASP.NET Core 웹 응용 프로그램을이 엔터티 프레임 워크 DbContext, 정의 된 모든 EF 코어 마이그레이션 및 데이터 액세스 구현 클래스 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="75885-246">In a typical ASP.NET Core web application, this will include the Entity Framework DbContext, any EF Core Migrations that have been defined, and data access implementation classes.</span></span> <span data-ttu-id="75885-247">사용 하 여 데이터 액세스 구현 코드를 추상화 하는 가장 일반적인 방법은는 [저장소 디자인 패턴](http://deviq.com/repository-pattern/)합니다.</span><span class="sxs-lookup"><span data-stu-id="75885-247">The most common way to abstract data access implementation code is through the use of the [Repository design pattern](http://deviq.com/repository-pattern/).</span></span>

<span data-ttu-id="75885-248">데이터 액세스 구현 외에도 인프라 프로젝트 인프라 문제가 상호 작용 해야 하는 서비스의 구현을 포함 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="75885-248">In addition to data access implementations, the Infrastructure project should contain implementations of services that must interact with infrastructure concerns.</span></span> <span data-ttu-id="75885-249">이러한 서비스 응용 프로그램 필수 요소에 정의 된 인터페이스를 구현 해야 하 이며 따라서 인프라 Application Core 프로젝트에 대 한 참조가 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="75885-249">These services should implement interfaces defined in the Application Core, and so Infrastructure should have a reference to the Application Core project.</span></span>

> ### <a name="infrastructure-types"></a><span data-ttu-id="75885-250">인프라 유형</span><span class="sxs-lookup"><span data-stu-id="75885-250">Infrastructure Types</span></span>
> -   <span data-ttu-id="75885-251">EF 코어 유형 (DbContext, 마이그레이션)</span><span class="sxs-lookup"><span data-stu-id="75885-251">EF Core types (DbContext, Migrations)</span></span>
> -   <span data-ttu-id="75885-252">데이터 액세스 구현 형식 (리포지토리)</span><span class="sxs-lookup"><span data-stu-id="75885-252">Data access implementation types (Repositories)</span></span>
> -   <span data-ttu-id="75885-253">인프라 관련 서비스 (FileLogger, SmtpNotifier 등)</span><span class="sxs-lookup"><span data-stu-id="75885-253">Infrastructure-specific services (FileLogger, SmtpNotifier, etc.)</span></span>

<span data-ttu-id="75885-254">ASP.NET Core MVC 응용 프로그램에서 사용자 인터페이스 계층을 응용 프로그램에 대 한 진입점 되며 ASP.NET Core MVC 프로젝트 됩니다.</span><span class="sxs-lookup"><span data-stu-id="75885-254">The user interface layer in an ASP.NET Core MVC application will be the entry point for the application, and will be an ASP.NET Core MVC project.</span></span> <span data-ttu-id="75885-255">이 프로젝트는 응용 프로그램 코어 프로젝트를 참조 해야 하 고 인프라 코어 응용 프로그램에에서 정의 된 인터페이스를 통해 엄격 하 게 상호 작용 하는 자체의 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="75885-255">This project should reference the Application Core project, and its types should interact with infrastructure strictly through interfaces defined in Application Core.</span></span> <span data-ttu-id="75885-256">없음의 직접 인스턴스화 (또는에 대 한 정적 호출) UI 계층의 인프라 계층 유형을 허용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="75885-256">No direct instantiation of (or static calls to) Infrastructure layer types should be permitted in the UI layer.</span></span>

> ### <a name="ui-layer-types"></a><span data-ttu-id="75885-257">UI 레이어 형식</span><span class="sxs-lookup"><span data-stu-id="75885-257">UI Layer Types</span></span>
> -   <span data-ttu-id="75885-258">컨트롤러</span><span class="sxs-lookup"><span data-stu-id="75885-258">Controllers</span></span>
> -   <span data-ttu-id="75885-259">필터</span><span class="sxs-lookup"><span data-stu-id="75885-259">Filters</span></span>
> -   <span data-ttu-id="75885-260">보기</span><span class="sxs-lookup"><span data-stu-id="75885-260">Views</span></span>
> -   <span data-ttu-id="75885-261">Viewmodel</span><span class="sxs-lookup"><span data-stu-id="75885-261">ViewModels</span></span>
> -   <span data-ttu-id="75885-262">시작</span><span class="sxs-lookup"><span data-stu-id="75885-262">Startup</span></span>

<span data-ttu-id="75885-263">시작 클래스는 응용 프로그램을 구성 하는 것에 대 한 마우스 구현 형식 연결은 대 한 인터페이스를 런타임 시 제대로 작동 하려면 종속성 주입을 허용 하 합니다.</span><span class="sxs-lookup"><span data-stu-id="75885-263">The Startup class is responsible for configuring the application, and for wiring up implementation types to interfaces, allowing dependency injection to work properly at run time.</span></span>

> [!NOTE]
> <span data-ttu-id="75885-264">UI 프로젝트의 ConfigureServices Startup.cs 파일에서의 종속성 주입을 연결 하기 위해 인프라 프로젝트 참조 프로젝트 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="75885-264">In order to wire up dependency injection in ConfigureServices in the Startup.cs file of the UI project, the project may need to reference the Infrastructure project.</span></span> <span data-ttu-id="75885-265">가장 쉽게 사용자 지정 DI 컨테이너를 사용 하 여이 종속성은 제거 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="75885-265">This dependency can be eliminated, most easily by using a custom DI container.</span></span> <span data-ttu-id="75885-266">이 샘플에서는 UI 프로젝트 인프라 프로젝트 참조를 허용 하는 가장 간단한 방법이입니다.</span><span class="sxs-lookup"><span data-stu-id="75885-266">For the purposes of this sample, the simplest approach is to allow the UI project to reference the Infrastructure project.</span></span>

## <a name="monolithic-applications-and-containers"></a><span data-ttu-id="75885-267">단일 응용 프로그램 및 컨테이너</span><span class="sxs-lookup"><span data-stu-id="75885-267">Monolithic Applications and Containers</span></span> 

<span data-ttu-id="75885-268">단일 및 모놀리식 배포 기반된 웹 응용 프로그램 또는 서비스 빌드하고 컨테이너로 배포할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="75885-268">You can build a single and monolithic-deployment based Web Application or Service and deploy it as a container.</span></span> <span data-ttu-id="75885-269">응용 프로그램 내에서 모놀리식 하지만 구성 된 여러 라이브러리, 구성 요소 또는 계층에는 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="75885-269">Within the application, it might not be monolithic but organized into several libraries, components or layers.</span></span> <span data-ttu-id="75885-270">외부에서 단일 프로세스, 단일 웹 응용 프로그램 또는 단일 서비스와 같은 단일의 컨테이너입니다.</span><span class="sxs-lookup"><span data-stu-id="75885-270">Externally it is a single container like a single process, single web application or single service.</span></span>

<span data-ttu-id="75885-271">이 모델을 관리 하려면 응용 프로그램을 나타내는 단일 컨테이너를 배포 합니다.</span><span class="sxs-lookup"><span data-stu-id="75885-271">To manage this model, you deploy a single container to represent the application.</span></span> <span data-ttu-id="75885-272">을 크기 조정 하려면 앞에 부하 분산 장치 추가 복사본이 추가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="75885-272">To scale, just add additional copies with a load balancer in front.</span></span> <span data-ttu-id="75885-273">간단 하 게 단일 컨테이너 또는 VM에 단일 배포를 관리에서 제공 됩니다.</span><span class="sxs-lookup"><span data-stu-id="75885-273">The simplicity comes from managing a single deployment in a single container or VM.</span></span>

![](./media/image5-13.png)

<span data-ttu-id="75885-274">그림 5-X와 같이 여러 구성 요소/라이브러리 또는 각 컨테이너 내에서 내부 레이어를 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="75885-274">You can include multiple components/libraries or internal layers within each container, as illustrated in Figure 5-X.</span></span> <span data-ttu-id="75885-275">그러나의 컨테이너 주체를 따라 *"컨테이너는 하나의 작업을 수행 하며 하나의 프로세스에는*", 모놀리식 패턴 충돌이 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="75885-275">But, following the container principal of *"a container does one thing, and does it in one process*", the monolithic pattern might be a conflict.</span></span>

<span data-ttu-id="75885-276">이 방법의 단점은/응용 프로그램 증가 확장할 필요 하면 제공 됩니다.</span><span class="sxs-lookup"><span data-stu-id="75885-276">The downside of this approach comes if/when the application grows, requiring it to scale.</span></span> <span data-ttu-id="75885-277">전체 응용 프로그램의 배율 조정 없는 경우 실제로 문제가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="75885-277">If the entire application scaled, it's not really a problem.</span></span> <span data-ttu-id="75885-278">그러나 대부분의 경우에서 응용 프로그램의 몇 가지 파트는 다른 구성 요소는 크기 조정 요구 좁게 포인트를 사용 하 작은입니다.</span><span class="sxs-lookup"><span data-stu-id="75885-278">However, in most cases, a few parts of the application are the choke points requiring scaling, while other components are used less.</span></span>

<span data-ttu-id="75885-279">일반적인 전자 상거래 예제;를 사용 하 여 가능성이 필요한 크기를 조정 하는 제품 정보 구성 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="75885-279">Using the typical eCommerce example; what you likely need to scale is the product information component.</span></span> <span data-ttu-id="75885-280">보다 많은 고객 구입 보다 제품을 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="75885-280">Many more customers browse products than purchase them.</span></span> <span data-ttu-id="75885-281">더 많은 고객 결제 파이프라인을 사용 하는 보다 자신의 바구니를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="75885-281">More customers use their basket than use the payment pipeline.</span></span> <span data-ttu-id="75885-282">더 적은 수의 고객 주석을 추가 하거나 자신의 구매 기록을 봅니다.</span><span class="sxs-lookup"><span data-stu-id="75885-282">Fewer customers add comments or view their purchase history.</span></span> <span data-ttu-id="75885-283">있고 가능성이는 소수의 콘텐츠 및 마케팅 캠페인을 관리 해야 하는 단일 지역에서 직원입니다.</span><span class="sxs-lookup"><span data-stu-id="75885-283">And you likely only have a handful of employees, in a single region, that need to manage the content and marketing campaigns.</span></span> <span data-ttu-id="75885-284">모놀리식 디자인을 조정 하 여 모든 코드가 여러 번 배포 됩니다.</span><span class="sxs-lookup"><span data-stu-id="75885-284">By scaling the monolithic design, all the code is deployed multiple times.</span></span>

<span data-ttu-id="75885-285">눈금 외에도 모든 문제를 단일 구성 요소에 대 한 변경 필요는 전체 응용 프로그램 및 모든 인스턴스의 전체 배포 시의 전체 다시 테스트 합니다.</span><span class="sxs-lookup"><span data-stu-id="75885-285">In addition to the scale everything problem, changes to a single component require complete retesting of the entire application, and a complete redeployment of all the instances.</span></span>

<span data-ttu-id="75885-286">일반적으로 모놀리식 접근 방식 및 대부분의 조직에서는이 아키텍처 접근 방법을 사용 하 여 개발 합니다.</span><span class="sxs-lookup"><span data-stu-id="75885-286">The monolithic approach is common, and many organizations are developing with this architectural approach.</span></span> <span data-ttu-id="75885-287">많은 발생 양호 충분 한 결과 다른 제한 도달 하는 동안.</span><span class="sxs-lookup"><span data-stu-id="75885-287">Many are having good enough results, while others are hitting limits.</span></span> <span data-ttu-id="75885-288">여러 도구 및 인프라 서비스 지향 아키텍처 soa (권한)을 작성 하기 너무 어렵습니다 되 고 응용 프로그램 증가 될 때까지 필요-표시 하지 않은 때문에이 모델에서 응용 프로그램의 설계 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="75885-288">Many designed their applications in this model, because the tools and infrastructure were too difficult to build service oriented architectures (SOA), and they didn't see the need - until the app grew.</span></span> <span data-ttu-id="75885-289">모놀리식 접근 방법의 제한에 도달 하는 경우 컨테이너와 microservices 더 잘 활용할 수 있도록 앱을 분할 해 다음 논리 단계 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="75885-289">If you find you're hitting the limits of the monolithic approach, breaking the app up to enable it to better leverage containers and microservices may be the next logical step.</span></span>

![](./media/image5-14.png)

<span data-ttu-id="75885-290">Microsoft Azure에서 단일 응용 프로그램 배포 각 인스턴스에 대 한 전용된 Vm을 사용 하 여 구현할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="75885-290">Deploying monolithic applications in Microsoft Azure can be achieved using dedicated VMs for each instance.</span></span> <span data-ttu-id="75885-291">사용 하 여 [Azure VM 크기 집합이](https://docs.microsoft.com/azure/virtual-machine-scale-sets/), Vm을 쉽게 확장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="75885-291">Using [Azure VM Scale Sets](https://docs.microsoft.com/azure/virtual-machine-scale-sets/), you can easily scale the VMs.</span></span> <span data-ttu-id="75885-292">[Azure 앱 서비스](https://azure.microsoft.com/services/app-service/) 모놀리식 응용 프로그램을 실행 하 고 Vm을 관리 하지 않고도 인스턴스를 쉽게 확장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="75885-292">[Azure App Services](https://azure.microsoft.com/services/app-service/) can run monolithic applications and easily scale instances without having to manage the VMs.</span></span> <span data-ttu-id="75885-293">Azure 앱 서비스 배포를 단순화 뿐, Docker 컨테이너의 단일 인스턴스를 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="75885-293">Azure App Services can run single instances of Docker containers as well, simplifying the deployment.</span></span> <span data-ttu-id="75885-294">Docker를 사용 하는 Docker 호스트에 단일 VM을 배포 하 고 여러 인스턴스를 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="75885-294">Using Docker, you can deploy a single VM as a Docker host, and run multiple instances.</span></span> <span data-ttu-id="75885-295">그림 5-14에 표시 된 것 처럼 Azure 분산 장치를 사용 하 여, 크기 조정을 관리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="75885-295">Using the Azure balancer, as shown in the Figure 5-14, you can manage scaling.</span></span>

<span data-ttu-id="75885-296">일반적인 배포 방법으로 다양 한 호스트에 배포를 관리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="75885-296">The deployment to the various hosts can be managed with traditional deployment techniques.</span></span> <span data-ttu-id="75885-297">와 같은 명령을 사용 하 여 Docker 호스트를 관리 **docker 실행** 지속적인 배달 (CD) 파이프라인 등을 수동으로 또는 자동화를 통해 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="75885-297">The Docker hosts can be managed with commands like **docker run** performed manually, or through automation such as Continuous Delivery (CD) pipelines.</span></span>

### <a name="monolithic-application-deployed-as-a-container"></a><span data-ttu-id="75885-298">컨테이너 배포 되는 모놀리식 응용 프로그램</span><span class="sxs-lookup"><span data-stu-id="75885-298">Monolithic application deployed as a container</span></span>

<span data-ttu-id="75885-299">컨테이너를 사용 하 여 단일 응용 프로그램 배포를 관리 하는 이점 있습니다.</span><span class="sxs-lookup"><span data-stu-id="75885-299">There are benefits of using containers to manage monolithic application deployments.</span></span> <span data-ttu-id="75885-300">컨테이너의 인스턴스를 확장 하는 것은 훨씬 보다 쉽고 빠르게 추가 Vm을 배포 합니다.</span><span class="sxs-lookup"><span data-stu-id="75885-300">Scaling the instances of containers is far faster and easier than deploying additional VMs.</span></span> <span data-ttu-id="75885-301">VM 크기 집합을 사용 하 여 Vm의 크기를 조정를 하는 경우에 하는 데 걸리는 시간 인스턴스.</span><span class="sxs-lookup"><span data-stu-id="75885-301">Even when using VM Scale Sets to scale VMs, they take time to instance.</span></span> <span data-ttu-id="75885-302">주 서버 인스턴스 응용 프로그램 인스턴스를 배포할 때 응용 프로그램의 구성은 VM의 일부로 관리 됩니다.</span><span class="sxs-lookup"><span data-stu-id="75885-302">When deployed as app instances, the configuration of the app is managed as part of the VM.</span></span>

<span data-ttu-id="75885-303">Docker 이미지는 훨씬 더 빠른 업데이트를 배포 하 고 효율적인 네트워크입니다.</span><span class="sxs-lookup"><span data-stu-id="75885-303">Deploying updates as Docker images is far faster and network efficient.</span></span> <span data-ttu-id="75885-304">Docker 이미지 롤아웃 속도 (초) 일반적으로 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="75885-304">Docker Images typically start in seconds, speeding rollouts.</span></span> <span data-ttu-id="75885-305">Docker 인스턴스를 중지 하는 것은 발급 하는 것 만큼 쉽게는 **docker stop** 명령, 일반적으로 몇 초에서 완료 합니다.</span><span class="sxs-lookup"><span data-stu-id="75885-305">Tearing down a Docker instance is as easy as issuing a **docker stop** command, typically completing in less than a second.</span></span>

<span data-ttu-id="75885-306">컨테이너를 기본적으로 디자인 하 여 변경할 수 없는 경우 처럼 필요가 있습니다 손상 된 Vm에 대해서는 걱정 반면 디스크에 몇 가지 특정 구성 또는 남아 있는 파일에 대 한 설명 하기 위해 업데이트 스크립트 제거 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="75885-306">As containers are inherently immutable by design, you never need to worry about corrupted VMs, whereas update scripts might forget to account for some specific configuration or file left on disk.</span></span>

<span data-ttu-id="75885-307">구식 응용 프로그램에서 단일 응용 프로그램 배율을 조정할 수 있는 하위 시스템을 손상 시 키 지 Docker 이점을 얻을 수 있습니다 하는 동안 개발 하 고 개별적으로 배포 microservices의 영역에 진입점이 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="75885-307">While monolithic apps can benefit from Docker, breaking up the monolithic application into sub systems which can be scaled, developed and deployed individually may be your entry point into the realm of microservices.</span></span>

> ### <a name="references--common-web-architectures"></a><span data-ttu-id="75885-308">참조 – 일반적인 웹 아키텍처</span><span class="sxs-lookup"><span data-stu-id="75885-308">References – Common Web Architectures</span></span>
> - <span data-ttu-id="75885-309">**정리 아키텍처**</span><span class="sxs-lookup"><span data-stu-id="75885-309">**The Clean Architecture**</span></span>  
> <span data-ttu-id="75885-310"><https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html></span><span class="sxs-lookup"><span data-stu-id="75885-310"><https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html></span></span>
> - <span data-ttu-id="75885-311">**양 파형 아키텍처**</span><span class="sxs-lookup"><span data-stu-id="75885-311">**The Onion Architecture**</span></span>  
> <span data-ttu-id="75885-312"><http://jeffreypalermo.com/blog/the-onion-architecture-part-1/></span><span class="sxs-lookup"><span data-stu-id="75885-312"><http://jeffreypalermo.com/blog/the-onion-architecture-part-1/></span></span>
> - <span data-ttu-id="75885-313">**리포지토리 패턴**</span><span class="sxs-lookup"><span data-stu-id="75885-313">**The Repository Pattern**</span></span>  
> <span data-ttu-id="75885-314"><http://deviq.com/repository-pattern/></span><span class="sxs-lookup"><span data-stu-id="75885-314"><http://deviq.com/repository-pattern/></span></span>
> - <span data-ttu-id="75885-315">**클린 아키텍처 솔루션 예제**</span><span class="sxs-lookup"><span data-stu-id="75885-315">**Clean Architecture Solution Sample**</span></span>  
> <span data-ttu-id="75885-316"><https://github.com/ardalis/cleanarchitecture></span><span class="sxs-lookup"><span data-stu-id="75885-316"><https://github.com/ardalis/cleanarchitecture></span></span>
> - <span data-ttu-id="75885-317">**Microservices 전자책 설계** <http://aka.ms/MicroservicesEbook></span><span class="sxs-lookup"><span data-stu-id="75885-317">**Architecting Microservices e-book** <http://aka.ms/MicroservicesEbook></span></span>

>[!div class="step-by-step"]
<span data-ttu-id="75885-318">[이전] (아키텍처-principles.md) [다음] (공통-클라이언트-쪽-웹-technologies.md)</span><span class="sxs-lookup"><span data-stu-id="75885-318">[Previous] (architectural-principles.md) [Next] (common-client-side-web-technologies.md)</span></span>

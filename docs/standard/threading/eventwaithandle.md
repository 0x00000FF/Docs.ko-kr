---
title: EventWaitHandle
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-standard
ms.tgt_pltfrm: 
ms.topic: article
helpviewer_keywords:
- threading [.NET Framework], EventWaitHandle class
- EventWaitHandle class
- event wait handles [.NET Framework]
- threading [.NET Framework], cross-process synchronization
ms.assetid: 11ee0b38-d663-4617-b793-35eb6c64e9fc
caps.latest.revision: "9"
author: rpetrusha
ms.author: ronpet
manager: wpickett
ms.openlocfilehash: 1bd248133bd95ff05246eb36a8e250247fd7ed61
ms.sourcegitcommit: 4f3fef493080a43e70e951223894768d36ce430a
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 11/21/2017
---
# <a name="eventwaithandle"></a><span data-ttu-id="dba10-102">EventWaitHandle</span><span class="sxs-lookup"><span data-stu-id="dba10-102">EventWaitHandle</span></span>
<span data-ttu-id="dba10-103"><xref:System.Threading.EventWaitHandle> 클래스를 사용 하면 스레드가 신호를 보내 및 신호 대기 하 여 서로 통신할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="dba10-103">The <xref:System.Threading.EventWaitHandle> class allows threads to communicate with each other by signaling and by waiting for signals.</span></span> <span data-ttu-id="dba10-104">이벤트 대기 핸들 (라고도 단순히 이벤트)는 하나 이상의 대기 중인 스레드를 해제 하기 위해 신호를 보낼 수 있는 대기 핸들입니다.</span><span class="sxs-lookup"><span data-stu-id="dba10-104">Event wait handles (also referred to simply as events) are wait handles that can be signaled in order to release one or more waiting threads.</span></span> <span data-ttu-id="dba10-105">신호를 받으면 이벤트 대기 핸들 수동 또는 자동으로 다시 설정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="dba10-105">After it is signaled, an event wait handle is reset either manually or automatically.</span></span> <span data-ttu-id="dba10-106"><xref:System.Threading.EventWaitHandle> 명명된 된 시스템 이벤트 대기 핸들 (명명 된 이벤트 나 시스템 이벤트를 모든 프로세스에 표시) 또는 클래스 중 하나는 로컬 이벤트 대기 핸들 (로컬 이벤트)를 나타낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="dba10-106">The <xref:System.Threading.EventWaitHandle> class can represent either a local event wait handle (local event) or a named system event wait handle (named event or system event, visible to all processes).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="dba10-107">이벤트 대기 핸들 일반적으로.NET Framework의 해당 단어가 의미 의미에서 이벤트를 나타내지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="dba10-107">Event wait handles are not events in the sense usually meant by that word in the .NET Framework.</span></span> <span data-ttu-id="dba10-108">없는 대리자 또는 이벤트 처리기 참여 한다고 합니다.</span><span class="sxs-lookup"><span data-stu-id="dba10-108">There are no delegates or event handlers involved.</span></span> <span data-ttu-id="dba10-109">이벤트가 발생 했음을 일반적으로 되었습니다를 참조 했으며 운영 체제 이벤트로 하 고 act 대기 핸들이 신호를 대기 중인 스레드를 나타내기 때문에를 설명 하는 단어 "이벤트" 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="dba10-109">The word "event" is used to describe them because they have traditionally been referred to as operating-system events, and because the act of signaling the wait handle indicates to waiting threads that an event has occurred.</span></span>  
  
 <span data-ttu-id="dba10-110">모두 로컬 및 명명 된 이벤트 대기 핸들에 의해 보호 되는 시스템 동기화 개체를 사용 하 여 <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> 래퍼는 리소스를 해제 됩니다.</span><span class="sxs-lookup"><span data-stu-id="dba10-110">Both local and named event wait handles use system synchronization objects, which are protected by <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> wrappers to ensure that the resources are released.</span></span> <span data-ttu-id="dba10-111">사용할 수는 <xref:System.Threading.WaitHandle.Dispose%2A> 메서드를 즉시 개체를 사용 하 여 완료 했을 때의 리소스를 해제 합니다.</span><span class="sxs-lookup"><span data-stu-id="dba10-111">You can use the <xref:System.Threading.WaitHandle.Dispose%2A> method to free the resources immediately when you have finished using the object.</span></span>  
  
## <a name="event-wait-handles-that-reset-automatically"></a><span data-ttu-id="dba10-112">자동으로 다시 설정 하는 이벤트 대기 핸들</span><span class="sxs-lookup"><span data-stu-id="dba10-112">Event Wait Handles That Reset Automatically</span></span>  
 <span data-ttu-id="dba10-113">지정 하 여 자동 재설정 이벤트를 만들 <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> 만들 때는 <xref:System.Threading.EventWaitHandle> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="dba10-113">You create an automatic reset event by specifying <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> when you create the <xref:System.Threading.EventWaitHandle> object.</span></span> <span data-ttu-id="dba10-114">이름에서 알 수 있듯이 단일 대기 중인 스레드를 해제 한 후 신호를 받으면이 동기화 이벤트 자동으로 초기화 합니다.</span><span class="sxs-lookup"><span data-stu-id="dba10-114">As its name implies, this synchronization event resets automatically when signaled, after releasing a single waiting thread.</span></span> <span data-ttu-id="dba10-115">호출 하 여 이벤트 신호 해당 <xref:System.Threading.EventWaitHandle.Set%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="dba10-115">Signal the event by calling its <xref:System.Threading.EventWaitHandle.Set%2A> method.</span></span>  
  
 <span data-ttu-id="dba10-116">자동 다시 설정 이벤트는 일반적으로 한 번에 단일 스레드에 대 한 리소스에 대 한 단독 액세스를 제공 하는 데 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="dba10-116">Automatic reset events are usually used to provide exclusive access to a resource for a single thread at a time.</span></span> <span data-ttu-id="dba10-117">호출 하 여 리소스를 요청 하는 스레드는 <xref:System.Threading.WaitHandle.WaitOne%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="dba10-117">A thread requests the resource by calling the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="dba10-118">메서드가 반환 하는 경우 다른 스레드에서 대기 핸들을 보류 중인 `true` 호출 스레드는 리소스를 제어 하 고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="dba10-118">If no other thread is holding the wait handle, the method returns `true` and the calling thread has control of the resource.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="dba10-119">모든 동기화 메커니즘에서와 마찬가지로 모든 코드 경로 보호 된 리소스에 액세스 하기 전에 적절 한 대기 핸들에 대기 함을 확인 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="dba10-119">As with all synchronization mechanisms, you must ensure that all code paths wait on the appropriate wait handle before accessing a protected resource.</span></span> <span data-ttu-id="dba10-120">스레드 동기화는 협력 작업 합니다.</span><span class="sxs-lookup"><span data-stu-id="dba10-120">Thread synchronization is cooperative.</span></span>  
  
 <span data-ttu-id="dba10-121">자동 재설정 이벤트 대기 중인 스레드가 없을 때 신호를 받는, 스레드가 대기 하려고 할 때까지 신호를 받은 유지 합니다.</span><span class="sxs-lookup"><span data-stu-id="dba10-121">If an automatic reset event is signaled when no threads are waiting, it remains signaled until a thread attempts to wait on it.</span></span> <span data-ttu-id="dba10-122">이벤트는 스레드를 해제 하 고 즉시 다시 설정 되며, 이후 스레드를 차단 합니다.</span><span class="sxs-lookup"><span data-stu-id="dba10-122">The event releases the thread and immediately resets, blocking subsequent threads.</span></span>  
  
## <a name="event-wait-handles-that-reset-manually"></a><span data-ttu-id="dba10-123">수동으로 다시 설정 하는 이벤트 대기 핸들</span><span class="sxs-lookup"><span data-stu-id="dba10-123">Event Wait Handles That Reset Manually</span></span>  
 <span data-ttu-id="dba10-124">수동 다시 설정 이벤트를 지정 하 여 만들 <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> 만들 때는 <xref:System.Threading.EventWaitHandle> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="dba10-124">You create a manual reset event by specifying <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> when you create the <xref:System.Threading.EventWaitHandle> object.</span></span> <span data-ttu-id="dba10-125">이름에서 알 수 있듯이 신호를 받은 후이 동기화 이벤트 수동으로 재설정 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="dba10-125">As its name implies, this synchronization event must be reset manually after it has been signaled.</span></span> <span data-ttu-id="dba10-126">재설정를 호출 하 여 해당 <xref:System.Threading.EventWaitHandle.Reset%2A> 메서드, 이벤트 핸들을 대기 하는 스레드가 즉시 진행을 차단 하지 않고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="dba10-126">Until it is reset, by calling its <xref:System.Threading.EventWaitHandle.Reset%2A> method, threads that wait on the event handle proceed immediately without blocking.</span></span>  
  
 <span data-ttu-id="dba10-127">수동 재설정는 블로킹의 문 처럼 이벤트 작동 합니다.</span><span class="sxs-lookup"><span data-stu-id="dba10-127">A manual reset event acts like the gate of a corral.</span></span> <span data-ttu-id="dba10-128">이벤트 신호를 받지 하는 경우에 블로킹 말 처럼 대기 중인 스레드를 차단 합니다.</span><span class="sxs-lookup"><span data-stu-id="dba10-128">When the event is not signaled, threads that wait on it block, like horses in a corral.</span></span> <span data-ttu-id="dba10-129">호출 하 여 이벤트가 신호 때 해당 <xref:System.Threading.EventWaitHandle.Set%2A> 메서드를 대기 중인 모든 스레드는 처리 가능 합니다.</span><span class="sxs-lookup"><span data-stu-id="dba10-129">When the event is signaled, by calling its <xref:System.Threading.EventWaitHandle.Set%2A> method, all waiting threads are free to proceed.</span></span> <span data-ttu-id="dba10-130">될 때까지 문제를 해결 되지 않은 해당 <xref:System.Threading.EventWaitHandle.Reset%2A> 메서드를 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="dba10-130">The event remains signaled until its <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.</span></span> <span data-ttu-id="dba10-131">이렇게 하면 수동 다시 설정 이벤트 하나의 스레드가 작업을 완료할 때까지 대기 해야 하는 스레드를 보관 하기 위한 이상적인 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="dba10-131">This makes the manual reset event an ideal way to hold up threads that need to wait until one thread finishes a task.</span></span>  
  
 <span data-ttu-id="dba10-132">꺼낼 말, 처럼 해제 된 스레드가 운영 체제에서 일정 예약 및 실행을 계속 하려면는 시간이 걸립니다.</span><span class="sxs-lookup"><span data-stu-id="dba10-132">Like horses leaving a corral, it takes time for the released threads to be scheduled by the operating system and to resume execution.</span></span> <span data-ttu-id="dba10-133">경우는 <xref:System.Threading.EventWaitHandle.Reset%2A> 모든 스레드의 실행이 다시 시작 되기 전에 메서드가 호출 되 면 다시 한 번 나머지 스레드를 차단 합니다.</span><span class="sxs-lookup"><span data-stu-id="dba10-133">If the <xref:System.Threading.EventWaitHandle.Reset%2A> method is called before all the threads have resumed execution, the remaining threads once again block.</span></span> <span data-ttu-id="dba10-134">어떤 스레드가 다시 시작 및 스레드 차단 되 바탕으로 스레드 수가 시스템에 부하 같은 임의 요소 대기 중인 스케줄러 등에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="dba10-134">Which threads resume and which threads block depends on random factors like the load on the system, the number of threads waiting for the scheduler, and so on.</span></span> <span data-ttu-id="dba10-135">가장 일반적인 사용 패턴, 신호를 보내면 이벤트 신호를 보내는 스레드가 종료 되는 경우에 문제가 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="dba10-135">This is not a problem if the thread that signals the event ends after signaling, which is the most common usage pattern.</span></span> <span data-ttu-id="dba10-136">모든 새 작업을 시작 하려면 이벤트의 대기 스레드가 신호 스레드를 사용 하도록 하려는 경우 대기 중인 모든 스레드가 다시 시작 될 때까지 차단 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="dba10-136">If you want the thread that signaled the event to begin a new task after all the waiting threads have resumed, you must block it until all the waiting threads have resumed.</span></span> <span data-ttu-id="dba10-137">그렇지 않은 경우 경합 조건이 있는 경우 및 코드의 동작을 예측할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="dba10-137">Otherwise, you have a race condition, and the behavior of your code is unpredictable.</span></span>  
  
## <a name="features-common-to-automatic-and-manual-events"></a><span data-ttu-id="dba10-138">자동 및 수동 이벤트에 공통 된 기능</span><span class="sxs-lookup"><span data-stu-id="dba10-138">Features Common to Automatic and Manual Events</span></span>  
 <span data-ttu-id="dba10-139">에 하나 이상의 스레드가 차단 되는 일반적으로 <xref:System.Threading.EventWaitHandle> 차단 되지 않은 스레드가 호출 될 때까지 <xref:System.Threading.EventWaitHandle.Set%2A> (자동 다시 설정 이벤트)의 경우 대기 중인 스레드 중 하나 또는 모두를 고정 하는 메서드 (수동의 경우 다시 설정 이벤트).</span><span class="sxs-lookup"><span data-stu-id="dba10-139">Typically, one or more threads block on an <xref:System.Threading.EventWaitHandle> until an unblocked thread calls the <xref:System.Threading.EventWaitHandle.Set%2A> method, which releases one of the waiting threads (in the case of automatic reset events) or all of them (in the case of manual reset events).</span></span> <span data-ttu-id="dba10-140">스레드를 표시할 수는 <xref:System.Threading.EventWaitHandle> 정적을 호출 하 여 원자성 작업으로,을 차단 <xref:System.Threading.WaitHandle.SignalAndWait%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="dba10-140">A thread can signal an <xref:System.Threading.EventWaitHandle> and then block on it, as an atomic operation, by calling the static <xref:System.Threading.WaitHandle.SignalAndWait%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="dba10-141"><xref:System.Threading.EventWaitHandle>개체를 정적으로 사용할 수 <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> 및 <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="dba10-141"><xref:System.Threading.EventWaitHandle> objects can be used with the static <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> and <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> methods.</span></span> <span data-ttu-id="dba10-142">때문에 <xref:System.Threading.EventWaitHandle> 및 <xref:System.Threading.Mutex> 에서 파생 된 클래스는 모두 <xref:System.Threading.WaitHandle>, 이러한 방법으로 두 클래스를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="dba10-142">Because the <xref:System.Threading.EventWaitHandle> and <xref:System.Threading.Mutex> classes both derive from <xref:System.Threading.WaitHandle>, you can use both classes with these methods.</span></span>  
  
### <a name="named-events"></a><span data-ttu-id="dba10-143">명명 된 이벤트</span><span class="sxs-lookup"><span data-stu-id="dba10-143">Named Events</span></span>  
 <span data-ttu-id="dba10-144">Windows 운영 체제 이름을 이벤트 대기 핸들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="dba10-144">The Windows operating system allows event wait handles to have names.</span></span> <span data-ttu-id="dba10-145">명명된 된 이벤트는 시스템 전체에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="dba10-145">A named event is system wide.</span></span> <span data-ttu-id="dba10-146">즉, 명명된 된 이벤트를 만든 후 모든 프로세스의 모든 스레드가 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="dba10-146">That is, once the named event is created, it is visible to all threads in all processes.</span></span> <span data-ttu-id="dba10-147">따라서 스레드 뿐 아니라 프로세스의 활동을 동기화 할 명명 된 이벤트를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="dba10-147">Thus, named events can be used to synchronize the activities of processes as well as threads.</span></span>  
  
 <span data-ttu-id="dba10-148">만들 수는 <xref:System.Threading.EventWaitHandle> 이벤트 이름을 지정 하는 생성자 중 하나를 사용 하 여 명명된 된 시스템 이벤트를 나타내는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="dba10-148">You can create an <xref:System.Threading.EventWaitHandle> object that represents a named system event by using one of the constructors that specifies an event name.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="dba10-149">없기 때문에 명명 된 이벤트는 시스템 전체를 여러 개 <xref:System.Threading.EventWaitHandle> 동일한 나타내는 개체를 명명 된 이벤트입니다.</span><span class="sxs-lookup"><span data-stu-id="dba10-149">Because named events are system wide, it is possible to have multiple <xref:System.Threading.EventWaitHandle> objects that represent the same named event.</span></span> <span data-ttu-id="dba10-150">생성자를 호출할 때마다 또는 <xref:System.Threading.EventWaitHandle.OpenExisting%2A> 메서드, 새 <xref:System.Threading.EventWaitHandle> 개체가 만들어집니다.</span><span class="sxs-lookup"><span data-stu-id="dba10-150">Each time you call a constructor, or the <xref:System.Threading.EventWaitHandle.OpenExisting%2A> method, a new <xref:System.Threading.EventWaitHandle> object is created.</span></span> <span data-ttu-id="dba10-151">이름이 같은 반복적으로 지정 하면 같은 명명 된 이벤트를 나타내는 개체가 여러 개 만들어집니다.</span><span class="sxs-lookup"><span data-stu-id="dba10-151">Specifying the same name repeatedly creates multiple objects that represent the same named event.</span></span>  
  
 <span data-ttu-id="dba10-152">명명 된 이벤트를 사용 하 여 주의 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="dba10-152">Caution is advised in using named events.</span></span> <span data-ttu-id="dba10-153">시스템 전체 있기 때문에 동일한 이름을 사용 하는 다른 프로세스가 예기치 않게 스레드 차단할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="dba10-153">Because they are system wide, another process that uses the same name can block your threads unexpectedly.</span></span> <span data-ttu-id="dba10-154">그러면 동일 컴퓨터에서 실행되는 악성 코드가 이를 악용해 서비스 거부 공격을 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="dba10-154">Malicious code executing on the same computer could use this as the basis of a denial-of-service attack.</span></span>  
  
 <span data-ttu-id="dba10-155">액세스 제어 보안을 사용 하 여 보호 하는 <xref:System.Threading.EventWaitHandle> 가급적 지정 하는 생성자를 사용 하 여 명명된 된 이벤트를 나타내는 개체입니다는 <xref:System.Security.AccessControl.EventWaitHandleSecurity> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="dba10-155">Use access control security to protect an <xref:System.Threading.EventWaitHandle> object that represents a named event, preferably by using a constructor that specifies an <xref:System.Security.AccessControl.EventWaitHandleSecurity> object.</span></span> <span data-ttu-id="dba10-156">사용 하 여 액세스 제어 보안을 적용할 수도 있습니다는 <xref:System.Threading.EventWaitHandle.SetAccessControl%2A> 메서드를 있지만 이렇게 하면 보호 되는 시간과 이벤트 대기 핸들을 만든 시간 사이 취약 합니다.</span><span class="sxs-lookup"><span data-stu-id="dba10-156">You can also apply access control security using the <xref:System.Threading.EventWaitHandle.SetAccessControl%2A> method, but this leaves a window of vulnerability between the time the event wait handle is created and the time it is protected.</span></span> <span data-ttu-id="dba10-157">이벤트 보호 액세스 제어를 사용한 보안 악의적인 공격을 방지할 수 있지만 의도 하지 않은 이름 충돌 문제가 해결 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="dba10-157">Protecting events with access control security helps prevent malicious attacks, but it does not solve the problem of unintentional name collisions.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="dba10-158">와 달리는 <xref:System.Threading.EventWaitHandle> 클래스, 파생 된 클래스 <xref:System.Threading.AutoResetEvent> 및 <xref:System.Threading.ManualResetEvent> 나타내는 로컬 대기할 수 있는 핸들입니다.</span><span class="sxs-lookup"><span data-stu-id="dba10-158">Unlike the <xref:System.Threading.EventWaitHandle> class, the derived classes <xref:System.Threading.AutoResetEvent> and <xref:System.Threading.ManualResetEvent> can represent only local wait handles.</span></span> <span data-ttu-id="dba10-159">명명 된 시스템 이벤트를 나타낼 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="dba10-159">They cannot represent named system events.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="dba10-160">참고 항목</span><span class="sxs-lookup"><span data-stu-id="dba10-160">See Also</span></span>  
 <xref:System.Threading.EventWaitHandle>  
 <xref:System.Threading.WaitHandle>  
 <xref:System.Threading.AutoResetEvent>  
 <xref:System.Threading.ManualResetEvent>  
 [<span data-ttu-id="dba10-161">EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent</span><span class="sxs-lookup"><span data-stu-id="dba10-161">EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent</span></span>](../../../docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md)

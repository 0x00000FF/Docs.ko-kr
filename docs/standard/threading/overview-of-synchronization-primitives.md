---
title: 동기화 기본 형식 개요
description: 공유 리소스에 대한 액세스를 동기화하거나 스레드 상호 작용을 제어하는 데 사용되는 .NET 스레드 동기화 기본 형식 알아보기
ms.date: 10/01/2018
ms.technology: dotnet-standard
helpviewer_keywords:
- synchronization, threads
- threading [.NET],synchronizing threads
- managed threading
ms.assetid: b782bcb8-da6a-4c6a-805f-2eb46d504309
ms.openlocfilehash: 43f78c914b7cb01f9b0de4c258d5882548e52790
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/15/2020
ms.locfileid: "73106587"
---
# <a name="overview-of-synchronization-primitives"></a><span data-ttu-id="916c1-103">동기화 기본 형식 개요</span><span class="sxs-lookup"><span data-stu-id="916c1-103">Overview of synchronization primitives</span></span>

<span data-ttu-id="916c1-104">.NET은 공유 리소스에 대한 액세스를 동기화하거나 스레드 상호 작용을 조정하는 데 사용할 수 있는 다양한 형식을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="916c1-104">.NET provides a range of types that you can use to synchronize access to a shared resource or coordinate thread interaction.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="916c1-105">동일한 동기화 기본 형식 인스턴스를 사용하여 공유 리소스에 대한 액세스를 보호합니다.</span><span class="sxs-lookup"><span data-stu-id="916c1-105">Use the same synchronization primitive instance to protect access of a shared resource.</span></span> <span data-ttu-id="916c1-106">다른 동기화 기본 형식 인스턴스를 사용하여 동일한 리소스를 보호하는 경우 동기화 기본 형식에서 제공하는 보호를 사용할 수 없게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="916c1-106">If you use different synchronization primitive instances to protect the same resource, you'll circumvent the protection provided by a synchronization primitive.</span></span>

## <a name="waithandle-class-and-lightweight-synchronization-types"></a><span data-ttu-id="916c1-107">WaitHandle 클래스 및 간단한 동기화 형식</span><span class="sxs-lookup"><span data-stu-id="916c1-107">WaitHandle class and lightweight synchronization types</span></span>

<span data-ttu-id="916c1-108">여러 .NET 동기화 기본 형식이 <xref:System.Threading.WaitHandle?displayProperty=nameWithType> 클래스에서 파생됩니다. 이 클래스는 네이티브 운영 체제 동기화 핸들을 캡슐화하고 스레드 상호 작용의 신호 메커니즘을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="916c1-108">Multiple .NET synchronization primitives derive from the <xref:System.Threading.WaitHandle?displayProperty=nameWithType> class, which encapsulates a native operating system synchronization handle and uses a signaling mechanism for thread interaction.</span></span> <span data-ttu-id="916c1-109">해당 클래스에는 다음이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="916c1-109">Those classes include:</span></span>

- <span data-ttu-id="916c1-110"><xref:System.Threading.Mutex?displayProperty=nameWithType> - 공유 리소스에 대한 배타적 액세스 권한을 부여합니다.</span><span class="sxs-lookup"><span data-stu-id="916c1-110"><xref:System.Threading.Mutex?displayProperty=nameWithType>, which grants exclusive access to a shared resource.</span></span> <span data-ttu-id="916c1-111">뮤텍스의 상태는 스레드가 소유하지 않는 경우 신호를 받습니다.</span><span class="sxs-lookup"><span data-stu-id="916c1-111">The state of a mutex is signaled if no thread owns it.</span></span>
- <span data-ttu-id="916c1-112"><xref:System.Threading.Semaphore?displayProperty=nameWithType> - 공유 리소스 또는 리소스 풀에 동시에 액세스할 수 있는 스레드 수를 제한합니다.</span><span class="sxs-lookup"><span data-stu-id="916c1-112"><xref:System.Threading.Semaphore?displayProperty=nameWithType>, which limits the number of threads that can access a shared resource or a pool of resources concurrently.</span></span> <span data-ttu-id="916c1-113">세마포 상태는 해당 개수가 0보다 크면 신호 알림으로 설정되고 해당 개수가 0이면 신호 알림 해제로 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="916c1-113">The state of a semaphore is set to signaled when its count is greater than zero, and nonsignaled when its count is zero.</span></span>
- <span data-ttu-id="916c1-114"><xref:System.Threading.EventWaitHandle?displayProperty=nameWithType> - 스레드 동기화 이벤트를 나타내고 신호 알림 또는 신호 알림 해제 상태일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="916c1-114"><xref:System.Threading.EventWaitHandle?displayProperty=nameWithType>, which represents a thread synchronization event and can be either in a signaled or unsignaled state.</span></span>
- <span data-ttu-id="916c1-115"><xref:System.Threading.AutoResetEvent?displayProperty=nameWithType> - <xref:System.Threading.EventWaitHandle>에서 파생되고 신호 알림을 받으면 단일 대기 스레드를 해제한 후 자동으로 신호 알림 해제 상태로 다시 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="916c1-115"><xref:System.Threading.AutoResetEvent?displayProperty=nameWithType>, which derives from <xref:System.Threading.EventWaitHandle> and, when signaled, resets automatically to an unsignaled state after releasing a single waiting thread.</span></span>
- <span data-ttu-id="916c1-116"><xref:System.Threading.ManualResetEvent?displayProperty=nameWithType> - <xref:System.Threading.EventWaitHandle>에서 파생되고 신호 알림을 받을 경우 <xref:System.Threading.EventWaitHandle.Reset%2A> 메서드가 호출될 때까지 신호 알림 상태를 유지합니다.</span><span class="sxs-lookup"><span data-stu-id="916c1-116"><xref:System.Threading.ManualResetEvent?displayProperty=nameWithType>, which derives from <xref:System.Threading.EventWaitHandle> and, when signaled, stays in a signaled state until the <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.</span></span>

<span data-ttu-id="916c1-117">.NET Framework에서 <xref:System.Threading.WaitHandle>은 <xref:System.MarshalByRefObject?displayProperty=nameWithType>에서 파생되므로 대기 핸들을 사용하여 애플리케이션 도메인 경계에 걸쳐 스레드 활동을 동기화할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="916c1-117">In the .NET Framework, because <xref:System.Threading.WaitHandle> derives from <xref:System.MarshalByRefObject?displayProperty=nameWithType>, these types can be used to synchronize the activities of threads across application domain boundaries.</span></span>

<span data-ttu-id="916c1-118">.NET Framework 및 .NET Core에서 이러한 형식 중 일부는 운영 체제 전체에 표시되고 프로세스 간 동기화에 사용할 수 있는 명명된 시스템 동기화 핸들을 나타낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="916c1-118">In the .NET Framework and .NET Core, some of these types can represent named system synchronization handles, which are visible throughout the operating system and can be used for the inter-process synchronization:</span></span>

- <span data-ttu-id="916c1-119"><xref:System.Threading.Mutex>(.NET Framework 및 .NET Core),</span><span class="sxs-lookup"><span data-stu-id="916c1-119"><xref:System.Threading.Mutex> (.NET Framework and .NET Core),</span></span>
- <span data-ttu-id="916c1-120"><xref:System.Threading.Semaphore>(Windows의 .NET Framework 및 .NET Core),</span><span class="sxs-lookup"><span data-stu-id="916c1-120"><xref:System.Threading.Semaphore> (.NET Framework and .NET Core on Windows),</span></span>
- <span data-ttu-id="916c1-121"><xref:System.Threading.EventWaitHandle>(Windows의 .NET Framework 및 .NET Core).</span><span class="sxs-lookup"><span data-stu-id="916c1-121"><xref:System.Threading.EventWaitHandle> (.NET Framework and .NET Core on Windows).</span></span>

<span data-ttu-id="916c1-122">자세한 내용은 <xref:System.Threading.WaitHandle> API 참조를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="916c1-122">For more information, see the <xref:System.Threading.WaitHandle> API reference.</span></span>

<span data-ttu-id="916c1-123">간단한 동기화 형식은 기본 운영 체제 핸들을 사용하지 않고 일반적으로 향상된 성능을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="916c1-123">Lightweight synchronization types don't rely on underlying operating system handles and typically provide better performance.</span></span> <span data-ttu-id="916c1-124">그러나 프로세스 간 동기화에는 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="916c1-124">However, they cannot be used for the inter-process synchronization.</span></span> <span data-ttu-id="916c1-125">한 애플리케이션 내에서 이러한 형식의 스레드 동기화를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="916c1-125">Use those types for thread synchronization within one application.</span></span>

<span data-ttu-id="916c1-126">이러한 형식 중 일부는 <xref:System.Threading.WaitHandle>에서 파생된 형식의 대체 항목입니다.</span><span class="sxs-lookup"><span data-stu-id="916c1-126">Some of those types are alternatives to the types derived from <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="916c1-127">예를 들어 <xref:System.Threading.SemaphoreSlim>은 <xref:System.Threading.Semaphore>의 간단한 대체 항목입니다.</span><span class="sxs-lookup"><span data-stu-id="916c1-127">For example, <xref:System.Threading.SemaphoreSlim> is a lightweight alternative to <xref:System.Threading.Semaphore>.</span></span>

## <a name="synchronization-of-access-to-a-shared-resource"></a><span data-ttu-id="916c1-128">공유 리소스에 대한 액세스 동기화</span><span class="sxs-lookup"><span data-stu-id="916c1-128">Synchronization of access to a shared resource</span></span>

<span data-ttu-id="916c1-129">.NET은 여러 스레드가 공유 리소스에 대한 액세스를 제어할 수 있는 다양한 동기화 기본 형식을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="916c1-129">.NET provides a range of synchronization primitives to control access to a shared resource by multiple threads.</span></span>

### <a name="monitor-class"></a><span data-ttu-id="916c1-130">Monitor 클래스</span><span class="sxs-lookup"><span data-stu-id="916c1-130">Monitor class</span></span>

<span data-ttu-id="916c1-131"><xref:System.Threading.Monitor?displayProperty=nameWithType> 클래스는 리소스를 식별하는 개체에 대한 잠금을 획득하거나 해제하여 공유 리소스에 대한 상호 배타적 액세스 권한을 부여합니다.</span><span class="sxs-lookup"><span data-stu-id="916c1-131">The <xref:System.Threading.Monitor?displayProperty=nameWithType> class grants mutually exclusive access to a shared resource by acquiring or releasing a lock on the object that identifies the resource.</span></span> <span data-ttu-id="916c1-132">잠금이 유지되는 동안 잠금을 보유하는 스레드는 잠금을 다시 획득하고 해제할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="916c1-132">While a lock is held, the thread that holds the lock can again acquire and release the lock.</span></span> <span data-ttu-id="916c1-133">다른 스레드는 잠금을 획득할 수 없도록 차단되고 <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> 메서드는 잠금이 해제될 때까지 대기합니다.</span><span class="sxs-lookup"><span data-stu-id="916c1-133">Any other thread is blocked from acquiring the lock and the <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> method waits until the lock is released.</span></span> <span data-ttu-id="916c1-134"><xref:System.Threading.Monitor.Enter%2A> 메서드는 해제된 잠금을 획득합니다.</span><span class="sxs-lookup"><span data-stu-id="916c1-134">The <xref:System.Threading.Monitor.Enter%2A> method acquires a released lock.</span></span> <span data-ttu-id="916c1-135">또한 <xref:System.Threading.Monitor.TryEnter%2A?displayProperty=nameWithType> 메서드를 사용하여 스레드가 잠금을 획득하려고 시도하는 시간을 지정할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="916c1-135">You can also use the <xref:System.Threading.Monitor.TryEnter%2A?displayProperty=nameWithType> method to specify the amount of time during which a thread attempts to acquire a lock.</span></span> <span data-ttu-id="916c1-136"><xref:System.Threading.Monitor> 클래스에 스레드 선호도가 있으므로 잠금을 획득한 스레드는 <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> 메서드를 호출하여 잠금을 해제해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="916c1-136">Because the <xref:System.Threading.Monitor> class has thread affinity, the thread that acquired a lock must release the lock by calling the <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> method.</span></span>

<span data-ttu-id="916c1-137"><xref:System.Threading.Monitor.Wait%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType> 및 <xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType> 메서드를 사용하여 동일한 개체에 대한 잠금을 획득하는 스레드의 상호 작용을 조정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="916c1-137">You can coordinate the interaction of threads that acquire a lock on the same object by using the <xref:System.Threading.Monitor.Wait%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType>, and <xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType> methods.</span></span>

<span data-ttu-id="916c1-138">자세한 내용은 <xref:System.Threading.Monitor> API 참조를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="916c1-138">For more information, see the <xref:System.Threading.Monitor> API reference.</span></span>

> [!NOTE]
> <span data-ttu-id="916c1-139">[ 클래스를 직접 사용하는 대신 C#의 ](../../csharp/language-reference/keywords/lock-statement.md)lock[ 문 및 Visual Basic의 ](../../visual-basic/language-reference/statements/synclock-statement.md)SyncLock<xref:System.Threading.Monitor> 문을 사용하여 공유 리소스에 대한 액세스를 동기화합니다.</span><span class="sxs-lookup"><span data-stu-id="916c1-139">Use the [lock](../../csharp/language-reference/keywords/lock-statement.md) statement in C# and the [SyncLock](../../visual-basic/language-reference/statements/synclock-statement.md) statement in Visual Basic to synchronize access to a shared resource instead of using the <xref:System.Threading.Monitor> class directly.</span></span> <span data-ttu-id="916c1-140">이러한 문은 획득한 잠금이 항상 해제되도록 <xref:System.Threading.Monitor.Enter%2A> 및 <xref:System.Threading.Monitor.Exit%2A> 메서드와 `try…finally` 블록을 사용하여 구현됩니다.</span><span class="sxs-lookup"><span data-stu-id="916c1-140">Those statements are implemented by using the <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A> methods and a `try…finally` block to ensure that the acquired lock is always released.</span></span>

### <a name="mutex-class"></a><span data-ttu-id="916c1-141">Mutex 클래스</span><span class="sxs-lookup"><span data-stu-id="916c1-141">Mutex class</span></span>

<span data-ttu-id="916c1-142"><xref:System.Threading.Mutex?displayProperty=nameWithType>와 같은 <xref:System.Threading.Monitor> 클래스는 공유 리소스에 대한 배타적 액세스 권한을 부여합니다.</span><span class="sxs-lookup"><span data-stu-id="916c1-142">The <xref:System.Threading.Mutex?displayProperty=nameWithType> class, like <xref:System.Threading.Monitor>, grants exclusive access to a shared resource.</span></span> <span data-ttu-id="916c1-143">[Mutex.WaitOne](<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>) 메서드 오버로드 중 하나를 사용하여 뮤텍스의 소유권을 요청합니다.</span><span class="sxs-lookup"><span data-stu-id="916c1-143">Use one of the [Mutex.WaitOne](<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>) method overloads to request the ownership of a mutex.</span></span> <span data-ttu-id="916c1-144"><xref:System.Threading.Monitor>와 마찬가지로 <xref:System.Threading.Mutex>에는 스레드 선호도가 있고 뮤텍스를 획득한 스레드는 <xref:System.Threading.Mutex.ReleaseMutex%2A?displayProperty=nameWithType> 메서드를 호출하여 뮤텍스를 해제해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="916c1-144">Like <xref:System.Threading.Monitor>, <xref:System.Threading.Mutex> has thread affinity and the thread that acquired a mutex must release it by calling the <xref:System.Threading.Mutex.ReleaseMutex%2A?displayProperty=nameWithType> method.</span></span>

<span data-ttu-id="916c1-145"><xref:System.Threading.Monitor>와 달리 <xref:System.Threading.Mutex> 클래스는 프로세스 간 동기화에 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="916c1-145">Unlike <xref:System.Threading.Monitor>, the <xref:System.Threading.Mutex> class can be used for inter-process synchronization.</span></span> <span data-ttu-id="916c1-146">이를 수행하려면 운영 체제 전체에 표시되는 명명된 뮤텍스를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="916c1-146">To do that, use a named mutex, which is visible throughout the operating system.</span></span> <span data-ttu-id="916c1-147">명명된 뮤텍스 인스턴스를 만들려면 이름을 지정하는 [뮤텍스 생성자](<xref:System.Threading.Mutex.%23ctor%2A>)를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="916c1-147">To create a named mutex instance, use a [Mutex constructor](<xref:System.Threading.Mutex.%23ctor%2A>) that specifies a name.</span></span> <span data-ttu-id="916c1-148"><xref:System.Threading.Mutex.OpenExisting%2A?displayProperty=nameWithType> 메서드를 호출하여 기존 명명된 시스템 뮤텍스를 열 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="916c1-148">You also can call the <xref:System.Threading.Mutex.OpenExisting%2A?displayProperty=nameWithType> method to open an existing named system mutex.</span></span>
  
<span data-ttu-id="916c1-149">자세한 내용은 [뮤텍스](mutexes.md) 문서 및 <xref:System.Threading.Mutex> API 참조를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="916c1-149">For more information, see the [Mutexes](mutexes.md) article and the <xref:System.Threading.Mutex> API reference.</span></span>

### <a name="spinlock-structure"></a><span data-ttu-id="916c1-150">SpinLock 구조체</span><span class="sxs-lookup"><span data-stu-id="916c1-150">SpinLock structure</span></span>

<span data-ttu-id="916c1-151"><xref:System.Threading.SpinLock?displayProperty=nameWithType>와 같은 <xref:System.Threading.Monitor> 구조체는 잠금의 가용성에 따라 공유 리소스에 대한 배타적 액세스 권한을 부여합니다.</span><span class="sxs-lookup"><span data-stu-id="916c1-151">The <xref:System.Threading.SpinLock?displayProperty=nameWithType> structure, like <xref:System.Threading.Monitor>, grants exclusive access to a shared resource based on the availability of a lock.</span></span> <span data-ttu-id="916c1-152"><xref:System.Threading.SpinLock>이 사용할 수 없는 잠금을 획득하려고 하면 잠금을 사용할 수 있을 때까지 루프에서 반복적으로 확인하면서 대기합니다.</span><span class="sxs-lookup"><span data-stu-id="916c1-152">When <xref:System.Threading.SpinLock> attempts to acquire a lock that is unavailable, it waits in a loop, repeatedly checking until the lock becomes available.</span></span>

<span data-ttu-id="916c1-153">회전 잠금을 사용하는 이점 및 결점에 대한 자세한 내용은 [SpinLock](spinlock.md) 문서 및 <xref:System.Threading.SpinLock> API 참조를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="916c1-153">For more information about the benefits and drawbacks of using spin lock, see the [SpinLock](spinlock.md) article and the <xref:System.Threading.SpinLock> API reference.</span></span>

### <a name="readerwriterlockslim-class"></a><span data-ttu-id="916c1-154">ReaderWriterLockSlim 클래스</span><span class="sxs-lookup"><span data-stu-id="916c1-154">ReaderWriterLockSlim class</span></span>

<span data-ttu-id="916c1-155"><xref:System.Threading.ReaderWriterLockSlim?displayProperty=nameWithType> 클래스는 쓰기 위해 공유 리소스에 대한 배타적 액세스 권한을 부여하고, 읽기 위해 여러 스레드가 동시에 리소스에 액세스하도록 허용합니다.</span><span class="sxs-lookup"><span data-stu-id="916c1-155">The <xref:System.Threading.ReaderWriterLockSlim?displayProperty=nameWithType> class grants exclusive access to a shared resource for writing and allows multiple threads to access the resource simultaneously for reading.</span></span> <span data-ttu-id="916c1-156"><xref:System.Threading.ReaderWriterLockSlim>을 사용하여 스레드로부터 안전한 읽기 작업을 지원하지만 쓰기 작업을 수행할 배타적 액세스 권한이 필요한 공유 데이터 구조에 대한 액세스를 동기화할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="916c1-156">You might want to use <xref:System.Threading.ReaderWriterLockSlim> to synchronize access to a shared data structure that supports thread-safe read operations, but requires exclusive access to perform write operation.</span></span> <span data-ttu-id="916c1-157">스레드가 배타적 액세스를 요청하면(예: <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A?displayProperty=nameWithType> 메서드 호출을 통해) 모든 기존 판독기가 잠금을 종료하고 작성기가 잠금을 시작 및 종료할 때까지 후속 판독기 및 작성기 요청이 차단됩니다.</span><span class="sxs-lookup"><span data-stu-id="916c1-157">When a thread requests exclusive access (for example, by calling the <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A?displayProperty=nameWithType> method), subsequent reader and writer requests block until all existing readers have exited the lock, and the writer has entered and exited the lock.</span></span>
  
<span data-ttu-id="916c1-158">자세한 내용은 <xref:System.Threading.ReaderWriterLockSlim> API 참조를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="916c1-158">For more information, see the <xref:System.Threading.ReaderWriterLockSlim> API reference.</span></span>

### <a name="semaphore-and-semaphoreslim-classes"></a><span data-ttu-id="916c1-159">세마포 및 SemaphoreSlim 클래스</span><span class="sxs-lookup"><span data-stu-id="916c1-159">Semaphore and SemaphoreSlim classes</span></span>

<span data-ttu-id="916c1-160"><xref:System.Threading.Semaphore?displayProperty=nameWithType> 및 <xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType> 클래스는 공유 리소스 또는 리소스 풀에 동시에 액세스할 수 있는 스레드 수를 제한합니다.</span><span class="sxs-lookup"><span data-stu-id="916c1-160">The <xref:System.Threading.Semaphore?displayProperty=nameWithType> and <xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType> classes limit the number of threads that can access a shared resource or a pool of resources concurrently.</span></span> <span data-ttu-id="916c1-161">리소스를 요청하는 추가적인 스레드는 스레드가 세마포를 해제할 때까지 대기합니다.</span><span class="sxs-lookup"><span data-stu-id="916c1-161">Additional threads that request the resource wait until any thread releases the semaphore.</span></span> <span data-ttu-id="916c1-162">세마포에는 스레드 선호도가 없으므로 한 스레드가 세마포를 획득할 수 있고 또 다른 스레드가 해당 세마포를 해제할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="916c1-162">Because the semaphore doesn't have thread affinity, a thread can acquire the semaphore and another one can release it.</span></span>

<span data-ttu-id="916c1-163"><xref:System.Threading.SemaphoreSlim>은 <xref:System.Threading.Semaphore>의 간단한 대체 항목이고 단일 프로세스 경계 내의 동기화에만 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="916c1-163"><xref:System.Threading.SemaphoreSlim> is a lightweight alternative to <xref:System.Threading.Semaphore> and can be used only for synchronization within a single process boundary.</span></span>

<span data-ttu-id="916c1-164">Windows에서는 프로세스 간 동기화에 <xref:System.Threading.Semaphore>를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="916c1-164">On Windows, you can use <xref:System.Threading.Semaphore> for the inter-process synchronization.</span></span> <span data-ttu-id="916c1-165">이 작업을 수행하려면 이름을 지정하는 <xref:System.Threading.Semaphore>세마포 생성자[ 중 하나 또는 ](<xref:System.Threading.Semaphore.%23ctor%2A>) 메서드를 사용하여 명명된 시스템 세마포를 나타내는 <xref:System.Threading.Semaphore.OpenExisting%2A?displayProperty=nameWithType> 인스턴스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="916c1-165">To do that, create a <xref:System.Threading.Semaphore> instance that represents a named system semaphore by using one of the [Semaphore constructors](<xref:System.Threading.Semaphore.%23ctor%2A>) that specifies a name or the <xref:System.Threading.Semaphore.OpenExisting%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="916c1-166"><xref:System.Threading.SemaphoreSlim>은 명명된 시스템 세마포를 지원하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="916c1-166"><xref:System.Threading.SemaphoreSlim> doesn't support named system semaphores.</span></span>

<span data-ttu-id="916c1-167">자세한 내용은 [세마포 및 SemaphoreSlim](semaphore-and-semaphoreslim.md) 문서와 <xref:System.Threading.Semaphore> 또는 <xref:System.Threading.SemaphoreSlim> API 참조를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="916c1-167">For more information, see the [Semaphore and SemaphoreSlim](semaphore-and-semaphoreslim.md) article and the <xref:System.Threading.Semaphore> or <xref:System.Threading.SemaphoreSlim> API reference.</span></span>

## <a name="thread-interaction-or-signaling"></a><span data-ttu-id="916c1-168">스레드 상호 작용 또는 신호</span><span class="sxs-lookup"><span data-stu-id="916c1-168">Thread interaction, or signaling</span></span>

<span data-ttu-id="916c1-169">스레드 상호 작용(또는 스레드 신호)은 스레드가 계속 진행하기 위해 하나 이상의 스레드에서 알림이나 신호를 기다려야 함을 의미합니다.</span><span class="sxs-lookup"><span data-stu-id="916c1-169">Thread interaction (or thread signaling) means that a thread must wait for notification, or a signal, from one or more threads in order to proceed.</span></span> <span data-ttu-id="916c1-170">예를 들어 스레드 A가 스레드 B의 <xref:System.Threading.Thread.Join%2A?displayProperty=nameWithType> 메서드를 호출하는 경우 스레드 B가 완료될 때까지 스레드 A가 차단됩니다.</span><span class="sxs-lookup"><span data-stu-id="916c1-170">For example, if thread A calls the <xref:System.Threading.Thread.Join%2A?displayProperty=nameWithType> method of thread B, thread A is blocked until thread B completes.</span></span> <span data-ttu-id="916c1-171">이전 섹션에 설명된 동기화 기본 형식은 신호를 위한 다른 메커니즘을 제공합니다. 잠금을 해제함으로써 스레드는 또 다른 스레드에 잠금을 획득하면 계속 진행할 수 있음을 알립니다.</span><span class="sxs-lookup"><span data-stu-id="916c1-171">The synchronization primitives described in the preceding section provide a different mechanism for signaling: by releasing a lock, a thread notifies another thread that it can proceed by acquiring the lock.</span></span>

<span data-ttu-id="916c1-172">이 섹션에서는 .NET에서 제공하는 추가 신호 구문을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="916c1-172">This section describes additional signaling constructs provided by .NET.</span></span>

### <a name="eventwaithandle-autoresetevent-manualresetevent-and-manualreseteventslim-classes"></a><span data-ttu-id="916c1-173">EventWaitHandle, AutoResetEvent, ManualResetEvent 및 ManualResetEventSlim 클래스</span><span class="sxs-lookup"><span data-stu-id="916c1-173">EventWaitHandle, AutoResetEvent, ManualResetEvent, and ManualResetEventSlim classes</span></span>

<span data-ttu-id="916c1-174"><xref:System.Threading.EventWaitHandle?displayProperty=nameWithType> 클래스는 스레드 동기화 이벤트를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="916c1-174">The <xref:System.Threading.EventWaitHandle?displayProperty=nameWithType> class represents a thread synchronization event.</span></span>

<span data-ttu-id="916c1-175">동기화 이벤트는 신호 알림 또는 신호 알림 해제 상태일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="916c1-175">A synchronization event can be either in an unsignaled or signaled state.</span></span> <span data-ttu-id="916c1-176">이벤트 상태가 신호 알림 해제인 경우 이벤트의 <xref:System.Threading.WaitHandle.WaitOne%2A?> 오버로드를 호출하는 스레드는 이벤트가 신호 알림을 받을 때까지 차단됩니다.</span><span class="sxs-lookup"><span data-stu-id="916c1-176">When the state of an event is unsignaled, a thread that calls the event's <xref:System.Threading.WaitHandle.WaitOne%2A?> overload is blocked until an event is signaled.</span></span> <span data-ttu-id="916c1-177"><xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType> 메서드는 이벤트 상태를 신호 알림으로 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="916c1-177">The <xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType> method sets the state of an event to signaled.</span></span>

<span data-ttu-id="916c1-178">신호 알림을 받은 <xref:System.Threading.EventWaitHandle>의 동작은 재설정 모드에 따라 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="916c1-178">The behavior of an <xref:System.Threading.EventWaitHandle> that has been signaled depends on its reset mode:</span></span>

- <span data-ttu-id="916c1-179"><xref:System.Threading.EventWaitHandle> 플래그를 사용하여 만들어진 <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType>은 단일 대기 스레드를 해제한 후 자동으로 다시 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="916c1-179">An <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> flag resets automatically after releasing a single waiting thread.</span></span> <span data-ttu-id="916c1-180">신호 알림을 받을 때마다 스레드를 하나만 허용하는 턴스타일과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="916c1-180">It's like a turnstile that allows only one thread through each time it's signaled.</span></span> <span data-ttu-id="916c1-181"><xref:System.Threading.AutoResetEvent?displayProperty=nameWithType>에서 파생되는 <xref:System.Threading.EventWaitHandle> 클래스는 해당 동작을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="916c1-181">The <xref:System.Threading.AutoResetEvent?displayProperty=nameWithType> class, which derives from <xref:System.Threading.EventWaitHandle>, represents that behavior.</span></span>
- <span data-ttu-id="916c1-182"><xref:System.Threading.EventWaitHandle> 플래그를 사용하여 만들어진 <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType>은 <xref:System.Threading.EventWaitHandle.Reset%2A> 메서드가 호출될 때까지 신호 알림 상태를 유지합니다.</span><span class="sxs-lookup"><span data-stu-id="916c1-182">An <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> flag remains signaled until its <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.</span></span> <span data-ttu-id="916c1-183">신호 알림을 받을 때까지 닫혀 있고 이후 누군가 닫을 때까지 열려 있는 게이트와 같습니다.</span><span class="sxs-lookup"><span data-stu-id="916c1-183">It's like a gate that is closed until signaled and then stays open until someone closes it.</span></span> <span data-ttu-id="916c1-184"><xref:System.Threading.ManualResetEvent?displayProperty=nameWithType>에서 파생되는 <xref:System.Threading.EventWaitHandle> 클래스는 해당 동작을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="916c1-184">The <xref:System.Threading.ManualResetEvent?displayProperty=nameWithType> class, which derives from <xref:System.Threading.EventWaitHandle>, represents that behavior.</span></span> <span data-ttu-id="916c1-185"><xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType> 클래스는 <xref:System.Threading.ManualResetEvent>의 간단한 대체 항목입니다.</span><span class="sxs-lookup"><span data-stu-id="916c1-185">The <xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType> class is a lightweight alternative to <xref:System.Threading.ManualResetEvent>.</span></span>

<span data-ttu-id="916c1-186">Windows에서는 프로세스 간 동기화에 <xref:System.Threading.EventWaitHandle>를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="916c1-186">On Windows, you can use <xref:System.Threading.EventWaitHandle> for the inter-process synchronization.</span></span> <span data-ttu-id="916c1-187">이 작업을 수행하려면 이름을 지정하는 <xref:System.Threading.EventWaitHandle>EventWaitHandle 생성자[ 중 하나 또는 ](<xref:System.Threading.EventWaitHandle.%23ctor%2A>) 메서드를 사용하여 명명된 시스템 동기화 이벤트를 나타내는 <xref:System.Threading.EventWaitHandle.OpenExisting%2A?displayProperty=nameWithType> 인스턴스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="916c1-187">To do that, create a <xref:System.Threading.EventWaitHandle> instance that represents a named system synchronization event by using one of the [EventWaitHandle constructors](<xref:System.Threading.EventWaitHandle.%23ctor%2A>) that specifies a name or the <xref:System.Threading.EventWaitHandle.OpenExisting%2A?displayProperty=nameWithType> method.</span></span>

<span data-ttu-id="916c1-188">자세한 내용은 [EventWaitHandle](eventwaithandle.md) 문서를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="916c1-188">For more information, see the [EventWaitHandle](eventwaithandle.md) article.</span></span> <span data-ttu-id="916c1-189">API 참조에 대해서는 <xref:System.Threading.EventWaitHandle>, <xref:System.Threading.AutoResetEvent>, <xref:System.Threading.ManualResetEvent> 및 <xref:System.Threading.ManualResetEventSlim>을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="916c1-189">For the API reference, see <xref:System.Threading.EventWaitHandle>, <xref:System.Threading.AutoResetEvent>, <xref:System.Threading.ManualResetEvent>, and <xref:System.Threading.ManualResetEventSlim>.</span></span>

### <a name="countdownevent-class"></a><span data-ttu-id="916c1-190">CountdownEvent 클래스</span><span class="sxs-lookup"><span data-stu-id="916c1-190">CountdownEvent class</span></span>

<span data-ttu-id="916c1-191"><xref:System.Threading.CountdownEvent?displayProperty=nameWithType> 클래스는 개수가 0일 때 설정되는 이벤트를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="916c1-191">The <xref:System.Threading.CountdownEvent?displayProperty=nameWithType> class represents an event that becomes set when its count is zero.</span></span> <span data-ttu-id="916c1-192"><xref:System.Threading.CountdownEvent.CurrentCount?displayProperty=nameWithType>는 0보다 크지만 <xref:System.Threading.CountdownEvent.Wait%2A?displayProperty=nameWithType>를 호출하는 스레드가 차단됩니다.</span><span class="sxs-lookup"><span data-stu-id="916c1-192">While <xref:System.Threading.CountdownEvent.CurrentCount?displayProperty=nameWithType> is greater than zero, a thread that calls <xref:System.Threading.CountdownEvent.Wait%2A?displayProperty=nameWithType> is blocked.</span></span> <span data-ttu-id="916c1-193"><xref:System.Threading.CountdownEvent.Signal%2A?displayProperty=nameWithType>을 호출하여 이벤트의 수를 감소시킵니다.</span><span class="sxs-lookup"><span data-stu-id="916c1-193">Call <xref:System.Threading.CountdownEvent.Signal%2A?displayProperty=nameWithType> to decrement an event's count.</span></span>

<span data-ttu-id="916c1-194">한 스레드의 신호로 다중 스레드를 차단 해제하는 데 사용할 수 있는 <xref:System.Threading.ManualResetEvent> 또는 <xref:System.Threading.ManualResetEventSlim>와 달리, <xref:System.Threading.CountdownEvent>를 사용하여 여러 스레드의 신호로 하나 이상의 스레드를 차단 해제할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="916c1-194">In contrast to <xref:System.Threading.ManualResetEvent> or <xref:System.Threading.ManualResetEventSlim>, which you can use to unblock multiple threads with a signal from one thread, you can use <xref:System.Threading.CountdownEvent> to unblock one or more threads with signals from multiple threads.</span></span>

<span data-ttu-id="916c1-195">자세한 내용은 [CountdownEvent](countdownevent.md) 문서 및 <xref:System.Threading.CountdownEvent> API 참조를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="916c1-195">For more information, see the [CountdownEvent](countdownevent.md) article and the <xref:System.Threading.CountdownEvent> API reference.</span></span>

### <a name="barrier-class"></a><span data-ttu-id="916c1-196">Barrier 클래스</span><span class="sxs-lookup"><span data-stu-id="916c1-196">Barrier class</span></span>

<span data-ttu-id="916c1-197"><xref:System.Threading.Barrier?displayProperty=nameWithType> 클래스는 스레드 실행 경계를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="916c1-197">The <xref:System.Threading.Barrier?displayProperty=nameWithType> class represents a thread execution barrier.</span></span> <span data-ttu-id="916c1-198"><xref:System.Threading.Barrier.SignalAndWait%2A?displayProperty=nameWithType> 메서드를 호출하는 스레드는 장벽에 도달했다는 신호 알림을 보내고 다른 참가자 스레드가 경계에 도달할 때까지 대기합니다.</span><span class="sxs-lookup"><span data-stu-id="916c1-198">A thread that calls the <xref:System.Threading.Barrier.SignalAndWait%2A?displayProperty=nameWithType> method signals that it reached the barrier and waits until other participant threads reach the barrier.</span></span> <span data-ttu-id="916c1-199">모든 참가자 스레드는 장벽에 도달하면 계속 진행하며 장벽이 다시 설정되고 다시 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="916c1-199">When all participant threads reach the barrier, they proceed and the barrier is reset and can be used again.</span></span>

<span data-ttu-id="916c1-200">하나 이상의 스레드가 다음 계산 단계로 진행하기 전에 다른 스레드의 결과를 필요로 할 때 <xref:System.Threading.Barrier>를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="916c1-200">You might use <xref:System.Threading.Barrier> when one or more threads require the results of other threads before proceeding to the next computation phase.</span></span>

<span data-ttu-id="916c1-201">자세한 내용은 [Barrier](barrier.md) 문서 및 <xref:System.Threading.Barrier> API 참조를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="916c1-201">For more information, see the [Barrier](barrier.md) article and the <xref:System.Threading.Barrier> API reference.</span></span>

## <a name="interlocked-class"></a><span data-ttu-id="916c1-202">Interlocked 클래스</span><span class="sxs-lookup"><span data-stu-id="916c1-202">Interlocked class</span></span>

<span data-ttu-id="916c1-203"><xref:System.Threading.Interlocked?displayProperty=nameWithType> 클래스는 변수에서 단순 원자성 작업을 수행하는 정적 메서드를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="916c1-203">The <xref:System.Threading.Interlocked?displayProperty=nameWithType> class provides static methods that perform simple atomic operations on a variable.</span></span> <span data-ttu-id="916c1-204">해당 원자성 작업에는 비교에 따른 추가, 증가 및 감소, 교환, 조건부 교환이 포함되고 64비트 정수 값을 읽는 작업이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="916c1-204">Those atomic operations include addition, increment and decrement, exchange and conditional exchange that depends on a comparison, and read operation of a 64-bit integer value.</span></span>

<span data-ttu-id="916c1-205">자세한 내용은 <xref:System.Threading.Interlocked> API 참조를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="916c1-205">For more information, see the <xref:System.Threading.Interlocked> API reference.</span></span>

## <a name="spinwait-structure"></a><span data-ttu-id="916c1-206">SpinWait 구조체</span><span class="sxs-lookup"><span data-stu-id="916c1-206">SpinWait structure</span></span>

<span data-ttu-id="916c1-207"><xref:System.Threading.SpinWait?displayProperty=nameWithType> 구조체는 회전 기반 대기를 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="916c1-207">The <xref:System.Threading.SpinWait?displayProperty=nameWithType> structure provides support for spin-based waiting.</span></span> <span data-ttu-id="916c1-208">이벤트가 신호를 받거나 조건이 충족될 때까지 스레드가 대기해야 하지만 대기 핸들을 사용하거나 현재 스레드를 차단하여 실제 대기 시간이 필요한 대기 시간보다 적을 것으로 예상할 때 이를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="916c1-208">You might want to use it when a thread has to wait for an event to be signaled or a condition to be met, but when the actual wait time is expected to be less than the waiting time required by using a wait handle or by otherwise blocking the thread.</span></span> <span data-ttu-id="916c1-209"><xref:System.Threading.SpinWait>를 사용하면 대기하는 동안 스핀하고 지정된 시간 안에 조건이 충족되지 않을 경우에만 대기 또는 중지를 통해 양보하는 짧은 기간을 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="916c1-209">By using <xref:System.Threading.SpinWait>, you can specify a short period of time to spin while waiting, and then yield (for example, by waiting or sleeping) only if the condition was not met in the specified time.</span></span>

<span data-ttu-id="916c1-210">자세한 내용은 [SpinWait](spinwait.md) 문서 및 <xref:System.Threading.SpinWait> API 참조를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="916c1-210">For more information, see the [SpinWait](spinwait.md) article and the <xref:System.Threading.SpinWait> API reference.</span></span>

## <a name="see-also"></a><span data-ttu-id="916c1-211">참고 항목</span><span class="sxs-lookup"><span data-stu-id="916c1-211">See also</span></span>

- <xref:System.Collections.Concurrent?displayProperty=nameWithType>
- [<span data-ttu-id="916c1-212">스레드로부터 안전한 컬렉션</span><span class="sxs-lookup"><span data-stu-id="916c1-212">Thread-safe collections</span></span>](../collections/thread-safe/index.md)
- [<span data-ttu-id="916c1-213">스레딩 개체 및 기능</span><span class="sxs-lookup"><span data-stu-id="916c1-213">Threading objects and features</span></span>](threading-objects-and-features.md)

---
title: 동기화 기본 형식 개요
ms.date: 03/30/2017
ms.technology: dotnet-standard
helpviewer_keywords:
- synchronization, threads
- threading [.NET Framework],synchronizing threads
- managed threading
ms.assetid: b782bcb8-da6a-4c6a-805f-2eb46d504309
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: 37abcb6b3a8fdf4ef91d5e946a97db7ca1428ce8
ms.sourcegitcommit: 6eac9a01ff5d70c6d18460324c016a3612c5e268
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 09/16/2018
ms.locfileid: "45591882"
---
# <a name="overview-of-synchronization-primitives"></a><span data-ttu-id="9c421-102">동기화 기본 형식 개요</span><span class="sxs-lookup"><span data-stu-id="9c421-102">Overview of Synchronization Primitives</span></span>
<a name="top"></a> <span data-ttu-id="9c421-103">.NET Framework에서는 스레드 조작을 제어하고 경합 상태를 방지할 수 있는 동기화 기본 형식 범위를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="9c421-103">The .NET Framework provides a range of synchronization primitives for controlling the interactions of threads and avoiding race conditions.</span></span> <span data-ttu-id="9c421-104">이들 기본 형식은 크게 잠금, 신호 및 연관 작업의 세 범주로 구분됩니다.</span><span class="sxs-lookup"><span data-stu-id="9c421-104">These can be roughly divided into three categories: locking, signaling, and interlocked operations.</span></span>  
  
 <span data-ttu-id="9c421-105">범주는 깔끔하고 분명하게 정의되지 않습니다. 일부 동기화 메커니즘에는 다음과 같은 여러 범주 특성이 있습니다. 한 번에 하나의 스레드를 해제하는 이벤트는 기능상 잠금과 같고, 잠금 해제는 신호로 간주할 수 있고, 연관 작업은 잠금을 구성하는 데 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9c421-105">The categories are not tidy nor clearly defined: Some synchronization mechanisms have characteristics of multiple categories; events that release a single thread at a time are functionally like locks; the release of any lock can be thought of as a signal; and interlocked operations can be used to construct locks.</span></span> <span data-ttu-id="9c421-106">그러나 범주도 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="9c421-106">However, the categories are still useful.</span></span>  
  
 <span data-ttu-id="9c421-107">스레드 동기화는 협력 작업임을 고려해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9c421-107">It is important to remember that thread synchronization is cooperative.</span></span> <span data-ttu-id="9c421-108">하나라도 스레드가 동기화 메커니즘을 건너뛰고 보호된 리소스에 직접 액세스하면 해당 동기화 메커니즘이 적용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9c421-108">If even one thread bypasses a synchronization mechanism and accesses the protected resource directly, that synchronization mechanism cannot be effective.</span></span>  
  
 <span data-ttu-id="9c421-109">이 개요는 다음과 같은 단원으로 구성됩니다.</span><span class="sxs-lookup"><span data-stu-id="9c421-109">This overview contains the following sections:</span></span>  
  
-   [<span data-ttu-id="9c421-110">Locking</span><span class="sxs-lookup"><span data-stu-id="9c421-110">Locking</span></span>](#locking)  
  
-   [<span data-ttu-id="9c421-111">Signaling</span><span class="sxs-lookup"><span data-stu-id="9c421-111">Signaling</span></span>](#signaling)  
  
-   [<span data-ttu-id="9c421-112">간단한 동기화 형식</span><span class="sxs-lookup"><span data-stu-id="9c421-112">Lightweight Synchronization Types</span></span>](#lightweight_synchronization_types)  
  
-   [<span data-ttu-id="9c421-113">SpinWait</span><span class="sxs-lookup"><span data-stu-id="9c421-113">SpinWait</span></span>](#spinwait)  
  
-   [<span data-ttu-id="9c421-114">연동 작업</span><span class="sxs-lookup"><span data-stu-id="9c421-114">Interlocked Operations</span></span>](#interlocked_operations)  
  
<a name="locking"></a>   
## <a name="locking"></a><span data-ttu-id="9c421-115">잠금</span><span class="sxs-lookup"><span data-stu-id="9c421-115">Locking</span></span>  
 <span data-ttu-id="9c421-116">잠금을 통해 리소스를 한 번에 하나의 스레드 또는 지정된 수의 스레드로 제어할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9c421-116">Locks give control of a resource to one thread at a time, or to a specified number of threads.</span></span> <span data-ttu-id="9c421-117">잠금이 사용 중일 때 단독 잠금을 요청하는 스레드는 잠금을 사용할 수 있을 때까지 차단됩니다.</span><span class="sxs-lookup"><span data-stu-id="9c421-117">A thread that requests an exclusive lock when the lock is in use blocks until the lock becomes available.</span></span>  
  
### <a name="exclusive-locks"></a><span data-ttu-id="9c421-118">단독 잠금</span><span class="sxs-lookup"><span data-stu-id="9c421-118">Exclusive Locks</span></span>  
 <span data-ttu-id="9c421-119">가장 단순한 잠금 형식은 코드 블록에 대한 액세스를 제어하는 C#의 `lock` 문과, Visual Basic의 `SyncLock` 문입니다.</span><span class="sxs-lookup"><span data-stu-id="9c421-119">The simplest form of locking is the `lock` statement in C# and the `SyncLock` statement in Visual Basic, which controls access to a block of code.</span></span> <span data-ttu-id="9c421-120">해당 블록을 임계 영역이라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="9c421-120">Such a block is frequently referred to as a critical section.</span></span> <span data-ttu-id="9c421-121">`lock` 문은 <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> 및 <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> 메서드를 사용하여 구현하고 `try…finally` 블록을 사용하여 잠금이 해제되었는지를 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="9c421-121">The `lock` statement is implemented by using the <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> and <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> methods, and it uses a `try…finally` block to ensure that the lock is released.</span></span>  
  
 <span data-ttu-id="9c421-122">일반적으로 `lock` 또는 `SyncLock` 문을 통해 작은 코드 블록을 보호하여 메서드가 두 개 이상 스패닝되지 않게 하는 것이 <xref:System.Threading.Monitor> 클래스를 사용하는 가장 좋은 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="9c421-122">In general, using the `lock` or `SyncLock` statement to protect small blocks of code, never spanning more than a single method, is the best way to use the <xref:System.Threading.Monitor> class.</span></span> <span data-ttu-id="9c421-123">강력하지만 <xref:System.Threading.Monitor> 클래스는 잠금 및 교착 상태를 분리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9c421-123">Although powerful, the <xref:System.Threading.Monitor> class is prone to orphan locks and deadlocks.</span></span>  
  
#### <a name="monitor-class"></a><span data-ttu-id="9c421-124">Monitor 클래스</span><span class="sxs-lookup"><span data-stu-id="9c421-124">Monitor Class</span></span>  
 <span data-ttu-id="9c421-125"><xref:System.Threading.Monitor> 클래스는 `lock` 문과 함께 사용할 수 있는 추가적인 기능을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="9c421-125">The <xref:System.Threading.Monitor> class provides additional functionality, which can be used in conjunction with the `lock` statement:</span></span>  
  
-   <span data-ttu-id="9c421-126"><xref:System.Threading.Monitor.TryEnter%2A> 메서드는 차단된 스레드가 지정된 간격 후에 리소스가 포기할 때까지 대기하도록 허용합니다.</span><span class="sxs-lookup"><span data-stu-id="9c421-126">The <xref:System.Threading.Monitor.TryEnter%2A> method allows a thread that is blocked waiting for the resource to give up after a specified interval.</span></span> <span data-ttu-id="9c421-127">잠재적인 교차 상태를 감지하고 방지하는 데 사용할 수 있는 성공 또는 실패를 나타내는 부울 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="9c421-127">It returns a Boolean value indicating success or failure, which can be used to detect and avoid potential deadlocks.</span></span>  
  
-   <span data-ttu-id="9c421-128"><xref:System.Threading.Monitor.Wait%2A> 메서드는 임계 영역에서 스레드가 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="9c421-128">The <xref:System.Threading.Monitor.Wait%2A> method is called by a thread in a critical section.</span></span> <span data-ttu-id="9c421-129">이 메서드는 리소스 제어를 포기하고 리소스를 다시 사용할 수 있을 때까지 차단됩니다.</span><span class="sxs-lookup"><span data-stu-id="9c421-129">It gives up control of the resource and blocks until the resource is available again.</span></span>  
  
-   <span data-ttu-id="9c421-130"><xref:System.Threading.Monitor.Pulse%2A> 및 <xref:System.Threading.Monitor.PulseAll%2A> 메서드는 잠금을 해제하거나 <xref:System.Threading.Monitor.Wait%2A>를 호출하여 스레드 하나 이상을 준비 큐에 넣으려고 하는 스레드를 허용하므로 잠금을 획득할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9c421-130">The <xref:System.Threading.Monitor.Pulse%2A> and <xref:System.Threading.Monitor.PulseAll%2A> methods allow a thread that is about to release the lock or to call <xref:System.Threading.Monitor.Wait%2A> to put one or more threads into the ready queue, so that they can acquire the lock.</span></span>  
  
 <span data-ttu-id="9c421-131"><xref:System.Threading.Monitor.Wait%2A> 메서드 오버로드에 대한 시간 제한은 스레드가 준비 큐로 이스케이프될 때까지 기다리도록 허용합니다.</span><span class="sxs-lookup"><span data-stu-id="9c421-131">Timeouts on <xref:System.Threading.Monitor.Wait%2A> method overloads allow waiting threads to escape to the ready queue.</span></span>  
  
 <span data-ttu-id="9c421-132">잠금에 사용되는 개체가 <xref:System.MarshalByRefObject>에서 파생되면 <xref:System.Threading.Monitor> 클래스는 여러 응용 프로그램 도메인에서 잠금을 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9c421-132">The <xref:System.Threading.Monitor> class can provide locking in multiple application domains if the object used for the lock derives from <xref:System.MarshalByRefObject>.</span></span>  
  
 <span data-ttu-id="9c421-133"><xref:System.Threading.Monitor>에는 스레드 선호도가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9c421-133"><xref:System.Threading.Monitor> has thread affinity.</span></span> <span data-ttu-id="9c421-134">즉, 모니터를 시작한 스레드는 <xref:System.Threading.Monitor.Exit%2A> 또는 <xref:System.Threading.Monitor.Wait%2A>를 호출하여 종료해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9c421-134">That is, a thread that entered the monitor must exit by calling <xref:System.Threading.Monitor.Exit%2A> or <xref:System.Threading.Monitor.Wait%2A>.</span></span>  
  
 <span data-ttu-id="9c421-135"><xref:System.Threading.Monitor> 클래스는 인스턴스화할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9c421-135">The <xref:System.Threading.Monitor> class is not instantiable.</span></span> <span data-ttu-id="9c421-136">해당 메서드는 정적(Visual Basic의 `Shared`)이고 인스턴스화할 수 있는 잠금 개체에서 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="9c421-136">Its methods are static (`Shared` in Visual Basic), and act on an instantiable lock object.</span></span>  
  
 <span data-ttu-id="9c421-137">개념적인 개요를 보려면 [모니터](https://msdn.microsoft.com/library/33fe4aef-b44b-42fd-9e72-c908e39e75db)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="9c421-137">For a conceptual overview, see [Monitors](https://msdn.microsoft.com/library/33fe4aef-b44b-42fd-9e72-c908e39e75db).</span></span>  
  
#### <a name="mutex-class"></a><span data-ttu-id="9c421-138">Mutex 클래스</span><span class="sxs-lookup"><span data-stu-id="9c421-138">Mutex Class</span></span>  
 <span data-ttu-id="9c421-139">스레드는 <xref:System.Threading.WaitHandle.WaitOne%2A> 메서드의 오버로드를 호출하여 <xref:System.Threading.Mutex>를 요청합니다.</span><span class="sxs-lookup"><span data-stu-id="9c421-139">Threads request a <xref:System.Threading.Mutex> by calling an overload of its <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="9c421-140">스레드가 대기를 포기할 수 있도록 시간 제한이 있는 오버로드가 제공됩니다.</span><span class="sxs-lookup"><span data-stu-id="9c421-140">Overloads with timeouts are provided, to allow threads to give up the wait.</span></span> <span data-ttu-id="9c421-141"><xref:System.Threading.Monitor> 클래스와 달리 뮤텍스는 로컬 또는 전역일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9c421-141">Unlike the <xref:System.Threading.Monitor> class, a mutex can be either local or global.</span></span> <span data-ttu-id="9c421-142">명명된 뮤텍스라고도 하는 전역 뮤텍스는 운영 체제 전체에 표시되고 여러 응용 프로그램 도메인 또는 프로세스에서 스레드를 동기화하는 데 사용될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9c421-142">Global mutexes, also called named mutexes, are visible throughout the operating system, and can be used to synchronize threads in multiple application domains or processes.</span></span> <span data-ttu-id="9c421-143">로컬 뮤텍스는 <xref:System.MarshalByRefObject>에서 파생되고 응용 프로그램 도메인 경계에 걸쳐 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9c421-143">Local mutexes derive from <xref:System.MarshalByRefObject>, and can be used across application domain boundaries.</span></span>  
  
 <span data-ttu-id="9c421-144">또한 <xref:System.Threading.Mutex>는 <xref:System.Threading.WaitHandle>에서 파생됩니다. 즉, <xref:System.Threading.WaitHandle.WaitAll%2A>, <xref:System.Threading.WaitHandle.WaitAny%2A> 및 <xref:System.Threading.WaitHandle.SignalAndWait%2A> 메서드와 같은 <xref:System.Threading.WaitHandle>에서 제공된 신호 메커니즘과 함께 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9c421-144">In addition, <xref:System.Threading.Mutex> derives from <xref:System.Threading.WaitHandle>, which means that it can be used with the signaling mechanisms provided by <xref:System.Threading.WaitHandle>, such as the <xref:System.Threading.WaitHandle.WaitAll%2A>, <xref:System.Threading.WaitHandle.WaitAny%2A>, and <xref:System.Threading.WaitHandle.SignalAndWait%2A> methods.</span></span>  
  
 <span data-ttu-id="9c421-145"><xref:System.Threading.Monitor>처럼 <xref:System.Threading.Mutex>에는 스레드 선호도가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9c421-145">Like <xref:System.Threading.Monitor>, <xref:System.Threading.Mutex> has thread affinity.</span></span> <span data-ttu-id="9c421-146"><xref:System.Threading.Monitor>와 달리 <xref:System.Threading.Mutex>는 인스턴스화할 수 있는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="9c421-146">Unlike <xref:System.Threading.Monitor>, a <xref:System.Threading.Mutex> is an instantiable object.</span></span>  
  
 <span data-ttu-id="9c421-147">개념적인 개요를 보려면 [뮤텍스](../../../docs/standard/threading/mutexes.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="9c421-147">For a conceptual overview, see [Mutexes](../../../docs/standard/threading/mutexes.md).</span></span>  
  
#### <a name="spinlock-class"></a><span data-ttu-id="9c421-148">SpinLock 클래스</span><span class="sxs-lookup"><span data-stu-id="9c421-148">SpinLock Class</span></span>  
 <span data-ttu-id="9c421-149">[!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)]부터는 <xref:System.Threading.Monitor>에 필요한 오버헤드의 성능이 저하될 때 <xref:System.Threading.SpinLock> 클래스를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9c421-149">Starting with the [!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)], you can use the <xref:System.Threading.SpinLock> class when the overhead required by <xref:System.Threading.Monitor> degrades performance.</span></span> <span data-ttu-id="9c421-150"><xref:System.Threading.SpinLock>는 잠긴 임계 영역을 발견하면 잠금을 사용할 수 있을 때까지 루프에서 스핀합니다.</span><span class="sxs-lookup"><span data-stu-id="9c421-150">When <xref:System.Threading.SpinLock> encounters a locked critical section, it simply spins in a loop until the lock becomes available.</span></span> <span data-ttu-id="9c421-151">잠시 잠금이 유지되면 스핀을 통해 차단보다 향상된 성능을 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9c421-151">If the lock is held for a very short time, spinning can provide better performance than blocking.</span></span> <span data-ttu-id="9c421-152">그러나 잠금이 몇십 회 주기 이상 유지되면 <xref:System.Threading.SpinLock>은 <xref:System.Threading.Monitor>처럼 동작하지만 더 많은 CPU 주기를 사용하므로 스레드 또는 프로세스의 성능이 저하될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9c421-152">However, if the lock is held for more than a few tens of cycles, <xref:System.Threading.SpinLock> performs just as well as <xref:System.Threading.Monitor>, but will use more CPU cycles and thus can degrade the performance of other threads or processes.</span></span>  
  
### <a name="other-locks"></a><span data-ttu-id="9c421-153">기타 잠금</span><span class="sxs-lookup"><span data-stu-id="9c421-153">Other Locks</span></span>  
 <span data-ttu-id="9c421-154">잠금은 단독 잠금일 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9c421-154">Locks need not be exclusive.</span></span> <span data-ttu-id="9c421-155">리소스에 동시에 액세스할 수 있는 스레드 수를 제한하는 것이 유용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9c421-155">It is often useful to allow a limited number of threads concurrent access to a resource.</span></span> <span data-ttu-id="9c421-156">세마포와 판독기 및 작성기 잠금은 이런 풀링된 리소스 액세스를 제어하도록 디자인되었습니다.</span><span class="sxs-lookup"><span data-stu-id="9c421-156">Semaphores and reader-writer locks are designed to control this kind of pooled resource access.</span></span>  
  
#### <a name="readerwriterlock-class"></a><span data-ttu-id="9c421-157">ReaderWriterLock 클래스</span><span class="sxs-lookup"><span data-stu-id="9c421-157">ReaderWriterLock Class</span></span>  
 <span data-ttu-id="9c421-158"><xref:System.Threading.ReaderWriterLockSlim> 클래스는 데이터를 변경하는 스레드에 리소스에 대한 단독 액세스 권한이 있어야 하는 경우를 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="9c421-158">The <xref:System.Threading.ReaderWriterLockSlim> class addresses the case where a thread that changes data, the writer, must have exclusive access to a resource.</span></span> <span data-ttu-id="9c421-159">작성기가 활성화되지 않으면 판독기가 제한 없이 리소스에 액세스할 수 있습니다(예: <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> 메서드 호출을 통해).</span><span class="sxs-lookup"><span data-stu-id="9c421-159">When the writer is not active, any number of readers can access the resource (for example, by calling the <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> method).</span></span> <span data-ttu-id="9c421-160">스레드가 단독 액세스를 요청하면(예: <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> 메서드 호출을 통해) 모든 기존 판독기가 잠금을 종료하고 작성기가 잠금을 시작 및 종료할 때까지 이후 작성기 요청이 차단됩니다.</span><span class="sxs-lookup"><span data-stu-id="9c421-160">When a thread requests exclusive access, (for example, by calling the <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> method), subsequent reader requests block until all existing readers have exited the lock, and the writer has entered and exited the lock.</span></span>  
  
 <span data-ttu-id="9c421-161"><xref:System.Threading.ReaderWriterLockSlim>에는 스레드 선호도가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9c421-161"><xref:System.Threading.ReaderWriterLockSlim> has thread affinity.</span></span>  
  
 <span data-ttu-id="9c421-162">개념적인 개요를 보려면 [판독기 및 작성기 잠금](../../../docs/standard/threading/reader-writer-locks.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="9c421-162">For a conceptual overview, see [Reader-Writer Locks](../../../docs/standard/threading/reader-writer-locks.md).</span></span>  
  
#### <a name="semaphore-class"></a><span data-ttu-id="9c421-163">Semaphore 클래스</span><span class="sxs-lookup"><span data-stu-id="9c421-163">Semaphore Class</span></span>  
 <span data-ttu-id="9c421-164"><xref:System.Threading.Semaphore> 클래스는 지정된 수만큼 스레드가 리소스에 액세스하도록 허용합니다.</span><span class="sxs-lookup"><span data-stu-id="9c421-164">The <xref:System.Threading.Semaphore> class allows a specified number of threads to access a resource.</span></span> <span data-ttu-id="9c421-165">리소스를 요청하는 추가적인 스레드는 스레드가 세마포를 해제할 때까지 차단됩니다.</span><span class="sxs-lookup"><span data-stu-id="9c421-165">Additional threads requesting the resource block until a thread releases the semaphore.</span></span>  
  
 <span data-ttu-id="9c421-166"><xref:System.Threading.Mutex> 클래스처럼 <xref:System.Threading.Semaphore>는 <xref:System.Threading.WaitHandle>에서 파생됩니다.</span><span class="sxs-lookup"><span data-stu-id="9c421-166">Like the <xref:System.Threading.Mutex> class, <xref:System.Threading.Semaphore> derives from <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="9c421-167"><xref:System.Threading.Mutex>처럼 <xref:System.Threading.Semaphore>도 로컬 또는 전역일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9c421-167">Also like <xref:System.Threading.Mutex>, a <xref:System.Threading.Semaphore> can be either local or global.</span></span> <span data-ttu-id="9c421-168">응용 프로그램 도메인 경계에 걸쳐 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9c421-168">It can be used across application domain boundaries.</span></span>  
  
 <span data-ttu-id="9c421-169"><xref:System.Threading.Monitor>, <xref:System.Threading.Mutex> 및 <xref:System.Threading.ReaderWriterLock>과 달리 <xref:System.Threading.Semaphore>에는 스레드 선호도가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9c421-169">Unlike <xref:System.Threading.Monitor>, <xref:System.Threading.Mutex>, and <xref:System.Threading.ReaderWriterLock>, <xref:System.Threading.Semaphore> does not have thread affinity.</span></span> <span data-ttu-id="9c421-170">즉, 한 스레드가 세마포를 획득하고 다른 스레드가 세마포를 해제하는 시나리오에서 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9c421-170">This means it can be used in scenarios where one thread acquires the semaphore and another releases it.</span></span>  
  
 <span data-ttu-id="9c421-171">개념적인 개요를 보려면 [세마포 및 SemaphoreSlim](../../../docs/standard/threading/semaphore-and-semaphoreslim.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="9c421-171">For a conceptual overview, see [Semaphore and SemaphoreSlim](../../../docs/standard/threading/semaphore-and-semaphoreslim.md).</span></span>  
  
 <span data-ttu-id="9c421-172"><xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType>은 단일 프로세스 경계 내에서 동기화하기 위한 간단한 세마포입니다.</span><span class="sxs-lookup"><span data-stu-id="9c421-172"><xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType> is a lightweight semaphore for synchronization within a single process boundary.</span></span>  
  
 [<span data-ttu-id="9c421-173">맨 위로 이동</span><span class="sxs-lookup"><span data-stu-id="9c421-173">Back to top</span></span>](#top)  
  
<a name="signaling"></a>   
## <a name="signaling"></a><span data-ttu-id="9c421-174">Signaling</span><span class="sxs-lookup"><span data-stu-id="9c421-174">Signaling</span></span>  
 <span data-ttu-id="9c421-175">다른 스레드의 신호를 기다리는 가장 간단한 방법은 다른 스레드가 완료될 때까지 차단되는 <xref:System.Threading.Thread.Join%2A> 메서드를 호출하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="9c421-175">The simplest way to wait for a signal from another thread is to call the <xref:System.Threading.Thread.Join%2A> method, which blocks until the other thread completes.</span></span> <span data-ttu-id="9c421-176"><xref:System.Threading.Thread.Join%2A>에는 차단된 스레드가 지정된 간격이 지난 후 대기에서 해제되도록 허용하는 두 가지 오버로드가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9c421-176"><xref:System.Threading.Thread.Join%2A> has two overloads that allow the blocked thread to break out of the wait after a specified interval has elapsed.</span></span>  
  
 <span data-ttu-id="9c421-177">대기 핸들은 훨씬 다양한 대기 및 신호 기능 집합을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="9c421-177">Wait handles provide a much richer set of waiting and signaling capabilities.</span></span>  
  
### <a name="wait-handles"></a><span data-ttu-id="9c421-178">대기 핸들</span><span class="sxs-lookup"><span data-stu-id="9c421-178">Wait Handles</span></span>  
 <span data-ttu-id="9c421-179">대기 핸들은 <xref:System.Threading.WaitHandle> 클래스에서 파생되고 이 클래스는 <xref:System.MarshalByRefObject>에서 파생됩니다.</span><span class="sxs-lookup"><span data-stu-id="9c421-179">Wait handles derive from the <xref:System.Threading.WaitHandle> class, which in turn derives from <xref:System.MarshalByRefObject>.</span></span> <span data-ttu-id="9c421-180">따라서 대기 핸들을 사용하여 응용 프로그램 도메인 경계에 걸쳐 스레드 활동을 동기화할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9c421-180">Thus, wait handles can be used to synchronize the activities of threads across application domain boundaries.</span></span>  
  
 <span data-ttu-id="9c421-181">스레드는 인스턴스 메서드 <xref:System.Threading.WaitHandle.WaitOne%2A>를 호출하거나 정적 메서드 <xref:System.Threading.WaitHandle.WaitAll%2A>, <xref:System.Threading.WaitHandle.WaitAny%2A> 또는 <xref:System.Threading.WaitHandle.SignalAndWait%2A>의 하나를 호출하는 방식으로 대기 핸들에서 차단됩니다.</span><span class="sxs-lookup"><span data-stu-id="9c421-181">Threads block on wait handles by calling the instance method <xref:System.Threading.WaitHandle.WaitOne%2A> or one of the static methods <xref:System.Threading.WaitHandle.WaitAll%2A>, <xref:System.Threading.WaitHandle.WaitAny%2A>, or <xref:System.Threading.WaitHandle.SignalAndWait%2A>.</span></span> <span data-ttu-id="9c421-182">스레드가 해제되는 방식은 호출되는 메서드 및 대기 핸들 유형에 따라 달라집니다.</span><span class="sxs-lookup"><span data-stu-id="9c421-182">How they are released depends on which method was called, and on the kind of wait handles.</span></span>  
  
 <span data-ttu-id="9c421-183">개념적인 개요를 보려면 [WaitHandle](https://msdn.microsoft.com/library/48d10b6f-5fd7-407c-86ab-0179aef72489)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="9c421-183">For a conceptual overview, see [Wait Handles](https://msdn.microsoft.com/library/48d10b6f-5fd7-407c-86ab-0179aef72489).</span></span>  
  
#### <a name="event-wait-handles"></a><span data-ttu-id="9c421-184">이벤트 대기 핸들</span><span class="sxs-lookup"><span data-stu-id="9c421-184">Event Wait Handles</span></span>  
 <span data-ttu-id="9c421-185">이벤트 대기 핸들에는 <xref:System.Threading.EventWaitHandle> 클래스와 파생 클래스 <xref:System.Threading.AutoResetEvent> 및 <xref:System.Threading.ManualResetEvent>가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="9c421-185">Event wait handles include the <xref:System.Threading.EventWaitHandle> class and its derived classes, <xref:System.Threading.AutoResetEvent> and <xref:System.Threading.ManualResetEvent>.</span></span> <span data-ttu-id="9c421-186"><xref:System.Threading.EventWaitHandle.Set%2A> 메서드를 호출하거나 <xref:System.Threading.WaitHandle.SignalAndWait%2A> 메서드를 사용하여 보낸 신호를 이벤트 대기 핸들이 받으면 이벤트 대기 핸들에서 스레드가 해제됩니다.</span><span class="sxs-lookup"><span data-stu-id="9c421-186">Threads are released from an event wait handle when the event wait handle is signaled by calling its <xref:System.Threading.EventWaitHandle.Set%2A> method or by using the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method.</span></span>  
  
 <span data-ttu-id="9c421-187">이벤트 대기 핸들은 신호를 받을 때마다 스레드를 하나만 허용하는 턴스타일처럼 자동으로 다시 설정되거나, 신호를 받을 때까지 닫혀 있다가 누군가 닫을 때까지 열려 있는 게이트처럼 수동으로 다시 설정되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9c421-187">Event wait handles either reset themselves automatically, like a turnstile that allows only one thread through each time it is signaled, or must be reset manually, like a gate that is closed until signaled and then open until someone closes it.</span></span> <span data-ttu-id="9c421-188">이름이 나타내듯이 <xref:System.Threading.AutoResetEvent> 및 <xref:System.Threading.ManualResetEvent>는 각각 전자 및 후자를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="9c421-188">As their names imply, <xref:System.Threading.AutoResetEvent> and <xref:System.Threading.ManualResetEvent> represent the former and latter, respectively.</span></span> <span data-ttu-id="9c421-189"><xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType>은 단일 프로세스 경계 내에서 동기화하기 위한 간단한 이벤트입니다.</span><span class="sxs-lookup"><span data-stu-id="9c421-189"><xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType> is a lightweight event for synchronization within a single process boundary.</span></span>  
  
 <span data-ttu-id="9c421-190"><xref:System.Threading.EventWaitHandle>은 이벤트 형식을 나타낼 수 있고 로컬 또는 전역일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9c421-190">An <xref:System.Threading.EventWaitHandle> can represent either type of event, and can be either local or global.</span></span> <span data-ttu-id="9c421-191">파생 클래스 <xref:System.Threading.AutoResetEvent> 및 <xref:System.Threading.ManualResetEvent>는 항상 로컬입니다.</span><span class="sxs-lookup"><span data-stu-id="9c421-191">The derived classes <xref:System.Threading.AutoResetEvent> and <xref:System.Threading.ManualResetEvent> are always local.</span></span>  
  
 <span data-ttu-id="9c421-192">이벤트 대기 핸들에는 스레드 선호도가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9c421-192">Event wait handles do not have thread affinity.</span></span> <span data-ttu-id="9c421-193">모든 스레드가 이벤트 대기 핸들에 신호를 보낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9c421-193">Any thread can signal an event wait handle.</span></span>  
  
 <span data-ttu-id="9c421-194">개념적인 개요를 보려면 [EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent](../../../docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="9c421-194">For a conceptual overview, see [EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent](../../../docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md).</span></span>  
  
#### <a name="mutex-and-semaphore-classes"></a><span data-ttu-id="9c421-195">뮤텍스 및 세마포 클래스</span><span class="sxs-lookup"><span data-stu-id="9c421-195">Mutex and Semaphore Classes</span></span>  
 <span data-ttu-id="9c421-196"><xref:System.Threading.Mutex> 및 <xref:System.Threading.Semaphore> 클래스는 <xref:System.Threading.WaitHandle>에서 파생되므로 <xref:System.Threading.WaitHandle>의 정적 메서드와 함께 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9c421-196">Because the <xref:System.Threading.Mutex> and <xref:System.Threading.Semaphore> classes derive from <xref:System.Threading.WaitHandle>, they can be used with the static methods of <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="9c421-197">예를 들어 스레드는 <xref:System.Threading.WaitHandle.WaitAll%2A> 메서드를 사용하여 <xref:System.Threading.EventWaitHandle>이 신호를 받고 <xref:System.Threading.Mutex>가 해제되고 <xref:System.Threading.Semaphore>가 해제되는 세 가지 조건이 모두 충족될 때까지 대기할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9c421-197">For example, a thread can use the <xref:System.Threading.WaitHandle.WaitAll%2A> method to wait until all three of the following are true: an <xref:System.Threading.EventWaitHandle> is signaled, a <xref:System.Threading.Mutex> is released, and a <xref:System.Threading.Semaphore> is released.</span></span> <span data-ttu-id="9c421-198">마찬가지로 스레드는 <xref:System.Threading.WaitHandle.WaitAny%2A> 메서드를 사용하여 해당 조건의 하나가 충족될 때까지 대기할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9c421-198">Similarly, a thread can use the <xref:System.Threading.WaitHandle.WaitAny%2A> method to wait until any one of those conditions is true.</span></span>  
  
 <span data-ttu-id="9c421-199"><xref:System.Threading.Mutex> 또는 <xref:System.Threading.Semaphore>의 경우 신호를 받는다는 것은 해제됨을 의미합니다.</span><span class="sxs-lookup"><span data-stu-id="9c421-199">For a <xref:System.Threading.Mutex> or a <xref:System.Threading.Semaphore>, being signaled means being released.</span></span> <span data-ttu-id="9c421-200">한쪽 형식이 <xref:System.Threading.WaitHandle.SignalAndWait%2A> 메서드의 첫 번째 인수로 사용되면 해제된 것입니다.</span><span class="sxs-lookup"><span data-stu-id="9c421-200">If either type is used as the first argument of the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method, it is released.</span></span> <span data-ttu-id="9c421-201">스레드 선호도가 있는 <xref:System.Threading.Mutex>의 경우 호출하는 스레드가 뮤텍스를 소유하고 있지 않으면 예외가 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="9c421-201">In the case of a <xref:System.Threading.Mutex>, which has thread affinity, an exception is thrown if the calling thread does not own the mutex.</span></span> <span data-ttu-id="9c421-202">앞에서 설명한 대로 세마포에는 스레드 선호도가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9c421-202">As noted previously, semaphores do not have thread affinity.</span></span>  
  
#### <a name="barrier"></a><span data-ttu-id="9c421-203">장벽</span><span class="sxs-lookup"><span data-stu-id="9c421-203">Barrier</span></span>  
 <span data-ttu-id="9c421-204"><xref:System.Threading.Barrier> 클래스는 여러 스레드가 같은 지점에서 모두 차단되고 모든 다른 스레드가 완료될 때까지 대기하도록 여러 스레드를 순환해서 동기화하는 방법을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="9c421-204">The <xref:System.Threading.Barrier> class provides a way to cyclically synchronize multiple threads so that they all block at the same point and wait for all other threads to complete.</span></span> <span data-ttu-id="9c421-205">장벽은 스레드 하나 이상이 알고리즘의 다음 단계로 진행하기 전에 다른 스레드의 결과를 필요로 할 때 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="9c421-205">A barrier is useful when one or more threads require the results of another thread before continuing to the next phase of an algorithm.</span></span> <span data-ttu-id="9c421-206">자세한 내용은 [Barrier](../../../docs/standard/threading/barrier.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="9c421-206">For more information, see [Barrier](../../../docs/standard/threading/barrier.md).</span></span>  
  
 [<span data-ttu-id="9c421-207">맨 위로 이동</span><span class="sxs-lookup"><span data-stu-id="9c421-207">Back to top</span></span>](#top)  
  
<a name="lightweight_synchronization_types"></a>   
## <a name="lightweight-synchronization-types"></a><span data-ttu-id="9c421-208">간단한 동기화 형식</span><span class="sxs-lookup"><span data-stu-id="9c421-208">Lightweight Synchronization Types</span></span>  
 <span data-ttu-id="9c421-209">[!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)]부터는 가능할 때마다 대기 핸들과 같은 비싼 Win32 커널 개체를 사용하지 않는 방식으로 빠른 성능을 제공하는 동기화 기본 형식을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9c421-209">Starting with the [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], you can use synchronization primitives that provide fast performance by avoiding expensive reliance on Win32 kernel objects such as wait handles whenever possible.</span></span> <span data-ttu-id="9c421-210">일반적으로 대기 시간이 짧은 경우와 원래 동기화 형식이 시도되었으나 만족스럽지 않은 것으로 확인된 경우에만 이들 형식을 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9c421-210">In general, you should use these types when wait times are short and only when the original synchronization types have been tried and found to be unsatisfactory.</span></span> <span data-ttu-id="9c421-211">간단한 형식은 프로세스 간 통신이 필요한 시나리오에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9c421-211">The lightweight types cannot be used in scenarios that require cross-process communication.</span></span>  
  
-   <span data-ttu-id="9c421-212"><xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType>은 <xref:System.Threading.Semaphore?displayProperty=nameWithType>의 간단한 버전입니다.</span><span class="sxs-lookup"><span data-stu-id="9c421-212"><xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType> is a lightweight version of <xref:System.Threading.Semaphore?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="9c421-213"><xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType>은 <xref:System.Threading.ManualResetEvent?displayProperty=nameWithType>의 간단한 버전입니다.</span><span class="sxs-lookup"><span data-stu-id="9c421-213"><xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType> is a lightweight version of <xref:System.Threading.ManualResetEvent?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="9c421-214"><xref:System.Threading.CountdownEvent?displayProperty=nameWithType>는 개수가 0일 때 신호를 받게 되는 이벤트를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="9c421-214"><xref:System.Threading.CountdownEvent?displayProperty=nameWithType> represents an event that becomes signaled when its count is zero.</span></span>  
  
-   <span data-ttu-id="9c421-215"><xref:System.Threading.Barrier?displayProperty=nameWithType>를 사용하면 여러 스레드가 마스터 스레드에 의한 제어 없이 서로 동기화될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9c421-215"><xref:System.Threading.Barrier?displayProperty=nameWithType> enables multiple threads to synchronize with one another without requiring control by a master thread.</span></span> <span data-ttu-id="9c421-216">장벽은 모든 스레드가 지정된 지점에 도달할 때까지 각 스레드가 계속하지 못하도록 차단합니다.</span><span class="sxs-lookup"><span data-stu-id="9c421-216">A barrier prevents each thread from continuing until all threads have reached a specified point.</span></span>  
  
 [<span data-ttu-id="9c421-217">맨 위로 이동</span><span class="sxs-lookup"><span data-stu-id="9c421-217">Back to top</span></span>](#top)  
  
<a name="spinwait"></a>   
## <a name="spinwait"></a><span data-ttu-id="9c421-218">SpinWait</span><span class="sxs-lookup"><span data-stu-id="9c421-218">SpinWait</span></span>  
 <span data-ttu-id="9c421-219">[!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)]부터는 이벤트가 신호를 받거나 조건이 충족될 때까지 스레드가 대기해야 하지만 대기 핸들을 사용하거나 현재 스레드를 차단하여 실제 대기 시간이 필요한 대기 시간보다 적을 것으로 예상할 때 <xref:System.Threading.SpinWait?displayProperty=nameWithType> 구조체를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9c421-219">Starting with the [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], you can use the <xref:System.Threading.SpinWait?displayProperty=nameWithType> structure when a thread has to wait for an event to be signaled or a condition to be met, but when the actual wait time is expected to be less than the waiting time required by using a wait handle or by otherwise blocking the current thread.</span></span> <span data-ttu-id="9c421-220"><xref:System.Threading.SpinWait>를 사용하면 대기하는 동안 스핀하고 지정된 시간 안에 조건이 충족되지 않을 경우에만 대기 또는 중지를 통해 양보하는 짧은 기간을 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9c421-220">By using <xref:System.Threading.SpinWait>, you can specify a short period of time to spin while waiting, and then yield (for example, by waiting or sleeping) only if the condition was not met in the specified time.</span></span>  
  
 [<span data-ttu-id="9c421-221">맨 위로 이동</span><span class="sxs-lookup"><span data-stu-id="9c421-221">Back to top</span></span>](#top)  
  
<a name="interlocked_operations"></a>   
## <a name="interlocked-operations"></a><span data-ttu-id="9c421-222">연동 작업</span><span class="sxs-lookup"><span data-stu-id="9c421-222">Interlocked Operations</span></span>  
 <span data-ttu-id="9c421-223">연동 작업은 <xref:System.Threading.Interlocked> 클래스의 정적 메서드를 통해 메모리 위치에서 수행되는 간단한 원자성 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="9c421-223">Interlocked operations are simple atomic operations performed on a memory location by static methods of the <xref:System.Threading.Interlocked> class.</span></span> <span data-ttu-id="9c421-224">해당 원자성 작업에는 비교에 따라 추가, 증가 및 감소, 교환, 조건부 교환이 포함되고 32비트 플랫폼에서 64비트 값을 읽는 작업이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="9c421-224">Those atomic operations include addition, increment and decrement, exchange, conditional exchange depending on a comparison, and read operations for 64-bit values on 32-bit platforms.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9c421-225">원자성 보장은 개별 작업으로 제한됩니다. 여러 작업을 한 단위로 수행해야 하면 더 개략적인 동기화 메커니즘을 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9c421-225">The guarantee of atomicity is limited to individual operations; when multiple operations must be performed as a unit, a more coarse-grained synchronization mechanism must be used.</span></span>  
  
 <span data-ttu-id="9c421-226">이들 작업은 잠금이나 신호가 아니지만 잠금 및 신호를 구성하는 데 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9c421-226">Although none of these operations are locks or signals, they can be used to construct locks and signals.</span></span> <span data-ttu-id="9c421-227">Windows 운영 체제에 기본 제공되므로 연동 작업은 매우 빠릅니다.</span><span class="sxs-lookup"><span data-stu-id="9c421-227">Because they are native to the Windows operating system, interlocked operations are extremely fast.</span></span>  
  
 <span data-ttu-id="9c421-228">연동 작업은 휘발성 메모리 보장과 함께 강력한 비차단 동시성을 보이는 응용 프로그램을 작성하는 데 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9c421-228">Interlocked operations can be used with volatile memory guarantees to write applications that exhibit powerful non-blocking concurrency.</span></span> <span data-ttu-id="9c421-229">그러나 연동 작업에는 정교하고 낮은 수준의 프로그래밍이 필요하므로 대부분 용도에는 간단한 잠금을 선택하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="9c421-229">However, they require sophisticated, low-level programming, so for most purposes, simple locks are a better choice.</span></span>  
  
 <span data-ttu-id="9c421-230">개념적 개요를 보려면 [연동 작업](../../../docs/standard/threading/interlocked-operations.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="9c421-230">For a conceptual overview, see [Interlocked Operations](../../../docs/standard/threading/interlocked-operations.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="9c421-231">참고 항목</span><span class="sxs-lookup"><span data-stu-id="9c421-231">See also</span></span>

- [<span data-ttu-id="9c421-232">다중 스레딩을 위한 데이터 동기화</span><span class="sxs-lookup"><span data-stu-id="9c421-232">Synchronizing Data for Multithreading</span></span>](../../../docs/standard/threading/synchronizing-data-for-multithreading.md)  
- [<span data-ttu-id="9c421-233">모니터</span><span class="sxs-lookup"><span data-stu-id="9c421-233">Monitors</span></span>](https://msdn.microsoft.com/library/33fe4aef-b44b-42fd-9e72-c908e39e75db)  
- [<span data-ttu-id="9c421-234">뮤텍스</span><span class="sxs-lookup"><span data-stu-id="9c421-234">Mutexes</span></span>](../../../docs/standard/threading/mutexes.md)  
- [<span data-ttu-id="9c421-235">세마포 및 SemaphoreSlim</span><span class="sxs-lookup"><span data-stu-id="9c421-235">Semaphore and SemaphoreSlim</span></span>](../../../docs/standard/threading/semaphore-and-semaphoreslim.md)  
- [<span data-ttu-id="9c421-236">EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent</span><span class="sxs-lookup"><span data-stu-id="9c421-236">EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent</span></span>](../../../docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md)  
- [<span data-ttu-id="9c421-237">대기 핸들</span><span class="sxs-lookup"><span data-stu-id="9c421-237">Wait Handles</span></span>](https://msdn.microsoft.com/library/48d10b6f-5fd7-407c-86ab-0179aef72489)  
- [<span data-ttu-id="9c421-238">연동 작업</span><span class="sxs-lookup"><span data-stu-id="9c421-238">Interlocked Operations</span></span>](../../../docs/standard/threading/interlocked-operations.md)  
- [<span data-ttu-id="9c421-239">판독기 및 작성기 잠금</span><span class="sxs-lookup"><span data-stu-id="9c421-239">Reader-Writer Locks</span></span>](../../../docs/standard/threading/reader-writer-locks.md)  
- [<span data-ttu-id="9c421-240">장벽</span><span class="sxs-lookup"><span data-stu-id="9c421-240">Barrier</span></span>](../../../docs/standard/threading/barrier.md)  
- [<span data-ttu-id="9c421-241">스핀 대기</span><span class="sxs-lookup"><span data-stu-id="9c421-241">SpinWait</span></span>](../../../docs/standard/threading/spinwait.md)  
- [<span data-ttu-id="9c421-242">스핀 잠금</span><span class="sxs-lookup"><span data-stu-id="9c421-242">SpinLock</span></span>](../../../docs/standard/threading/spinlock.md)

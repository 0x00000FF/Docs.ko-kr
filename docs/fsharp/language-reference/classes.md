---
title: 클래스
description: 설명 하는 방법 F# 클래스는 속성, 메서드 및 이벤트를 가질 수 있는 개체를 나타내는 형식입니다.
ms.date: 05/16/2016
ms.openlocfilehash: 6bf838e98acecb89436d3e87809d9eb6da0c66d5
ms.sourcegitcommit: 9b552addadfb57fab0b9e7852ed4f1f1b8a42f8e
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 04/23/2019
ms.locfileid: "61870294"
---
# <a name="classes"></a>클래스

*클래스* 는 속성, 메서드 및 이벤트를 보유할 수 있는 개체를 나타내는 형식입니다.

## <a name="syntax"></a>구문

```fsharp
// Class definition:
type [access-modifier] type-name [type-params] [access-modifier] ( parameter-list ) [ as identifier ] =
[ class ]
[ inherit base-type-name(base-constructor-args) ]
[ let-bindings ]
[ do-bindings ]
member-list
...
[ end ]
// Mutually recursive class definitions:
type [access-modifier] type-name1 ...
and [access-modifier] type-name2 ...
...
```

## <a name="remarks"></a>설명

클래스에 대 한.NET 개체 형식; 기본 설명을 나타내는합니다 클래스의 개체 지향 프로그래밍을 지 원하는 기본 형식 개념은 F#입니다.

위의 구문에서은 `type-name` 은 임의의 유효한 식별자입니다. `type-params` 선택적 제네릭 형식 매개 변수를 설명 합니다. 형식 매개 변수 이름과 꺾쇠 괄호로 묶여 있는 제약 조건을 구성 됩니다 (`<` 고 `>`). 자세한 내용은 [제네릭](generics/index.md) 하 고 [제약 조건](generics/constraints.md)합니다. `parameter-list` 생성자 매개 변수를 설명 합니다. 형식에 관련 된 첫 번째 액세스 한정자 두 번째 기본 생성자와 관련이 있습니다. 두 경우 모두 기본값은 `public`합니다.

사용 하 여 클래스에 대 한 기본 클래스를 지정 하는 `inherit` 키워드입니다. 괄호의 기본 클래스 생성자에 대 한 인수를 제공 해야 합니다.

필드를 선언 하거나 함수를 사용 하 여 로컬 클래스에 있는 값 `let` 바인딩 및 수에 대 한 일반 규칙을 따라야 `let` 바인딩. `do-bindings` 섹션 개체 생성 시 실행할 코드를 포함 합니다.

`member-list` 추가 생성자, 인스턴스 및 정적 메서드 선언, 인터페이스 선언에서 추상 바인딩 및 속성 및 이벤트 선언으로 구성 됩니다. 에 설명 된 이러한 [멤버](members/index.md)합니다.

합니다 `identifier` 선택적으로 사용 되는 `as` 키워드 인스턴스 변수 또는 형식의 인스턴스를 참조 하도록 형식 정의에 사용할 수 있는 자체 식별자 이름을 제공 합니다. 자세한 내용은이 항목 뒷부분의 자체 식별자 섹션을 참조 합니다.

키워드 `class` 고 `end` 시작을 표시 하 고 정의의 끝은 선택 사항입니다.

서로 참조 하는 형식에는 재귀 형식 함께 조인 되는 함께 사용할 수는 `and` 상호 재귀 함수는 마찬가지로 키워드입니다. 예를 들어 상호 재귀 형식 섹션을 참조 합니다.

## <a name="constructors"></a>생성자

생성자는 클래스 형식의 인스턴스를 만드는 코드입니다. 클래스에 대 한 생성자에서와 다르게 작동 F# 다른.NET 언어에서 수행한 것입니다. 에 F# 클래스, 해당 인수에 설명 된 기본 생성자는 항상 합니다 `parameter-list` 오는 형식 이름 및 해당 본문으로 구성 됩니다는 `let` (및 `let rec`) 바인딩 클래스 선언의 시작 및 `do` 뒤에 있습니다. 기본 생성자의 인수는 클래스 선언 전체 범위에.

추가 생성자를 사용 하 여 추가할 수 있습니다는 `new` 키워드를 다음과 같이 멤버를 추가 합니다.

`new`(`argument-list`) = `constructor-body`

새로운 생성자의 본문 클래스 선언의 맨 위에 있는 지정 된 기본 생성자를 호출 해야 합니다.

다음 예제에서는이 개념을 보여줍니다. 다음 코드에서 `MyClass` 두 생성자에는 두 개의 인수 및 다른 생성자는 기본 생성자에 인수가 없는 합니다.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet2401.fs)]

## <a name="let-and-do-bindings"></a>let 및 do 바인딩

합니다 `let` 및 `do` 클래스 정의에서 바인딩을 기본 클래스 생성자의 본문을 형성 하 고 실행 되므로 클래스 인스턴스를 만들 때마다 합니다. 경우는 `let` 바인딩 함수는 다음 멤버는 컴파일됩니다. 경우는 `let` 바인딩 함수 또는 멤버에서 사용 되지 않는 값을 생성자에 로컬인 변수는 컴파일됩니다. 그렇지 않으면 클래스의 필드로 컴파일됩니다. `do` 식 다음에 나오는 기본 생성자로 컴파일되고 모든 인스턴스에 대 한 초기화 코드를 실행 합니다. 추가 생성자에는 항상 기본 생성자를 호출 하므로 합니다 `let` 바인딩 및 `do` 바인딩은 생성자가 호출에 관계 없이 항상 실행 합니다.

그러나 만든 필드 `let` 액세스할 수에서 정적 메서드는 정적 메서드를 매개 변수로 인스턴스 변수를 사용 하는 경우에; 바인딩 메서드 및 클래스의 속성을 통해 액세스할 수 있습니다. 이러한 있을 경우, 자체 식별자를 사용 하 여 액세스할 수 없습니다.

## <a name="self-identifiers"></a>자체 식별자

A *자체 식별자* 현재 인스턴스를 나타내는 이름입니다. 자체 식별자와 유사 합니다 `this` 키워드 C# 또는 C++ 또는 `Me` Visual Basic의 합니다. 전체 클래스 정의 대 한 또는 개별 메서드에 대해서만 범위 내에서에 자체 식별자 여부에 따라 두 가지 방법으로 자체 식별자를 정의할 수 있습니다.

전체 클래스에 대 한 자체 식별자를 정의 하려면 사용 된 `as` 생성자 매개 변수의 닫는 괄호 뒤 키워드 목록 및 식별자 이름을 지정 합니다.

단 하나의 메서드에 대 한 자체 식별자를 정의 하는 메서드 이름과 구분 기호로 마침표 (.) 직전 멤버 선언에서 자체 식별자를 제공 합니다.

다음 코드 예제에는 자체 식별자는 두 가지 방법을 보여 줍니다. 첫 번째 줄에서은 `as` 키워드 자체 식별자를 정의 하는 데 사용 됩니다. 다섯 번째 줄에서는 식별자 `this` 범위가 메서드로 제한 된 자체 식별자를 정의 하는 데 사용 됩니다 `PrintMessage`합니다.

```fsharp
type MyClass2(dataIn) as self =
    let data = dataIn
    do
        self.PrintMessage()
    member this.PrintMessage() =
        printf "Creating MyClass2 with Data %d" data
```

와 달리 다른.NET 언어의 이름을 지정할 수 있습니다 자체 식별자 원하는; 수에 제한 되지 않습니다 이름은 같은 `self`, `Me`, 또는 `this`합니다.

선언 된 자체 식별자를 `as` 키워드 될 때까지 초기화 되지 않은 후는 `let` 바인딩이 실행 되 합니다. 따라서에서 사용할 수는 `let` 바인딩. 자체 식별자를 사용할 수는 `do` 바인딩 섹션입니다.

## <a name="generic-type-parameters"></a>제네릭 형식 매개 변수

제네릭 형식 매개 변수를 꺾쇠 괄호로 지정 됩니다 (`<` 및 `>`), 작은 따옴표 뒤에 식별자의 형태로 합니다. 여러 제네릭 형식 매개 변수는 쉼표로 구분 됩니다. 제네릭 형식 매개 변수는 선언 전체 범위의 경우 다음 코드 예제에서는 제네릭 형식 매개 변수를 지정 하는 방법을 보여 줍니다.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet2403.fs)]

형식 인수 형식을 사용 하는 경우 유추 됩니다. 다음 코드에서는 유추 된 형식은 튜플 시퀀스입니다.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet24031.fs)]

## <a name="specifying-inheritance"></a>상속을 지정합니다.

`inherit` 있을 경우 절은 직접 기본 클래스를 식별 합니다. F#, 하나의 직접 기본 클래스는 허용 합니다. 클래스가 구현 하는 인터페이스는 기본 클래스를 고려 하지 않습니다. 인터페이스에 설명 되어는 [인터페이스](Interfaces.md) 항목입니다.

있습니다 수는 메서드 및 속성 액세스 기본 클래스의 파생된 클래스에서 언어 키워드를 사용 하 여 `base` 는 식별자 뒤에 마침표 (.) 및 멤버의 이름입니다.

자세한 내용은 [상속](inheritance.md)을 참조하세요.

## <a name="members-section"></a>멤버 섹션

이 섹션의 정적 또는 인스턴스 메서드, 속성, 인터페이스 구현, 추상 멤버, 이벤트 선언 및 추가 생성자를 정의할 수 있습니다. 수 있도록 하 고 수행 바인딩을이 섹션에 나타날 수 없습니다. 다양 한 멤버를 추가할 수 있으므로 F# 형식 클래스 외에도 별도 항목에서 설명 [멤버](members/index.md)합니다.

## <a name="mutually-recursive-types"></a>상호 재귀 형식

순환 방식으로 서로 참조 하는 형식을 정의할 때 있습니다 문자열 함께 형식 정의 사용 하 여는 `and` 키워드입니다. 합니다 `and` 키워드를 대체 합니다 `type` 다음과 같이 첫 번째 정의 제외한 모든 키워드입니다.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet2404.fs)]

출력은 현재 디렉터리에 있는 모든 파일의 목록입니다.

## <a name="when-to-use-classes-unions-records-and-structures"></a>클래스, 공용 구조체, 레코드 및 구조를 사용 하는 경우

다양 한 선택할 수 있는 형식이 지정 되 면 새로운 각 유형에 설계에 대 한 특정 상황에 대 한 적절 한 유형을 선택 하려면 잘 이해 해야 합니다. 클래스는 개체 지향 프로그래밍 컨텍스트에서 사용 하기 위해 설계 되었습니다. 개체 지향 프로그래밍은.NET Framework에 대해 작성 된 응용 프로그램에서 사용 하는 기준 패러다임입니다. 경우에 F# .NET Framework 또는 다른 개체 지향 라이브러리와 밀접 하 게 작동 하는 코드 및 클래스는 아마도 적절 한 UI 라이브러리와 같은 개체 지향 형식 시스템을 확장 해야 하는 경우에 특히 합니다.

하지 상호 작용 하는 긴밀 하 게 코드 개체 지향 또는 자체 포함 되어 있으므로 개체 지향 코드와 자주 상호 작용 으로부터 보호 하는 코드를 작성 하는 경우 레코드를 사용 하 여 고려해 야 하 고 구별 된 공용 구조체. 단일도 생각 하 여 작성 한 적절 한 패턴 일치 코드와 함께 구별 된 공용 구조체 개체 계층 구조에는 보다 간단한 대안으로 자주 사용할 수 있습니다. 구별 된 공용 구조체에 대 한 자세한 내용은 참조 하세요. [구별 된 공용 구조체](discriminated-unions.md)합니다.

레코드 클래스를 보다 간단 하다는 이점이 없지만 단순성을 사용 하 여 수행할 수 있는 형식의 요구 초과 하는 경우 레코드 적합 하지 않습니다. 레코드는 기본적으로 단순 집계 값을 사용자 지정 작업을 수행할 수 있는 별도 생성자가 없는, 숨겨진된 필드를 상속 하거나 인터페이스 구현 없이입니다. 더 복잡 한 동작을 확인 하는 레코드를 속성 및 메서드와 같은 멤버를 추가할 수 있지만 레코드에 저장 되는 필드는 여전히 값의 간단한 집계. 레코드에 대 한 자세한 내용은 참조 하세요. [레코드](records.md)합니다.

구조 데이터의 작은 집계에도 유용 하지만.NET의 값 형식에 클래스 및 레코드에서 다릅니다. 클래스 및 레코드에는.NET 참조 형식입니다. 값 형식을 값으로 전달 되는 값 형식과 참조 의미 체계 서로 다릅니다. 즉, 복사 되는 비트 수준 매개 변수로 전달 하거나 함수에서 반환 하는 경우에 합니다. 또한 스택에 저장 인지, 대신 부모 개체 내에 포함 된 필드로 사용 하는 경우 힙의 고유한 별도 위치에 저장 합니다. 따라서 힙에 액세스 하는 오버 헤드가 문제인 경우 구조는 자주 액세스 하는 데이터에 적합 합니다. 구조에 대 한 자세한 내용은 참조 하세요. [구조](structures.md)합니다.

## <a name="see-also"></a>참고자료

- [F# 언어 참조](index.md)
- [멤버](members/index.md)
- [상속](inheritance.md)
- [인터페이스](interfaces.md)
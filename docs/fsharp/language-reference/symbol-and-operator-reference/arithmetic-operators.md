---
title: 산술 연산자
description: F# 프로그래밍 언어에서 사용할 수 있는 산술 연산자에 대해 알아봅니다.
ms.date: 04/04/2018
ms.openlocfilehash: b783a0134541f11f06dde83af97676699b797da1
ms.sourcegitcommit: f20dd18dbcf2275513281f5d9ad7ece6a62644b4
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 07/30/2019
ms.locfileid: "68630789"
---
# <a name="arithmetic-operators"></a><span data-ttu-id="a6149-103">산술 연산자</span><span class="sxs-lookup"><span data-stu-id="a6149-103">Arithmetic Operators</span></span>

<span data-ttu-id="a6149-104">이 항목에서는 F# 언어에서 사용할 수 있는 산술 연산자에 대해 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="a6149-104">This topic describes arithmetic operators that are available in the F# language.</span></span>

## <a name="summary-of-binary-arithmetic-operators"></a><span data-ttu-id="a6149-105">이진 산술 연산자 요약</span><span class="sxs-lookup"><span data-stu-id="a6149-105">Summary of Binary Arithmetic Operators</span></span>

<span data-ttu-id="a6149-106">다음 표에서는 unboxed 정수 계열 및 부동 소수점 형식에 사용할 수 있는 이항 산술 연산자를 요약 합니다.</span><span class="sxs-lookup"><span data-stu-id="a6149-106">The following table summarizes the binary arithmetic operators that are available for unboxed integral and floating-point types.</span></span>

|<span data-ttu-id="a6149-107">이항 연산자</span><span class="sxs-lookup"><span data-stu-id="a6149-107">Binary operator</span></span>|<span data-ttu-id="a6149-108">참고</span><span class="sxs-lookup"><span data-stu-id="a6149-108">Notes</span></span>|
|---------------|-----|
|<span data-ttu-id="a6149-109">`+`(더하기, 더하기)</span><span class="sxs-lookup"><span data-stu-id="a6149-109">`+` (addition, plus)</span></span>|<span data-ttu-id="a6149-110">선택 취소.</span><span class="sxs-lookup"><span data-stu-id="a6149-110">Unchecked.</span></span> <span data-ttu-id="a6149-111">숫자가 함께 추가 되 고 합계가 유형에 서 지 원하는 최대 절대값을 초과 하는 경우 가능한 오버플로 조건입니다.</span><span class="sxs-lookup"><span data-stu-id="a6149-111">Possible overflow condition when numbers are added together and the sum exceeds the maximum absolute value supported by the type.</span></span>|
|<span data-ttu-id="a6149-112">`-`(빼기, 빼기)</span><span class="sxs-lookup"><span data-stu-id="a6149-112">`-` (subtraction, minus)</span></span>|<span data-ttu-id="a6149-113">선택 취소.</span><span class="sxs-lookup"><span data-stu-id="a6149-113">Unchecked.</span></span> <span data-ttu-id="a6149-114">부호 없는 형식을 뺄 때 또는 부동 소수점 값이 너무 작아서 형식으로 표현할 수 없는 경우 가능한 언더플로 조건입니다.</span><span class="sxs-lookup"><span data-stu-id="a6149-114">Possible underflow condition when unsigned types are subtracted, or when floating-point values are too small to be represented by the type.</span></span>|
|<span data-ttu-id="a6149-115">`*`(곱하기, times)</span><span class="sxs-lookup"><span data-stu-id="a6149-115">`*` (multiplication, times)</span></span>|<span data-ttu-id="a6149-116">선택 취소.</span><span class="sxs-lookup"><span data-stu-id="a6149-116">Unchecked.</span></span> <span data-ttu-id="a6149-117">숫자를 곱하고 제품이 유형에 서 지 원하는 최대 절대 값을 초과 하는 경우 가능한 오버플로 조건입니다.</span><span class="sxs-lookup"><span data-stu-id="a6149-117">Possible overflow condition when numbers are multiplied and the product exceeds the maximum absolute value supported by the type.</span></span>|
|<span data-ttu-id="a6149-118">`/`(나누기, 분할)</span><span class="sxs-lookup"><span data-stu-id="a6149-118">`/` (division, divided by)</span></span>|<span data-ttu-id="a6149-119">0으로 나누면 정수 계열 <xref:System.DivideByZeroException> 형식에 대 한가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="a6149-119">Division by zero causes a <xref:System.DivideByZeroException> for integral types.</span></span> <span data-ttu-id="a6149-120">부동 소수점 형식의 경우 0으로 나누면 특수 부동 소수점 값 `+Infinity` 또는 `-Infinity`이 제공 됩니다.</span><span class="sxs-lookup"><span data-stu-id="a6149-120">For floating-point types, division by zero gives you the special floating-point values `+Infinity` or `-Infinity`.</span></span> <span data-ttu-id="a6149-121">부동 소수점 숫자가 너무 작아 형식으로 표현할 수 없는 경우에도 가능한 언더플로 조건이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a6149-121">There is also a possible underflow condition when a floating-point number is too small to be represented by the type.</span></span>|
|<span data-ttu-id="a6149-122">`%`(나머지, rem)</span><span class="sxs-lookup"><span data-stu-id="a6149-122">`%` (remainder, rem)</span></span>|<span data-ttu-id="a6149-123">나누기 연산의 나머지를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="a6149-123">Returns the remainder of a division operation.</span></span> <span data-ttu-id="a6149-124">결과의 부호는 첫 번째 피연산자의 부호와 동일 합니다.</span><span class="sxs-lookup"><span data-stu-id="a6149-124">The sign of the result is the same as the sign of the first operand.</span></span>|
|<span data-ttu-id="a6149-125">`**`(지 수,의 제곱)</span><span class="sxs-lookup"><span data-stu-id="a6149-125">`**` (exponentiation, to the power of)</span></span>|<span data-ttu-id="a6149-126">결과가 형식의 최대 절대값을 초과 하는 경우 가능한 오버플로 조건입니다.</span><span class="sxs-lookup"><span data-stu-id="a6149-126">Possible overflow condition when the result exceeds the maximum absolute value for the type.</span></span><br /><br /><span data-ttu-id="a6149-127">지 각 연산자는 부동 소수점 형식 에서만 작동 합니다.</span><span class="sxs-lookup"><span data-stu-id="a6149-127">The exponentiation operator works only with floating-point types.</span></span>|

## <a name="summary-of-unary-arithmetic-operators"></a><span data-ttu-id="a6149-128">단항 산술 연산자 요약</span><span class="sxs-lookup"><span data-stu-id="a6149-128">Summary of Unary Arithmetic Operators</span></span>

<span data-ttu-id="a6149-129">다음 표에서는 정수 계열 및 부동 소수점 형식에 사용할 수 있는 단항 산술 연산자를 요약 하 여 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="a6149-129">The following table summarizes the unary arithmetic operators that are available for integral and floating-point types.</span></span>

|<span data-ttu-id="a6149-130">단항 연산자</span><span class="sxs-lookup"><span data-stu-id="a6149-130">Unary operator</span></span>|<span data-ttu-id="a6149-131">참고</span><span class="sxs-lookup"><span data-stu-id="a6149-131">Notes</span></span>|
|--------------|-----|
|<span data-ttu-id="a6149-132">`+`양의</span><span class="sxs-lookup"><span data-stu-id="a6149-132">`+` (positive)</span></span>|<span data-ttu-id="a6149-133">모든 산술 식에 적용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a6149-133">Can be applied to any arithmetic expression.</span></span> <span data-ttu-id="a6149-134">값의 부호를 변경 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="a6149-134">Does not change the sign of the value.</span></span>|
|<span data-ttu-id="a6149-135">`-`(부정, 부정)</span><span class="sxs-lookup"><span data-stu-id="a6149-135">`-` (negation, negative)</span></span>|<span data-ttu-id="a6149-136">모든 산술 식에 적용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a6149-136">Can be applied to any arithmetic expression.</span></span> <span data-ttu-id="a6149-137">값의 부호를 변경 합니다.</span><span class="sxs-lookup"><span data-stu-id="a6149-137">Changes the sign of the value.</span></span>|

<span data-ttu-id="a6149-138">정수 계열 형식에 대 한 오버플로 또는 언더플로 동작은 래핑됩니다.</span><span class="sxs-lookup"><span data-stu-id="a6149-138">The behavior at overflow or underflow for integral types is to wrap around.</span></span> <span data-ttu-id="a6149-139">이로 인해 잘못 된 결과가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="a6149-139">This causes an incorrect result.</span></span> <span data-ttu-id="a6149-140">정수 오버플로는 잠재적으로 심각한 문제로, 소프트웨어를 고려 하 여 소프트웨어를 작성 하지 않은 경우 보안 문제에 영향을 줄 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a6149-140">Integer overflow is a potentially serious problem that can contribute to security issues when software is not written to account for it.</span></span> <span data-ttu-id="a6149-141">응용 프로그램에 문제가 있는 경우에서 `Microsoft.FSharp.Core.Operators.Checked`확인 된 연산자를 사용 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="a6149-141">If this is a concern for your application, consider using the checked operators in `Microsoft.FSharp.Core.Operators.Checked`.</span></span>

## <a name="summary-of-binary-comparison-operators"></a><span data-ttu-id="a6149-142">이진 비교 연산자 요약</span><span class="sxs-lookup"><span data-stu-id="a6149-142">Summary of Binary Comparison Operators</span></span>

<span data-ttu-id="a6149-143">다음 표에서는 정수 계열 및 부동 소수점 형식에 사용할 수 있는 이진 비교 연산자를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="a6149-143">The following table shows the binary comparison operators that are available for integral and floating-point types.</span></span> <span data-ttu-id="a6149-144">이러한 연산자는 형식의 `bool`값을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="a6149-144">These operators return values of type `bool`.</span></span>

<span data-ttu-id="a6149-145">IEEE 부동 소수점 표현은 정확한 같음 연산을 지원 하지 않으므로 부동 소수점 숫자는 같지 않음을 직접 비교 하면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="a6149-145">Floating-point numbers should never be directly compared for equality, because the IEEE floating-point representation does not support an exact equality operation.</span></span> <span data-ttu-id="a6149-146">코드를 검사 하 여 동일한 것으로 쉽게 확인할 수 있는 두 숫자는 실제로 다른 비트 표현이 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a6149-146">Two numbers that you can easily verify to be equal by inspecting the code might actually have different bit representations.</span></span>

|<span data-ttu-id="a6149-147">연산자</span><span class="sxs-lookup"><span data-stu-id="a6149-147">Operator</span></span>|<span data-ttu-id="a6149-148">참고</span><span class="sxs-lookup"><span data-stu-id="a6149-148">Notes</span></span>|
|--------|-----|
|<span data-ttu-id="a6149-149">`=`(같음, 같음)</span><span class="sxs-lookup"><span data-stu-id="a6149-149">`=` (equality, equals)</span></span>|<span data-ttu-id="a6149-150">할당 연산자가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="a6149-150">This is not an assignment operator.</span></span> <span data-ttu-id="a6149-151">비교에만 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="a6149-151">It is used only for comparison.</span></span> <span data-ttu-id="a6149-152">제네릭 연산자입니다.</span><span class="sxs-lookup"><span data-stu-id="a6149-152">This is a generic operator.</span></span>|
|<span data-ttu-id="a6149-153">`>`(보다 큼)</span><span class="sxs-lookup"><span data-stu-id="a6149-153">`>` (greater than)</span></span>|<span data-ttu-id="a6149-154">제네릭 연산자입니다.</span><span class="sxs-lookup"><span data-stu-id="a6149-154">This is a generic operator.</span></span>|
|<span data-ttu-id="a6149-155">`<`(보다 작음)</span><span class="sxs-lookup"><span data-stu-id="a6149-155">`<` (less than)</span></span>|<span data-ttu-id="a6149-156">제네릭 연산자입니다.</span><span class="sxs-lookup"><span data-stu-id="a6149-156">This is a generic operator.</span></span>|
|<span data-ttu-id="a6149-157">`>=`(크거나 같음)</span><span class="sxs-lookup"><span data-stu-id="a6149-157">`>=` (greater than or equals)</span></span>|<span data-ttu-id="a6149-158">제네릭 연산자입니다.</span><span class="sxs-lookup"><span data-stu-id="a6149-158">This is a generic operator.</span></span>|
|<span data-ttu-id="a6149-159">`<=`(작거나 같음)</span><span class="sxs-lookup"><span data-stu-id="a6149-159">`<=` (less than or equals)</span></span>|<span data-ttu-id="a6149-160">제네릭 연산자입니다.</span><span class="sxs-lookup"><span data-stu-id="a6149-160">This is a generic operator.</span></span>|
|<span data-ttu-id="a6149-161">`<>`(같지 않음)</span><span class="sxs-lookup"><span data-stu-id="a6149-161">`<>` (not equal)</span></span>|<span data-ttu-id="a6149-162">제네릭 연산자입니다.</span><span class="sxs-lookup"><span data-stu-id="a6149-162">This is a generic operator.</span></span>|

## <a name="overloaded-and-generic-operators"></a><span data-ttu-id="a6149-163">오버 로드 된 및 제네릭 연산자</span><span class="sxs-lookup"><span data-stu-id="a6149-163">Overloaded and Generic Operators</span></span>

<span data-ttu-id="a6149-164">이 항목에서 설명 하는 모든 연산자는 **fsharp.core** 네임 스페이스에 정의 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a6149-164">All of the operators discussed in this topic are defined in the **Microsoft.FSharp.Core.Operators** namespace.</span></span> <span data-ttu-id="a6149-165">일부 연산자는 정적으로 확인 된 형식 매개 변수를 사용 하 여 정의 됩니다.</span><span class="sxs-lookup"><span data-stu-id="a6149-165">Some of the operators are defined by using statically resolved type parameters.</span></span> <span data-ttu-id="a6149-166">즉, 해당 연산자와 작동 하는 각 특정 형식에 대 한 개별 정의가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a6149-166">This means that there are individual definitions for each specific type that works with that operator.</span></span> <span data-ttu-id="a6149-167">모든 단항 및 이항 산술 연산자 및 비트 연산자는이 범주에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a6149-167">All of the unary and binary arithmetic and bitwise operators are in this category.</span></span> <span data-ttu-id="a6149-168">비교 연산자는 일반적 이므로 기본 산술 형식 뿐만 아니라 모든 형식에서 작동 합니다.</span><span class="sxs-lookup"><span data-stu-id="a6149-168">The comparison operators are generic and therefore work with any type, not just primitive arithmetic types.</span></span> <span data-ttu-id="a6149-169">구분 된 공용 구조체 및 레코드 형식에는 F# 컴파일러에서 생성 되는 고유한 사용자 지정 구현이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a6149-169">Discriminated union and record types have their own custom implementations that are generated by the F# compiler.</span></span> <span data-ttu-id="a6149-170">클래스 형식은 메서드 <xref:System.Object.Equals%2A>를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="a6149-170">Class types use the method <xref:System.Object.Equals%2A>.</span></span>

<span data-ttu-id="a6149-171">제네릭 연산자는 사용자 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a6149-171">The generic operators are customizable.</span></span> <span data-ttu-id="a6149-172">비교 함수를 사용자 지정 하려면를 <xref:System.Object.Equals%2A> 재정의 하 여 사용자 지정 같음 비교를 제공한 다음을 <xref:System.IComparable>구현 합니다.</span><span class="sxs-lookup"><span data-stu-id="a6149-172">To customize the comparison functions, override <xref:System.Object.Equals%2A> to provide your own custom equality comparison, and then implement <xref:System.IComparable>.</span></span> <span data-ttu-id="a6149-173">인터페이스에는 <xref:System.IComparable.CompareTo%2A> 메서드가 하나인 단일 메서드가 있습니다. <xref:System.IComparable?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="a6149-173">The <xref:System.IComparable?displayProperty=nameWithType> interface has a single method, the <xref:System.IComparable.CompareTo%2A> method.</span></span>

## <a name="operators-and-type-inference"></a><span data-ttu-id="a6149-174">연산자 및 형식 유추</span><span class="sxs-lookup"><span data-stu-id="a6149-174">Operators and Type Inference</span></span>

<span data-ttu-id="a6149-175">식에서 연산자를 사용 하면 해당 연산자에 대 한 형식 유추가 제한 됩니다.</span><span class="sxs-lookup"><span data-stu-id="a6149-175">The use of an operator in an expression constrains type inference on that operator.</span></span> <span data-ttu-id="a6149-176">또한 연산자를 사용 하면 산술 형식이 암시 되기 때문에 연산자를 사용 하 여 자동 일반화를 방지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a6149-176">Also, the use of operators prevents automatic generalization, because the use of operators implies an arithmetic type.</span></span> <span data-ttu-id="a6149-177">다른 정보가 없을 경우 컴파일러는 F# 산술 식의 형식으로 `int` 유추 됩니다.</span><span class="sxs-lookup"><span data-stu-id="a6149-177">In the absence of any other information, the F# compiler infers `int` as the type of arithmetic expressions.</span></span> <span data-ttu-id="a6149-178">다른 형식을 지정 하 여이 동작을 재정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a6149-178">You can override this behavior by specifying another type.</span></span> <span data-ttu-id="a6149-179">따라서 다음 코드에서 `function1` 의 인수 형식 및 반환 형식은로 유추 `int`되지만 `float`의 `function2` 형식은로 유추 됩니다.</span><span class="sxs-lookup"><span data-stu-id="a6149-179">Thus the argument types and return type of `function1` in the following code are inferred to be `int`, but the types for `function2` are inferred to be `float`.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet3501.fs)]

## <a name="see-also"></a><span data-ttu-id="a6149-180">참고자료</span><span class="sxs-lookup"><span data-stu-id="a6149-180">See also</span></span>

- [<span data-ttu-id="a6149-181">기호 및 연산자 참조</span><span class="sxs-lookup"><span data-stu-id="a6149-181">Symbol and Operator Reference</span></span>](index.md)
- [<span data-ttu-id="a6149-182">연산자 오버로드</span><span class="sxs-lookup"><span data-stu-id="a6149-182">Operator Overloading</span></span>](../operator-overloading.md)
- [<span data-ttu-id="a6149-183">비트 연산자</span><span class="sxs-lookup"><span data-stu-id="a6149-183">Bitwise Operators</span></span>](bitwise-operators.md)
- [<span data-ttu-id="a6149-184">부울 연산자</span><span class="sxs-lookup"><span data-stu-id="a6149-184">Boolean Operators</span></span>](boolean-operators.md)

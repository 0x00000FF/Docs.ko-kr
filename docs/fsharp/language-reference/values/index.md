---
title: 값(F#)
description: 'F #의 값은 특정 유형이 있는 수량 방법에 대해 알아봅니다.'
ms.date: 05/16/2016
ms.openlocfilehash: 4d2874a694d9c39048a28827be858cba499dca87
ms.sourcegitcommit: e5bb395ec86f536e114314184288f40a8c745e2e
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 05/12/2018
ms.locfileid: "34149116"
---
# <a name="values"></a><span data-ttu-id="f2fef-103">값</span><span class="sxs-lookup"><span data-stu-id="f2fef-103">Values</span></span>

<span data-ttu-id="f2fef-104">F#의 값은 특정 형식을 가진 수량이며, 값은 정수 또는 부동 소수점 숫자, 문자 또는 텍스트, 목록, 시퀀스, 배열, 튜플, 구분된 공용 구조체, 레코드, 클래스 형식 또는 함수 값이 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f2fef-104">Values in F# are quantities that have a specific type; values can be integral or floating point numbers, characters or text, lists, sequences, arrays, tuples, discriminated unions, records, class types, or function values.</span></span>


## <a name="binding-a-value"></a><span data-ttu-id="f2fef-105">값 바인딩</span><span class="sxs-lookup"><span data-stu-id="f2fef-105">Binding a Value</span></span>
<span data-ttu-id="f2fef-106">*바인딩*이란 용어는 이름과 정의를 연결하는 것을 의미합니다.</span><span class="sxs-lookup"><span data-stu-id="f2fef-106">The term *binding* means associating a name with a definition.</span></span> <span data-ttu-id="f2fef-107">`let` 키워드는 다음 예제와 같이 값을 바인딩합니다.</span><span class="sxs-lookup"><span data-stu-id="f2fef-107">The `let` keyword binds a value, as in the following examples:</span></span>

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-1/snippet601.fs)]

<span data-ttu-id="f2fef-108">특정 값의 형식은 정의에서 유추됩니다.</span><span class="sxs-lookup"><span data-stu-id="f2fef-108">The type of a value is inferred from the definition.</span></span> <span data-ttu-id="f2fef-109">정수 또는 부동 소수점 숫자와 같은 기본 형식의 경우 형식은 리터럴 형식에서 결정됩니다.</span><span class="sxs-lookup"><span data-stu-id="f2fef-109">For a primitive type, such as an integral or floating point number, the type is determined from the type of the literal.</span></span> <span data-ttu-id="f2fef-110">따라서 앞의 예제에서 컴파일러는 `b`의 형식을 `unsigned int`로 유추하는 반면 컴파일러는 `a`의 형식을 `int`로 유추합니다.</span><span class="sxs-lookup"><span data-stu-id="f2fef-110">Therefore, in the previous example, the compiler infers the type of `b` to be `unsigned int`, whereas the compiler infers the type of `a` to be `int`.</span></span> <span data-ttu-id="f2fef-111">함수 값의 형식은 함수 본문의 반환 값에서 결정됩니다.</span><span class="sxs-lookup"><span data-stu-id="f2fef-111">The type of a function value is determined from the return value in the function body.</span></span> <span data-ttu-id="f2fef-112">함수 값 형식에 대한 자세한 내용은 [함수](../functions/index.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="f2fef-112">For more information about function value types, see [Functions](../functions/index.md).</span></span> <span data-ttu-id="f2fef-113">리터럴 형식에 대한 자세한 내용은 [리터럴](../literals.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="f2fef-113">For more information about literal types, see [Literals](../literals.md).</span></span>

<span data-ttu-id="f2fef-114">컴파일러는 기본적으로 사용 하지 않는 바인딩에 대 한 진단 발생 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="f2fef-114">The compiler does not issue diagnostics about unused bindings by default.</span></span> <span data-ttu-id="f2fef-115">이러한 메시지를 받으려면 사용 컴파일러를 호출할 때 또는 프로젝트 파일에서 1182 경고 (참조 `--warnon` 아래 [컴파일러 옵션](../compiler-options.md)).</span><span class="sxs-lookup"><span data-stu-id="f2fef-115">To receive these messages, enable warning 1182 in your project file or when invoking the compiler (see `--warnon` under [Compiler Options](../compiler-options.md)).</span></span>

## <a name="why-immutable"></a><span data-ttu-id="f2fef-116">변경할 수 없는 이유</span><span class="sxs-lookup"><span data-stu-id="f2fef-116">Why Immutable?</span></span>
<span data-ttu-id="f2fef-117">변경할 수 없는 값은 프로그램의 실행 과정에서 변경할 수 없는 값입니다.</span><span class="sxs-lookup"><span data-stu-id="f2fef-117">Immutable values are values that cannot be changed throughout the course of a program's execution.</span></span> <span data-ttu-id="f2fef-118">C++, Visual Basic, C# 등의 언어를 사용하는 경우, 프로그램의 실행 과정에서 F#이 새 값을 할당할 수 있는 변수보다 변경할 수 없는 값에 우선 순위를 두는 것이 낯설게 여겨질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f2fef-118">If you are used to languages such as C++, Visual Basic, or C#, you might find it surprising that F# puts primacy over immutable values rather than variables that can be assigned new values during the execution of a program.</span></span> <span data-ttu-id="f2fef-119">변경 불가능한 데이터는 함수형 프로그래밍의 중요한 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="f2fef-119">Immutable data is an important element of functional programming.</span></span> <span data-ttu-id="f2fef-120">다중 스레드 환경에서 여러 다양한 스레드에 의해 변경될 수 있는 공유 가변 변수는 관리하기가 어렵습니다.</span><span class="sxs-lookup"><span data-stu-id="f2fef-120">In a multithreaded environment, shared mutable variables that can be changed by many different threads are difficult to manage.</span></span> <span data-ttu-id="f2fef-121">또한 변경 가능한 변수를 사용할 경우 다른 함수에 전달되는 변수를 변경할 수 있는지 여부를 구분하는 것이 때로 어렵습니다.</span><span class="sxs-lookup"><span data-stu-id="f2fef-121">Also, with mutable variables, it can sometimes be hard to tell if a variable might be changed when it is passed to another function.</span></span>

<span data-ttu-id="f2fef-122">순수 함수형 언어에서는, 변수가 없으며 함수는 수학 함수로 엄격하게 동작합니다.</span><span class="sxs-lookup"><span data-stu-id="f2fef-122">In pure functional languages, there are no variables, and functions behave strictly as mathematical functions.</span></span> <span data-ttu-id="f2fef-123">프로시저 언어의 코드는 변수 할당을 사용하여 값을 변경하는 경우, 함수형 언어의 해당하는 코드에는 변경할 수 없는 값(입력), 변경할 수 없는 함수 및 여러 변경할 수 없는 값(출력)이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f2fef-123">Where code in a procedural language uses a variable assignment to alter a value, the equivalent code in a functional language has an immutable value that is the input, an immutable function, and different immutable values as the output.</span></span> <span data-ttu-id="f2fef-124">이러한 수학적 엄격성은 프로그램의 동작에 대한 트리거 추론을 허용합니다.</span><span class="sxs-lookup"><span data-stu-id="f2fef-124">This mathematical strictness allows for tighter reasoning about the behavior of the program.</span></span> <span data-ttu-id="f2fef-125">이러한 트리거 추론이 바로 컴파일러에서 코드를 보다 엄격하게 확인하고 보다 효과적으로 최적화할 수 있는 요인이며, 이를 통해 개발자는 올바른 코드를 쉽게 이해하고 작성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f2fef-125">This tighter reasoning is what enables compilers to check code more stringently and to optimize more effectively, and helps make it easier for developers to understand and write correct code.</span></span> <span data-ttu-id="f2fef-126">따라서 함수형 코드는 일반적인 프로시저 코드보다 디버깅하기 쉬울 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f2fef-126">Functional code is therefore likely to be easier to debug than ordinary procedural code.</span></span>

<span data-ttu-id="f2fef-127">F#은 순수 함수형 언어가 아니지만 함수형 프로그래밍을 완전하게 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="f2fef-127">F# is not a pure functional language, yet it fully supports functional programming.</span></span> <span data-ttu-id="f2fef-128">변경할 수 없는 값을 사용하면 코드가 함수형 프로그래밍의 중요한 측면에서 이점을 얻을 수 있으므로 그렇게 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="f2fef-128">Using immutable values is a good practice because doing this allows your code to benefit from an important aspect of functional programming.</span></span>


## <a name="mutable-variables"></a><span data-ttu-id="f2fef-129">변경 가능한 변수</span><span class="sxs-lookup"><span data-stu-id="f2fef-129">Mutable Variables</span></span>
<span data-ttu-id="f2fef-130">`mutable` 키워드를 사용하여 변경할 수 있는 변수를 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f2fef-130">You can use the keyword `mutable` to specify a variable that can be changed.</span></span> <span data-ttu-id="f2fef-131">F#의 변경 가능한 변수에는 일반적으로 특정 형식의 필드로 또는 로컬 값의 제한된 범위가 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f2fef-131">Mutable variables in F# should generally have a limited scope, either as a field of a type or as a local value.</span></span> <span data-ttu-id="f2fef-132">제한된 범위의 변경 가능한 변수는 더 쉽게 제어할 수 있으므로 잘못된 방법으로 수정하는 경우가 더 적습니다.</span><span class="sxs-lookup"><span data-stu-id="f2fef-132">Mutable variables with a limited scope are easier to control and are less likely to be modified in incorrect ways.</span></span>

<span data-ttu-id="f2fef-133">값을 정의할 때와 동일한 방식으로 `let` 키워드를 사용하여 변경 가능한 변수에 초기 값을 할당할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f2fef-133">You can assign an initial value to a mutable variable by using the `let` keyword in the same way as you would define a value.</span></span> <span data-ttu-id="f2fef-134">그러나 다음 예제와 같이, 이후에 `<-` 연산자를 사용하여 변경 가능한 변수에 새 값을 할당할 수 있다는 점이 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="f2fef-134">However, the difference is that you can subsequently assign new values to mutable variables by using the `<-` operator, as in the following example.</span></span>

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-1/snippet602.fs)]

<span data-ttu-id="f2fef-135">표시 된 값 `mutable` 를 자동으로 승격 될 수 있습니다 `'a ref` 클로저를 캡처, 클로저의 등 작성 하는 폼을 포함 하 여 `seq` 작성기입니다.</span><span class="sxs-lookup"><span data-stu-id="f2fef-135">Values marked `mutable` may be automatically promoted to `'a ref` if captured by a closure, including forms that create closures, such as `seq` builders.</span></span> <span data-ttu-id="f2fef-136">이 경우 알림이 표시 하려는 경우 경고를 활성화 3180 컴파일러를 호출할 때 또는 프로젝트 파일에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f2fef-136">If you wish to be notified when this occurs, enable warning 3180 in your project file or when invoking the compiler.</span></span>
    
## <a name="related-topics"></a><span data-ttu-id="f2fef-137">관련 항목</span><span class="sxs-lookup"><span data-stu-id="f2fef-137">Related Topics</span></span>


|<span data-ttu-id="f2fef-138">제목</span><span class="sxs-lookup"><span data-stu-id="f2fef-138">Title</span></span>|<span data-ttu-id="f2fef-139">설명</span><span class="sxs-lookup"><span data-stu-id="f2fef-139">Description</span></span>|
|-----|-----------|
|[<span data-ttu-id="f2fef-140">let 바인딩</span><span class="sxs-lookup"><span data-stu-id="f2fef-140">let Bindings</span></span>](../functions/let-bindings.md)|<span data-ttu-id="f2fef-141">사용 하는 방법에 대 한 정보를 제공는 `let` 이름 값과 변수에 바인딩할 키워드입니다.</span><span class="sxs-lookup"><span data-stu-id="f2fef-141">Provides information about using the `let` keyword to bind names to values and functions.</span></span>|
|[<span data-ttu-id="f2fef-142">함수</span><span class="sxs-lookup"><span data-stu-id="f2fef-142">Functions</span></span>](../functions/index.md)|<span data-ttu-id="f2fef-143">F#의 함수를 간략하게 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="f2fef-143">Provides an overview of functions in F#.</span></span>|

## <a name="see-also"></a><span data-ttu-id="f2fef-144">참고 항목</span><span class="sxs-lookup"><span data-stu-id="f2fef-144">See Also</span></span>
[<span data-ttu-id="f2fef-145">Null 값</span><span class="sxs-lookup"><span data-stu-id="f2fef-145">Null Values</span></span>](null-Values.md)

[<span data-ttu-id="f2fef-146">F# 언어 참조</span><span class="sxs-lookup"><span data-stu-id="f2fef-146">F# Language Reference</span></span>](../index.md)

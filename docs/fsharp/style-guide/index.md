---
title: F# 스타일 가이드
description: '좋은 F # 코드의 다섯 가지 원칙을 알아보십시오.'
ms.date: 12/10/2018
ms.openlocfilehash: 9f47257626e04b09b546de2ae315d48d791678be
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/14/2020
ms.locfileid: "79401114"
---
# <a name="f-style-guide"></a><span data-ttu-id="11d4c-103">F# 스타일 가이드</span><span class="sxs-lookup"><span data-stu-id="11d4c-103">F# style guide</span></span>

<span data-ttu-id="11d4c-104">다음 문서에서는 F# 코드 서식 지정에 대한 지침과 언어 기능에 대한 국소 지침 및 사용 방법에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="11d4c-104">The following articles describe guidelines for formatting F# code and topical guidance for features of the language and how they should be used.</span></span>

<span data-ttu-id="11d4c-105">이 지침은 다양한 프로그래머 그룹이 있는 대규모 코드베이스에서 F#을 사용하여 공식화되었습니다.</span><span class="sxs-lookup"><span data-stu-id="11d4c-105">This guidance has been formulated based on the use of F# in large codebases with a diverse group of programmers.</span></span> <span data-ttu-id="11d4c-106">이 지침은 일반적으로 F#을 성공적으로 사용하게 되며 시간에 따라 프로그램에 대한 요구 사항이 변경될 때 불만을 최소화합니다.</span><span class="sxs-lookup"><span data-stu-id="11d4c-106">This guidance generally leads to successful use of F# and minimizes frustrations when requirements for programs change over time.</span></span>

## <a name="five-principles-of-good-f-code"></a><span data-ttu-id="11d4c-107">좋은 F # 코드의 다섯 가지 원칙</span><span class="sxs-lookup"><span data-stu-id="11d4c-107">Five principles of good F# code</span></span>

<span data-ttu-id="11d4c-108">특히 시간이 지남에 따라 변경되는 시스템에서 는 F# 코드를 작성할 때마다 다음 원칙을 염두에 두어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="11d4c-108">Keep the following principles in mind any time you write F# code, especially in systems that will change over time.</span></span> <span data-ttu-id="11d4c-109">추가 기사의 모든 지침은 이 다섯 가지 사항에서 비롯됩니다.</span><span class="sxs-lookup"><span data-stu-id="11d4c-109">Every piece of guidance in further articles stems from these five points.</span></span>

1. <span data-ttu-id="11d4c-110">**좋은 F # 코드는 간결하고 표현력이 뛰어나며 컴포지블합니다.**</span><span class="sxs-lookup"><span data-stu-id="11d4c-110">**Good F# code is succinct, expressive, and composable**</span></span>

    <span data-ttu-id="11d4c-111">F#에는 적은 코드 줄로 작업을 표현하고 일반 기능을 다시 사용할 수 있는 많은 기능이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="11d4c-111">F# has many features that allow you to express actions in fewer lines of code and reuse generic functionality.</span></span> <span data-ttu-id="11d4c-112">F# 코어 라이브러리에는 일반적인 데이터 컬렉션 작업에 유용한 형식과 함수도 많이 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="11d4c-112">The F# core library also contains many useful types and functions for working with common collections of data.</span></span> <span data-ttu-id="11d4c-113">사용자 고유의 함수와 F# 코어 라이브러리(또는 기타 라이브러리)의 컴포지션은 일상적인 관용F# 프로그래밍의 일부입니다.</span><span class="sxs-lookup"><span data-stu-id="11d4c-113">Composition of your own functions and those in the F# core library (or other libraries) is a part of routine idiomatic F# programming.</span></span> <span data-ttu-id="11d4c-114">일반적으로 적은 코드 줄에서 문제에 대한 해결책을 표현할 수 있다면 다른 개발자(또는 미래의 자체)는 감사하게 될 것입니다.</span><span class="sxs-lookup"><span data-stu-id="11d4c-114">As a general rule, if you can express a solution to a problem in fewer lines of code, other developers (or your future self) will be appreciative.</span></span> <span data-ttu-id="11d4c-115">또한 FSharp.Core, F#가 실행되는 [광대 한 .NET 라이브러리](../../../api/index.md) 또는 사소한 작업을 수행해야 할 때 [NuGet에서](https://www.nuget.org/) 타사 패키지를 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="11d4c-115">It's also highly recommended that you use a library such as FSharp.Core, the [vast .NET libraries](../../../api/index.md) that F# runs on, or a third-party package on [NuGet](https://www.nuget.org/) when you need to do a nontrivial task.</span></span>

2. <span data-ttu-id="11d4c-116">**좋은 F # 코드는 상호 운용 가능**</span><span class="sxs-lookup"><span data-stu-id="11d4c-116">**Good F# code is interoperable**</span></span>

    <span data-ttu-id="11d4c-117">상호 운용은 다른 언어로 코드를 사용하는 것을 포함하여 여러 형태를 취할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="11d4c-117">Interoperation can take multiple forms, including consuming code in different languages.</span></span> <span data-ttu-id="11d4c-118">다른 호출자가 상호 운용하는 코드의 경계는 호출자가 F#에 있더라도 올바르게 작동하기 위해 중요한 부분입니다.</span><span class="sxs-lookup"><span data-stu-id="11d4c-118">The boundaries of your code that other callers interoperate with are critical pieces to get right, even if the callers are also in F#.</span></span> <span data-ttu-id="11d4c-119">F#을 작성할 때는 C#과 같은 다른 언어에서 다른 코드를 작성하는 경우를 포함하여 다른 코드가 작성하는 코드에 어떻게 호출되는지 항상 고려해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="11d4c-119">When writing F#, you should always be thinking about how other code will call into the code you're writing, including if they do so from another language like C#.</span></span> <span data-ttu-id="11d4c-120">[F# 구성 요소 디자인 지침은](component-design-guidelines.md) 상호 운용성을 자세히 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="11d4c-120">The [F# Component Design Guidelines](component-design-guidelines.md) describe interoperability in detail.</span></span>

3. <span data-ttu-id="11d4c-121">**좋은 F # 코드는 객체 방향이 아닌 객체 프로그래밍을 사용합니다.**</span><span class="sxs-lookup"><span data-stu-id="11d4c-121">**Good F# code makes use of object programming, not object orientation**</span></span>

    <span data-ttu-id="11d4c-122">F#은 [클래스,](../language-reference/classes.md)인터페이스, [액세스 수정자,](../language-reference/access-control.md) [추상 클래스](../language-reference/abstract-classes.md)등을 포함하여 .NET의 [개체를](../language-reference/interfaces.md)사용하여 프로그래밍하는 데 전폭적인 지원을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="11d4c-122">F# has full support for programming with objects in .NET, including [classes](../language-reference/classes.md), [interfaces](../language-reference/interfaces.md), [access modifiers](../language-reference/access-control.md), [abstract classes](../language-reference/abstract-classes.md), and so on.</span></span> <span data-ttu-id="11d4c-123">컨텍스트를 인식해야 하는 함수와 같이 더 복잡한 함수 코드의 경우 개체는 함수가 할 수 없는 방식으로 컨텍스트 정보를 쉽게 캡슐화할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="11d4c-123">For more complicated functional code, such as functions that must be context-aware, objects can easily encapsulate contextual information in ways that functions cannot.</span></span> <span data-ttu-id="11d4c-124">[선택적 매개 변수](../language-reference/members/methods.md#optional-arguments) 및 [과부하를](../language-reference/members/methods.md#overloaded-methods) 주의 깊게 사용하면 호출자에게 이 기능을 더 쉽게 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="11d4c-124">Features such as [optional parameters](../language-reference/members/methods.md#optional-arguments) and careful use of [overloading](../language-reference/members/methods.md#overloaded-methods) can make consumption of this functionality easier for callers.</span></span>

4. <span data-ttu-id="11d4c-125">**좋은 F # 코드는 돌연변이를 노출하지 않고 잘 수행됩니다.**</span><span class="sxs-lookup"><span data-stu-id="11d4c-125">**Good F# code performs well without exposing mutation**</span></span>

    <span data-ttu-id="11d4c-126">고성능 코드를 작성하려면 돌연변이를 사용해야 한다는 것은 비밀이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="11d4c-126">It's no secret that to write high-performance code, you must use mutation.</span></span> <span data-ttu-id="11d4c-127">결국 컴퓨터가 작동하는 방식입니다.</span><span class="sxs-lookup"><span data-stu-id="11d4c-127">It's how computers work, after all.</span></span> <span data-ttu-id="11d4c-128">이러한 코드는 종종 오류가 발생하기 쉽고 올바르게 이해하기가 어렵습니다.</span><span class="sxs-lookup"><span data-stu-id="11d4c-128">Such code is often error-prone and difficult to get right.</span></span> <span data-ttu-id="11d4c-129">호출자에게 돌연변이를 노출하지 마십시오.</span><span class="sxs-lookup"><span data-stu-id="11d4c-129">Avoid exposing mutation to callers.</span></span> <span data-ttu-id="11d4c-130">대신 성능이 중요한 경우 [돌연변이 기반 구현을 숨기는 기능 인터페이스를 빌드합니다.](conventions.md#performance)</span><span class="sxs-lookup"><span data-stu-id="11d4c-130">Instead, [build a functional interface that hides a mutation-based implementation](conventions.md#performance) when performance is critical.</span></span>

5. <span data-ttu-id="11d4c-131">**좋은 F # 코드는 툴 수 있습니다**</span><span class="sxs-lookup"><span data-stu-id="11d4c-131">**Good F# code is toolable**</span></span>

    <span data-ttu-id="11d4c-132">도구는 대규모 코드베이스에서 작업하는 데 매우 유용하며 F# 언어 툴링에서 보다 효과적으로 사용할 수 있도록 F# 코드를 작성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="11d4c-132">Tools are invaluable for working in large codebases, and you can write F# code such that it can be used more effectively with F# language tooling.</span></span> <span data-ttu-id="11d4c-133">한 가지 예는 중간 값을 디버거로 검사할 수 있도록 포인트 프리 프로그래밍 스타일로 과도하게 수행하지 않도록 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="11d4c-133">One example is making sure you don't overdo it with a point-free style of programming, so that intermediate values can be inspected with a debugger.</span></span> <span data-ttu-id="11d4c-134">또 다른 예는 편집기의 도구 설명이 호출 사이트에 해당 주석을 표시할 수 있도록 구문 설명을 설명하는 [XML 설명서](../language-reference/xml-documentation.md) 주석을 사용하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="11d4c-134">Another example is using [XML documentation comments](../language-reference/xml-documentation.md) describing constructs such that tooltips in editors can display those comments at the call site.</span></span> <span data-ttu-id="11d4c-135">다른 프로그래머가 도구를 사용하여 코드를 읽고, 탐색하고, 디버깅하고, 조작하는 방법을 항상 생각해 보십시오.</span><span class="sxs-lookup"><span data-stu-id="11d4c-135">Always think about how your code will be read, navigated, debugged, and manipulated by other programmers with their tools.</span></span>

## <a name="next-steps"></a><span data-ttu-id="11d4c-136">다음 단계</span><span class="sxs-lookup"><span data-stu-id="11d4c-136">Next steps</span></span>

<span data-ttu-id="11d4c-137">[F# 코드 서식 지정 지침은](formatting.md) 읽기 쉽도록 코드를 포맷하는 방법에 대한 지침을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="11d4c-137">The [F# code formatting guidelines](formatting.md) provide guidance on how to format code so that it is easy to read.</span></span>

<span data-ttu-id="11d4c-138">[F# 코딩 규칙은](conventions.md) 더 큰 F# 코드베이스의 장기적인 유지 관리에 도움이 되는 F# 프로그래밍 숙어에 대한 지침을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="11d4c-138">The [F# coding conventions](conventions.md) provide guidance for F# programming idioms that will help the long-term maintenance of larger F# codebases.</span></span>

<span data-ttu-id="11d4c-139">[F# 구성 요소 디자인 지침은](component-design-guidelines.md) 라이브러리와 같은 F# 구성 요소를 작성하기 위한 지침을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="11d4c-139">The [F# component design guidelines](component-design-guidelines.md) provide guidance for authoring F# components, such as libraries.</span></span>
